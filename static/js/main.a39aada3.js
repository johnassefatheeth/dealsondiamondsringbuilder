/*! For license information please see main.a39aada3.js.LICENSE.txt */
(() => {
    var e = {
            6960: (e, t) => {
                "use strict";

                function n(e, t) {
                    var n = e.length;
                    e.push(t);
                    e: for (; 0 < n;) {
                        var r = n - 1 >>> 1,
                            i = e[r];
                        if (!(0 < o(i, t))) break e;
                        e[r] = t, e[n] = i, n = r
                    }
                }

                function r(e) {
                    return 0 === e.length ? null : e[0]
                }

                function i(e) {
                    if (0 === e.length) return null;
                    var t = e[0],
                        n = e.pop();
                    if (n !== t) {
                        e[0] = n;
                        e: for (var r = 0, i = e.length, a = i >>> 1; r < a;) {
                            var s = 2 * (r + 1) - 1,
                                l = e[s],
                                c = s + 1,
                                u = e[c];
                            if (0 > o(l, n)) c < i && 0 > o(u, l) ? (e[r] = u, e[c] = n, r = c) : (e[r] = l, e[s] = n, r = s);
                            else {
                                if (!(c < i && 0 > o(u, n))) break e;
                                e[r] = u, e[c] = n, r = c
                            }
                        }
                    }
                    return t
                }

                function o(e, t) {
                    var n = e.sortIndex - t.sortIndex;
                    return 0 !== n ? n : e.id - t.id
                }
                if ("object" === typeof performance && "function" === typeof performance.now) {
                    var a = performance;
                    t.unstable_now = function() {
                        return a.now()
                    }
                } else {
                    var s = Date,
                        l = s.now();
                    t.unstable_now = function() {
                        return s.now() - l
                    }
                }
                var c = [],
                    u = [],
                    d = 1,
                    h = null,
                    p = 3,
                    f = !1,
                    m = !1,
                    g = !1,
                    v = "function" === typeof setTimeout ? setTimeout : null,
                    y = "function" === typeof clearTimeout ? clearTimeout : null,
                    b = "undefined" !== typeof setImmediate ? setImmediate : null;

                function x(e) {
                    for (var t = r(u); null !== t;) {
                        if (null === t.callback) i(u);
                        else {
                            if (!(t.startTime <= e)) break;
                            i(u), t.sortIndex = t.expirationTime, n(c, t)
                        }
                        t = r(u)
                    }
                }

                function _(e) {
                    if (g = !1, x(e), !m)
                        if (null !== r(c)) m = !0, B(M);
                        else {
                            var t = r(u);
                            null !== t && L(_, t.startTime - e)
                        }
                }

                function M(e, n) {
                    m = !1, g && (g = !1, y(E), E = -1), f = !0;
                    var o = p;
                    try {
                        for (x(n), h = r(c); null !== h && (!(h.expirationTime > n) || e && !P());) {
                            var a = h.callback;
                            if ("function" === typeof a) {
                                h.callback = null, p = h.priorityLevel;
                                var s = a(h.expirationTime <= n);
                                n = t.unstable_now(), "function" === typeof s ? h.callback = s : h === r(c) && i(c), x(n)
                            } else i(c);
                            h = r(c)
                        }
                        if (null !== h) var l = !0;
                        else {
                            var d = r(u);
                            null !== d && L(_, d.startTime - n), l = !1
                        }
                        return l
                    } finally {
                        h = null, p = o, f = !1
                    }
                }
                "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
                var w, A = !1,
                    S = null,
                    E = -1,
                    C = 5,
                    T = -1;

                function P() {
                    return !(t.unstable_now() - T < C)
                }

                function R() {
                    if (null !== S) {
                        var e = t.unstable_now();
                        T = e;
                        var n = !0;
                        try {
                            n = S(!0, e)
                        } finally {
                            n ? w() : (A = !1, S = null)
                        }
                    } else A = !1
                }
                if ("function" === typeof b) w = function() {
                    b(R)
                };
                else if ("undefined" !== typeof MessageChannel) {
                    var I = new MessageChannel,
                        O = I.port2;
                    I.port1.onmessage = R, w = function() {
                        O.postMessage(null)
                    }
                } else w = function() {
                    v(R, 0)
                };

                function B(e) {
                    S = e, A || (A = !0, w())
                }

                function L(e, n) {
                    E = v((function() {
                        e(t.unstable_now())
                    }), n)
                }
                t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(e) {
                    e.callback = null
                }, t.unstable_continueExecution = function() {
                    m || f || (m = !0, B(M))
                }, t.unstable_forceFrameRate = function(e) {
                    0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : C = 0 < e ? Math.floor(1e3 / e) : 5
                }, t.unstable_getCurrentPriorityLevel = function() {
                    return p
                }, t.unstable_getFirstCallbackNode = function() {
                    return r(c)
                }, t.unstable_next = function(e) {
                    switch (p) {
                        case 1:
                        case 2:
                        case 3:
                            var t = 3;
                            break;
                        default:
                            t = p
                    }
                    var n = p;
                    p = t;
                    try {
                        return e()
                    } finally {
                        p = n
                    }
                }, t.unstable_pauseExecution = function() {}, t.unstable_requestPaint = function() {}, t.unstable_runWithPriority = function(e, t) {
                    switch (e) {
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        default:
                            e = 3
                    }
                    var n = p;
                    p = e;
                    try {
                        return t()
                    } finally {
                        p = n
                    }
                }, t.unstable_scheduleCallback = function(e, i, o) {
                    var a = t.unstable_now();
                    switch ("object" === typeof o && null !== o ? o = "number" === typeof(o = o.delay) && 0 < o ? a + o : a : o = a, e) {
                        case 1:
                            var s = -1;
                            break;
                        case 2:
                            s = 250;
                            break;
                        case 5:
                            s = 1073741823;
                            break;
                        case 4:
                            s = 1e4;
                            break;
                        default:
                            s = 5e3
                    }
                    return e = {
                        id: d++,
                        callback: i,
                        priorityLevel: e,
                        startTime: o,
                        expirationTime: s = o + s,
                        sortIndex: -1
                    }, o > a ? (e.sortIndex = o, n(u, e), null === r(c) && e === r(u) && (g ? (y(E), E = -1) : g = !0, L(_, o - a))) : (e.sortIndex = s, n(c, e), m || f || (m = !0, B(M))), e
                }, t.unstable_shouldYield = P, t.unstable_wrapCallback = function(e) {
                    var t = p;
                    return function() {
                        var n = p;
                        p = t;
                        try {
                            return e.apply(this, arguments)
                        } finally {
                            p = n
                        }
                    }
                }
            },
            2712: (e, t, n) => {
                "use strict";
                e.exports = n(6960)
            },
            6902: (e, t, n) => {
                "use strict";
                n.r(t), n.d(t, {
                    buildQueries: () => at,
                    configure: () => xe,
                    createEvent: () => En,
                    findAllByAltText: () => Wt,
                    findAllByDisplayValue: () => Ft,
                    findAllByLabelText: () => ft,
                    findAllByPlaceholderText: () => At,
                    findAllByRole: () => ln,
                    findAllByTestId: () => gn,
                    findAllByText: () => It,
                    findAllByTitle: () => $t,
                    findByAltText: () => Xt,
                    findByDisplayValue: () => Ut,
                    findByLabelText: () => mt,
                    findByPlaceholderText: () => St,
                    findByRole: () => cn,
                    findByTestId: () => vn,
                    findByText: () => Ot,
                    findByTitle: () => en,
                    fireEvent: () => Sn,
                    getAllByAltText: () => Vt,
                    getAllByDisplayValue: () => Nt,
                    getAllByLabelText: () => gt,
                    getAllByPlaceholderText: () => Mt,
                    getAllByRole: () => an,
                    getAllByTestId: () => fn,
                    getAllByText: () => Pt,
                    getAllByTitle: () => Qt,
                    getByAltText: () => qt,
                    getByDisplayValue: () => kt,
                    getByLabelText: () => vt,
                    getByPlaceholderText: () => wt,
                    getByRole: () => sn,
                    getByTestId: () => mn,
                    getByText: () => Rt,
                    getByTitle: () => Zt,
                    getConfig: () => _e,
                    getDefaultNormalizer: () => Re,
                    getElementError: () => Ye,
                    getMultipleElementsFoundError: () => Qe,
                    getNodeText: () => Be,
                    getQueriesForElement: () => bn,
                    getRoles: () => Fe,
                    getSuggestedQuery: () => We,
                    isInaccessible: () => Ne,
                    logDOM: () => ye,
                    logRoles: () => ze,
                    makeFindQuery: () => rt,
                    makeGetAllQuery: () => nt,
                    makeSingleQuery: () => et,
                    prettyDOM: () => ve,
                    prettyFormat: () => r,
                    queries: () => yn,
                    queryAllByAltText: () => jt,
                    queryAllByAttribute: () => Ze,
                    queryAllByDisplayValue: () => Lt,
                    queryAllByLabelText: () => yt,
                    queryAllByPlaceholderText: () => xt,
                    queryAllByRole: () => rn,
                    queryAllByTestId: () => hn,
                    queryAllByText: () => Ct,
                    queryAllByTitle: () => Jt,
                    queryByAltText: () => Gt,
                    queryByAttribute: () => $e,
                    queryByDisplayValue: () => Dt,
                    queryByLabelText: () => ht,
                    queryByPlaceholderText: () => _t,
                    queryByRole: () => on,
                    queryByTestId: () => pn,
                    queryByText: () => Tt,
                    queryByTitle: () => Yt,
                    queryHelpers: () => st,
                    screen: () => Pn,
                    waitFor: () => Je,
                    waitForElementToBeRemoved: () => Mn,
                    within: () => bn,
                    wrapAllByQueryWithSuggestion: () => ot,
                    wrapSingleQueryWithSuggestion: () => it
                });
                var r = n(228),
                    i = Object.prototype.toString;

                function o(e) {
                    return "function" === typeof e || "[object Function]" === i.call(e)
                }
                var a = Math.pow(2, 53) - 1;

                function s(e) {
                    var t = function(e) {
                        var t = Number(e);
                        return isNaN(t) ? 0 : 0 !== t && isFinite(t) ? (t > 0 ? 1 : -1) * Math.floor(Math.abs(t)) : t
                    }(e);
                    return Math.min(Math.max(t, 0), a)
                }

                function l(e, t) {
                    var n = Array,
                        r = Object(e);
                    if (null == e) throw new TypeError("Array.from requires an array-like object - not null or undefined");
                    if ("undefined" !== typeof t && !o(t)) throw new TypeError("Array.from: when provided, the second argument must be a function");
                    for (var i, a = s(r.length), l = o(n) ? Object(new n(a)) : new Array(a), c = 0; c < a;) i = r[c], l[c] = t ? t(i, c) : i, c += 1;
                    return l.length = a, l
                }

                function c(e) {
                    return c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                        return typeof e
                    } : function(e) {
                        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                    }, c(e)
                }

                function u(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var r = t[n];
                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, d(r.key), r)
                    }
                }

                function d(e) {
                    var t = function(e, t) {
                        if ("object" !== c(e) || null === e) return e;
                        var n = e[Symbol.toPrimitive];
                        if (void 0 !== n) {
                            var r = n.call(e, t || "default");
                            if ("object" !== c(r)) return r;
                            throw new TypeError("@@toPrimitive must return a primitive value.")
                        }
                        return ("string" === t ? String : Number)(e)
                    }(e, "string");
                    return "symbol" === c(t) ? t : String(t)
                }
                const h = "undefined" === typeof Set ? Set : function() {
                    function e() {
                        var t, n, r, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                        ! function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, e), t = this, r = void 0, (n = d(n = "items")) in t ? Object.defineProperty(t, n, {
                            value: r,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : t[n] = r, this.items = i
                    }
                    var t, n, r;
                    return t = e, (n = [{
                        key: "add",
                        value: function(e) {
                            return !1 === this.has(e) && this.items.push(e), this
                        }
                    }, {
                        key: "clear",
                        value: function() {
                            this.items = []
                        }
                    }, {
                        key: "delete",
                        value: function(e) {
                            var t = this.items.length;
                            return this.items = this.items.filter((function(t) {
                                return t !== e
                            })), t !== this.items.length
                        }
                    }, {
                        key: "forEach",
                        value: function(e) {
                            var t = this;
                            this.items.forEach((function(n) {
                                e(n, n, t)
                            }))
                        }
                    }, {
                        key: "has",
                        value: function(e) {
                            return -1 !== this.items.indexOf(e)
                        }
                    }, {
                        key: "size",
                        get: function() {
                            return this.items.length
                        }
                    }]) && u(t.prototype, n), r && u(t, r), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), e
                }();

                function p(e) {
                    var t;
                    return null !== (t = e.localName) && void 0 !== t ? t : e.tagName.toLowerCase()
                }
                var f = {
                        article: "article",
                        aside: "complementary",
                        button: "button",
                        datalist: "listbox",
                        dd: "definition",
                        details: "group",
                        dialog: "dialog",
                        dt: "term",
                        fieldset: "group",
                        figure: "figure",
                        form: "form",
                        footer: "contentinfo",
                        h1: "heading",
                        h2: "heading",
                        h3: "heading",
                        h4: "heading",
                        h5: "heading",
                        h6: "heading",
                        header: "banner",
                        hr: "separator",
                        html: "document",
                        legend: "legend",
                        li: "listitem",
                        math: "math",
                        main: "main",
                        menu: "list",
                        nav: "navigation",
                        ol: "list",
                        optgroup: "group",
                        option: "option",
                        output: "status",
                        progress: "progressbar",
                        section: "region",
                        summary: "button",
                        table: "table",
                        tbody: "rowgroup",
                        textarea: "textbox",
                        tfoot: "rowgroup",
                        td: "cell",
                        th: "columnheader",
                        thead: "rowgroup",
                        tr: "row",
                        ul: "list"
                    },
                    m = {
                        caption: new Set(["aria-label", "aria-labelledby"]),
                        code: new Set(["aria-label", "aria-labelledby"]),
                        deletion: new Set(["aria-label", "aria-labelledby"]),
                        emphasis: new Set(["aria-label", "aria-labelledby"]),
                        generic: new Set(["aria-label", "aria-labelledby", "aria-roledescription"]),
                        insertion: new Set(["aria-label", "aria-labelledby"]),
                        paragraph: new Set(["aria-label", "aria-labelledby"]),
                        presentation: new Set(["aria-label", "aria-labelledby"]),
                        strong: new Set(["aria-label", "aria-labelledby"]),
                        subscript: new Set(["aria-label", "aria-labelledby"]),
                        superscript: new Set(["aria-label", "aria-labelledby"])
                    };

                function g(e, t) {
                    return function(e, t) {
                        return ["aria-atomic", "aria-busy", "aria-controls", "aria-current", "aria-describedby", "aria-details", "aria-dropeffect", "aria-flowto", "aria-grabbed", "aria-hidden", "aria-keyshortcuts", "aria-label", "aria-labelledby", "aria-live", "aria-owns", "aria-relevant", "aria-roledescription"].some((function(n) {
                            var r;
                            return e.hasAttribute(n) && !(null !== (r = m[t]) && void 0 !== r && r.has(n))
                        }))
                    }(e, t)
                }

                function v(e) {
                    var t = function(e) {
                        var t = e.getAttribute("role");
                        if (null !== t) {
                            var n = t.trim().split(" ")[0];
                            if (n.length > 0) return n
                        }
                        return null
                    }(e);
                    if (null === t || "presentation" === t) {
                        var n = function(e) {
                            var t = f[p(e)];
                            if (void 0 !== t) return t;
                            switch (p(e)) {
                                case "a":
                                case "area":
                                case "link":
                                    if (e.hasAttribute("href")) return "link";
                                    break;
                                case "img":
                                    return "" !== e.getAttribute("alt") || g(e, "img") ? "img" : "presentation";
                                case "input":
                                    var n = e.type;
                                    switch (n) {
                                        case "button":
                                        case "image":
                                        case "reset":
                                        case "submit":
                                            return "button";
                                        case "checkbox":
                                        case "radio":
                                            return n;
                                        case "range":
                                            return "slider";
                                        case "email":
                                        case "tel":
                                        case "text":
                                        case "url":
                                            return e.hasAttribute("list") ? "combobox" : "textbox";
                                        case "search":
                                            return e.hasAttribute("list") ? "combobox" : "searchbox";
                                        case "number":
                                            return "spinbutton";
                                        default:
                                            return null
                                    }
                                case "select":
                                    return e.hasAttribute("multiple") || e.size > 1 ? "listbox" : "combobox"
                            }
                            return null
                        }(e);
                        if ("presentation" !== t || g(e, n || "")) return n
                    }
                    return t
                }

                function y(e) {
                    return null !== e && e.nodeType === e.ELEMENT_NODE
                }

                function b(e) {
                    return y(e) && "caption" === p(e)
                }

                function x(e) {
                    return y(e) && "input" === p(e)
                }

                function _(e) {
                    return y(e) && "legend" === p(e)
                }

                function M(e) {
                    return function(e) {
                        return y(e) && void 0 !== e.ownerSVGElement
                    }(e) && "title" === p(e)
                }

                function w(e, t) {
                    if (y(e) && e.hasAttribute(t)) {
                        var n = e.getAttribute(t).split(" "),
                            r = e.getRootNode ? e.getRootNode() : e.ownerDocument;
                        return n.map((function(e) {
                            return r.getElementById(e)
                        })).filter((function(e) {
                            return null !== e
                        }))
                    }
                    return []
                }

                function A(e, t) {
                    return !!y(e) && -1 !== t.indexOf(v(e))
                }

                function S(e, t) {
                    if (!y(e)) return !1;
                    if ("range" === t) return A(e, ["meter", "progressbar", "scrollbar", "slider", "spinbutton"]);
                    throw new TypeError("No knowledge about abstract role '".concat(t, "'. This is likely a bug :("))
                }

                function E(e, t) {
                    var n = l(e.querySelectorAll(t));
                    return w(e, "aria-owns").forEach((function(e) {
                        n.push.apply(n, l(e.querySelectorAll(t)))
                    })), n
                }

                function C(e) {
                    return y(t = e) && "select" === p(t) ? e.selectedOptions || E(e, "[selected]") : E(e, '[aria-selected="true"]');
                    var t
                }

                function T(e) {
                    return x(e) || y(t = e) && "textarea" === p(t) ? e.value : e.textContent || "";
                    var t
                }

                function P(e) {
                    var t = e.getPropertyValue("content");
                    return /^["'].*["']$/.test(t) ? t.slice(1, -1) : ""
                }

                function R(e) {
                    var t = p(e);
                    return "button" === t || "input" === t && "hidden" !== e.getAttribute("type") || "meter" === t || "output" === t || "progress" === t || "select" === t || "textarea" === t
                }

                function I(e) {
                    if (R(e)) return e;
                    var t = null;
                    return e.childNodes.forEach((function(e) {
                        if (null === t && y(e)) {
                            var n = I(e);
                            null !== n && (t = n)
                        }
                    })), t
                }

                function O(e) {
                    if (void 0 !== e.control) return e.control;
                    var t = e.getAttribute("for");
                    return null !== t ? e.ownerDocument.getElementById(t) : I(e)
                }

                function B(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                        n = new h,
                        r = function(e) {
                            var t = (null === e.ownerDocument ? e : e.ownerDocument).defaultView;
                            if (null === t) throw new TypeError("no window available");
                            return t
                        }(e),
                        i = t.compute,
                        o = void 0 === i ? "name" : i,
                        a = t.computedStyleSupportsPseudoElements,
                        s = void 0 === a ? void 0 !== t.getComputedStyle : a,
                        c = t.getComputedStyle,
                        u = void 0 === c ? r.getComputedStyle.bind(r) : c,
                        d = t.hidden,
                        f = void 0 !== d && d;

                    function m(e, t) {
                        var n = "";
                        if (y(e) && s) {
                            var r = P(u(e, "::before"));
                            n = "".concat(r, " ").concat(n)
                        }
                        if ((function(e) {
                                return y(e) && "slot" === p(e)
                            }(e) ? function(e) {
                                var t = e.assignedNodes();
                                return 0 === t.length ? l(e.childNodes) : t
                            }(e) : l(e.childNodes).concat(w(e, "aria-owns"))).forEach((function(e) {
                                var r = E(e, {
                                        isEmbeddedInLabel: t.isEmbeddedInLabel,
                                        isReferenced: !1,
                                        recursion: !0
                                    }),
                                    i = "inline" !== (y(e) ? u(e).getPropertyValue("display") : "inline") ? " " : "";
                                n += "".concat(i).concat(r).concat(i)
                            })), y(e) && s) {
                            var i = P(u(e, "::after"));
                            n = "".concat(n, " ").concat(i)
                        }
                        return n.trim()
                    }

                    function g(e, t) {
                        var r = e.getAttributeNode(t);
                        return null === r || n.has(r) || "" === r.value.trim() ? null : (n.add(r), r.value)
                    }

                    function v(e) {
                        if (!y(e)) return null;
                        if (function(e) {
                                return y(e) && "fieldset" === p(e)
                            }(e)) {
                            n.add(e);
                            for (var t = l(e.childNodes), r = 0; r < t.length; r += 1) {
                                var i = t[r];
                                if (_(i)) return E(i, {
                                    isEmbeddedInLabel: !1,
                                    isReferenced: !1,
                                    recursion: !1
                                })
                            }
                        } else if (function(e) {
                                return y(e) && "table" === p(e)
                            }(e)) {
                            n.add(e);
                            for (var o = l(e.childNodes), a = 0; a < o.length; a += 1) {
                                var s = o[a];
                                if (b(s)) return E(s, {
                                    isEmbeddedInLabel: !1,
                                    isReferenced: !1,
                                    recursion: !1
                                })
                            }
                        } else {
                            if (function(e) {
                                    return y(e) && "svg" === p(e)
                                }(e)) {
                                n.add(e);
                                for (var c = l(e.childNodes), u = 0; u < c.length; u += 1) {
                                    var d = c[u];
                                    if (M(d)) return d.textContent
                                }
                                return null
                            }
                            if ("img" === p(e) || "area" === p(e)) {
                                var h = g(e, "alt");
                                if (null !== h) return h
                            } else if (function(e) {
                                    return y(e) && "optgroup" === p(e)
                                }(e)) {
                                var f = g(e, "label");
                                if (null !== f) return f
                            }
                        }
                        if (x(e) && ("button" === e.type || "submit" === e.type || "reset" === e.type)) {
                            var v = g(e, "value");
                            if (null !== v) return v;
                            if ("submit" === e.type) return "Submit";
                            if ("reset" === e.type) return "Reset"
                        }
                        var w = function(e) {
                            var t = e.labels;
                            return null === t ? t : void 0 !== t ? l(t) : R(e) ? l(e.ownerDocument.querySelectorAll("label")).filter((function(t) {
                                return O(t) === e
                            })) : null
                        }(e);
                        if (null !== w && 0 !== w.length) return n.add(e), l(w).map((function(e) {
                            return E(e, {
                                isEmbeddedInLabel: !0,
                                isReferenced: !1,
                                recursion: !0
                            })
                        })).filter((function(e) {
                            return e.length > 0
                        })).join(" ");
                        if (x(e) && "image" === e.type) {
                            var S = g(e, "alt");
                            if (null !== S) return S;
                            var C = g(e, "title");
                            return null !== C ? C : "Submit Query"
                        }
                        if (A(e, ["button"])) {
                            var T = m(e, {
                                isEmbeddedInLabel: !1,
                                isReferenced: !1
                            });
                            if ("" !== T) return T
                        }
                        return null
                    }

                    function E(e, t) {
                        if (n.has(e)) return "";
                        if (!f && function(e, t) {
                                if (!y(e)) return !1;
                                if (e.hasAttribute("hidden") || "true" === e.getAttribute("aria-hidden")) return !0;
                                var n = t(e);
                                return "none" === n.getPropertyValue("display") || "hidden" === n.getPropertyValue("visibility")
                            }(e, u) && !t.isReferenced) return n.add(e), "";
                        var r = y(e) ? e.getAttributeNode("aria-labelledby") : null,
                            i = null === r || n.has(r) ? [] : w(e, "aria-labelledby");
                        if ("name" === o && !t.isReferenced && i.length > 0) return n.add(r), i.map((function(e) {
                            return E(e, {
                                isEmbeddedInLabel: t.isEmbeddedInLabel,
                                isReferenced: !0,
                                recursion: !1
                            })
                        })).join(" ");
                        var a, s = t.recursion && (A(a = e, ["button", "combobox", "listbox", "textbox"]) || S(a, "range")) && "name" === o;
                        if (!s) {
                            var c = (y(e) && e.getAttribute("aria-label") || "").trim();
                            if ("" !== c && "name" === o) return n.add(e), c;
                            if (! function(e) {
                                    return A(e, ["none", "presentation"])
                                }(e)) {
                                var d = v(e);
                                if (null !== d) return n.add(e), d
                            }
                        }
                        if (A(e, ["menu"])) return n.add(e), "";
                        if (s || t.isEmbeddedInLabel || t.isReferenced) {
                            if (A(e, ["combobox", "listbox"])) {
                                n.add(e);
                                var h = C(e);
                                return 0 === h.length ? x(e) ? e.value : "" : l(h).map((function(e) {
                                    return E(e, {
                                        isEmbeddedInLabel: t.isEmbeddedInLabel,
                                        isReferenced: !1,
                                        recursion: !0
                                    })
                                })).join(" ")
                            }
                            if (S(e, "range")) return n.add(e), e.hasAttribute("aria-valuetext") ? e.getAttribute("aria-valuetext") : e.hasAttribute("aria-valuenow") ? e.getAttribute("aria-valuenow") : e.getAttribute("value") || "";
                            if (A(e, ["textbox"])) return n.add(e), T(e)
                        }
                        if (function(e) {
                                return A(e, ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "label", "legend", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"])
                            }(e) || y(e) && t.isReferenced || function(e) {
                                return b(e)
                            }(e)) {
                            var p = m(e, {
                                isEmbeddedInLabel: t.isEmbeddedInLabel,
                                isReferenced: !1
                            });
                            if ("" !== p) return n.add(e), p
                        }
                        if (e.nodeType === e.TEXT_NODE) return n.add(e), e.textContent || "";
                        if (t.recursion) return n.add(e), m(e, {
                            isEmbeddedInLabel: t.isEmbeddedInLabel,
                            isReferenced: !1
                        });
                        var _ = function(e) {
                            return y(e) ? g(e, "title") : null
                        }(e);
                        return null !== _ ? (n.add(e), _) : (n.add(e), "")
                    }
                    return E(e, {
                        isEmbeddedInLabel: !1,
                        isReferenced: "description" === o,
                        recursion: !1
                    }).trim().replace(/\s\s+/g, " ")
                }

                function L(e) {
                    return L = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                        return typeof e
                    } : function(e) {
                        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                    }, L(e)
                }

                function D(e, t) {
                    var n = Object.keys(e);
                    if (Object.getOwnPropertySymbols) {
                        var r = Object.getOwnPropertySymbols(e);
                        t && (r = r.filter((function(t) {
                            return Object.getOwnPropertyDescriptor(e, t).enumerable
                        }))), n.push.apply(n, r)
                    }
                    return n
                }

                function N(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var n = null != arguments[t] ? arguments[t] : {};
                        t % 2 ? D(Object(n), !0).forEach((function(t) {
                            k(e, t, n[t])
                        })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : D(Object(n)).forEach((function(t) {
                            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
                        }))
                    }
                    return e
                }

                function k(e, t, n) {
                    return (t = function(e) {
                        var t = function(e, t) {
                            if ("object" !== L(e) || null === e) return e;
                            var n = e[Symbol.toPrimitive];
                            if (void 0 !== n) {
                                var r = n.call(e, t || "default");
                                if ("object" !== L(r)) return r;
                                throw new TypeError("@@toPrimitive must return a primitive value.")
                            }
                            return ("string" === t ? String : Number)(e)
                        }(e, "string");
                        return "symbol" === L(t) ? t : String(t)
                    }(t)) in e ? Object.defineProperty(e, t, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : e[t] = n, e
                }

                function F(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                        n = w(e, "aria-describedby").map((function(e) {
                            return B(e, N(N({}, t), {}, {
                                compute: "description"
                            }))
                        })).join(" ");
                    if ("" === n) {
                        var r = e.getAttribute("title");
                        n = null === r ? "" : r
                    }
                    return n
                }

                function U(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    return A(e, ["caption", "code", "deletion", "emphasis", "generic", "insertion", "paragraph", "presentation", "strong", "subscript", "superscript"]) ? "" : B(e, t)
                }
                var z = n(4616),
                    H = n(6711),
                    j = n.n(H);

                function G(e) {
                    return e.replace(/</g, "&lt;").replace(/>/g, "&gt;")
                }
                e = n.hmd(e);
                const V = (e, t, n, r, i, o, a) => {
                        const s = r + n.indent,
                            l = n.colors;
                        return e.map((e => {
                            const c = t[e];
                            let u = a(c, n, s, i, o);
                            return "string" !== typeof c && (-1 !== u.indexOf("\n") && (u = n.spacingOuter + s + u + n.spacingOuter + r), u = "{" + u + "}"), n.spacingInner + r + l.prop.open + e + l.prop.close + "=" + l.value.open + u + l.value.close
                        })).join("")
                    },
                    q = (e, t, n, r, i, o) => e.map((e => {
                        const a = "string" === typeof e ? W(e, t) : o(e, t, n, r, i);
                        return "" === a && "object" === typeof e && null !== e && 3 !== e.nodeType ? "" : t.spacingOuter + n + a
                    })).join(""),
                    W = (e, t) => {
                        const n = t.colors.content;
                        return n.open + G(e) + n.close
                    },
                    X = (e, t) => {
                        const n = t.colors.comment;
                        return n.open + "\x3c!--" + G(e) + "--\x3e" + n.close
                    },
                    K = (e, t, n, r, i) => {
                        const o = r.colors.tag;
                        return o.open + "<" + e + (t && o.close + t + r.spacingOuter + i + o.open) + (n ? ">" + o.close + n + r.spacingOuter + i + o.open + "</" + e : (t && !r.min ? "" : " ") + "/") + ">" + o.close
                    },
                    J = (e, t) => {
                        const n = t.colors.tag;
                        return n.open + "<" + e + n.close + " \u2026" + n.open + " />" + n.close
                    },
                    Y = 3,
                    Q = 8,
                    Z = 11,
                    $ = /^((HTML|SVG)\w*)?Element$/,
                    ee = e => {
                        const t = e.constructor.name,
                            {
                                nodeType: n,
                                tagName: r
                            } = e,
                            i = "string" === typeof r && r.includes("-") || "function" === typeof e.hasAttribute && e.hasAttribute("is");
                        return 1 === n && ($.test(t) || i) || n === Y && "Text" === t || n === Q && "Comment" === t || n === Z && "DocumentFragment" === t
                    };

                function te(e) {
                    return e.nodeType === Z
                }

                function ne(e) {
                    return {
                        test: e => {
                            var t;
                            return (null == e || null == (t = e.constructor) ? void 0 : t.name) && ee(e)
                        },
                        serialize: (t, n, r, i, o, a) => {
                            if (function(e) {
                                    return e.nodeType === Y
                                }(t)) return W(t.data, n);
                            if (function(e) {
                                    return e.nodeType === Q
                                }(t)) return X(t.data, n);
                            const s = te(t) ? "DocumentFragment" : t.tagName.toLowerCase();
                            return ++i > n.maxDepth ? J(s, n) : K(s, V(te(t) ? [] : Array.from(t.attributes).map((e => e.name)).sort(), te(t) ? {} : Array.from(t.attributes).reduce(((e, t) => (e[t.name] = t.value, e)), {}), n, r + n.indent, i, o, a), q(Array.prototype.slice.call(t.childNodes || t.children).filter(e), n, r + n.indent, i, o, a), n, r)
                        }
                    }
                }
                let re = null,
                    ie = null,
                    oe = null;
                try {
                    const t = e && e.require;
                    ie = t.call(e, "fs").readFileSync, oe = t.call(e, "@babel/code-frame").codeFrameColumns, re = t.call(e, "chalk")
                } catch {}

                function ae() {
                    if (!ie || !oe) return "";
                    return function(e) {
                        const t = e.indexOf("(") + 1,
                            n = e.indexOf(")"),
                            r = e.slice(t, n),
                            i = r.split(":"),
                            [o, a, s] = [i[0], parseInt(i[1], 10), parseInt(i[2], 10)];
                        let l = "";
                        try {
                            l = ie(o, "utf-8")
                        } catch {
                            return ""
                        }
                        const c = oe(l, {
                            start: {
                                line: a,
                                column: s
                            }
                        }, {
                            highlightCode: !0,
                            linesBelow: 0
                        });
                        return re.dim(r) + "\n" + c + "\n"
                    }((new Error).stack.split("\n").slice(1).find((e => !e.includes("node_modules/"))))
                }
                const se = 3;

                function le() {
                    return "undefined" !== typeof jest && null !== jest && (!0 === setTimeout._isMockFunction || Object.prototype.hasOwnProperty.call(setTimeout, "clock"))
                }

                function ce() {
                    if ("undefined" === typeof window) throw new Error("Could not find default container");
                    return window.document
                }

                function ue(e) {
                    if (e.defaultView) return e.defaultView;
                    if (e.ownerDocument && e.ownerDocument.defaultView) return e.ownerDocument.defaultView;
                    if (e.window) return e.window;
                    throw e.ownerDocument && null === e.ownerDocument.defaultView ? new Error("It looks like the window object is not available for the provided node.") : e.then instanceof Function ? new Error("It looks like you passed a Promise object instead of a DOM node. Did you do something like `fireEvent.click(screen.findBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`, or await the findBy query `fireEvent.click(await screen.findBy...`?") : Array.isArray(e) ? new Error("It looks like you passed an Array instead of a DOM node. Did you do something like `fireEvent.click(screen.getAllBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`?") : "function" === typeof e.debug && "function" === typeof e.logTestingPlaygroundURL ? new Error("It looks like you passed a `screen` object. Did you do something like `fireEvent.click(screen, ...` when you meant to use a query, e.g. `fireEvent.click(screen.getBy..., `?") : new Error("The given node is not an Element, the node type is: " + typeof e + ".")
                }

                function de(e) {
                    if (!e || "function" !== typeof e.querySelector || "function" !== typeof e.querySelectorAll) throw new TypeError("Expected container to be an Element, a Document or a DocumentFragment but got " + function(e) {
                        if ("object" === typeof e) return null === e ? "null" : e.constructor.name;
                        return typeof e
                    }(e) + ".")
                }
                const he = () => {
                        let e;
                        try {
                            var t;
                            e = JSON.parse(null == process || null == (t = {
                                NODE_ENV: "production",
                                PUBLIC_URL: "",
                                WDS_SOCKET_HOST: void 0,
                                WDS_SOCKET_PATH: void 0,
                                WDS_SOCKET_PORT: void 0,
                                FAST_REFRESH: !0,
                                REACT_APP_PRICING_API_TOKEN: "Token 8f365b2027ef6a62b0a4027a5171238a09838305"
                            }) ? void 0 : t.COLORS)
                        } catch (n) {}
                        return "boolean" === typeof e ? e : "undefined" !== typeof process && void 0 !== process.versions && void 0 !== process.versions.node
                    },
                    {
                        DOMCollection: pe
                    } = r.plugins,
                    fe = 1,
                    me = 8;

                function ge(e) {
                    return e.nodeType !== me && (e.nodeType !== fe || !e.matches(_e().defaultIgnore))
                }

                function ve(e, t, n) {
                    if (void 0 === n && (n = {}), e || (e = ce().body), "number" !== typeof t && (t = "undefined" !== typeof process && {
                            NODE_ENV: "production",
                            PUBLIC_URL: "",
                            WDS_SOCKET_HOST: void 0,
                            WDS_SOCKET_PATH: void 0,
                            WDS_SOCKET_PORT: void 0,
                            FAST_REFRESH: !0,
                            REACT_APP_PRICING_API_TOKEN: "Token 8f365b2027ef6a62b0a4027a5171238a09838305"
                        }.DEBUG_PRINT_LIMIT || 7e3), 0 === t) return "";
                    e.documentElement && (e = e.documentElement);
                    let i = typeof e;
                    if ("object" === i ? i = e.constructor.name : e = {}, !("outerHTML" in e)) throw new TypeError("Expected an element or document but got " + i);
                    const {
                        filterNode: o = ge,
                        ...a
                    } = n, s = r.format(e, {
                        plugins: [ne(o), pe],
                        printFunctionName: !1,
                        highlight: he(),
                        ...a
                    });
                    return void 0 !== t && e.outerHTML.length > t ? s.slice(0, t) + "..." : s
                }
                const ye = function() {
                    const e = ae();
                    e ? console.log(ve(...arguments) + "\n\n" + e) : console.log(ve(...arguments))
                };
                let be = {
                    testIdAttribute: "data-testid",
                    asyncUtilTimeout: 1e3,
                    asyncWrapper: e => e(),
                    unstable_advanceTimersWrapper: e => e(),
                    eventWrapper: e => e(),
                    defaultHidden: !1,
                    defaultIgnore: "script, style",
                    showOriginalStackTrace: !1,
                    throwSuggestions: !1,
                    getElementError(e, t) {
                        const n = ve(t),
                            r = new Error([e, "Ignored nodes: comments, " + be.defaultIgnore + "\n" + n].filter(Boolean).join("\n\n"));
                        return r.name = "TestingLibraryElementError", r
                    },
                    _disableExpensiveErrorDiagnostics: !1,
                    computedStyleSupportsPseudoElements: !1
                };

                function xe(e) {
                    "function" === typeof e && (e = e(be)), be = { ...be,
                        ...e
                    }
                }

                function _e() {
                    return be
                }
                const Me = ["button", "meter", "output", "progress", "select", "textarea", "input"];

                function we(e) {
                    return Me.includes(e.nodeName.toLowerCase()) ? "" : e.nodeType === se ? e.textContent : Array.from(e.childNodes).map((e => we(e))).join("")
                }

                function Ae(e) {
                    let t;
                    return t = "label" === e.tagName.toLowerCase() ? we(e) : e.value || e.textContent, t
                }

                function Se(e) {
                    var t;
                    if (void 0 !== e.labels) return null != (t = e.labels) ? t : [];
                    if (! function(e) {
                            return /BUTTON|METER|OUTPUT|PROGRESS|SELECT|TEXTAREA/.test(e.tagName) || "INPUT" === e.tagName && "hidden" !== e.getAttribute("type")
                        }(e)) return [];
                    const n = e.ownerDocument.querySelectorAll("label");
                    return Array.from(n).filter((t => t.control === e))
                }

                function Ee(e, t, n) {
                    let {
                        selector: r = "*"
                    } = void 0 === n ? {} : n;
                    const i = t.getAttribute("aria-labelledby"),
                        o = i ? i.split(" ") : [];
                    return o.length ? o.map((t => {
                        const n = e.querySelector('[id="' + t + '"]');
                        return n ? {
                            content: Ae(n),
                            formControl: null
                        } : {
                            content: "",
                            formControl: null
                        }
                    })) : Array.from(Se(t)).map((e => ({
                        content: Ae(e),
                        formControl: Array.from(e.querySelectorAll("button, input, meter, output, progress, select, textarea")).filter((e => e.matches(r)))[0]
                    })))
                }

                function Ce(e) {
                    if (null === e || void 0 === e) throw new Error("It looks like " + e + " was passed instead of a matcher. Did you do something like getByText(" + e + ")?")
                }

                function Te(e, t, n, r) {
                    if ("string" !== typeof e) return !1;
                    Ce(n);
                    const i = r(e);
                    return "string" === typeof n || "number" === typeof n ? i.toLowerCase().includes(n.toString().toLowerCase()) : "function" === typeof n ? n(i, t) : Oe(n, i)
                }

                function Pe(e, t, n, r) {
                    if ("string" !== typeof e) return !1;
                    Ce(n);
                    const i = r(e);
                    return n instanceof Function ? n(i, t) : n instanceof RegExp ? Oe(n, i) : i === String(n)
                }

                function Re(e) {
                    let {
                        trim: t = !0,
                        collapseWhitespace: n = !0
                    } = void 0 === e ? {} : e;
                    return e => {
                        let r = e;
                        return r = t ? r.trim() : r, r = n ? r.replace(/\s+/g, " ") : r, r
                    }
                }

                function Ie(e) {
                    let {
                        trim: t,
                        collapseWhitespace: n,
                        normalizer: r
                    } = e;
                    if (!r) return Re({
                        trim: t,
                        collapseWhitespace: n
                    });
                    if ("undefined" !== typeof t || "undefined" !== typeof n) throw new Error('trim and collapseWhitespace are not supported with a normalizer. If you want to use the default trim and collapseWhitespace logic in your normalizer, use "getDefaultNormalizer({trim, collapseWhitespace})" and compose that into your normalizer');
                    return r
                }

                function Oe(e, t) {
                    const n = e.test(t);
                    return e.global && 0 !== e.lastIndex && (console.warn("To match all elements we had to reset the lastIndex of the RegExp because the global flag is enabled. We encourage to remove the global flag from the RegExp."), e.lastIndex = 0), n
                }

                function Be(e) {
                    return e.matches("input[type=submit], input[type=button], input[type=reset]") ? e.value : Array.from(e.childNodes).filter((e => e.nodeType === se && Boolean(e.textContent))).map((e => e.textContent)).join("")
                }
                const Le = function(e) {
                    function t(e) {
                        let {
                            attributes: t = []
                        } = e;
                        return t.length
                    }

                    function n(e) {
                        let {
                            attributes: t = []
                        } = e;
                        const n = t.findIndex((e => e.value && "type" === e.name && "text" === e.value));
                        n >= 0 && (t = [...t.slice(0, n), ...t.slice(n + 1)]);
                        const r = function(e) {
                            let {
                                name: t,
                                attributes: n
                            } = e;
                            return "" + t + n.map((e => {
                                let {
                                    name: t,
                                    value: n,
                                    constraints: r = []
                                } = e;
                                return -1 !== r.indexOf("undefined") ? ":not([" + t + "])" : n ? "[" + t + '="' + n + '"]' : "[" + t + "]"
                            })).join("")
                        }({ ...e,
                            attributes: t
                        });
                        return e => !(n >= 0 && "text" !== e.type) && e.matches(r)
                    }
                    let r = [];
                    for (const [i, o] of e.entries()) r = [...r, {
                        match: n(i),
                        roles: Array.from(o),
                        specificity: t(i)
                    }];
                    return r.sort((function(e, t) {
                        let {
                            specificity: n
                        } = e, {
                            specificity: r
                        } = t;
                        return r - n
                    }))
                }(z.Er);

                function De(e) {
                    if (!0 === e.hidden) return !0;
                    if ("true" === e.getAttribute("aria-hidden")) return !0;
                    return "none" === e.ownerDocument.defaultView.getComputedStyle(e).display
                }

                function Ne(e, t) {
                    void 0 === t && (t = {});
                    const {
                        isSubtreeInaccessible: n = De
                    } = t;
                    if ("hidden" === e.ownerDocument.defaultView.getComputedStyle(e).visibility) return !0;
                    let r = e;
                    for (; r;) {
                        if (n(r)) return !0;
                        r = r.parentElement
                    }
                    return !1
                }

                function ke(e) {
                    for (const {
                            match: t,
                            roles: n
                        } of Le)
                        if (t(e)) return [...n];
                    return []
                }

                function Fe(e, t) {
                    let {
                        hidden: n = !1
                    } = void 0 === t ? {} : t;
                    return function e(t) {
                        return [t, ...Array.from(t.children).reduce(((t, n) => [...t, ...e(n)]), [])]
                    }(e).filter((e => !1 !== n || !1 === Ne(e))).reduce(((e, t) => {
                        let n = [];
                        return n = t.hasAttribute("role") ? t.getAttribute("role").split(" ").slice(0, 1) : ke(t), n.reduce(((e, n) => Array.isArray(e[n]) ? { ...e,
                            [n]: [...e[n], t]
                        } : { ...e,
                            [n]: [t]
                        }), e)
                    }), {})
                }

                function Ue(e, t) {
                    let {
                        hidden: n,
                        includeDescription: r
                    } = t;
                    const i = Fe(e, {
                        hidden: n
                    });
                    return Object.entries(i).filter((e => {
                        let [t] = e;
                        return "generic" !== t
                    })).map((e => {
                        let [t, n] = e;
                        const i = "-".repeat(50);
                        return t + ":\n\n" + n.map((e => {
                            const t = 'Name "' + U(e, {
                                    computedStyleSupportsPseudoElements: _e().computedStyleSupportsPseudoElements
                                }) + '":\n',
                                n = ve(e.cloneNode(!1));
                            if (r) {
                                return "" + t + ('Description "' + F(e, {
                                    computedStyleSupportsPseudoElements: _e().computedStyleSupportsPseudoElements
                                }) + '":\n') + n
                            }
                            return "" + t + n
                        })).join("\n\n") + "\n\n" + i
                    })).join("\n")
                }
                const ze = function(e, t) {
                    let {
                        hidden: n = !1
                    } = void 0 === t ? {} : t;
                    return console.log(Ue(e, {
                        hidden: n
                    }))
                };

                function He(e, t) {
                    const n = e.getAttribute(t);
                    return "true" === n || "false" !== n && void 0
                }
                const je = Re();

                function Ge(e) {
                    return new RegExp(function(e) {
                        return e.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&")
                    }(e.toLowerCase()), "i")
                }

                function Ve(e, t, n, r) {
                    let {
                        variant: i,
                        name: o
                    } = r, a = "";
                    const s = {},
                        l = [
                            ["Role", "TestId"].includes(e) ? n : Ge(n)
                        ];
                    o && (s.name = Ge(o)), "Role" === e && Ne(t) && (s.hidden = !0, a = "Element is inaccessible. This means that the element and all its children are invisible to screen readers.\n    If you are using the aria-hidden prop, make sure this is the right choice for your case.\n    "), Object.keys(s).length > 0 && l.push(s);
                    const c = i + "By" + e;
                    return {
                        queryName: e,
                        queryMethod: c,
                        queryArgs: l,
                        variant: i,
                        warning: a,
                        toString() {
                            a && console.warn(a);
                            let [e, t] = l;
                            return e = "string" === typeof e ? "'" + e + "'" : e, t = t ? ", { " + Object.entries(t).map((e => {
                                let [t, n] = e;
                                return t + ": " + n
                            })).join(", ") + " }" : "", c + "(" + e + t + ")"
                        }
                    }
                }

                function qe(e, t, n) {
                    return n && (!t || t.toLowerCase() === e.toLowerCase())
                }

                function We(e, t, n) {
                    var r, i;
                    if (void 0 === t && (t = "get"), e.matches(_e().defaultIgnore)) return;
                    const o = null != (r = e.getAttribute("role")) ? r : null == (i = ke(e)) ? void 0 : i[0];
                    if ("generic" !== o && qe("Role", n, o)) return Ve("Role", e, o, {
                        variant: t,
                        name: U(e, {
                            computedStyleSupportsPseudoElements: _e().computedStyleSupportsPseudoElements
                        })
                    });
                    const a = Ee(document, e).map((e => e.content)).join(" ");
                    if (qe("LabelText", n, a)) return Ve("LabelText", e, a, {
                        variant: t
                    });
                    const s = e.getAttribute("placeholder");
                    if (qe("PlaceholderText", n, s)) return Ve("PlaceholderText", e, s, {
                        variant: t
                    });
                    const l = je(Be(e));
                    if (qe("Text", n, l)) return Ve("Text", e, l, {
                        variant: t
                    });
                    if (qe("DisplayValue", n, e.value)) return Ve("DisplayValue", e, je(e.value), {
                        variant: t
                    });
                    const c = e.getAttribute("alt");
                    if (qe("AltText", n, c)) return Ve("AltText", e, c, {
                        variant: t
                    });
                    const u = e.getAttribute("title");
                    if (qe("Title", n, u)) return Ve("Title", e, u, {
                        variant: t
                    });
                    const d = e.getAttribute(_e().testIdAttribute);
                    return qe("TestId", n, d) ? Ve("TestId", e, d, {
                        variant: t
                    }) : void 0
                }

                function Xe(e, t) {
                    e.stack = t.stack.replace(t.message, e.message)
                }

                function Ke(e, t) {
                    let {
                        container: n = ce(),
                        timeout: r = _e().asyncUtilTimeout,
                        showOriginalStackTrace: i = _e().showOriginalStackTrace,
                        stackTraceError: o,
                        interval: a = 50,
                        onTimeout: s = (e => (e.message = _e().getElementError(e.message, n).message, e)),
                        mutationObserverOptions: l = {
                            subtree: !0,
                            childList: !0,
                            attributes: !0,
                            characterData: !0
                        }
                    } = t;
                    if ("function" !== typeof e) throw new TypeError("Received `callback` arg must be a function");
                    return new Promise((async (t, c) => {
                        let u, d, h, p = !1,
                            f = "idle";
                        const m = setTimeout((function() {
                                let e;
                                u ? (e = u, i || "TestingLibraryElementError" !== e.name || Xe(e, o)) : (e = new Error("Timed out in waitFor."), i || Xe(e, o));
                                v(s(e), null)
                            }), r),
                            g = le();
                        if (g) {
                            const {
                                unstable_advanceTimersWrapper: e
                            } = _e();
                            for (b(); !p;) {
                                if (!le()) {
                                    const e = new Error("Changed from using fake timers to real timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to real timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
                                    return i || Xe(e, o), void c(e)
                                }
                                if (e((() => {
                                        jest.advanceTimersByTime(a)
                                    })), b(), p) break;
                                await e((async () => {
                                    await new Promise((e => {
                                        setTimeout(e, 0), jest.advanceTimersByTime(0)
                                    }))
                                }))
                            }
                        } else {
                            try {
                                de(n)
                            } catch (x) {
                                return void c(x)
                            }
                            d = setInterval(y, a);
                            const {
                                MutationObserver: e
                            } = ue(n);
                            h = new e(y), h.observe(n, l), b()
                        }

                        function v(e, n) {
                            p = !0, clearTimeout(m), g || (clearInterval(d), h.disconnect()), e ? c(e) : t(n)
                        }

                        function y() {
                            if (le()) {
                                const e = new Error("Changed from using real timers to fake timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to fake timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
                                return i || Xe(e, o), c(e)
                            }
                            return b()
                        }

                        function b() {
                            if ("pending" !== f) try {
                                const t = function(e) {
                                    try {
                                        return be._disableExpensiveErrorDiagnostics = !0, e()
                                    } finally {
                                        be._disableExpensiveErrorDiagnostics = !1
                                    }
                                }(e);
                                "function" === typeof(null == t ? void 0 : t.then) ? (f = "pending", t.then((e => {
                                    f = "resolved", v(null, e)
                                }), (e => {
                                    f = "rejected", u = e
                                }))) : v(null, t)
                            } catch (t) {
                                u = t
                            }
                        }
                    }))
                }

                function Je(e, t) {
                    const n = new Error("STACK_TRACE_MESSAGE");
                    return _e().asyncWrapper((() => Ke(e, {
                        stackTraceError: n,
                        ...t
                    })))
                }

                function Ye(e, t) {
                    return _e().getElementError(e, t)
                }

                function Qe(e, t) {
                    return Ye(e + "\n\n(If this is intentional, then use the `*AllBy*` variant of the query (like `queryAllByText`, `getAllByText`, or `findAllByText`)).", t)
                }

                function Ze(e, t, n, r) {
                    let {
                        exact: i = !0,
                        collapseWhitespace: o,
                        trim: a,
                        normalizer: s
                    } = void 0 === r ? {} : r;
                    const l = i ? Pe : Te,
                        c = Ie({
                            collapseWhitespace: o,
                            trim: a,
                            normalizer: s
                        });
                    return Array.from(t.querySelectorAll("[" + e + "]")).filter((t => l(t.getAttribute(e), t, n, c)))
                }

                function $e(e, t, n, r) {
                    const i = Ze(e, t, n, r);
                    if (i.length > 1) throw Qe("Found multiple elements by [" + e + "=" + n + "]", t);
                    return i[0] || null
                }

                function et(e, t) {
                    return function(n) {
                        for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++) i[o - 1] = arguments[o];
                        const a = e(n, ...i);
                        if (a.length > 1) {
                            const e = a.map((e => Ye(null, e).message)).join("\n\n");
                            throw Qe(t(n, ...i) + "\n\nHere are the matching elements:\n\n" + e, n)
                        }
                        return a[0] || null
                    }
                }

                function tt(e, t) {
                    return _e().getElementError("A better query is available, try this:\n" + e.toString() + "\n", t)
                }

                function nt(e, t) {
                    return function(n) {
                        for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++) i[o - 1] = arguments[o];
                        const a = e(n, ...i);
                        if (!a.length) throw _e().getElementError(t(n, ...i), n);
                        return a
                    }
                }

                function rt(e) {
                    return (t, n, r, i) => Je((() => e(t, n, r)), {
                        container: t,
                        ...i
                    })
                }
                const it = (e, t, n) => function(r) {
                        for (var i = arguments.length, o = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++) o[a - 1] = arguments[a];
                        const s = e(r, ...o),
                            [{
                                suggest: l = _e().throwSuggestions
                            } = {}] = o.slice(-1);
                        if (s && l) {
                            const e = We(s, n);
                            if (e && !t.endsWith(e.queryName)) throw tt(e.toString(), r)
                        }
                        return s
                    },
                    ot = (e, t, n) => function(r) {
                        for (var i = arguments.length, o = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++) o[a - 1] = arguments[a];
                        const s = e(r, ...o),
                            [{
                                suggest: l = _e().throwSuggestions
                            } = {}] = o.slice(-1);
                        if (s.length && l) {
                            const e = [...new Set(s.map((e => {
                                var t;
                                return null == (t = We(e, n)) ? void 0 : t.toString()
                            })))];
                            if (1 === e.length && !t.endsWith(We(s[0], n).queryName)) throw tt(e[0], r)
                        }
                        return s
                    };

                function at(e, t, n) {
                    const r = it(et(e, t), e.name, "query"),
                        i = nt(e, n),
                        o = et(i, t),
                        a = it(o, e.name, "get");
                    return [r, ot(i, e.name.replace("query", "get"), "getAll"), a, rt(ot(i, e.name, "findAll")), rt(it(o, e.name, "find"))]
                }
                var st = Object.freeze({
                    __proto__: null,
                    getElementError: Ye,
                    wrapAllByQueryWithSuggestion: ot,
                    wrapSingleQueryWithSuggestion: it,
                    getMultipleElementsFoundError: Qe,
                    queryAllByAttribute: Ze,
                    queryByAttribute: $e,
                    makeSingleQuery: et,
                    makeGetAllQuery: nt,
                    makeFindQuery: rt,
                    buildQueries: at
                });
                const lt = function(e, t, n) {
                        let {
                            exact: r = !0,
                            trim: i,
                            collapseWhitespace: o,
                            normalizer: a
                        } = void 0 === n ? {} : n;
                        const s = r ? Pe : Te,
                            l = Ie({
                                collapseWhitespace: o,
                                trim: i,
                                normalizer: a
                            }),
                            c = function(e) {
                                return Array.from(e.querySelectorAll("label,input")).map((e => ({
                                    node: e,
                                    textToMatch: Ae(e)
                                }))).filter((e => {
                                    let {
                                        textToMatch: t
                                    } = e;
                                    return null !== t
                                }))
                            }(e);
                        return c.filter((e => {
                            let {
                                node: n,
                                textToMatch: r
                            } = e;
                            return s(r, n, t, l)
                        })).map((e => {
                            let {
                                node: t
                            } = e;
                            return t
                        }))
                    },
                    ct = function(e, t, n) {
                        let {
                            selector: r = "*",
                            exact: i = !0,
                            collapseWhitespace: o,
                            trim: a,
                            normalizer: s
                        } = void 0 === n ? {} : n;
                        de(e);
                        const l = i ? Pe : Te,
                            c = Ie({
                                collapseWhitespace: o,
                                trim: a,
                                normalizer: s
                            }),
                            u = Array.from(e.querySelectorAll("*")).filter((e => Se(e).length || e.hasAttribute("aria-labelledby"))).reduce(((n, i) => {
                                const o = Ee(e, i, {
                                    selector: r
                                });
                                o.filter((e => Boolean(e.formControl))).forEach((e => {
                                    l(e.content, e.formControl, t, c) && e.formControl && n.push(e.formControl)
                                }));
                                const a = o.filter((e => Boolean(e.content))).map((e => e.content));
                                return l(a.join(" "), i, t, c) && n.push(i), a.length > 1 && a.forEach(((e, r) => {
                                    l(e, i, t, c) && n.push(i);
                                    const o = [...a];
                                    o.splice(r, 1), o.length > 1 && l(o.join(" "), i, t, c) && n.push(i)
                                })), n
                            }), []).concat(Ze("aria-label", e, t, {
                                exact: i,
                                normalizer: c
                            }));
                        return Array.from(new Set(u)).filter((e => e.matches(r)))
                    },
                    ut = function(e, t) {
                        for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++) r[i - 2] = arguments[i];
                        const o = ct(e, t, ...r);
                        if (!o.length) {
                            const n = lt(e, t, ...r);
                            if (n.length) {
                                const r = n.map((t => function(e, t) {
                                    const n = t.getAttribute("for");
                                    if (!n) return null;
                                    const r = e.querySelector('[id="' + n + '"]');
                                    return r ? r.tagName.toLowerCase() : null
                                }(e, t))).filter((e => !!e));
                                throw r.length ? _e().getElementError(r.map((e => "Found a label with the text of: " + t + ", however the element associated with this label (<" + e + " />) is non-labellable [https://html.spec.whatwg.org/multipage/forms.html#category-label]. If you really need to label a <" + e + " />, you can use aria-label or aria-labelledby instead.")).join("\n\n"), e) : _e().getElementError("Found a label with the text of: " + t + ', however no form control was found associated to that label. Make sure you\'re using the "for" attribute or "aria-labelledby" attribute correctly.', e)
                            }
                            throw _e().getElementError("Unable to find a label with the text of: " + t, e)
                        }
                        return o
                    };
                const dt = (e, t) => "Found multiple elements with the text of: " + t,
                    ht = it(et(ct, dt), ct.name, "query"),
                    pt = et(ut, dt),
                    ft = rt(ot(ut, ut.name, "findAll")),
                    mt = rt(it(pt, ut.name, "find")),
                    gt = ot(ut, ut.name, "getAll"),
                    vt = it(pt, ut.name, "get"),
                    yt = ot(ct, ct.name, "queryAll"),
                    bt = function() {
                        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                        return de(t[0]), Ze("placeholder", ...t)
                    },
                    xt = ot(bt, bt.name, "queryAll"),
                    [_t, Mt, wt, At, St] = at(bt, ((e, t) => "Found multiple elements with the placeholder text of: " + t), ((e, t) => "Unable to find an element with the placeholder text of: " + t)),
                    Et = function(e, t, n) {
                        let {
                            selector: r = "*",
                            exact: i = !0,
                            collapseWhitespace: o,
                            trim: a,
                            ignore: s = _e().defaultIgnore,
                            normalizer: l
                        } = void 0 === n ? {} : n;
                        de(e);
                        const c = i ? Pe : Te,
                            u = Ie({
                                collapseWhitespace: o,
                                trim: a,
                                normalizer: l
                            });
                        let d = [];
                        return "function" === typeof e.matches && e.matches(r) && (d = [e]), [...d, ...Array.from(e.querySelectorAll(r))].filter((e => !s || !e.matches(s))).filter((e => c(Be(e), e, t, u)))
                    },
                    Ct = ot(Et, Et.name, "queryAll"),
                    [Tt, Pt, Rt, It, Ot] = at(Et, ((e, t) => "Found multiple elements with the text: " + t), (function(e, t, n) {
                        void 0 === n && (n = {});
                        const {
                            collapseWhitespace: r,
                            trim: i,
                            normalizer: o,
                            selector: a
                        } = n, s = Ie({
                            collapseWhitespace: r,
                            trim: i,
                            normalizer: o
                        })(t.toString());
                        return "Unable to find an element with the text: " + (s !== t.toString() ? s + " (normalized from '" + t + "')" : t) + ("*" !== (null != a ? a : "*") ? ", which matches selector '" + a + "'" : "") + ". This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible."
                    })),
                    Bt = function(e, t, n) {
                        let {
                            exact: r = !0,
                            collapseWhitespace: i,
                            trim: o,
                            normalizer: a
                        } = void 0 === n ? {} : n;
                        de(e);
                        const s = r ? Pe : Te,
                            l = Ie({
                                collapseWhitespace: i,
                                trim: o,
                                normalizer: a
                            });
                        return Array.from(e.querySelectorAll("input,textarea,select")).filter((e => {
                            if ("SELECT" === e.tagName) {
                                return Array.from(e.options).filter((e => e.selected)).some((e => s(Be(e), e, t, l)))
                            }
                            return s(e.value, e, t, l)
                        }))
                    },
                    Lt = ot(Bt, Bt.name, "queryAll"),
                    [Dt, Nt, kt, Ft, Ut] = at(Bt, ((e, t) => "Found multiple elements with the display value: " + t + "."), ((e, t) => "Unable to find an element with the display value: " + t + ".")),
                    zt = /^(img|input|area|.+-.+)$/i,
                    Ht = function(e, t, n) {
                        return void 0 === n && (n = {}), de(e), Ze("alt", e, t, n).filter((e => zt.test(e.tagName)))
                    },
                    jt = ot(Ht, Ht.name, "queryAll"),
                    [Gt, Vt, qt, Wt, Xt] = at(Ht, ((e, t) => "Found multiple elements with the alt text: " + t), ((e, t) => "Unable to find an element with the alt text: " + t)),
                    Kt = function(e, t, n) {
                        let {
                            exact: r = !0,
                            collapseWhitespace: i,
                            trim: o,
                            normalizer: a
                        } = void 0 === n ? {} : n;
                        de(e);
                        const s = r ? Pe : Te,
                            l = Ie({
                                collapseWhitespace: i,
                                trim: o,
                                normalizer: a
                            });
                        return Array.from(e.querySelectorAll("[title], svg > title")).filter((e => s(e.getAttribute("title"), e, t, l) || (e => {
                            var t;
                            return "title" === e.tagName.toLowerCase() && "svg" === (null == (t = e.parentElement) ? void 0 : t.tagName.toLowerCase())
                        })(e) && s(Be(e), e, t, l)))
                    },
                    Jt = ot(Kt, Kt.name, "queryAll"),
                    [Yt, Qt, Zt, $t, en] = at(Kt, ((e, t) => "Found multiple elements with the title: " + t + "."), ((e, t) => "Unable to find an element with the title: " + t + "."));

                function tn(e, t, n) {
                    let {
                        exact: r = !0,
                        collapseWhitespace: i,
                        hidden: o = _e().defaultHidden,
                        name: a,
                        description: s,
                        trim: l,
                        normalizer: c,
                        queryFallbacks: u = !1,
                        selected: d,
                        checked: h,
                        pressed: p,
                        current: f,
                        level: m,
                        expanded: g
                    } = void 0 === n ? {} : n;
                    de(e);
                    const v = r ? Pe : Te,
                        y = Ie({
                            collapseWhitespace: i,
                            trim: l,
                            normalizer: c
                        });
                    var b, x, _, M, w;
                    if (void 0 !== d && void 0 === (null == (b = z.gF.get(t)) ? void 0 : b.props["aria-selected"])) throw new Error('"aria-selected" is not supported on role "' + t + '".');
                    if (void 0 !== h && void 0 === (null == (x = z.gF.get(t)) ? void 0 : x.props["aria-checked"])) throw new Error('"aria-checked" is not supported on role "' + t + '".');
                    if (void 0 !== p && void 0 === (null == (_ = z.gF.get(t)) ? void 0 : _.props["aria-pressed"])) throw new Error('"aria-pressed" is not supported on role "' + t + '".');
                    if (void 0 !== f && void 0 === (null == (M = z.gF.get(t)) ? void 0 : M.props["aria-current"])) throw new Error('"aria-current" is not supported on role "' + t + '".');
                    if (void 0 !== m && "heading" !== t) throw new Error('Role "' + t + '" cannot have "level" property.');
                    if (void 0 !== g && void 0 === (null == (w = z.gF.get(t)) ? void 0 : w.props["aria-expanded"])) throw new Error('"aria-expanded" is not supported on role "' + t + '".');
                    const A = new WeakMap;

                    function S(e) {
                        return A.has(e) || A.set(e, De(e)), A.get(e)
                    }
                    return Array.from(e.querySelectorAll(function(e, t, n) {
                        var r;
                        if ("string" !== typeof e) return "*";
                        const i = t && !n ? '*[role~="' + e + '"]' : "*[role]",
                            o = null != (r = z.e4.get(e)) ? r : new Set,
                            a = new Set(Array.from(o).map((e => {
                                let {
                                    name: t
                                } = e;
                                return t
                            })));
                        return [i].concat(Array.from(a)).join(",")
                    }(t, r, c ? y : void 0))).filter((e => {
                        if (e.hasAttribute("role")) {
                            const n = e.getAttribute("role");
                            if (u) return n.split(" ").filter(Boolean).some((n => v(n, e, t, y)));
                            if (c) return v(n, e, t, y);
                            const [r] = n.split(" ");
                            return v(r, e, t, y)
                        }
                        return ke(e).some((n => v(n, e, t, y)))
                    })).filter((e => void 0 !== d ? d === function(e) {
                        return "OPTION" === e.tagName ? e.selected : He(e, "aria-selected")
                    }(e) : void 0 !== h ? h === function(e) {
                        if (!("indeterminate" in e) || !e.indeterminate) return "checked" in e ? e.checked : He(e, "aria-checked")
                    }(e) : void 0 !== p ? p === function(e) {
                        return He(e, "aria-pressed")
                    }(e) : void 0 !== f ? f === function(e) {
                        var t, n;
                        return null != (t = null != (n = He(e, "aria-current")) ? n : e.getAttribute("aria-current")) && t
                    }(e) : void 0 !== g ? g === function(e) {
                        return He(e, "aria-expanded")
                    }(e) : void 0 === m || m === function(e) {
                        return e.getAttribute("aria-level") && Number(e.getAttribute("aria-level")) || {
                            H1: 1,
                            H2: 2,
                            H3: 3,
                            H4: 4,
                            H5: 5,
                            H6: 6
                        }[e.tagName]
                    }(e))).filter((e => void 0 === a || Pe(U(e, {
                        computedStyleSupportsPseudoElements: _e().computedStyleSupportsPseudoElements
                    }), e, a, (e => e)))).filter((e => void 0 === s || Pe(F(e, {
                        computedStyleSupportsPseudoElements: _e().computedStyleSupportsPseudoElements
                    }), e, s, (e => e)))).filter((e => !1 !== o || !1 === Ne(e, {
                        isSubtreeInaccessible: S
                    })))
                }
                const nn = e => {
                        let t = "";
                        return t = void 0 === e ? "" : "string" === typeof e ? ' and name "' + e + '"' : " and name `" + e + "`", t
                    },
                    rn = ot(tn, tn.name, "queryAll"),
                    [on, an, sn, ln, cn] = at(tn, (function(e, t, n) {
                        let {
                            name: r
                        } = void 0 === n ? {} : n;
                        return 'Found multiple elements with the role "' + t + '"' + nn(r)
                    }), (function(e, t, n) {
                        let {
                            hidden: r = _e().defaultHidden,
                            name: i,
                            description: o
                        } = void 0 === n ? {} : n;
                        if (_e()._disableExpensiveErrorDiagnostics) return 'Unable to find role="' + t + '"' + nn(i);
                        let a, s = "";
                        Array.from(e.children).forEach((e => {
                            s += Ue(e, {
                                hidden: r,
                                includeDescription: void 0 !== o
                            })
                        })), a = 0 === s.length ? !1 === r ? "There are no accessible roles. But there might be some inaccessible roles. If you wish to access them, then set the `hidden` option to `true`. Learn more about this here: https://testing-library.com/docs/dom-testing-library/api-queries#byrole" : "There are no available roles." : ("\nHere are the " + (!1 === r ? "accessible" : "available") + " roles:\n\n  " + s.replace(/\n/g, "\n  ").replace(/\n\s\s\n/g, "\n\n") + "\n").trim();
                        let l = "";
                        l = void 0 === i ? "" : "string" === typeof i ? ' and name "' + i + '"' : " and name `" + i + "`";
                        let c = "";
                        return c = void 0 === o ? "" : "string" === typeof o ? ' and description "' + o + '"' : " and description `" + o + "`", ("\nUnable to find an " + (!1 === r ? "accessible " : "") + 'element with the role "' + t + '"' + l + c + "\n\n" + a).trim()
                    })),
                    un = () => _e().testIdAttribute,
                    dn = function() {
                        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                        return de(t[0]), Ze(un(), ...t)
                    },
                    hn = ot(dn, dn.name, "queryAll"),
                    [pn, fn, mn, gn, vn] = at(dn, ((e, t) => "Found multiple elements by: [" + un() + '="' + t + '"]'), ((e, t) => "Unable to find an element by: [" + un() + '="' + t + '"]'));
                var yn = Object.freeze({
                    __proto__: null,
                    queryAllByLabelText: yt,
                    queryByLabelText: ht,
                    getAllByLabelText: gt,
                    getByLabelText: vt,
                    findAllByLabelText: ft,
                    findByLabelText: mt,
                    queryByPlaceholderText: _t,
                    queryAllByPlaceholderText: xt,
                    getByPlaceholderText: wt,
                    getAllByPlaceholderText: Mt,
                    findAllByPlaceholderText: At,
                    findByPlaceholderText: St,
                    queryByText: Tt,
                    queryAllByText: Ct,
                    getByText: Rt,
                    getAllByText: Pt,
                    findAllByText: It,
                    findByText: Ot,
                    queryByDisplayValue: Dt,
                    queryAllByDisplayValue: Lt,
                    getByDisplayValue: kt,
                    getAllByDisplayValue: Nt,
                    findAllByDisplayValue: Ft,
                    findByDisplayValue: Ut,
                    queryByAltText: Gt,
                    queryAllByAltText: jt,
                    getByAltText: qt,
                    getAllByAltText: Vt,
                    findAllByAltText: Wt,
                    findByAltText: Xt,
                    queryByTitle: Yt,
                    queryAllByTitle: Jt,
                    getByTitle: Zt,
                    getAllByTitle: Qt,
                    findAllByTitle: $t,
                    findByTitle: en,
                    queryByRole: on,
                    queryAllByRole: rn,
                    getAllByRole: an,
                    getByRole: sn,
                    findAllByRole: ln,
                    findByRole: cn,
                    queryByTestId: pn,
                    queryAllByTestId: hn,
                    getByTestId: mn,
                    getAllByTestId: fn,
                    findAllByTestId: gn,
                    findByTestId: vn
                });

                function bn(e, t, n) {
                    return void 0 === t && (t = yn), void 0 === n && (n = {}), Object.keys(t).reduce(((n, r) => {
                        const i = t[r];
                        return n[r] = i.bind(null, e), n
                    }), n)
                }
                const xn = e => !e || Array.isArray(e) && !e.length;

                function _n(e) {
                    if (xn(e)) throw new Error("The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.")
                }
                async function Mn(e, t) {
                    const n = new Error("Timed out in waitForElementToBeRemoved.");
                    if ("function" !== typeof e) {
                        _n(e);
                        const t = (Array.isArray(e) ? e : [e]).map((e => {
                            let t = e.parentElement;
                            if (null === t) return () => null;
                            for (; t.parentElement;) t = t.parentElement;
                            return () => t.contains(e) ? e : null
                        }));
                        e = () => t.map((e => e())).filter(Boolean)
                    }
                    return _n(e()), Je((() => {
                        let t;
                        try {
                            t = e()
                        } catch (r) {
                            if ("TestingLibraryElementError" === r.name) return;
                            throw r
                        }
                        if (!xn(t)) throw n
                    }), t)
                }
                const wn = {
                        copy: {
                            EventType: "ClipboardEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        cut: {
                            EventType: "ClipboardEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        paste: {
                            EventType: "ClipboardEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        compositionEnd: {
                            EventType: "CompositionEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        compositionStart: {
                            EventType: "CompositionEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        compositionUpdate: {
                            EventType: "CompositionEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        keyDown: {
                            EventType: "KeyboardEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                charCode: 0,
                                composed: !0
                            }
                        },
                        keyPress: {
                            EventType: "KeyboardEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                charCode: 0,
                                composed: !0
                            }
                        },
                        keyUp: {
                            EventType: "KeyboardEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                charCode: 0,
                                composed: !0
                            }
                        },
                        focus: {
                            EventType: "FocusEvent",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1,
                                composed: !0
                            }
                        },
                        blur: {
                            EventType: "FocusEvent",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1,
                                composed: !0
                            }
                        },
                        focusIn: {
                            EventType: "FocusEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !1,
                                composed: !0
                            }
                        },
                        focusOut: {
                            EventType: "FocusEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !1,
                                composed: !0
                            }
                        },
                        change: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !1
                            }
                        },
                        input: {
                            EventType: "InputEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !1,
                                composed: !0
                            }
                        },
                        invalid: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !0
                            }
                        },
                        submit: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0
                            }
                        },
                        reset: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0
                            }
                        },
                        click: {
                            EventType: "MouseEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                button: 0,
                                composed: !0
                            }
                        },
                        contextMenu: {
                            EventType: "MouseEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        dblClick: {
                            EventType: "MouseEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        drag: {
                            EventType: "DragEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        dragEnd: {
                            EventType: "DragEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !1,
                                composed: !0
                            }
                        },
                        dragEnter: {
                            EventType: "DragEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        dragExit: {
                            EventType: "DragEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !1,
                                composed: !0
                            }
                        },
                        dragLeave: {
                            EventType: "DragEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !1,
                                composed: !0
                            }
                        },
                        dragOver: {
                            EventType: "DragEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        dragStart: {
                            EventType: "DragEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        drop: {
                            EventType: "DragEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        mouseDown: {
                            EventType: "MouseEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        mouseEnter: {
                            EventType: "MouseEvent",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1,
                                composed: !0
                            }
                        },
                        mouseLeave: {
                            EventType: "MouseEvent",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1,
                                composed: !0
                            }
                        },
                        mouseMove: {
                            EventType: "MouseEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        mouseOut: {
                            EventType: "MouseEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        mouseOver: {
                            EventType: "MouseEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        mouseUp: {
                            EventType: "MouseEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        select: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !1
                            }
                        },
                        touchCancel: {
                            EventType: "TouchEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !1,
                                composed: !0
                            }
                        },
                        touchEnd: {
                            EventType: "TouchEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        touchMove: {
                            EventType: "TouchEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        touchStart: {
                            EventType: "TouchEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        resize: {
                            EventType: "UIEvent",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        scroll: {
                            EventType: "UIEvent",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        wheel: {
                            EventType: "WheelEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        abort: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        canPlay: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        canPlayThrough: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        durationChange: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        emptied: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        encrypted: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        ended: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        loadedData: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        loadedMetadata: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        loadStart: {
                            EventType: "ProgressEvent",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        pause: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        play: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        playing: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        progress: {
                            EventType: "ProgressEvent",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        rateChange: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        seeked: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        seeking: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        stalled: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        suspend: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        timeUpdate: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        volumeChange: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        waiting: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        load: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        error: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        animationStart: {
                            EventType: "AnimationEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !1
                            }
                        },
                        animationEnd: {
                            EventType: "AnimationEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !1
                            }
                        },
                        animationIteration: {
                            EventType: "AnimationEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !1
                            }
                        },
                        transitionCancel: {
                            EventType: "TransitionEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !1
                            }
                        },
                        transitionEnd: {
                            EventType: "TransitionEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0
                            }
                        },
                        transitionRun: {
                            EventType: "TransitionEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !1
                            }
                        },
                        transitionStart: {
                            EventType: "TransitionEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !1
                            }
                        },
                        pointerOver: {
                            EventType: "PointerEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        pointerEnter: {
                            EventType: "PointerEvent",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        pointerDown: {
                            EventType: "PointerEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        pointerMove: {
                            EventType: "PointerEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        pointerUp: {
                            EventType: "PointerEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        pointerCancel: {
                            EventType: "PointerEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !1,
                                composed: !0
                            }
                        },
                        pointerOut: {
                            EventType: "PointerEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !0,
                                composed: !0
                            }
                        },
                        pointerLeave: {
                            EventType: "PointerEvent",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        gotPointerCapture: {
                            EventType: "PointerEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !1,
                                composed: !0
                            }
                        },
                        lostPointerCapture: {
                            EventType: "PointerEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !1,
                                composed: !0
                            }
                        },
                        popState: {
                            EventType: "PopStateEvent",
                            defaultInit: {
                                bubbles: !0,
                                cancelable: !1
                            }
                        },
                        offline: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        },
                        online: {
                            EventType: "Event",
                            defaultInit: {
                                bubbles: !1,
                                cancelable: !1
                            }
                        }
                    },
                    An = {
                        doubleClick: "dblClick"
                    };

                function Sn(e, t) {
                    return _e().eventWrapper((() => {
                        if (!t) throw new Error("Unable to fire an event - please provide an event object.");
                        if (!e) throw new Error('Unable to fire a "' + t.type + '" event - please provide a DOM element.');
                        return e.dispatchEvent(t)
                    }))
                }

                function En(e, t, n, r) {
                    let {
                        EventType: i = "Event",
                        defaultInit: o = {}
                    } = void 0 === r ? {} : r;
                    if (!t) throw new Error('Unable to fire a "' + e + '" event - please provide a DOM element.');
                    const a = { ...o,
                            ...n
                        },
                        {
                            target: {
                                value: s,
                                files: l,
                                ...c
                            } = {}
                        } = a;
                    void 0 !== s && function(e, t) {
                        const {
                            set: n
                        } = Object.getOwnPropertyDescriptor(e, "value") || {}, r = Object.getPrototypeOf(e), {
                            set: i
                        } = Object.getOwnPropertyDescriptor(r, "value") || {};
                        if (i && n !== i) i.call(e, t);
                        else {
                            if (!n) throw new Error("The given element does not have a value setter");
                            n.call(e, t)
                        }
                    }(t, s), void 0 !== l && Object.defineProperty(t, "files", {
                        configurable: !0,
                        enumerable: !0,
                        writable: !0,
                        value: l
                    }), Object.assign(t, c);
                    const u = ue(t),
                        d = u[i] || u.Event;
                    let h;
                    if ("function" === typeof d) h = new d(e, a);
                    else {
                        h = u.document.createEvent(i);
                        const {
                            bubbles: t,
                            cancelable: n,
                            detail: r,
                            ...o
                        } = a;
                        h.initEvent(e, t, n, r), Object.keys(o).forEach((e => {
                            h[e] = o[e]
                        }))
                    }
                    return ["dataTransfer", "clipboardData"].forEach((e => {
                        const t = a[e];
                        "object" === typeof t && ("function" === typeof u.DataTransfer ? Object.defineProperty(h, e, {
                            value: Object.getOwnPropertyNames(t).reduce(((e, n) => (Object.defineProperty(e, n, {
                                value: t[n]
                            }), e)), new u.DataTransfer)
                        }) : Object.defineProperty(h, e, {
                            value: t
                        }))
                    })), h
                }

                function Cn(e) {
                    return "https://testing-playground.com/#markup=" + (t = e, j().compressToEncodedURIComponent(t.replace(/[ \t]*[\n][ \t]*/g, "\n")));
                    var t
                }
                Object.keys(wn).forEach((e => {
                    const {
                        EventType: t,
                        defaultInit: n
                    } = wn[e], r = e.toLowerCase();
                    En[e] = (e, i) => En(r, e, i, {
                        EventType: t,
                        defaultInit: n
                    }), Sn[e] = (t, n) => Sn(t, En[e](t, n))
                })), Object.keys(An).forEach((e => {
                    const t = An[e];
                    Sn[e] = function() {
                        return Sn[t](...arguments)
                    }
                }));
                const Tn = {
                        debug: (e, t, n) => Array.isArray(e) ? e.forEach((e => ye(e, t, n))) : ye(e, t, n),
                        logTestingPlaygroundURL: function(e) {
                            if (void 0 === e && (e = ce().body), !e || !("innerHTML" in e)) return void console.log("The element you're providing isn't a valid DOM element.");
                            if (!e.innerHTML) return void console.log("The provided element doesn't have any children.");
                            const t = Cn(e.innerHTML);
                            return console.log("Open this URL in your browser\n\n" + t), t
                        }
                    },
                    Pn = "undefined" !== typeof document && document.body ? bn(document.body, yn, Tn) : Object.keys(yn).reduce(((e, t) => (e[t] = () => {
                        throw new TypeError("For queries bound to document.body a global document has to be available... Learn more: https://testing-library.com/s/screen-global-error")
                    }, e)), Tn)
            },
            2540: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.TEXT_NODE = void 0, t.checkContainerType = function(e) {
                    if (!e || "function" !== typeof e.querySelector || "function" !== typeof e.querySelectorAll) throw new TypeError("Expected container to be an Element, a Document or a DocumentFragment but got ".concat(function(e) {
                        if ("object" === typeof e) return null === e ? "null" : e.constructor.name;
                        return typeof e
                    }(e), "."))
                }, t.getDocument = function() {
                    if ("undefined" === typeof window) throw new Error("Could not find default container");
                    return window.document
                }, t.getWindowFromNode = function(e) {
                    if (e.defaultView) return e.defaultView;
                    if (e.ownerDocument && e.ownerDocument.defaultView) return e.ownerDocument.defaultView;
                    if (e.window) return e.window;
                    throw e.ownerDocument && null === e.ownerDocument.defaultView ? new Error("It looks like the window object is not available for the provided node.") : e.then instanceof Function ? new Error("It looks like you passed a Promise object instead of a DOM node. Did you do something like `fireEvent.click(screen.findBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`, or await the findBy query `fireEvent.click(await screen.findBy...`?") : Array.isArray(e) ? new Error("It looks like you passed an Array instead of a DOM node. Did you do something like `fireEvent.click(screen.getAllBy...` when you meant to use a `getBy` query `fireEvent.click(screen.getBy...`?") : "function" === typeof e.debug && "function" === typeof e.logTestingPlaygroundURL ? new Error("It looks like you passed a `screen` object. Did you do something like `fireEvent.click(screen, ...` when you meant to use a query, e.g. `fireEvent.click(screen.getBy..., `?") : new Error("The given node is not an Element, the node type is: ".concat(typeof e, "."))
                }, t.jestFakeTimersAreEnabled = function() {
                    if ("undefined" !== typeof jest && null !== jest) return !0 === setTimeout._isMockFunction || Object.prototype.hasOwnProperty.call(setTimeout, "clock");
                    return !1
                };
                t.TEXT_NODE = 3
            },
            3976: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var r, i = (r = n(1644)) && r.__esModule ? r : {
                    default: r
                };

                function o(e, t) {
                    return function(e) {
                        if (Array.isArray(e)) return e
                    }(e) || function(e, t) {
                        var n = null == e ? null : "undefined" !== typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                        if (null == n) return;
                        var r, i, o = [],
                            a = !0,
                            s = !1;
                        try {
                            for (n = n.call(e); !(a = (r = n.next()).done) && (o.push(r.value), !t || o.length !== t); a = !0);
                        } catch (l) {
                            s = !0, i = l
                        } finally {
                            try {
                                a || null == n.return || n.return()
                            } finally {
                                if (s) throw i
                            }
                        }
                        return o
                    }(e, t) || a(e, t) || function() {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function a(e, t) {
                    if (e) {
                        if ("string" === typeof e) return s(e, t);
                        var n = Object.prototype.toString.call(e).slice(8, -1);
                        return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? s(e, t) : void 0
                    }
                }

                function s(e, t) {
                    (null == t || t > e.length) && (t = e.length);
                    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
                    return r
                }
                var l = [
                        ["aria-activedescendant", {
                            type: "id"
                        }],
                        ["aria-atomic", {
                            type: "boolean"
                        }],
                        ["aria-autocomplete", {
                            type: "token",
                            values: ["inline", "list", "both", "none"]
                        }],
                        ["aria-busy", {
                            type: "boolean"
                        }],
                        ["aria-checked", {
                            type: "tristate"
                        }],
                        ["aria-colcount", {
                            type: "integer"
                        }],
                        ["aria-colindex", {
                            type: "integer"
                        }],
                        ["aria-colspan", {
                            type: "integer"
                        }],
                        ["aria-controls", {
                            type: "idlist"
                        }],
                        ["aria-current", {
                            type: "token",
                            values: ["page", "step", "location", "date", "time", !0, !1]
                        }],
                        ["aria-describedby", {
                            type: "idlist"
                        }],
                        ["aria-details", {
                            type: "id"
                        }],
                        ["aria-disabled", {
                            type: "boolean"
                        }],
                        ["aria-dropeffect", {
                            type: "tokenlist",
                            values: ["copy", "execute", "link", "move", "none", "popup"]
                        }],
                        ["aria-errormessage", {
                            type: "id"
                        }],
                        ["aria-expanded", {
                            type: "boolean",
                            allowundefined: !0
                        }],
                        ["aria-flowto", {
                            type: "idlist"
                        }],
                        ["aria-grabbed", {
                            type: "boolean",
                            allowundefined: !0
                        }],
                        ["aria-haspopup", {
                            type: "token",
                            values: [!1, !0, "menu", "listbox", "tree", "grid", "dialog"]
                        }],
                        ["aria-hidden", {
                            type: "boolean",
                            allowundefined: !0
                        }],
                        ["aria-invalid", {
                            type: "token",
                            values: ["grammar", !1, "spelling", !0]
                        }],
                        ["aria-keyshortcuts", {
                            type: "string"
                        }],
                        ["aria-label", {
                            type: "string"
                        }],
                        ["aria-labelledby", {
                            type: "idlist"
                        }],
                        ["aria-level", {
                            type: "integer"
                        }],
                        ["aria-live", {
                            type: "token",
                            values: ["assertive", "off", "polite"]
                        }],
                        ["aria-modal", {
                            type: "boolean"
                        }],
                        ["aria-multiline", {
                            type: "boolean"
                        }],
                        ["aria-multiselectable", {
                            type: "boolean"
                        }],
                        ["aria-orientation", {
                            type: "token",
                            values: ["vertical", "undefined", "horizontal"]
                        }],
                        ["aria-owns", {
                            type: "idlist"
                        }],
                        ["aria-placeholder", {
                            type: "string"
                        }],
                        ["aria-posinset", {
                            type: "integer"
                        }],
                        ["aria-pressed", {
                            type: "tristate"
                        }],
                        ["aria-readonly", {
                            type: "boolean"
                        }],
                        ["aria-relevant", {
                            type: "tokenlist",
                            values: ["additions", "all", "removals", "text"]
                        }],
                        ["aria-required", {
                            type: "boolean"
                        }],
                        ["aria-roledescription", {
                            type: "string"
                        }],
                        ["aria-rowcount", {
                            type: "integer"
                        }],
                        ["aria-rowindex", {
                            type: "integer"
                        }],
                        ["aria-rowspan", {
                            type: "integer"
                        }],
                        ["aria-selected", {
                            type: "boolean",
                            allowundefined: !0
                        }],
                        ["aria-setsize", {
                            type: "integer"
                        }],
                        ["aria-sort", {
                            type: "token",
                            values: ["ascending", "descending", "none", "other"]
                        }],
                        ["aria-valuemax", {
                            type: "number"
                        }],
                        ["aria-valuemin", {
                            type: "number"
                        }],
                        ["aria-valuenow", {
                            type: "number"
                        }],
                        ["aria-valuetext", {
                            type: "string"
                        }]
                    ],
                    c = {
                        entries: function() {
                            return l
                        },
                        forEach: function(e) {
                            var t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                                r = function(e, t) {
                                    var n = "undefined" !== typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                    if (!n) {
                                        if (Array.isArray(e) || (n = a(e)) || t && e && "number" === typeof e.length) {
                                            n && (e = n);
                                            var r = 0,
                                                i = function() {};
                                            return {
                                                s: i,
                                                n: function() {
                                                    return r >= e.length ? {
                                                        done: !0
                                                    } : {
                                                        done: !1,
                                                        value: e[r++]
                                                    }
                                                },
                                                e: function(e) {
                                                    throw e
                                                },
                                                f: i
                                            }
                                        }
                                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                                    }
                                    var o, s = !0,
                                        l = !1;
                                    return {
                                        s: function() {
                                            n = n.call(e)
                                        },
                                        n: function() {
                                            var e = n.next();
                                            return s = e.done, e
                                        },
                                        e: function(e) {
                                            l = !0, o = e
                                        },
                                        f: function() {
                                            try {
                                                s || null == n.return || n.return()
                                            } finally {
                                                if (l) throw o
                                            }
                                        }
                                    }
                                }(l);
                            try {
                                for (r.s(); !(t = r.n()).done;) {
                                    var i = o(t.value, 2),
                                        s = i[0],
                                        c = i[1];
                                    e.call(n, c, s, l)
                                }
                            } catch (u) {
                                r.e(u)
                            } finally {
                                r.f()
                            }
                        },
                        get: function(e) {
                            var t = l.find((function(t) {
                                return t[0] === e
                            }));
                            return t && t[1]
                        },
                        has: function(e) {
                            return !!c.get(e)
                        },
                        keys: function() {
                            return l.map((function(e) {
                                return o(e, 1)[0]
                            }))
                        },
                        values: function() {
                            return l.map((function(e) {
                                return o(e, 2)[1]
                            }))
                        }
                    },
                    u = (0, i.default)(c, c.entries());
                t.default = u
            },
            3816: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var r, i = (r = n(1644)) && r.__esModule ? r : {
                    default: r
                };

                function o(e, t) {
                    return function(e) {
                        if (Array.isArray(e)) return e
                    }(e) || function(e, t) {
                        var n = null == e ? null : "undefined" !== typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                        if (null == n) return;
                        var r, i, o = [],
                            a = !0,
                            s = !1;
                        try {
                            for (n = n.call(e); !(a = (r = n.next()).done) && (o.push(r.value), !t || o.length !== t); a = !0);
                        } catch (l) {
                            s = !0, i = l
                        } finally {
                            try {
                                a || null == n.return || n.return()
                            } finally {
                                if (s) throw i
                            }
                        }
                        return o
                    }(e, t) || a(e, t) || function() {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function a(e, t) {
                    if (e) {
                        if ("string" === typeof e) return s(e, t);
                        var n = Object.prototype.toString.call(e).slice(8, -1);
                        return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? s(e, t) : void 0
                    }
                }

                function s(e, t) {
                    (null == t || t > e.length) && (t = e.length);
                    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
                    return r
                }
                var l = [
                        ["a", {
                            reserved: !1
                        }],
                        ["abbr", {
                            reserved: !1
                        }],
                        ["acronym", {
                            reserved: !1
                        }],
                        ["address", {
                            reserved: !1
                        }],
                        ["applet", {
                            reserved: !1
                        }],
                        ["area", {
                            reserved: !1
                        }],
                        ["article", {
                            reserved: !1
                        }],
                        ["aside", {
                            reserved: !1
                        }],
                        ["audio", {
                            reserved: !1
                        }],
                        ["b", {
                            reserved: !1
                        }],
                        ["base", {
                            reserved: !0
                        }],
                        ["bdi", {
                            reserved: !1
                        }],
                        ["bdo", {
                            reserved: !1
                        }],
                        ["big", {
                            reserved: !1
                        }],
                        ["blink", {
                            reserved: !1
                        }],
                        ["blockquote", {
                            reserved: !1
                        }],
                        ["body", {
                            reserved: !1
                        }],
                        ["br", {
                            reserved: !1
                        }],
                        ["button", {
                            reserved: !1
                        }],
                        ["canvas", {
                            reserved: !1
                        }],
                        ["caption", {
                            reserved: !1
                        }],
                        ["center", {
                            reserved: !1
                        }],
                        ["cite", {
                            reserved: !1
                        }],
                        ["code", {
                            reserved: !1
                        }],
                        ["col", {
                            reserved: !0
                        }],
                        ["colgroup", {
                            reserved: !0
                        }],
                        ["content", {
                            reserved: !1
                        }],
                        ["data", {
                            reserved: !1
                        }],
                        ["datalist", {
                            reserved: !1
                        }],
                        ["dd", {
                            reserved: !1
                        }],
                        ["del", {
                            reserved: !1
                        }],
                        ["details", {
                            reserved: !1
                        }],
                        ["dfn", {
                            reserved: !1
                        }],
                        ["dialog", {
                            reserved: !1
                        }],
                        ["dir", {
                            reserved: !1
                        }],
                        ["div", {
                            reserved: !1
                        }],
                        ["dl", {
                            reserved: !1
                        }],
                        ["dt", {
                            reserved: !1
                        }],
                        ["em", {
                            reserved: !1
                        }],
                        ["embed", {
                            reserved: !1
                        }],
                        ["fieldset", {
                            reserved: !1
                        }],
                        ["figcaption", {
                            reserved: !1
                        }],
                        ["figure", {
                            reserved: !1
                        }],
                        ["font", {
                            reserved: !1
                        }],
                        ["footer", {
                            reserved: !1
                        }],
                        ["form", {
                            reserved: !1
                        }],
                        ["frame", {
                            reserved: !1
                        }],
                        ["frameset", {
                            reserved: !1
                        }],
                        ["h1", {
                            reserved: !1
                        }],
                        ["h2", {
                            reserved: !1
                        }],
                        ["h3", {
                            reserved: !1
                        }],
                        ["h4", {
                            reserved: !1
                        }],
                        ["h5", {
                            reserved: !1
                        }],
                        ["h6", {
                            reserved: !1
                        }],
                        ["head", {
                            reserved: !0
                        }],
                        ["header", {
                            reserved: !1
                        }],
                        ["hgroup", {
                            reserved: !1
                        }],
                        ["hr", {
                            reserved: !1
                        }],
                        ["html", {
                            reserved: !0
                        }],
                        ["i", {
                            reserved: !1
                        }],
                        ["iframe", {
                            reserved: !1
                        }],
                        ["img", {
                            reserved: !1
                        }],
                        ["input", {
                            reserved: !1
                        }],
                        ["ins", {
                            reserved: !1
                        }],
                        ["kbd", {
                            reserved: !1
                        }],
                        ["keygen", {
                            reserved: !1
                        }],
                        ["label", {
                            reserved: !1
                        }],
                        ["legend", {
                            reserved: !1
                        }],
                        ["li", {
                            reserved: !1
                        }],
                        ["link", {
                            reserved: !0
                        }],
                        ["main", {
                            reserved: !1
                        }],
                        ["map", {
                            reserved: !1
                        }],
                        ["mark", {
                            reserved: !1
                        }],
                        ["marquee", {
                            reserved: !1
                        }],
                        ["menu", {
                            reserved: !1
                        }],
                        ["menuitem", {
                            reserved: !1
                        }],
                        ["meta", {
                            reserved: !0
                        }],
                        ["meter", {
                            reserved: !1
                        }],
                        ["nav", {
                            reserved: !1
                        }],
                        ["noembed", {
                            reserved: !0
                        }],
                        ["noscript", {
                            reserved: !0
                        }],
                        ["object", {
                            reserved: !1
                        }],
                        ["ol", {
                            reserved: !1
                        }],
                        ["optgroup", {
                            reserved: !1
                        }],
                        ["option", {
                            reserved: !1
                        }],
                        ["output", {
                            reserved: !1
                        }],
                        ["p", {
                            reserved: !1
                        }],
                        ["param", {
                            reserved: !0
                        }],
                        ["picture", {
                            reserved: !0
                        }],
                        ["pre", {
                            reserved: !1
                        }],
                        ["progress", {
                            reserved: !1
                        }],
                        ["q", {
                            reserved: !1
                        }],
                        ["rp", {
                            reserved: !1
                        }],
                        ["rt", {
                            reserved: !1
                        }],
                        ["rtc", {
                            reserved: !1
                        }],
                        ["ruby", {
                            reserved: !1
                        }],
                        ["s", {
                            reserved: !1
                        }],
                        ["samp", {
                            reserved: !1
                        }],
                        ["script", {
                            reserved: !0
                        }],
                        ["section", {
                            reserved: !1
                        }],
                        ["select", {
                            reserved: !1
                        }],
                        ["small", {
                            reserved: !1
                        }],
                        ["source", {
                            reserved: !0
                        }],
                        ["spacer", {
                            reserved: !1
                        }],
                        ["span", {
                            reserved: !1
                        }],
                        ["strike", {
                            reserved: !1
                        }],
                        ["strong", {
                            reserved: !1
                        }],
                        ["style", {
                            reserved: !0
                        }],
                        ["sub", {
                            reserved: !1
                        }],
                        ["summary", {
                            reserved: !1
                        }],
                        ["sup", {
                            reserved: !1
                        }],
                        ["table", {
                            reserved: !1
                        }],
                        ["tbody", {
                            reserved: !1
                        }],
                        ["td", {
                            reserved: !1
                        }],
                        ["textarea", {
                            reserved: !1
                        }],
                        ["tfoot", {
                            reserved: !1
                        }],
                        ["th", {
                            reserved: !1
                        }],
                        ["thead", {
                            reserved: !1
                        }],
                        ["time", {
                            reserved: !1
                        }],
                        ["title", {
                            reserved: !0
                        }],
                        ["tr", {
                            reserved: !1
                        }],
                        ["track", {
                            reserved: !0
                        }],
                        ["tt", {
                            reserved: !1
                        }],
                        ["u", {
                            reserved: !1
                        }],
                        ["ul", {
                            reserved: !1
                        }],
                        ["var", {
                            reserved: !1
                        }],
                        ["video", {
                            reserved: !1
                        }],
                        ["wbr", {
                            reserved: !1
                        }],
                        ["xmp", {
                            reserved: !1
                        }]
                    ],
                    c = {
                        entries: function() {
                            return l
                        },
                        forEach: function(e) {
                            var t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                                r = function(e, t) {
                                    var n = "undefined" !== typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                    if (!n) {
                                        if (Array.isArray(e) || (n = a(e)) || t && e && "number" === typeof e.length) {
                                            n && (e = n);
                                            var r = 0,
                                                i = function() {};
                                            return {
                                                s: i,
                                                n: function() {
                                                    return r >= e.length ? {
                                                        done: !0
                                                    } : {
                                                        done: !1,
                                                        value: e[r++]
                                                    }
                                                },
                                                e: function(e) {
                                                    throw e
                                                },
                                                f: i
                                            }
                                        }
                                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                                    }
                                    var o, s = !0,
                                        l = !1;
                                    return {
                                        s: function() {
                                            n = n.call(e)
                                        },
                                        n: function() {
                                            var e = n.next();
                                            return s = e.done, e
                                        },
                                        e: function(e) {
                                            l = !0, o = e
                                        },
                                        f: function() {
                                            try {
                                                s || null == n.return || n.return()
                                            } finally {
                                                if (l) throw o
                                            }
                                        }
                                    }
                                }(l);
                            try {
                                for (r.s(); !(t = r.n()).done;) {
                                    var i = o(t.value, 2),
                                        s = i[0],
                                        c = i[1];
                                    e.call(n, c, s, l)
                                }
                            } catch (u) {
                                r.e(u)
                            } finally {
                                r.f()
                            }
                        },
                        get: function(e) {
                            var t = l.find((function(t) {
                                return t[0] === e
                            }));
                            return t && t[1]
                        },
                        has: function(e) {
                            return !!c.get(e)
                        },
                        keys: function() {
                            return l.map((function(e) {
                                return o(e, 1)[0]
                            }))
                        },
                        values: function() {
                            return l.map((function(e) {
                                return o(e, 2)[1]
                            }))
                        }
                    },
                    u = (0, i.default)(c, c.entries());
                t.default = u
            },
            2996: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var r = a(n(7859)),
                    i = a(n(1644)),
                    o = a(n(8080));

                function a(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function s(e, t) {
                    return function(e) {
                        if (Array.isArray(e)) return e
                    }(e) || function(e, t) {
                        var n = null == e ? null : "undefined" !== typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                        if (null == n) return;
                        var r, i, o = [],
                            a = !0,
                            s = !1;
                        try {
                            for (n = n.call(e); !(a = (r = n.next()).done) && (o.push(r.value), !t || o.length !== t); a = !0);
                        } catch (l) {
                            s = !0, i = l
                        } finally {
                            try {
                                a || null == n.return || n.return()
                            } finally {
                                if (s) throw i
                            }
                        }
                        return o
                    }(e, t) || l(e, t) || function() {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function l(e, t) {
                    if (e) {
                        if ("string" === typeof e) return c(e, t);
                        var n = Object.prototype.toString.call(e).slice(8, -1);
                        return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? c(e, t) : void 0
                    }
                }

                function c(e, t) {
                    (null == t || t > e.length) && (t = e.length);
                    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
                    return r
                }
                for (var u = [], d = o.default.keys(), h = 0; h < d.length; h++) {
                    var p = d[h],
                        f = o.default.get(p);
                    if (f)
                        for (var m = [].concat(f.baseConcepts, f.relatedConcepts), g = 0; g < m.length; g++) {
                            var v = m[g];
                            if ("HTML" === v.module) {
                                var y = v.concept;
                                y && function() {
                                    var e = JSON.stringify(y),
                                        t = u.find((function(t) {
                                            return JSON.stringify(t[0]) === e
                                        })),
                                        n = void 0;
                                    n = t ? t[1] : [];
                                    for (var r = !0, i = 0; i < n.length; i++)
                                        if (n[i] === p) {
                                            r = !1;
                                            break
                                        }
                                    r && n.push(p), u.push([y, n])
                                }()
                            }
                        }
                }
                var b = {
                        entries: function() {
                            return u
                        },
                        forEach: function(e) {
                            var t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                                r = function(e, t) {
                                    var n = "undefined" !== typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                    if (!n) {
                                        if (Array.isArray(e) || (n = l(e)) || t && e && "number" === typeof e.length) {
                                            n && (e = n);
                                            var r = 0,
                                                i = function() {};
                                            return {
                                                s: i,
                                                n: function() {
                                                    return r >= e.length ? {
                                                        done: !0
                                                    } : {
                                                        done: !1,
                                                        value: e[r++]
                                                    }
                                                },
                                                e: function(e) {
                                                    throw e
                                                },
                                                f: i
                                            }
                                        }
                                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                                    }
                                    var o, a = !0,
                                        s = !1;
                                    return {
                                        s: function() {
                                            n = n.call(e)
                                        },
                                        n: function() {
                                            var e = n.next();
                                            return a = e.done, e
                                        },
                                        e: function(e) {
                                            s = !0, o = e
                                        },
                                        f: function() {
                                            try {
                                                a || null == n.return || n.return()
                                            } finally {
                                                if (s) throw o
                                            }
                                        }
                                    }
                                }(u);
                            try {
                                for (r.s(); !(t = r.n()).done;) {
                                    var i = s(t.value, 2),
                                        o = i[0],
                                        a = i[1];
                                    e.call(n, a, o, u)
                                }
                            } catch (c) {
                                r.e(c)
                            } finally {
                                r.f()
                            }
                        },
                        get: function(e) {
                            var t = u.find((function(t) {
                                return (0, r.default)(e, t[0])
                            }));
                            return t && t[1]
                        },
                        has: function(e) {
                            return !!b.get(e)
                        },
                        keys: function() {
                            return u.map((function(e) {
                                return s(e, 1)[0]
                            }))
                        },
                        values: function() {
                            return u.map((function(e) {
                                return s(e, 2)[1]
                            }))
                        }
                    },
                    x = (0, i.default)(b, b.entries());
                t.default = x
            },
            6392: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !0,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            name: "menuitem"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "widget"]
                    ]
                };
                t.default = n
            },
            8948: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !0,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-activedescendant": null,
                        "aria-disabled": null
                    },
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "widget"]
                    ]
                };
                t.default = n
            },
            7540: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !0,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "input"
                        },
                        module: "XForms"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "widget"]
                    ]
                };
                t.default = n
            },
            932: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !0,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            692: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !0,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-valuemax": null,
                        "aria-valuemin": null,
                        "aria-valuenow": null
                    },
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure"]
                    ]
                };
                t.default = n
            },
            9964: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !0,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: [],
                    prohibitedProps: [],
                    props: {
                        "aria-atomic": null,
                        "aria-busy": null,
                        "aria-controls": null,
                        "aria-current": null,
                        "aria-describedby": null,
                        "aria-details": null,
                        "aria-dropeffect": null,
                        "aria-flowto": null,
                        "aria-grabbed": null,
                        "aria-hidden": null,
                        "aria-keyshortcuts": null,
                        "aria-label": null,
                        "aria-labelledby": null,
                        "aria-live": null,
                        "aria-owns": null,
                        "aria-relevant": null,
                        "aria-roledescription": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "rel"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "role"
                        },
                        module: "XHTML"
                    }, {
                        concept: {
                            name: "type"
                        },
                        module: "Dublin Core"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: []
                };
                t.default = n
            },
            9092: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !0,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: [],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            name: "frontmatter"
                        },
                        module: "DTB"
                    }, {
                        concept: {
                            name: "level"
                        },
                        module: "DTB"
                    }, {
                        concept: {
                            name: "level"
                        },
                        module: "SMIL"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure"]
                    ]
                };
                t.default = n
            },
            1816: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !0,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author", "contents"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure"]
                    ]
                };
                t.default = n
            },
            9216: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !0,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-orientation": null
                    },
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "widget", "composite"],
                        ["roletype", "structure", "section", "group"]
                    ]
                };
                t.default = n
            },
            3784: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !0,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: [],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype"]
                    ]
                };
                t.default = n
            },
            5304: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !0,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: [],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype"]
                    ]
                };
                t.default = n
            },
            9464: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !0,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-modal": null
                    },
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype"]
                    ]
                };
                t.default = n
            },
            6232: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var r = m(n(6392)),
                    i = m(n(8948)),
                    o = m(n(7540)),
                    a = m(n(932)),
                    s = m(n(692)),
                    l = m(n(9964)),
                    c = m(n(9092)),
                    u = m(n(1816)),
                    d = m(n(9216)),
                    h = m(n(3784)),
                    p = m(n(5304)),
                    f = m(n(9464));

                function m(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                var g = [
                    ["command", r.default],
                    ["composite", i.default],
                    ["input", o.default],
                    ["landmark", a.default],
                    ["range", s.default],
                    ["roletype", l.default],
                    ["section", c.default],
                    ["sectionhead", u.default],
                    ["select", d.default],
                    ["structure", h.default],
                    ["widget", p.default],
                    ["window", f.default]
                ];
                t.default = g
            },
            4540: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var r = j(n(9448)),
                    i = j(n(6336)),
                    o = j(n(860)),
                    a = j(n(1544)),
                    s = j(n(656)),
                    l = j(n(1288)),
                    c = j(n(5820)),
                    u = j(n(9732)),
                    d = j(n(6803)),
                    h = j(n(3120)),
                    p = j(n(5164)),
                    f = j(n(2984)),
                    m = j(n(7420)),
                    g = j(n(7616)),
                    v = j(n(7080)),
                    y = j(n(9496)),
                    b = j(n(4076)),
                    x = j(n(1888)),
                    _ = j(n(8276)),
                    M = j(n(6488)),
                    w = j(n(6536)),
                    A = j(n(9900)),
                    S = j(n(2288)),
                    E = j(n(7144)),
                    C = j(n(6989)),
                    T = j(n(1944)),
                    P = j(n(6704)),
                    R = j(n(1012)),
                    I = j(n(5728)),
                    O = j(n(7120)),
                    B = j(n(1683)),
                    L = j(n(3796)),
                    D = j(n(4748)),
                    N = j(n(6168)),
                    k = j(n(7300)),
                    F = j(n(4288)),
                    U = j(n(348)),
                    z = j(n(2772)),
                    H = j(n(9744));

                function j(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                var G = [
                    ["doc-abstract", r.default],
                    ["doc-acknowledgments", i.default],
                    ["doc-afterword", o.default],
                    ["doc-appendix", a.default],
                    ["doc-backlink", s.default],
                    ["doc-biblioentry", l.default],
                    ["doc-bibliography", c.default],
                    ["doc-biblioref", u.default],
                    ["doc-chapter", d.default],
                    ["doc-colophon", h.default],
                    ["doc-conclusion", p.default],
                    ["doc-cover", f.default],
                    ["doc-credit", m.default],
                    ["doc-credits", g.default],
                    ["doc-dedication", v.default],
                    ["doc-endnote", y.default],
                    ["doc-endnotes", b.default],
                    ["doc-epigraph", x.default],
                    ["doc-epilogue", _.default],
                    ["doc-errata", M.default],
                    ["doc-example", w.default],
                    ["doc-footnote", A.default],
                    ["doc-foreword", S.default],
                    ["doc-glossary", E.default],
                    ["doc-glossref", C.default],
                    ["doc-index", T.default],
                    ["doc-introduction", P.default],
                    ["doc-noteref", R.default],
                    ["doc-notice", I.default],
                    ["doc-pagebreak", O.default],
                    ["doc-pagelist", B.default],
                    ["doc-part", L.default],
                    ["doc-preface", D.default],
                    ["doc-prologue", N.default],
                    ["doc-pullquote", k.default],
                    ["doc-qna", F.default],
                    ["doc-subtitle", U.default],
                    ["doc-tip", z.default],
                    ["doc-toc", H.default]
                ];
                t.default = G
            },
            7480: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var r = a(n(9328)),
                    i = a(n(8740)),
                    o = a(n(5340));

                function a(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                var s = [
                    ["graphics-document", r.default],
                    ["graphics-object", i.default],
                    ["graphics-symbol", o.default]
                ];
                t.default = s
            },
            1148: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var r = Ie(n(2e3)),
                    i = Ie(n(3252)),
                    o = Ie(n(6664)),
                    a = Ie(n(9672)),
                    s = Ie(n(4432)),
                    l = Ie(n(332)),
                    c = Ie(n(1992)),
                    u = Ie(n(5480)),
                    d = Ie(n(356)),
                    h = Ie(n(7264)),
                    p = Ie(n(4696)),
                    f = Ie(n(1064)),
                    m = Ie(n(6464)),
                    g = Ie(n(8360)),
                    v = Ie(n(6996)),
                    y = Ie(n(3992)),
                    b = Ie(n(5720)),
                    x = Ie(n(9576)),
                    _ = Ie(n(4204)),
                    M = Ie(n(6056)),
                    w = Ie(n(1844)),
                    A = Ie(n(8868)),
                    S = Ie(n(7232)),
                    E = Ie(n(6616)),
                    C = Ie(n(88)),
                    T = Ie(n(5412)),
                    P = Ie(n(6432)),
                    R = Ie(n(747)),
                    I = Ie(n(5372)),
                    O = Ie(n(2752)),
                    B = Ie(n(8904)),
                    L = Ie(n(2256)),
                    D = Ie(n(728)),
                    N = Ie(n(8008)),
                    k = Ie(n(6828)),
                    F = Ie(n(6052)),
                    U = Ie(n(1940)),
                    z = Ie(n(5532)),
                    H = Ie(n(904)),
                    j = Ie(n(1117)),
                    G = Ie(n(4780)),
                    V = Ie(n(972)),
                    q = Ie(n(2200)),
                    W = Ie(n(3312)),
                    X = Ie(n(552)),
                    K = Ie(n(1232)),
                    J = Ie(n(372)),
                    Y = Ie(n(5723)),
                    Q = Ie(n(1216)),
                    Z = Ie(n(5992)),
                    $ = Ie(n(6720)),
                    ee = Ie(n(5018)),
                    te = Ie(n(9828)),
                    ne = Ie(n(6340)),
                    re = Ie(n(5076)),
                    ie = Ie(n(5448)),
                    oe = Ie(n(7272)),
                    ae = Ie(n(1592)),
                    se = Ie(n(7288)),
                    le = Ie(n(9780)),
                    ce = Ie(n(3584)),
                    ue = Ie(n(7576)),
                    de = Ie(n(1456)),
                    he = Ie(n(6112)),
                    pe = Ie(n(4652)),
                    fe = Ie(n(3592)),
                    me = Ie(n(8560)),
                    ge = Ie(n(7492)),
                    ve = Ie(n(1748)),
                    ye = Ie(n(6144)),
                    be = Ie(n(4460)),
                    xe = Ie(n(6808)),
                    _e = Ie(n(9380)),
                    Me = Ie(n(3891)),
                    we = Ie(n(1e3)),
                    Ae = Ie(n(7960)),
                    Se = Ie(n(8344)),
                    Ee = Ie(n(8352)),
                    Ce = Ie(n(6352)),
                    Te = Ie(n(1976)),
                    Pe = Ie(n(4611)),
                    Re = Ie(n(5548));

                function Ie(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                var Oe = [
                    ["alert", r.default],
                    ["alertdialog", i.default],
                    ["application", o.default],
                    ["article", a.default],
                    ["banner", s.default],
                    ["blockquote", l.default],
                    ["button", c.default],
                    ["caption", u.default],
                    ["cell", d.default],
                    ["checkbox", h.default],
                    ["code", p.default],
                    ["columnheader", f.default],
                    ["combobox", m.default],
                    ["complementary", g.default],
                    ["contentinfo", v.default],
                    ["definition", y.default],
                    ["deletion", b.default],
                    ["dialog", x.default],
                    ["directory", _.default],
                    ["document", M.default],
                    ["emphasis", w.default],
                    ["feed", A.default],
                    ["figure", S.default],
                    ["form", E.default],
                    ["generic", C.default],
                    ["grid", T.default],
                    ["gridcell", P.default],
                    ["group", R.default],
                    ["heading", I.default],
                    ["img", O.default],
                    ["insertion", B.default],
                    ["link", L.default],
                    ["list", D.default],
                    ["listbox", N.default],
                    ["listitem", k.default],
                    ["log", F.default],
                    ["main", U.default],
                    ["marquee", z.default],
                    ["math", H.default],
                    ["menu", j.default],
                    ["menubar", G.default],
                    ["menuitem", V.default],
                    ["menuitemcheckbox", q.default],
                    ["menuitemradio", W.default],
                    ["meter", X.default],
                    ["navigation", K.default],
                    ["none", J.default],
                    ["note", Y.default],
                    ["option", Q.default],
                    ["paragraph", Z.default],
                    ["presentation", $.default],
                    ["progressbar", ee.default],
                    ["radio", te.default],
                    ["radiogroup", ne.default],
                    ["region", re.default],
                    ["row", ie.default],
                    ["rowgroup", oe.default],
                    ["rowheader", ae.default],
                    ["scrollbar", se.default],
                    ["search", le.default],
                    ["searchbox", ce.default],
                    ["separator", ue.default],
                    ["slider", de.default],
                    ["spinbutton", he.default],
                    ["status", pe.default],
                    ["strong", fe.default],
                    ["subscript", me.default],
                    ["superscript", ge.default],
                    ["switch", ve.default],
                    ["tab", ye.default],
                    ["table", be.default],
                    ["tablist", xe.default],
                    ["tabpanel", _e.default],
                    ["term", Me.default],
                    ["textbox", we.default],
                    ["time", Ae.default],
                    ["timer", Se.default],
                    ["toolbar", Ee.default],
                    ["tooltip", Ce.default],
                    ["tree", Te.default],
                    ["treegrid", Pe.default],
                    ["treeitem", Re.default]
                ];
                t.default = Oe
            },
            9448: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "abstract [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            6336: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "acknowledgments [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark"]
                    ]
                };
                t.default = n
            },
            860: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "afterword [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark"]
                    ]
                };
                t.default = n
            },
            1544: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "appendix [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark"]
                    ]
                };
                t.default = n
            },
            656: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author", "content"],
                    prohibitedProps: [],
                    props: {
                        "aria-errormessage": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "referrer [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "widget", "command", "link"]
                    ]
                };
                t.default = n
            },
            1288: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "EPUB biblioentry [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: ["doc-bibliography"],
                    requiredContextRole: ["doc-bibliography"],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "listitem"]
                    ]
                };
                t.default = n
            },
            5820: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "bibliography [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [
                        ["doc-biblioentry"]
                    ],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark"]
                    ]
                };
                t.default = n
            },
            9732: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author", "contents"],
                    prohibitedProps: [],
                    props: {
                        "aria-errormessage": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "biblioref [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "widget", "command", "link"]
                    ]
                };
                t.default = n
            },
            6803: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "chapter [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark"]
                    ]
                };
                t.default = n
            },
            3120: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "colophon [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            5164: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "conclusion [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark"]
                    ]
                };
                t.default = n
            },
            2984: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "cover [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "img"]
                    ]
                };
                t.default = n
            },
            7420: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "credit [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            7616: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "credits [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark"]
                    ]
                };
                t.default = n
            },
            7080: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "dedication [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            9496: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "rearnote [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: ["doc-endnotes"],
                    requiredContextRole: ["doc-endnotes"],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "listitem"]
                    ]
                };
                t.default = n
            },
            4076: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "rearnotes [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [
                        ["doc-endnote"]
                    ],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark"]
                    ]
                };
                t.default = n
            },
            1888: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "epigraph [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            8276: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "epilogue [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark"]
                    ]
                };
                t.default = n
            },
            6488: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "errata [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark"]
                    ]
                };
                t.default = n
            },
            6536: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            9900: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "footnote [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            2288: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "foreword [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark"]
                    ]
                };
                t.default = n
            },
            7144: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "glossary [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [
                        ["definition"],
                        ["term"]
                    ],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark"]
                    ]
                };
                t.default = n
            },
            6989: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author", "contents"],
                    prohibitedProps: [],
                    props: {
                        "aria-errormessage": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "glossref [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "widget", "command", "link"]
                    ]
                };
                t.default = n
            },
            1944: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "index [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark", "navigation"]
                    ]
                };
                t.default = n
            },
            6704: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "introduction [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark"]
                    ]
                };
                t.default = n
            },
            1012: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author", "contents"],
                    prohibitedProps: [],
                    props: {
                        "aria-errormessage": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "noteref [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "widget", "command", "link"]
                    ]
                };
                t.default = n
            },
            5728: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "notice [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "note"]
                    ]
                };
                t.default = n
            },
            7120: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !0,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "pagebreak [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "separator"]
                    ]
                };
                t.default = n
            },
            1683: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "page-list [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark", "navigation"]
                    ]
                };
                t.default = n
            },
            3796: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "part [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark"]
                    ]
                };
                t.default = n
            },
            4748: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "preface [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark"]
                    ]
                };
                t.default = n
            },
            6168: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "prologue [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark"]
                    ]
                };
                t.default = n
            },
            7300: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            name: "pullquote [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["none"]
                    ]
                };
                t.default = n
            },
            4288: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "qna [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            348: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "subtitle [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "sectionhead"]
                    ]
                };
                t.default = n
            },
            2772: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "help [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "note"]
                    ]
                };
                t.default = n
            },
            9744: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "toc [EPUB-SSV]"
                        },
                        module: "EPUB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark", "navigation"]
                    ]
                };
                t.default = n
            },
            9328: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        module: "GRAPHICS",
                        concept: {
                            name: "graphics-object"
                        }
                    }, {
                        module: "ARIA",
                        concept: {
                            name: "img"
                        }
                    }, {
                        module: "ARIA",
                        concept: {
                            name: "article"
                        }
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "document"]
                    ]
                };
                t.default = n
            },
            8740: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author", "contents"],
                    prohibitedProps: [],
                    props: {
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        module: "GRAPHICS",
                        concept: {
                            name: "graphics-document"
                        }
                    }, {
                        module: "ARIA",
                        concept: {
                            name: "group"
                        }
                    }, {
                        module: "ARIA",
                        concept: {
                            name: "img"
                        }
                    }, {
                        module: "GRAPHICS",
                        concept: {
                            name: "graphics-symbol"
                        }
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "group"]
                    ]
                };
                t.default = n
            },
            5340: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !0,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "img"]
                    ]
                };
                t.default = n
            },
            2e3: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-atomic": "true",
                        "aria-live": "assertive"
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "alert"
                        },
                        module: "XForms"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            3252: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            name: "alert"
                        },
                        module: "XForms"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "alert"],
                        ["roletype", "window", "dialog"]
                    ]
                };
                t.default = n
            },
            6664: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-activedescendant": null,
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "Device Independence Delivery Unit"
                        }
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure"]
                    ]
                };
                t.default = n
            },
            9672: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-posinset": null,
                        "aria-setsize": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "article"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "document"]
                    ]
                };
                t.default = n
            },
            4432: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            constraints: ["direct descendant of document"],
                            name: "header"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark"]
                    ]
                };
                t.default = n
            },
            332: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            1992: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !0,
                    nameFrom: ["author", "contents"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-pressed": null
                    },
                    relatedConcepts: [{
                        concept: {
                            attributes: [{
                                constraints: ["set"],
                                name: "aria-pressed"
                            }, {
                                name: "type",
                                value: "checkbox"
                            }],
                            name: "input"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                name: "aria-expanded",
                                value: "false"
                            }],
                            name: "summary"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                name: "aria-expanded",
                                value: "true"
                            }],
                            constraints: ["direct descendant of details element with the open attribute defined"],
                            name: "summary"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                name: "type",
                                value: "button"
                            }],
                            name: "input"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                name: "type",
                                value: "image"
                            }],
                            name: "input"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                name: "type",
                                value: "reset"
                            }],
                            name: "input"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                name: "type",
                                value: "submit"
                            }],
                            name: "input"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "button"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "trigger"
                        },
                        module: "XForms"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "widget", "command"]
                    ]
                };
                t.default = n
            },
            5480: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["prohibited"],
                    prohibitedProps: ["aria-label", "aria-labelledby"],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: ["figure", "grid", "table"],
                    requiredContextRole: ["figure", "grid", "table"],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            356: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author", "contents"],
                    prohibitedProps: [],
                    props: {
                        "aria-colindex": null,
                        "aria-colspan": null,
                        "aria-rowindex": null,
                        "aria-rowspan": null
                    },
                    relatedConcepts: [{
                        concept: {
                            constraints: ["descendant of table"],
                            name: "td"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: ["row"],
                    requiredContextRole: ["row"],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            7264: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !0,
                    nameFrom: ["author", "contents"],
                    prohibitedProps: [],
                    props: {
                        "aria-checked": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-invalid": null,
                        "aria-readonly": null,
                        "aria-required": null
                    },
                    relatedConcepts: [{
                        concept: {
                            attributes: [{
                                name: "type",
                                value: "checkbox"
                            }],
                            name: "input"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "option"
                        },
                        module: "ARIA"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {
                        "aria-checked": null
                    },
                    superClass: [
                        ["roletype", "widget", "input"]
                    ]
                };
                t.default = n
            },
            4696: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["prohibited"],
                    prohibitedProps: ["aria-label", "aria-labelledby"],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            1064: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author", "contents"],
                    prohibitedProps: [],
                    props: {
                        "aria-sort": null
                    },
                    relatedConcepts: [{
                        attributes: [{
                            name: "scope",
                            value: "col"
                        }],
                        concept: {
                            name: "th"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: ["row"],
                    requiredContextRole: ["row"],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "cell"],
                        ["roletype", "structure", "section", "cell", "gridcell"],
                        ["roletype", "widget", "gridcell"],
                        ["roletype", "structure", "sectionhead"]
                    ]
                };
                t.default = n
            },
            6464: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-activedescendant": null,
                        "aria-autocomplete": null,
                        "aria-errormessage": null,
                        "aria-invalid": null,
                        "aria-readonly": null,
                        "aria-required": null,
                        "aria-expanded": "false",
                        "aria-haspopup": "listbox"
                    },
                    relatedConcepts: [{
                        concept: {
                            attributes: [{
                                constraints: ["set"],
                                name: "list"
                            }, {
                                name: "type",
                                value: "email"
                            }],
                            name: "input"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                constraints: ["set"],
                                name: "list"
                            }, {
                                name: "type",
                                value: "search"
                            }],
                            name: "input"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                constraints: ["set"],
                                name: "list"
                            }, {
                                name: "type",
                                value: "tel"
                            }],
                            name: "input"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                constraints: ["set"],
                                name: "list"
                            }, {
                                name: "type",
                                value: "text"
                            }],
                            name: "input"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                constraints: ["set"],
                                name: "list"
                            }, {
                                name: "type",
                                value: "url"
                            }],
                            name: "input"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                constraints: ["set"],
                                name: "list"
                            }, {
                                name: "type",
                                value: "url"
                            }],
                            name: "input"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                constraints: ["undefined"],
                                name: "multiple"
                            }, {
                                constraints: ["undefined"],
                                name: "size"
                            }],
                            name: "select"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                constraints: ["undefined"],
                                name: "multiple"
                            }, {
                                name: "size",
                                value: 1
                            }],
                            name: "select"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "select"
                        },
                        module: "XForms"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {
                        "aria-controls": null,
                        "aria-expanded": "false"
                    },
                    superClass: [
                        ["roletype", "widget", "input"]
                    ]
                };
                t.default = n
            },
            8360: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            name: "aside"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark"]
                    ]
                };
                t.default = n
            },
            6996: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            constraints: ["direct descendant of document"],
                            name: "footer"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark"]
                    ]
                };
                t.default = n
            },
            3992: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            name: "dd"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            5720: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["prohibited"],
                    prohibitedProps: ["aria-label", "aria-labelledby"],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            9576: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            name: "dialog"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "window"]
                    ]
                };
                t.default = n
            },
            4204: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        module: "DAISY Guide"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "list"]
                    ]
                };
                t.default = n
            },
            6056: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            name: "Device Independence Delivery Unit"
                        }
                    }, {
                        concept: {
                            name: "body"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure"]
                    ]
                };
                t.default = n
            },
            1844: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["prohibited"],
                    prohibitedProps: ["aria-label", "aria-labelledby"],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            8868: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [
                        ["article"]
                    ],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "list"]
                    ]
                };
                t.default = n
            },
            7232: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            name: "figure"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            6616: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            attributes: [{
                                constraints: ["set"],
                                name: "aria-label"
                            }],
                            name: "form"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                constraints: ["set"],
                                name: "aria-labelledby"
                            }],
                            name: "form"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                constraints: ["set"],
                                name: "name"
                            }],
                            name: "form"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark"]
                    ]
                };
                t.default = n
            },
            88: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["prohibited"],
                    prohibitedProps: ["aria-label", "aria-labelledby"],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            name: "span"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "div"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure"]
                    ]
                };
                t.default = n
            },
            5412: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-multiselectable": null,
                        "aria-readonly": null
                    },
                    relatedConcepts: [{
                        concept: {
                            attributes: [{
                                name: "role",
                                value: "grid"
                            }],
                            name: "table"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [
                        ["row"],
                        ["row", "rowgroup"]
                    ],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "widget", "composite"],
                        ["roletype", "structure", "section", "table"]
                    ]
                };
                t.default = n
            },
            6432: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author", "contents"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-invalid": null,
                        "aria-readonly": null,
                        "aria-required": null,
                        "aria-selected": null
                    },
                    relatedConcepts: [{
                        concept: {
                            attributes: [{
                                name: "role",
                                value: "gridcell"
                            }],
                            name: "td"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: ["row"],
                    requiredContextRole: ["row"],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "cell"],
                        ["roletype", "widget"]
                    ]
                };
                t.default = n
            },
            747: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-activedescendant": null,
                        "aria-disabled": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "details"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "fieldset"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "optgroup"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            5372: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author", "contents"],
                    prohibitedProps: [],
                    props: {
                        "aria-level": "2"
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "h1"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "h2"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "h3"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "h4"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "h5"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "h6"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {
                        "aria-level": "2"
                    },
                    superClass: [
                        ["roletype", "structure", "sectionhead"]
                    ]
                };
                t.default = n
            },
            2752: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !0,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            attributes: [{
                                constraints: ["set"],
                                name: "alt"
                            }],
                            name: "img"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                constraints: ["undefined"],
                                name: "alt"
                            }],
                            name: "img"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "imggroup"
                        },
                        module: "DTB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            8904: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["prohibited"],
                    prohibitedProps: ["aria-label", "aria-labelledby"],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            2256: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author", "contents"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-expanded": null,
                        "aria-haspopup": null
                    },
                    relatedConcepts: [{
                        concept: {
                            attributes: [{
                                name: "href"
                            }],
                            name: "a"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                name: "href"
                            }],
                            name: "area"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                name: "href"
                            }],
                            name: "link"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "widget", "command"]
                    ]
                };
                t.default = n
            },
            728: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            name: "menu"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "ol"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "ul"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [
                        ["listitem"]
                    ],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            8008: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-errormessage": null,
                        "aria-expanded": null,
                        "aria-invalid": null,
                        "aria-multiselectable": null,
                        "aria-readonly": null,
                        "aria-required": null,
                        "aria-orientation": "vertical"
                    },
                    relatedConcepts: [{
                        concept: {
                            attributes: [{
                                constraints: [">1"],
                                name: "size"
                            }, {
                                name: "multiple"
                            }],
                            name: "select"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                constraints: [">1"],
                                name: "size"
                            }],
                            name: "select"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                name: "multiple"
                            }],
                            name: "select"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "datalist"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "list"
                        },
                        module: "ARIA"
                    }, {
                        concept: {
                            name: "select"
                        },
                        module: "XForms"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [
                        ["option", "group"],
                        ["option"]
                    ],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "widget", "composite", "select"],
                        ["roletype", "structure", "section", "group", "select"]
                    ]
                };
                t.default = n
            },
            6828: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-level": null,
                        "aria-posinset": null,
                        "aria-setsize": null
                    },
                    relatedConcepts: [{
                        concept: {
                            constraints: ["direct descendant of ol, ul or menu"],
                            name: "li"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "item"
                        },
                        module: "XForms"
                    }],
                    requireContextRole: ["directory", "list"],
                    requiredContextRole: ["directory", "list"],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            6052: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-live": "polite"
                    },
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            1940: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            name: "main"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark"]
                    ]
                };
                t.default = n
            },
            5532: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            904: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            name: "math"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            1117: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-orientation": "vertical"
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "MENU"
                        },
                        module: "JAPI"
                    }, {
                        concept: {
                            name: "list"
                        },
                        module: "ARIA"
                    }, {
                        concept: {
                            name: "select"
                        },
                        module: "XForms"
                    }, {
                        concept: {
                            name: "sidebar"
                        },
                        module: "DTB"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [
                        ["menuitem", "group"],
                        ["menuitemradio", "group"],
                        ["menuitemcheckbox", "group"],
                        ["menuitem"],
                        ["menuitemcheckbox"],
                        ["menuitemradio"]
                    ],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "widget", "composite", "select"],
                        ["roletype", "structure", "section", "group", "select"]
                    ]
                };
                t.default = n
            },
            4780: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-orientation": "horizontal"
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "toolbar"
                        },
                        module: "ARIA"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [
                        ["menuitem", "group"],
                        ["menuitemradio", "group"],
                        ["menuitemcheckbox", "group"],
                        ["menuitem"],
                        ["menuitemcheckbox"],
                        ["menuitemradio"]
                    ],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "widget", "composite", "select", "menu"],
                        ["roletype", "structure", "section", "group", "select", "menu"]
                    ]
                };
                t.default = n
            },
            972: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author", "contents"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-posinset": null,
                        "aria-setsize": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "MENU_ITEM"
                        },
                        module: "JAPI"
                    }, {
                        concept: {
                            name: "listitem"
                        },
                        module: "ARIA"
                    }, {
                        concept: {
                            name: "menuitem"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "option"
                        },
                        module: "ARIA"
                    }],
                    requireContextRole: ["group", "menu", "menubar"],
                    requiredContextRole: ["group", "menu", "menubar"],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "widget", "command"]
                    ]
                };
                t.default = n
            },
            2200: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !0,
                    nameFrom: ["author", "contents"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            name: "menuitem"
                        },
                        module: "ARIA"
                    }],
                    requireContextRole: ["group", "menu", "menubar"],
                    requiredContextRole: ["group", "menu", "menubar"],
                    requiredOwnedElements: [],
                    requiredProps: {
                        "aria-checked": null
                    },
                    superClass: [
                        ["roletype", "widget", "input", "checkbox"],
                        ["roletype", "widget", "command", "menuitem"]
                    ]
                };
                t.default = n
            },
            3312: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !0,
                    nameFrom: ["author", "contents"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            name: "menuitem"
                        },
                        module: "ARIA"
                    }],
                    requireContextRole: ["group", "menu", "menubar"],
                    requiredContextRole: ["group", "menu", "menubar"],
                    requiredOwnedElements: [],
                    requiredProps: {
                        "aria-checked": null
                    },
                    superClass: [
                        ["roletype", "widget", "input", "checkbox", "menuitemcheckbox"],
                        ["roletype", "widget", "command", "menuitem", "menuitemcheckbox"],
                        ["roletype", "widget", "input", "radio"]
                    ]
                };
                t.default = n
            },
            552: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !0,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-valuetext": null,
                        "aria-valuemax": "100",
                        "aria-valuemin": "0"
                    },
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {
                        "aria-valuenow": null
                    },
                    superClass: [
                        ["roletype", "structure", "range"]
                    ]
                };
                t.default = n
            },
            1232: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            name: "nav"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark"]
                    ]
                };
                t.default = n
            },
            372: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: [],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: []
                };
                t.default = n
            },
            5723: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            1216: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !0,
                    nameFrom: ["author", "contents"],
                    prohibitedProps: [],
                    props: {
                        "aria-checked": null,
                        "aria-posinset": null,
                        "aria-setsize": null,
                        "aria-selected": "false"
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "item"
                        },
                        module: "XForms"
                    }, {
                        concept: {
                            name: "listitem"
                        },
                        module: "ARIA"
                    }, {
                        concept: {
                            name: "option"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {
                        "aria-selected": "false"
                    },
                    superClass: [
                        ["roletype", "widget", "input"]
                    ]
                };
                t.default = n
            },
            5992: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["prohibited"],
                    prohibitedProps: ["aria-label", "aria-labelledby"],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            6720: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["prohibited"],
                    prohibitedProps: ["aria-label", "aria-labelledby"],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure"]
                    ]
                };
                t.default = n
            },
            5018: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !0,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-valuetext": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "progress"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "status"
                        },
                        module: "ARIA"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "range"],
                        ["roletype", "widget"]
                    ]
                };
                t.default = n
            },
            9828: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !0,
                    nameFrom: ["author", "contents"],
                    prohibitedProps: [],
                    props: {
                        "aria-checked": null,
                        "aria-posinset": null,
                        "aria-setsize": null
                    },
                    relatedConcepts: [{
                        concept: {
                            attributes: [{
                                name: "type",
                                value: "radio"
                            }],
                            name: "input"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {
                        "aria-checked": null
                    },
                    superClass: [
                        ["roletype", "widget", "input"]
                    ]
                };
                t.default = n
            },
            6340: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-errormessage": null,
                        "aria-invalid": null,
                        "aria-readonly": null,
                        "aria-required": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "list"
                        },
                        module: "ARIA"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [
                        ["radio"]
                    ],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "widget", "composite", "select"],
                        ["roletype", "structure", "section", "group", "select"]
                    ]
                };
                t.default = n
            },
            5076: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            attributes: [{
                                constraints: ["set"],
                                name: "aria-label"
                            }],
                            name: "section"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                constraints: ["set"],
                                name: "aria-labelledby"
                            }],
                            name: "section"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "Device Independence Glossart perceivable unit"
                        }
                    }, {
                        concept: {
                            name: "frame"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark"]
                    ]
                };
                t.default = n
            },
            5448: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author", "contents"],
                    prohibitedProps: [],
                    props: {
                        "aria-colindex": null,
                        "aria-expanded": null,
                        "aria-level": null,
                        "aria-posinset": null,
                        "aria-rowindex": null,
                        "aria-selected": null,
                        "aria-setsize": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "tr"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: ["grid", "rowgroup", "table", "treegrid"],
                    requiredContextRole: ["grid", "rowgroup", "table", "treegrid"],
                    requiredOwnedElements: [
                        ["cell"],
                        ["columnheader"],
                        ["gridcell"],
                        ["rowheader"]
                    ],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "group"],
                        ["roletype", "widget"]
                    ]
                };
                t.default = n
            },
            7272: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author", "contents"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            name: "tbody"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "tfoot"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "thead"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: ["grid", "table", "treegrid"],
                    requiredContextRole: ["grid", "table", "treegrid"],
                    requiredOwnedElements: [
                        ["row"]
                    ],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure"]
                    ]
                };
                t.default = n
            },
            1592: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author", "contents"],
                    prohibitedProps: [],
                    props: {
                        "aria-sort": null
                    },
                    relatedConcepts: [{
                        concept: {
                            attributes: [{
                                name: "scope",
                                value: "row"
                            }],
                            name: "th"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                name: "scope",
                                value: "rowgroup"
                            }],
                            name: "th"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: ["row", "rowgroup"],
                    requiredContextRole: ["row", "rowgroup"],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "cell"],
                        ["roletype", "structure", "section", "cell", "gridcell"],
                        ["roletype", "widget", "gridcell"],
                        ["roletype", "structure", "sectionhead"]
                    ]
                };
                t.default = n
            },
            7288: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !0,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-valuetext": null,
                        "aria-orientation": "vertical",
                        "aria-valuemax": "100",
                        "aria-valuemin": "0"
                    },
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {
                        "aria-controls": null,
                        "aria-valuenow": null
                    },
                    superClass: [
                        ["roletype", "structure", "range"],
                        ["roletype", "widget"]
                    ]
                };
                t.default = n
            },
            9780: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "landmark"]
                    ]
                };
                t.default = n
            },
            3584: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            attributes: [{
                                constraints: ["undefined"],
                                name: "list"
                            }, {
                                name: "type",
                                value: "search"
                            }],
                            name: "input"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "widget", "input", "textbox"]
                    ]
                };
                t.default = n
            },
            7576: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !0,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-orientation": "horizontal",
                        "aria-valuemax": "100",
                        "aria-valuemin": "0",
                        "aria-valuenow": null,
                        "aria-valuetext": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "hr"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure"]
                    ]
                };
                t.default = n
            },
            1456: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !0,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-errormessage": null,
                        "aria-haspopup": null,
                        "aria-invalid": null,
                        "aria-readonly": null,
                        "aria-valuetext": null,
                        "aria-orientation": "horizontal",
                        "aria-valuemax": "100",
                        "aria-valuemin": "0"
                    },
                    relatedConcepts: [{
                        concept: {
                            attributes: [{
                                name: "type",
                                value: "range"
                            }],
                            name: "input"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {
                        "aria-valuenow": null
                    },
                    superClass: [
                        ["roletype", "widget", "input"],
                        ["roletype", "structure", "range"]
                    ]
                };
                t.default = n
            },
            6112: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-errormessage": null,
                        "aria-invalid": null,
                        "aria-readonly": null,
                        "aria-required": null,
                        "aria-valuetext": null,
                        "aria-valuenow": "0"
                    },
                    relatedConcepts: [{
                        concept: {
                            attributes: [{
                                name: "type",
                                value: "number"
                            }],
                            name: "input"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "widget", "composite"],
                        ["roletype", "widget", "input"],
                        ["roletype", "structure", "range"]
                    ]
                };
                t.default = n
            },
            4652: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-atomic": "true",
                        "aria-live": "polite"
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "output"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            3592: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["prohibited"],
                    prohibitedProps: ["aria-label", "aria-labelledby"],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            8560: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["prohibited"],
                    prohibitedProps: ["aria-label", "aria-labelledby"],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            7492: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["prohibited"],
                    prohibitedProps: ["aria-label", "aria-labelledby"],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            1748: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !0,
                    nameFrom: ["author", "contents"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            name: "button"
                        },
                        module: "ARIA"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {
                        "aria-checked": null
                    },
                    superClass: [
                        ["roletype", "widget", "input", "checkbox"]
                    ]
                };
                t.default = n
            },
            6144: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !0,
                    nameFrom: ["author", "contents"],
                    prohibitedProps: [],
                    props: {
                        "aria-disabled": null,
                        "aria-expanded": null,
                        "aria-haspopup": null,
                        "aria-posinset": null,
                        "aria-setsize": null,
                        "aria-selected": "false"
                    },
                    relatedConcepts: [],
                    requireContextRole: ["tablist"],
                    requiredContextRole: ["tablist"],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "sectionhead"],
                        ["roletype", "widget"]
                    ]
                };
                t.default = n
            },
            4460: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-colcount": null,
                        "aria-rowcount": null
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "table"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [
                        ["row"],
                        ["row", "rowgroup"]
                    ],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            6808: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-level": null,
                        "aria-multiselectable": null,
                        "aria-orientation": "horizontal"
                    },
                    relatedConcepts: [{
                        module: "DAISY",
                        concept: {
                            name: "guide"
                        }
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [
                        ["tab"]
                    ],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "widget", "composite"]
                    ]
                };
                t.default = n
            },
            9380: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            3891: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [{
                        concept: {
                            name: "dfn"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "dt"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            1e3: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-activedescendant": null,
                        "aria-autocomplete": null,
                        "aria-errormessage": null,
                        "aria-haspopup": null,
                        "aria-invalid": null,
                        "aria-multiline": null,
                        "aria-placeholder": null,
                        "aria-readonly": null,
                        "aria-required": null
                    },
                    relatedConcepts: [{
                        concept: {
                            attributes: [{
                                constraints: ["undefined"],
                                name: "type"
                            }, {
                                constraints: ["undefined"],
                                name: "list"
                            }],
                            name: "input"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                constraints: ["undefined"],
                                name: "list"
                            }, {
                                name: "type",
                                value: "email"
                            }],
                            name: "input"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                constraints: ["undefined"],
                                name: "list"
                            }, {
                                name: "type",
                                value: "tel"
                            }],
                            name: "input"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                constraints: ["undefined"],
                                name: "list"
                            }, {
                                name: "type",
                                value: "text"
                            }],
                            name: "input"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            attributes: [{
                                constraints: ["undefined"],
                                name: "list"
                            }, {
                                name: "type",
                                value: "url"
                            }],
                            name: "input"
                        },
                        module: "HTML"
                    }, {
                        concept: {
                            name: "input"
                        },
                        module: "XForms"
                    }, {
                        concept: {
                            name: "textarea"
                        },
                        module: "HTML"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "widget", "input"]
                    ]
                };
                t.default = n
            },
            7960: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            8344: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "status"]
                    ]
                };
                t.default = n
            },
            8352: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !1,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-orientation": "horizontal"
                    },
                    relatedConcepts: [{
                        concept: {
                            name: "menubar"
                        },
                        module: "ARIA"
                    }],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section", "group"]
                    ]
                };
                t.default = n
            },
            6352: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author", "contents"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "structure", "section"]
                    ]
                };
                t.default = n
            },
            1976: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {
                        "aria-errormessage": null,
                        "aria-invalid": null,
                        "aria-multiselectable": null,
                        "aria-required": null,
                        "aria-orientation": "vertical"
                    },
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [
                        ["treeitem", "group"],
                        ["treeitem"]
                    ],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "widget", "composite", "select"],
                        ["roletype", "structure", "section", "group", "select"]
                    ]
                };
                t.default = n
            },
            4611: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author"],
                    prohibitedProps: [],
                    props: {},
                    relatedConcepts: [],
                    requireContextRole: [],
                    requiredContextRole: [],
                    requiredOwnedElements: [
                        ["row"],
                        ["row", "rowgroup"]
                    ],
                    requiredProps: {},
                    superClass: [
                        ["roletype", "widget", "composite", "grid"],
                        ["roletype", "structure", "section", "table", "grid"],
                        ["roletype", "widget", "composite", "select", "tree"],
                        ["roletype", "structure", "section", "group", "select", "tree"]
                    ]
                };
                t.default = n
            },
            5548: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = {
                    abstract: !1,
                    accessibleNameRequired: !0,
                    baseConcepts: [],
                    childrenPresentational: !1,
                    nameFrom: ["author", "contents"],
                    prohibitedProps: [],
                    props: {
                        "aria-expanded": null,
                        "aria-haspopup": null
                    },
                    relatedConcepts: [],
                    requireContextRole: ["group", "tree"],
                    requiredContextRole: ["group", "tree"],
                    requiredOwnedElements: [],
                    requiredProps: {
                        "aria-selected": null
                    },
                    superClass: [
                        ["roletype", "structure", "section", "listitem"],
                        ["roletype", "widget", "input", "option"]
                    ]
                };
                t.default = n
            },
            4616: (e, t, n) => {
                "use strict";
                t.gF = t.e4 = t.Er = void 0;
                var r = l(n(3976)),
                    i = l(n(3816)),
                    o = l(n(8080)),
                    a = l(n(2996)),
                    s = l(n(6008));

                function l(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                r.default, i.default;
                var c = o.default;
                t.gF = c;
                var u = a.default;
                t.Er = u;
                var d = s.default;
                t.e4 = d
            },
            6008: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var r = o(n(1644)),
                    i = o(n(8080));

                function o(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function a(e, t) {
                    return function(e) {
                        if (Array.isArray(e)) return e
                    }(e) || function(e, t) {
                        var n = null == e ? null : "undefined" !== typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                        if (null == n) return;
                        var r, i, o = [],
                            a = !0,
                            s = !1;
                        try {
                            for (n = n.call(e); !(a = (r = n.next()).done) && (o.push(r.value), !t || o.length !== t); a = !0);
                        } catch (l) {
                            s = !0, i = l
                        } finally {
                            try {
                                a || null == n.return || n.return()
                            } finally {
                                if (s) throw i
                            }
                        }
                        return o
                    }(e, t) || s(e, t) || function() {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function s(e, t) {
                    if (e) {
                        if ("string" === typeof e) return l(e, t);
                        var n = Object.prototype.toString.call(e).slice(8, -1);
                        return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? l(e, t) : void 0
                    }
                }

                function l(e, t) {
                    (null == t || t > e.length) && (t = e.length);
                    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
                    return r
                }
                for (var c = [], u = i.default.keys(), d = function(e) {
                        var t = u[e],
                            n = i.default.get(t);
                        if (n)
                            for (var r = [].concat(n.baseConcepts, n.relatedConcepts), o = 0; o < r.length; o++) {
                                var a = r[o];
                                if ("HTML" === a.module) {
                                    var s = a.concept;
                                    if (s) {
                                        var l = c.find((function(e) {
                                                return e[0] === t
                                            })),
                                            d = void 0;
                                        (d = l ? l[1] : []).push(s), c.push([t, d])
                                    }
                                }
                            }
                    }, h = 0; h < u.length; h++) d(h);
                var p = {
                        entries: function() {
                            return c
                        },
                        forEach: function(e) {
                            var t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                                r = function(e, t) {
                                    var n = "undefined" !== typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                                    if (!n) {
                                        if (Array.isArray(e) || (n = s(e)) || t && e && "number" === typeof e.length) {
                                            n && (e = n);
                                            var r = 0,
                                                i = function() {};
                                            return {
                                                s: i,
                                                n: function() {
                                                    return r >= e.length ? {
                                                        done: !0
                                                    } : {
                                                        done: !1,
                                                        value: e[r++]
                                                    }
                                                },
                                                e: function(e) {
                                                    throw e
                                                },
                                                f: i
                                            }
                                        }
                                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                                    }
                                    var o, a = !0,
                                        l = !1;
                                    return {
                                        s: function() {
                                            n = n.call(e)
                                        },
                                        n: function() {
                                            var e = n.next();
                                            return a = e.done, e
                                        },
                                        e: function(e) {
                                            l = !0, o = e
                                        },
                                        f: function() {
                                            try {
                                                a || null == n.return || n.return()
                                            } finally {
                                                if (l) throw o
                                            }
                                        }
                                    }
                                }(c);
                            try {
                                for (r.s(); !(t = r.n()).done;) {
                                    var i = a(t.value, 2),
                                        o = i[0],
                                        l = i[1];
                                    e.call(n, l, o, c)
                                }
                            } catch (u) {
                                r.e(u)
                            } finally {
                                r.f()
                            }
                        },
                        get: function(e) {
                            var t = c.find((function(t) {
                                return t[0] === e
                            }));
                            return t && t[1]
                        },
                        has: function(e) {
                            return !!p.get(e)
                        },
                        keys: function() {
                            return c.map((function(e) {
                                return a(e, 1)[0]
                            }))
                        },
                        values: function() {
                            return c.map((function(e) {
                                return a(e, 2)[1]
                            }))
                        }
                    },
                    f = (0, r.default)(p, p.entries());
                t.default = f
            },
            8080: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var r = l(n(6232)),
                    i = l(n(1148)),
                    o = l(n(4540)),
                    a = l(n(7480)),
                    s = l(n(1644));

                function l(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function c(e, t) {
                    var n = "undefined" !== typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                    if (!n) {
                        if (Array.isArray(e) || (n = d(e)) || t && e && "number" === typeof e.length) {
                            n && (e = n);
                            var r = 0,
                                i = function() {};
                            return {
                                s: i,
                                n: function() {
                                    return r >= e.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: e[r++]
                                    }
                                },
                                e: function(e) {
                                    throw e
                                },
                                f: i
                            }
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }
                    var o, a = !0,
                        s = !1;
                    return {
                        s: function() {
                            n = n.call(e)
                        },
                        n: function() {
                            var e = n.next();
                            return a = e.done, e
                        },
                        e: function(e) {
                            s = !0, o = e
                        },
                        f: function() {
                            try {
                                a || null == n.return || n.return()
                            } finally {
                                if (s) throw o
                            }
                        }
                    }
                }

                function u(e, t) {
                    return function(e) {
                        if (Array.isArray(e)) return e
                    }(e) || function(e, t) {
                        var n = null == e ? null : "undefined" !== typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                        if (null == n) return;
                        var r, i, o = [],
                            a = !0,
                            s = !1;
                        try {
                            for (n = n.call(e); !(a = (r = n.next()).done) && (o.push(r.value), !t || o.length !== t); a = !0);
                        } catch (l) {
                            s = !0, i = l
                        } finally {
                            try {
                                a || null == n.return || n.return()
                            } finally {
                                if (s) throw i
                            }
                        }
                        return o
                    }(e, t) || d(e, t) || function() {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function d(e, t) {
                    if (e) {
                        if ("string" === typeof e) return h(e, t);
                        var n = Object.prototype.toString.call(e).slice(8, -1);
                        return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? h(e, t) : void 0
                    }
                }

                function h(e, t) {
                    (null == t || t > e.length) && (t = e.length);
                    for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
                    return r
                }
                var p = [].concat(r.default, i.default, o.default, a.default);
                p.forEach((function(e) {
                    var t, n = u(e, 2)[1],
                        r = c(n.superClass);
                    try {
                        for (r.s(); !(t = r.n()).done;) {
                            var i, o = c(t.value);
                            try {
                                var a = function() {
                                    var e, t, r, o = i.value,
                                        a = p.find((function(e) {
                                            return u(e, 1)[0] === o
                                        }));
                                    if (a)
                                        for (var s = a[1], l = 0, c = Object.keys(s.props); l < c.length; l++) {
                                            var d = c[l];
                                            Object.prototype.hasOwnProperty.call(n.props, d) || Object.assign(n.props, (e = {}, t = d, r = s.props[d], t in e ? Object.defineProperty(e, t, {
                                                value: r,
                                                enumerable: !0,
                                                configurable: !0,
                                                writable: !0
                                            }) : e[t] = r, e))
                                        }
                                };
                                for (o.s(); !(i = o.n()).done;) a()
                            } catch (s) {
                                o.e(s)
                            } finally {
                                o.f()
                            }
                        }
                    } catch (s) {
                        r.e(s)
                    } finally {
                        r.f()
                    }
                }));
                var f = {
                        entries: function() {
                            return p
                        },
                        forEach: function(e) {
                            var t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                                r = c(p);
                            try {
                                for (r.s(); !(t = r.n()).done;) {
                                    var i = u(t.value, 2),
                                        o = i[0],
                                        a = i[1];
                                    e.call(n, a, o, p)
                                }
                            } catch (s) {
                                r.e(s)
                            } finally {
                                r.f()
                            }
                        },
                        get: function(e) {
                            var t = p.find((function(t) {
                                return t[0] === e
                            }));
                            return t && t[1]
                        },
                        has: function(e) {
                            return !!f.get(e)
                        },
                        keys: function() {
                            return p.map((function(e) {
                                return u(e, 1)[0]
                            }))
                        },
                        values: function() {
                            return p.map((function(e) {
                                return u(e, 2)[1]
                            }))
                        }
                    },
                    m = (0, s.default)(f, f.entries());
                t.default = m
            },
            1644: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e, t) {
                    "function" === typeof Symbol && "symbol" === o(Symbol.iterator) && Object.defineProperty(e, Symbol.iterator, {
                        value: i.default.bind(t)
                    });
                    return e
                };
                var r, i = (r = n(2424)) && r.__esModule ? r : {
                    default: r
                };

                function o(e) {
                    return o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                        return typeof e
                    } : function(e) {
                        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                    }, o(e)
                }
            },
            2424: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var n = function() {
                    var e = this,
                        t = 0,
                        n = {
                            "@@iterator": function() {
                                return n
                            },
                            next: function() {
                                if (t < e.length) {
                                    var n = e[t];
                                    return t += 1, {
                                        done: !1,
                                        value: n
                                    }
                                }
                                return {
                                    done: !0
                                }
                            }
                        };
                    return n
                };
                t.default = n
            },
            1392: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.printIteratorEntries = function(e, t, n, r, i, o) {
                    let a = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : ": ",
                        s = "",
                        l = e.next();
                    if (!l.done) {
                        s += t.spacingOuter;
                        const c = n + t.indent;
                        for (; !l.done;) {
                            s += c + o(l.value[0], t, c, r, i) + a + o(l.value[1], t, c, r, i), l = e.next(), l.done ? t.min || (s += ",") : s += "," + t.spacingInner
                        }
                        s += t.spacingOuter + n
                    }
                    return s
                }, t.printIteratorValues = function(e, t, n, r, i, o) {
                    let a = "",
                        s = e.next();
                    if (!s.done) {
                        a += t.spacingOuter;
                        const l = n + t.indent;
                        for (; !s.done;) a += l + o(s.value, t, l, r, i), s = e.next(), s.done ? t.min || (a += ",") : a += "," + t.spacingInner;
                        a += t.spacingOuter + n
                    }
                    return a
                }, t.printListItems = function(e, t, n, r, i, o) {
                    let a = "";
                    if (e.length) {
                        a += t.spacingOuter;
                        const s = n + t.indent;
                        for (let n = 0; n < e.length; n++) a += s, n in e && (a += o(e[n], t, s, r, i)), n < e.length - 1 ? a += "," + t.spacingInner : t.min || (a += ",");
                        a += t.spacingOuter + n
                    }
                    return a
                }, t.printObjectProperties = function(e, t, r, i, o, a) {
                    let s = "";
                    const l = n(e, t.compareKeys);
                    if (l.length) {
                        s += t.spacingOuter;
                        const n = r + t.indent;
                        for (let r = 0; r < l.length; r++) {
                            const c = l[r];
                            s += n + a(c, t, n, i, o) + ": " + a(e[c], t, n, i, o), r < l.length - 1 ? s += "," + t.spacingInner : t.min || (s += ",")
                        }
                        s += t.spacingOuter + r
                    }
                    return s
                };
                const n = (e, t) => {
                    const n = Object.keys(e).sort(t);
                    return Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(e).forEach((t => {
                        Object.getOwnPropertyDescriptor(e, t).enumerable && n.push(t)
                    })), n
                }
            },
            228: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = t.DEFAULT_OPTIONS = void 0, t.format = F, t.plugins = void 0;
                var r = h(n(7840)),
                    i = n(1392),
                    o = h(n(4200)),
                    a = h(n(4336)),
                    s = h(n(408)),
                    l = h(n(2608)),
                    c = h(n(156)),
                    u = h(n(5020)),
                    d = h(n(8676));

                function h(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                const p = Object.prototype.toString,
                    f = Date.prototype.toISOString,
                    m = Error.prototype.toString,
                    g = RegExp.prototype.toString,
                    v = e => "function" === typeof e.constructor && e.constructor.name || "Object",
                    y = e => "undefined" !== typeof window && e === window,
                    b = /^Symbol\((.*)\)(.*)$/,
                    x = /\n/gi;
                class _ extends Error {
                    constructor(e, t) {
                        super(e), this.stack = t, this.name = this.constructor.name
                    }
                }

                function M(e, t) {
                    return t ? "[Function " + (e.name || "anonymous") + "]" : "[Function]"
                }

                function w(e) {
                    return String(e).replace(b, "Symbol($1)")
                }

                function A(e) {
                    return "[" + m.call(e) + "]"
                }

                function S(e, t, n, r) {
                    if (!0 === e || !1 === e) return "" + e;
                    if (void 0 === e) return "undefined";
                    if (null === e) return "null";
                    const i = typeof e;
                    if ("number" === i) return function(e) {
                        return Object.is(e, -0) ? "-0" : String(e)
                    }(e);
                    if ("bigint" === i) return function(e) {
                        return String("".concat(e, "n"))
                    }(e);
                    if ("string" === i) return r ? '"' + e.replace(/"|\\/g, "\\$&") + '"' : '"' + e + '"';
                    if ("function" === i) return M(e, t);
                    if ("symbol" === i) return w(e);
                    const o = p.call(e);
                    return "[object WeakMap]" === o ? "WeakMap {}" : "[object WeakSet]" === o ? "WeakSet {}" : "[object Function]" === o || "[object GeneratorFunction]" === o ? M(e, t) : "[object Symbol]" === o ? w(e) : "[object Date]" === o ? isNaN(+e) ? "Date { NaN }" : f.call(e) : "[object Error]" === o ? A(e) : "[object RegExp]" === o ? n ? g.call(e).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&") : g.call(e) : e instanceof Error ? A(e) : null
                }

                function E(e, t, n, r, o, a) {
                    if (-1 !== o.indexOf(e)) return "[Circular]";
                    (o = o.slice()).push(e);
                    const s = ++r > t.maxDepth,
                        l = t.min;
                    if (t.callToJSON && !s && e.toJSON && "function" === typeof e.toJSON && !a) return P(e.toJSON(), t, n, r, o, !0);
                    const c = p.call(e);
                    return "[object Arguments]" === c ? s ? "[Arguments]" : (l ? "" : "Arguments ") + "[" + (0, i.printListItems)(e, t, n, r, o, P) + "]" : function(e) {
                        return "[object Array]" === e || "[object ArrayBuffer]" === e || "[object DataView]" === e || "[object Float32Array]" === e || "[object Float64Array]" === e || "[object Int8Array]" === e || "[object Int16Array]" === e || "[object Int32Array]" === e || "[object Uint8Array]" === e || "[object Uint8ClampedArray]" === e || "[object Uint16Array]" === e || "[object Uint32Array]" === e
                    }(c) ? s ? "[" + e.constructor.name + "]" : (l ? "" : t.printBasicPrototype || "Array" !== e.constructor.name ? e.constructor.name + " " : "") + "[" + (0, i.printListItems)(e, t, n, r, o, P) + "]" : "[object Map]" === c ? s ? "[Map]" : "Map {" + (0, i.printIteratorEntries)(e.entries(), t, n, r, o, P, " => ") + "}" : "[object Set]" === c ? s ? "[Set]" : "Set {" + (0, i.printIteratorValues)(e.values(), t, n, r, o, P) + "}" : s || y(e) ? "[" + v(e) + "]" : (l ? "" : t.printBasicPrototype || "Object" !== v(e) ? v(e) + " " : "") + "{" + (0, i.printObjectProperties)(e, t, n, r, o, P) + "}"
                }

                function C(e, t, n, r, i, o) {
                    let a;
                    try {
                        a = function(e) {
                            return null != e.serialize
                        }(e) ? e.serialize(t, n, r, i, o, P) : e.print(t, (e => P(e, n, r, i, o)), (e => {
                            const t = r + n.indent;
                            return t + e.replace(x, "\n" + t)
                        }), {
                            edgeSpacing: n.spacingOuter,
                            min: n.min,
                            spacing: n.spacingInner
                        }, n.colors)
                    } catch (s) {
                        throw new _(s.message, s.stack)
                    }
                    if ("string" !== typeof a) throw new Error('pretty-format: Plugin must return type "string" but instead returned "'.concat(typeof a, '".'));
                    return a
                }

                function T(e, t) {
                    for (let r = 0; r < e.length; r++) try {
                        if (e[r].test(t)) return e[r]
                    } catch (n) {
                        throw new _(n.message, n.stack)
                    }
                    return null
                }

                function P(e, t, n, r, i, o) {
                    const a = T(t.plugins, e);
                    if (null !== a) return C(a, e, t, n, r, i);
                    const s = S(e, t.printFunctionName, t.escapeRegex, t.escapeString);
                    return null !== s ? s : E(e, t, n, r, i, o)
                }
                const R = {
                        comment: "gray",
                        content: "reset",
                        prop: "yellow",
                        tag: "cyan",
                        value: "green"
                    },
                    I = Object.keys(R),
                    O = {
                        callToJSON: !0,
                        compareKeys: void 0,
                        escapeRegex: !1,
                        escapeString: !0,
                        highlight: !1,
                        indent: 2,
                        maxDepth: 1 / 0,
                        min: !1,
                        plugins: [],
                        printBasicPrototype: !0,
                        printFunctionName: !0,
                        theme: R
                    };
                t.DEFAULT_OPTIONS = O;
                const B = e => I.reduce(((t, n) => {
                        const i = e.theme && void 0 !== e.theme[n] ? e.theme[n] : R[n],
                            o = i && r.default[i];
                        if (!o || "string" !== typeof o.close || "string" !== typeof o.open) throw new Error('pretty-format: Option "theme" has a key "'.concat(n, '" whose value "').concat(i, '" is undefined in ansi-styles.'));
                        return t[n] = o, t
                    }), Object.create(null)),
                    L = e => e && void 0 !== e.printFunctionName ? e.printFunctionName : O.printFunctionName,
                    D = e => e && void 0 !== e.escapeRegex ? e.escapeRegex : O.escapeRegex,
                    N = e => e && void 0 !== e.escapeString ? e.escapeString : O.escapeString,
                    k = e => {
                        var t, n;
                        return {
                            callToJSON: e && void 0 !== e.callToJSON ? e.callToJSON : O.callToJSON,
                            colors: e && e.highlight ? B(e) : I.reduce(((e, t) => (e[t] = {
                                close: "",
                                open: ""
                            }, e)), Object.create(null)),
                            compareKeys: e && "function" === typeof e.compareKeys ? e.compareKeys : O.compareKeys,
                            escapeRegex: D(e),
                            escapeString: N(e),
                            indent: e && e.min ? "" : (n = e && void 0 !== e.indent ? e.indent : O.indent, new Array(n + 1).join(" ")),
                            maxDepth: e && void 0 !== e.maxDepth ? e.maxDepth : O.maxDepth,
                            min: e && void 0 !== e.min ? e.min : O.min,
                            plugins: e && void 0 !== e.plugins ? e.plugins : O.plugins,
                            printBasicPrototype: null === (t = null === e || void 0 === e ? void 0 : e.printBasicPrototype) || void 0 === t || t,
                            printFunctionName: L(e),
                            spacingInner: e && e.min ? " " : "\n",
                            spacingOuter: e && e.min ? "" : "\n"
                        }
                    };

                function F(e, t) {
                    if (t && (function(e) {
                            if (Object.keys(e).forEach((e => {
                                    if (!O.hasOwnProperty(e)) throw new Error('pretty-format: Unknown option "'.concat(e, '".'))
                                })), e.min && void 0 !== e.indent && 0 !== e.indent) throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
                            if (void 0 !== e.theme) {
                                if (null === e.theme) throw new Error('pretty-format: Option "theme" must not be null.');
                                if ("object" !== typeof e.theme) throw new Error('pretty-format: Option "theme" must be of type "object" but instead received "'.concat(typeof e.theme, '".'))
                            }
                        }(t), t.plugins)) {
                        const n = T(t.plugins, e);
                        if (null !== n) return C(n, e, k(t), "", 0, [])
                    }
                    const n = S(e, L(t), D(t), N(t));
                    return null !== n ? n : E(e, k(t), "", 0, [])
                }
                const U = {
                    AsymmetricMatcher: o.default,
                    ConvertAnsi: a.default,
                    DOMCollection: s.default,
                    DOMElement: l.default,
                    Immutable: c.default,
                    ReactElement: u.default,
                    ReactTestComponent: d.default
                };
                t.plugins = U;
                var z = F;
                t.default = z
            },
            4200: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.test = t.serialize = t.default = void 0;
                var r = n(1392),
                    i = "undefined" !== typeof globalThis ? globalThis : "undefined" !== typeof i ? i : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : Function("return this")(),
                    o = i["jest-symbol-do-not-touch"] || i.Symbol;
                const a = "function" === typeof o && o.for ? o.for("jest.asymmetricMatcher") : 1267621,
                    s = " ",
                    l = (e, t, n, i, o, a) => {
                        const l = e.toString();
                        return "ArrayContaining" === l || "ArrayNotContaining" === l ? ++i > t.maxDepth ? "[" + l + "]" : l + s + "[" + (0, r.printListItems)(e.sample, t, n, i, o, a) + "]" : "ObjectContaining" === l || "ObjectNotContaining" === l ? ++i > t.maxDepth ? "[" + l + "]" : l + s + "{" + (0, r.printObjectProperties)(e.sample, t, n, i, o, a) + "}" : "StringMatching" === l || "StringNotMatching" === l || "StringContaining" === l || "StringNotContaining" === l ? l + s + a(e.sample, t, n, i, o) : e.toAsymmetricMatcher()
                    };
                t.serialize = l;
                const c = e => e && e.$$typeof === a;
                t.test = c;
                var u = {
                    serialize: l,
                    test: c
                };
                t.default = u
            },
            4336: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.test = t.serialize = t.default = void 0;
                var r = o(n(3368)),
                    i = o(n(7840));

                function o(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                const a = e => "string" === typeof e && !!e.match((0, r.default)());
                t.test = a;
                const s = (e, t, n, o, a, s) => s(e.replace((0, r.default)(), (e => {
                    switch (e) {
                        case i.default.red.close:
                        case i.default.green.close:
                        case i.default.cyan.close:
                        case i.default.gray.close:
                        case i.default.white.close:
                        case i.default.yellow.close:
                        case i.default.bgRed.close:
                        case i.default.bgGreen.close:
                        case i.default.bgYellow.close:
                        case i.default.inverse.close:
                        case i.default.dim.close:
                        case i.default.bold.close:
                        case i.default.reset.open:
                        case i.default.reset.close:
                            return "</>";
                        case i.default.red.open:
                            return "<red>";
                        case i.default.green.open:
                            return "<green>";
                        case i.default.cyan.open:
                            return "<cyan>";
                        case i.default.gray.open:
                            return "<gray>";
                        case i.default.white.open:
                            return "<white>";
                        case i.default.yellow.open:
                            return "<yellow>";
                        case i.default.bgRed.open:
                            return "<bgRed>";
                        case i.default.bgGreen.open:
                            return "<bgGreen>";
                        case i.default.bgYellow.open:
                            return "<bgYellow>";
                        case i.default.inverse.open:
                            return "<inverse>";
                        case i.default.dim.open:
                            return "<dim>";
                        case i.default.bold.open:
                            return "<bold>";
                        default:
                            return ""
                    }
                })), t, n, o, a);
                t.serialize = s;
                var l = {
                    serialize: s,
                    test: a
                };
                t.default = l
            },
            408: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.test = t.serialize = t.default = void 0;
                var r = n(1392);
                const i = ["DOMStringMap", "NamedNodeMap"],
                    o = /^(HTML\w*Collection|NodeList)$/,
                    a = e => {
                        return e && e.constructor && !!e.constructor.name && (t = e.constructor.name, -1 !== i.indexOf(t) || o.test(t));
                        var t
                    };
                t.test = a;
                const s = (e, t, n, o, a, s) => {
                    const l = e.constructor.name;
                    return ++o > t.maxDepth ? "[" + l + "]" : (t.min ? "" : l + " ") + (-1 !== i.indexOf(l) ? "{" + (0, r.printObjectProperties)((e => "NamedNodeMap" === e.constructor.name)(e) ? Array.from(e).reduce(((e, t) => (e[t.name] = t.value, e)), {}) : { ...e
                    }, t, n, o, a, s) + "}" : "[" + (0, r.printListItems)(Array.from(e), t, n, o, a, s) + "]")
                };
                t.serialize = s;
                var l = {
                    serialize: s,
                    test: a
                };
                t.default = l
            },
            2608: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.test = t.serialize = t.default = void 0;
                var r = n(9224);
                const i = /^((HTML|SVG)\w*)?Element$/,
                    o = e => {
                        var t;
                        return (null === e || void 0 === e || null === (t = e.constructor) || void 0 === t ? void 0 : t.name) && (e => {
                            const t = e.constructor.name,
                                {
                                    nodeType: n,
                                    tagName: r
                                } = e,
                                o = "string" === typeof r && r.includes("-") || (e => {
                                    try {
                                        return "function" === typeof e.hasAttribute && e.hasAttribute("is")
                                    } catch {
                                        return !1
                                    }
                                })(e);
                            return 1 === n && (i.test(t) || o) || 3 === n && "Text" === t || 8 === n && "Comment" === t || 11 === n && "DocumentFragment" === t
                        })(e)
                    };

                function a(e) {
                    return 11 === e.nodeType
                }
                t.test = o;
                const s = (e, t, n, i, o, s) => {
                    if (function(e) {
                            return 3 === e.nodeType
                        }(e)) return (0, r.printText)(e.data, t);
                    if (function(e) {
                            return 8 === e.nodeType
                        }(e)) return (0, r.printComment)(e.data, t);
                    const l = a(e) ? "DocumentFragment" : e.tagName.toLowerCase();
                    return ++i > t.maxDepth ? (0, r.printElementAsLeaf)(l, t) : (0, r.printElement)(l, (0, r.printProps)(a(e) ? [] : Array.from(e.attributes).map((e => e.name)).sort(), a(e) ? {} : Array.from(e.attributes).reduce(((e, t) => (e[t.name] = t.value, e)), {}), t, n + t.indent, i, o, s), (0, r.printChildren)(Array.prototype.slice.call(e.childNodes || e.children), t, n + t.indent, i, o, s), t, n)
                };
                t.serialize = s;
                var l = {
                    serialize: s,
                    test: o
                };
                t.default = l
            },
            156: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.test = t.serialize = t.default = void 0;
                var r = n(1392);
                const i = "@@__IMMUTABLE_ORDERED__@@",
                    o = e => "Immutable." + e,
                    a = e => "[" + e + "]",
                    s = " ";
                const l = (e, t, n, i, l, c, u) => ++i > t.maxDepth ? a(o(u)) : o(u) + s + "[" + (0, r.printIteratorValues)(e.values(), t, n, i, l, c) + "]",
                    c = (e, t, n, c, u, d) => e["@@__IMMUTABLE_MAP__@@"] ? ((e, t, n, i, l, c, u) => ++i > t.maxDepth ? a(o(u)) : o(u) + s + "{" + (0, r.printIteratorEntries)(e.entries(), t, n, i, l, c) + "}")(e, t, n, c, u, d, e[i] ? "OrderedMap" : "Map") : e["@@__IMMUTABLE_LIST__@@"] ? l(e, t, n, c, u, d, "List") : e["@@__IMMUTABLE_SET__@@"] ? l(e, t, n, c, u, d, e[i] ? "OrderedSet" : "Set") : e["@@__IMMUTABLE_STACK__@@"] ? l(e, t, n, c, u, d, "Stack") : e["@@__IMMUTABLE_SEQ__@@"] ? ((e, t, n, i, l, c) => {
                        const u = o("Seq");
                        return ++i > t.maxDepth ? a(u) : e["@@__IMMUTABLE_KEYED__@@"] ? u + s + "{" + (e._iter || e._object ? (0, r.printIteratorEntries)(e.entries(), t, n, i, l, c) : "\u2026") + "}" : u + s + "[" + (e._iter || e._array || e._collection || e._iterable ? (0, r.printIteratorValues)(e.values(), t, n, i, l, c) : "\u2026") + "]"
                    })(e, t, n, c, u, d) : ((e, t, n, i, l, c) => {
                        const u = o(e._name || "Record");
                        return ++i > t.maxDepth ? a(u) : u + s + "{" + (0, r.printIteratorEntries)(function(e) {
                            let t = 0;
                            return {
                                next() {
                                    if (t < e._keys.length) {
                                        const n = e._keys[t++];
                                        return {
                                            done: !1,
                                            value: [n, e.get(n)]
                                        }
                                    }
                                    return {
                                        done: !0,
                                        value: void 0
                                    }
                                }
                            }
                        }(e), t, n, i, l, c) + "}"
                    })(e, t, n, c, u, d);
                t.serialize = c;
                const u = e => e && (!0 === e["@@__IMMUTABLE_ITERABLE__@@"] || !0 === e["@@__IMMUTABLE_RECORD__@@"]);
                t.test = u;
                var d = {
                    serialize: c,
                    test: u
                };
                t.default = d
            },
            5020: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.test = t.serialize = t.default = void 0;
                var r = function(e, t) {
                        if (!t && e && e.__esModule) return e;
                        if (null === e || "object" !== typeof e && "function" !== typeof e) return {
                            default: e
                        };
                        var n = o(t);
                        if (n && n.has(e)) return n.get(e);
                        var r = {},
                            i = Object.defineProperty && Object.getOwnPropertyDescriptor;
                        for (var a in e)
                            if ("default" !== a && Object.prototype.hasOwnProperty.call(e, a)) {
                                var s = i ? Object.getOwnPropertyDescriptor(e, a) : null;
                                s && (s.get || s.set) ? Object.defineProperty(r, a, s) : r[a] = e[a]
                            }
                        r.default = e, n && n.set(e, r);
                        return r
                    }(n(2636)),
                    i = n(9224);

                function o(e) {
                    if ("function" !== typeof WeakMap) return null;
                    var t = new WeakMap,
                        n = new WeakMap;
                    return (o = function(e) {
                        return e ? n : t
                    })(e)
                }
                const a = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                        return Array.isArray(e) ? e.forEach((e => {
                            a(e, t)
                        })) : null != e && !1 !== e && t.push(e), t
                    },
                    s = e => {
                        const t = e.type;
                        if ("string" === typeof t) return t;
                        if ("function" === typeof t) return t.displayName || t.name || "Unknown";
                        if (r.isFragment(e)) return "React.Fragment";
                        if (r.isSuspense(e)) return "React.Suspense";
                        if ("object" === typeof t && null !== t) {
                            if (r.isContextProvider(e)) return "Context.Provider";
                            if (r.isContextConsumer(e)) return "Context.Consumer";
                            if (r.isForwardRef(e)) {
                                if (t.displayName) return t.displayName;
                                const e = t.render.displayName || t.render.name || "";
                                return "" !== e ? "ForwardRef(" + e + ")" : "ForwardRef"
                            }
                            if (r.isMemo(e)) {
                                const e = t.displayName || t.type.displayName || t.type.name || "";
                                return "" !== e ? "Memo(" + e + ")" : "Memo"
                            }
                        }
                        return "UNDEFINED"
                    },
                    l = (e, t, n, r, o, l) => ++r > t.maxDepth ? (0, i.printElementAsLeaf)(s(e), t) : (0, i.printElement)(s(e), (0, i.printProps)((e => {
                        const {
                            props: t
                        } = e;
                        return Object.keys(t).filter((e => "children" !== e && void 0 !== t[e])).sort()
                    })(e), e.props, t, n + t.indent, r, o, l), (0, i.printChildren)(a(e.props.children), t, n + t.indent, r, o, l), t, n);
                t.serialize = l;
                const c = e => null != e && r.isElement(e);
                t.test = c;
                var u = {
                    serialize: l,
                    test: c
                };
                t.default = u
            },
            8676: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.test = t.serialize = t.default = void 0;
                var r = n(9224),
                    i = "undefined" !== typeof globalThis ? globalThis : "undefined" !== typeof i ? i : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : Function("return this")(),
                    o = i["jest-symbol-do-not-touch"] || i.Symbol;
                const a = "function" === typeof o && o.for ? o.for("react.test.json") : 245830487,
                    s = (e, t, n, i, o, a) => ++i > t.maxDepth ? (0, r.printElementAsLeaf)(e.type, t) : (0, r.printElement)(e.type, e.props ? (0, r.printProps)((e => {
                        const {
                            props: t
                        } = e;
                        return t ? Object.keys(t).filter((e => void 0 !== t[e])).sort() : []
                    })(e), e.props, t, n + t.indent, i, o, a) : "", e.children ? (0, r.printChildren)(e.children, t, n + t.indent, i, o, a) : "", t, n);
                t.serialize = s;
                const l = e => e && e.$$typeof === a;
                t.test = l;
                var c = {
                    serialize: s,
                    test: l
                };
                t.default = c
            },
            4096: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e) {
                    return e.replace(/</g, "&lt;").replace(/>/g, "&gt;")
                }
            },
            9224: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.printText = t.printProps = t.printElementAsLeaf = t.printElement = t.printComment = t.printChildren = void 0;
                var r, i = (r = n(4096)) && r.__esModule ? r : {
                    default: r
                };
                t.printProps = (e, t, n, r, i, o, a) => {
                    const s = r + n.indent,
                        l = n.colors;
                    return e.map((e => {
                        const c = t[e];
                        let u = a(c, n, s, i, o);
                        return "string" !== typeof c && (-1 !== u.indexOf("\n") && (u = n.spacingOuter + s + u + n.spacingOuter + r), u = "{" + u + "}"), n.spacingInner + r + l.prop.open + e + l.prop.close + "=" + l.value.open + u + l.value.close
                    })).join("")
                };
                t.printChildren = (e, t, n, r, i, a) => e.map((e => t.spacingOuter + n + ("string" === typeof e ? o(e, t) : a(e, t, n, r, i)))).join("");
                const o = (e, t) => {
                    const n = t.colors.content;
                    return n.open + (0, i.default)(e) + n.close
                };
                t.printText = o;
                t.printComment = (e, t) => {
                    const n = t.colors.comment;
                    return n.open + "\x3c!--" + (0, i.default)(e) + "--\x3e" + n.close
                };
                t.printElement = (e, t, n, r, i) => {
                    const o = r.colors.tag;
                    return o.open + "<" + e + (t && o.close + t + r.spacingOuter + i + o.open) + (n ? ">" + o.close + n + r.spacingOuter + i + o.open + "</" + e : (t && !r.min ? "" : " ") + "/") + ">" + o.close
                };
                t.printElementAsLeaf = (e, t) => {
                    const n = t.colors.tag;
                    return n.open + "<" + e + n.close + " \u2026" + n.open + " />" + n.close
                }
            },
            7840: (e, t, n) => {
                "use strict";
                e = n.nmd(e);
                const r = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                        return t => "\x1b[".concat(38 + e, ";5;").concat(t, "m")
                    },
                    i = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                        return (t, n, r) => "\x1b[".concat(38 + e, ";2;").concat(t, ";").concat(n, ";").concat(r, "m")
                    };
                Object.defineProperty(e, "exports", {
                    enumerable: !0,
                    get: function() {
                        const e = new Map,
                            t = {
                                modifier: {
                                    reset: [0, 0],
                                    bold: [1, 22],
                                    dim: [2, 22],
                                    italic: [3, 23],
                                    underline: [4, 24],
                                    overline: [53, 55],
                                    inverse: [7, 27],
                                    hidden: [8, 28],
                                    strikethrough: [9, 29]
                                },
                                color: {
                                    black: [30, 39],
                                    red: [31, 39],
                                    green: [32, 39],
                                    yellow: [33, 39],
                                    blue: [34, 39],
                                    magenta: [35, 39],
                                    cyan: [36, 39],
                                    white: [37, 39],
                                    blackBright: [90, 39],
                                    redBright: [91, 39],
                                    greenBright: [92, 39],
                                    yellowBright: [93, 39],
                                    blueBright: [94, 39],
                                    magentaBright: [95, 39],
                                    cyanBright: [96, 39],
                                    whiteBright: [97, 39]
                                },
                                bgColor: {
                                    bgBlack: [40, 49],
                                    bgRed: [41, 49],
                                    bgGreen: [42, 49],
                                    bgYellow: [43, 49],
                                    bgBlue: [44, 49],
                                    bgMagenta: [45, 49],
                                    bgCyan: [46, 49],
                                    bgWhite: [47, 49],
                                    bgBlackBright: [100, 49],
                                    bgRedBright: [101, 49],
                                    bgGreenBright: [102, 49],
                                    bgYellowBright: [103, 49],
                                    bgBlueBright: [104, 49],
                                    bgMagentaBright: [105, 49],
                                    bgCyanBright: [106, 49],
                                    bgWhiteBright: [107, 49]
                                }
                            };
                        t.color.gray = t.color.blackBright, t.bgColor.bgGray = t.bgColor.bgBlackBright, t.color.grey = t.color.blackBright, t.bgColor.bgGrey = t.bgColor.bgBlackBright;
                        for (const [n, r] of Object.entries(t)) {
                            for (const [n, i] of Object.entries(r)) t[n] = {
                                open: "\x1b[".concat(i[0], "m"),
                                close: "\x1b[".concat(i[1], "m")
                            }, r[n] = t[n], e.set(i[0], i[1]);
                            Object.defineProperty(t, n, {
                                value: r,
                                enumerable: !1
                            })
                        }
                        return Object.defineProperty(t, "codes", {
                            value: e,
                            enumerable: !1
                        }), t.color.close = "\x1b[39m", t.bgColor.close = "\x1b[49m", t.color.ansi256 = r(), t.color.ansi16m = i(), t.bgColor.ansi256 = r(10), t.bgColor.ansi16m = i(10), Object.defineProperties(t, {
                            rgbToAnsi256: {
                                value: (e, t, n) => e === t && t === n ? e < 8 ? 16 : e > 248 ? 231 : Math.round((e - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(e / 255 * 5) + 6 * Math.round(t / 255 * 5) + Math.round(n / 255 * 5),
                                enumerable: !1
                            },
                            hexToRgb: {
                                value: e => {
                                    const t = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(e.toString(16));
                                    if (!t) return [0, 0, 0];
                                    let {
                                        colorString: n
                                    } = t.groups;
                                    3 === n.length && (n = n.split("").map((e => e + e)).join(""));
                                    const r = Number.parseInt(n, 16);
                                    return [r >> 16 & 255, r >> 8 & 255, 255 & r]
                                },
                                enumerable: !1
                            },
                            hexToAnsi256: {
                                value: e => t.rgbToAnsi256(...t.hexToRgb(e)),
                                enumerable: !1
                            }
                        }), t
                    }
                })
            },
            7712: (e, t) => {
                "use strict";
                var n = 60103,
                    r = 60106,
                    i = 60107,
                    o = 60108,
                    a = 60114,
                    s = 60109,
                    l = 60110,
                    c = 60112,
                    u = 60113,
                    d = 60120,
                    h = 60115,
                    p = 60116,
                    f = 60121,
                    m = 60122,
                    g = 60117,
                    v = 60129,
                    y = 60131;
                if ("function" === typeof Symbol && Symbol.for) {
                    var b = Symbol.for;
                    n = b("react.element"), r = b("react.portal"), i = b("react.fragment"), o = b("react.strict_mode"), a = b("react.profiler"), s = b("react.provider"), l = b("react.context"), c = b("react.forward_ref"), u = b("react.suspense"), d = b("react.suspense_list"), h = b("react.memo"), p = b("react.lazy"), f = b("react.block"), m = b("react.server.block"), g = b("react.fundamental"), v = b("react.debug_trace_mode"), y = b("react.legacy_hidden")
                }

                function x(e) {
                    if ("object" === typeof e && null !== e) {
                        var t = e.$$typeof;
                        switch (t) {
                            case n:
                                switch (e = e.type) {
                                    case i:
                                    case a:
                                    case o:
                                    case u:
                                    case d:
                                        return e;
                                    default:
                                        switch (e = e && e.$$typeof) {
                                            case l:
                                            case c:
                                            case p:
                                            case h:
                                            case s:
                                                return e;
                                            default:
                                                return t
                                        }
                                }
                            case r:
                                return t
                        }
                    }
                }
                var _ = s,
                    M = n,
                    w = c,
                    A = i,
                    S = p,
                    E = h,
                    C = r,
                    T = a,
                    P = o,
                    R = u;
                t.ContextConsumer = l, t.ContextProvider = _, t.Element = M, t.ForwardRef = w, t.Fragment = A, t.Lazy = S, t.Memo = E, t.Portal = C, t.Profiler = T, t.StrictMode = P, t.Suspense = R, t.isAsyncMode = function() {
                    return !1
                }, t.isConcurrentMode = function() {
                    return !1
                }, t.isContextConsumer = function(e) {
                    return x(e) === l
                }, t.isContextProvider = function(e) {
                    return x(e) === s
                }, t.isElement = function(e) {
                    return "object" === typeof e && null !== e && e.$$typeof === n
                }, t.isForwardRef = function(e) {
                    return x(e) === c
                }, t.isFragment = function(e) {
                    return x(e) === i
                }, t.isLazy = function(e) {
                    return x(e) === p
                }, t.isMemo = function(e) {
                    return x(e) === h
                }, t.isPortal = function(e) {
                    return x(e) === r
                }, t.isProfiler = function(e) {
                    return x(e) === a
                }, t.isStrictMode = function(e) {
                    return x(e) === o
                }, t.isSuspense = function(e) {
                    return x(e) === u
                }, t.isValidElementType = function(e) {
                    return "string" === typeof e || "function" === typeof e || e === i || e === a || e === v || e === o || e === u || e === d || e === y || "object" === typeof e && null !== e && (e.$$typeof === p || e.$$typeof === h || e.$$typeof === s || e.$$typeof === l || e.$$typeof === c || e.$$typeof === g || e.$$typeof === f || e[0] === m)
                }, t.typeOf = x
            },
            2636: (e, t, n) => {
                "use strict";
                e.exports = n(7712)
            },
            7384: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.blur = function(e) {
                    if (!(0, r.isFocusable)(e)) return;
                    if ((0, r.getActiveElement)(e.ownerDocument) !== e) return;
                    (0, r.eventWrapper)((() => e.blur()))
                };
                var r = n(3104)
            },
            7128: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.clear = function(e) {
                    var t, n;
                    if (!(0, r.isElementType)(e, ["input", "textarea"])) throw new Error("clear currently only supports input and textarea elements.");
                    if ((0, r.isDisabled)(e)) return;
                    const o = e.type;
                    "textarea" !== o && (e.type = "text");
                    (0, i.type)(e, "{selectall}{del}", {
                        delay: 0,
                        initialSelectionStart: null != (t = e.selectionStart) ? t : void 0,
                        initialSelectionEnd: null != (n = e.selectionEnd) ? n : void 0
                    }), "textarea" !== o && (e.type = o)
                };
                var r = n(3104),
                    i = n(3812)
            },
            4340: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.click = c, t.dblClick = function(e, t) {
                    let {
                        skipPointerEventsCheck: n = !1
                    } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    if (!n && !(0, i.hasPointerEvents)(e)) throw new Error('unable to double-click element as it has or inherits pointer-events set to "none".');
                    (0, o.hover)(e, t, {
                        skipPointerEventsCheck: n
                    }), c(e, t, {
                        skipHover: !0,
                        clickCount: 0,
                        skipPointerEventsCheck: n
                    }), c(e, t, {
                        skipHover: !0,
                        clickCount: 1,
                        skipPointerEventsCheck: n
                    }), r.fireEvent.dblClick(e, (0, i.getMouseEventOptions)("dblclick", t, 2))
                };
                var r = n(6902),
                    i = n(3104),
                    o = n(3628),
                    a = n(7384),
                    s = n(9507);

                function l(e, t, n) {
                    let {
                        clickCount: o
                    } = n;
                    const l = function(e) {
                        const t = e.ownerDocument.activeElement;
                        return t && t !== e.ownerDocument.body && t !== e ? t : null
                    }(e);
                    if (r.fireEvent.pointerDown(e, t), !(0, i.isDisabled)(e)) {
                        if (r.fireEvent.mouseDown(e, (0, i.getMouseEventOptions)("mousedown", t, o))) {
                            const t = function(e, t) {
                                let n = e;
                                do {
                                    if (t(n)) return n;
                                    n = n.parentElement
                                } while (n && n !== e.ownerDocument.body);
                                return
                            }(e, i.isFocusable);
                            l && !t ? (0, a.blur)(l) : t && (0, s.focus)(t)
                        }
                    }
                    if (r.fireEvent.pointerUp(e, t), !(0, i.isDisabled)(e)) {
                        r.fireEvent.mouseUp(e, (0, i.getMouseEventOptions)("mouseup", t, o)), u(e, (0, i.getMouseEventOptions)("click", t, o));
                        const n = e.closest("label");
                        null != n && n.control && (0, s.focus)(n.control)
                    }
                }

                function c(e, t) {
                    let {
                        skipHover: n = !1,
                        clickCount: a = 0,
                        skipPointerEventsCheck: c = !1
                    } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    if (!c && !(0, i.hasPointerEvents)(e)) throw new Error('unable to click element as it has or inherits pointer-events set to "none".');
                    n || (0, o.hover)(e, t, {
                        skipPointerEventsCheck: !0
                    }), (0, i.isElementType)(e, "label") ? function(e, t, n) {
                        let {
                            clickCount: o
                        } = n;
                        (0, i.isLabelWithInternallyDisabledControl)(e) || (r.fireEvent.pointerDown(e, t), r.fireEvent.mouseDown(e, (0, i.getMouseEventOptions)("mousedown", t, o)), r.fireEvent.pointerUp(e, t), r.fireEvent.mouseUp(e, (0, i.getMouseEventOptions)("mouseup", t, o)), u(e, (0, i.getMouseEventOptions)("click", t, o)), e.control && (0, s.focus)(e.control))
                    }(e, t, {
                        clickCount: a
                    }) : !(0, i.isElementType)(e, "input") || "checkbox" !== e.type && "radio" !== e.type ? l(e, t, {
                        clickCount: a
                    }) : function(e, t, n) {
                        let {
                            clickCount: o
                        } = n;
                        r.fireEvent.pointerDown(e, t), e.disabled || r.fireEvent.mouseDown(e, (0, i.getMouseEventOptions)("mousedown", t, o)), (0, s.focus)(e), r.fireEvent.pointerUp(e, t), e.disabled || (r.fireEvent.mouseUp(e, (0, i.getMouseEventOptions)("mouseup", t, o)), u(e, (0, i.getMouseEventOptions)("click", t, o)))
                    }(e, t, {
                        clickCount: a
                    })
                }

                function u(e, t) {
                    2 === t.button ? r.fireEvent.contextMenu(e, t) : r.fireEvent.click(e, t)
                }
            },
            9507: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.focus = function(e) {
                    if (!(0, r.isFocusable)(e)) return;
                    if ((0, r.getActiveElement)(e.ownerDocument) === e) return;
                    (0, r.eventWrapper)((() => e.focus()))
                };
                var r = n(3104)
            },
            3628: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.hover = function(e, t) {
                    let {
                        skipPointerEventsCheck: n = !1
                    } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    if (!n && !(0, i.hasPointerEvents)(e)) throw new Error('unable to hover element as it has or inherits pointer-events set to "none".');
                    if ((0, i.isLabelWithInternallyDisabledControl)(e)) return;
                    const a = o(e).reverse();
                    r.fireEvent.pointerOver(e, t);
                    for (const i of a) r.fireEvent.pointerEnter(i, t);
                    if (!(0, i.isDisabled)(e)) {
                        r.fireEvent.mouseOver(e, (0, i.getMouseEventOptions)("mouseover", t));
                        for (const e of a) r.fireEvent.mouseEnter(e, (0, i.getMouseEventOptions)("mouseenter", t))
                    }
                    r.fireEvent.pointerMove(e, t), (0, i.isDisabled)(e) || r.fireEvent.mouseMove(e, (0, i.getMouseEventOptions)("mousemove", t))
                }, t.unhover = function(e, t) {
                    let {
                        skipPointerEventsCheck: n = !1
                    } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    if (!n && !(0, i.hasPointerEvents)(e)) throw new Error('unable to unhover element as it has or inherits pointer-events set to "none".');
                    if ((0, i.isLabelWithInternallyDisabledControl)(e)) return;
                    const a = o(e);
                    r.fireEvent.pointerMove(e, t), (0, i.isDisabled)(e) || r.fireEvent.mouseMove(e, (0, i.getMouseEventOptions)("mousemove", t));
                    r.fireEvent.pointerOut(e, t);
                    for (const i of a) r.fireEvent.pointerLeave(i, t);
                    if (!(0, i.isDisabled)(e)) {
                        r.fireEvent.mouseOut(e, (0, i.getMouseEventOptions)("mouseout", t));
                        for (const e of a) r.fireEvent.mouseLeave(e, (0, i.getMouseEventOptions)("mouseleave", t))
                    }
                };
                var r = n(6902),
                    i = n(3104);

                function o(e) {
                    const t = [e];
                    let n = e;
                    for (; null != (n = n.parentElement);) t.push(n);
                    return t
                }
            },
            7832: (e, t, n) => {
                "use strict";
                var r = n(4340),
                    i = n(3812),
                    o = n(7128),
                    a = n(5052),
                    s = n(3628),
                    l = n(1452),
                    c = n(7320),
                    u = n(2692),
                    d = n(6792);
                r.click, r.dblClick, i.type, o.clear, a.tab, s.hover, s.unhover, l.upload, c.selectOptions, c.deselectOptions, u.paste, d.keyboard
            },
            3640: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getKeyEventProps = function(e, t) {
                    var n, r;
                    return {
                        key: e.key,
                        code: e.code,
                        altKey: t.modifiers.alt,
                        ctrlKey: t.modifiers.ctrl,
                        metaKey: t.modifiers.meta,
                        shiftKey: t.modifiers.shift,
                        keyCode: null != (n = e.keyCode) ? n : 1 === (null == (r = e.key) ? void 0 : r.length) ? e.key.charCodeAt(0) : void 0
                    }
                }, t.getMouseEventProps = function(e) {
                    return {
                        altKey: e.modifiers.alt,
                        ctrlKey: e.modifiers.ctrl,
                        metaKey: e.modifiers.meta,
                        shiftKey: e.modifiers.shift
                    }
                }
            },
            4453: (e, t) => {
                "use strict";
                var n, r, i;

                function o(e, t) {
                    const n = e[t];
                    return s(n, e, t), {
                        consumedLength: t += n.length,
                        descriptor: n,
                        releasePrevious: !1,
                        releaseSelf: !0,
                        repeat: 1
                    }
                }

                function a(e, t, r) {
                    var i, o, a;
                    const l = "/" === e[t] ? "/" : "";
                    t += l.length;
                    const d = null == (i = e.slice(t).match(/^\w+/)) ? void 0 : i[0];
                    s(d, e, t), t += d.length;
                    const h = null != (o = null == (a = e.slice(t).match(/^>\d+/)) ? void 0 : a[0]) ? o : "",
                        p = "/" === e[t += h.length] || !h && ">" === e[t] ? e[t] : "";
                    t += p.length;
                    const f = n[r],
                        m = e[t] === f ? f : "";
                    if (!m) throw new Error(u([!h && "repeat modifier", !p && "release modifier", '"'.concat(f, '"')].filter(Boolean).join(" or "), e[t], e));
                    return {
                        consumedLength: t += m.length,
                        descriptor: d,
                        releasePrevious: !!l,
                        repeat: h ? Math.max(Number(h.substr(1)), 1) : 1,
                        releaseSelf: c(r, d, p, h)
                    }
                }

                function s(e, t, n) {
                    if (!e) throw new Error(u("key descriptor", t[n], t))
                }

                function l(e, t) {
                    return e[t]
                }

                function c(e, t, n, i) {
                    return n ? "/" === n : !i && ("{" !== e || !l(r, t.toLowerCase()))
                }

                function u(e, t, n) {
                    return "Expected ".concat(e, ' but found "').concat(null != t ? t : "", '" in "').concat(n, '"\n    See https://github.com/testing-library/user-event/blob/main/README.md#keyboardtext-options\n    for more information about how userEvent parses your input.')
                }
                Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.getNextKeyDef = function(e, t) {
                        var r;
                        const {
                            type: s,
                            descriptor: c,
                            consumedLength: u,
                            releasePrevious: d,
                            releaseSelf: h,
                            repeat: p
                        } = function(e) {
                            let t = 0;
                            const r = e[t] in n ? e[t] : "";
                            t += r.length;
                            const i = r ? e.match(new RegExp("^\\".concat(r, "+")))[0].length : 0,
                                s = 2 === i || "{" === r && i > 3 ? "" : r;
                            return {
                                type: s,
                                ..."" === s ? o(e, t) : a(e, t, s)
                            }
                        }(e);
                        return {
                            keyDef: null != (r = t.keyboardMap.find((e => {
                                var t;
                                if ("[" === s) return (null == (t = e.code) ? void 0 : t.toLowerCase()) === c.toLowerCase();
                                if ("{" === s) {
                                    var n;
                                    const t = function(e) {
                                        var t;
                                        return null != (t = l(i, e)) ? t : e
                                    }(c);
                                    return (null == (n = e.key) ? void 0 : n.toLowerCase()) === t.toLowerCase()
                                }
                                return e.key === c
                            }))) ? r : {
                                key: "Unknown",
                                code: "Unknown",
                                ["[" === s ? "code" : "key"]: c
                            },
                            consumedLength: u,
                            releasePrevious: d,
                            releaseSelf: h,
                            repeat: p
                        }
                    },
                    function(e) {
                        e["{"] = "}", e["["] = "]"
                    }(n || (n = {})),
                    function(e) {
                        e.alt = "alt", e.ctrl = "ctrl", e.meta = "meta", e.shift = "shift"
                    }(r || (r = {})),
                    function(e) {
                        e.ctrl = "Control", e.del = "Delete", e.esc = "Escape", e.space = " "
                    }(i || (i = {}))
            },
            6792: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.keyboard = function(e, t) {
                    var n;
                    const {
                        promise: i,
                        state: o
                    } = s(e, t);
                    return (null != (n = null == t ? void 0 : t.delay) ? n : 0) > 0 ? (0, r.getConfig)().asyncWrapper((() => i.then((() => o)))) : (i.catch(console.error), o)
                }, t.keyboardImplementationWrapper = s, Object.defineProperty(t, "specialCharMap", {
                    enumerable: !0,
                    get: function() {
                        return a.specialCharMap
                    }
                });
                var r = n(6902),
                    i = n(152),
                    o = n(6240),
                    a = n(6100);

                function s(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    const {
                        keyboardState: n = l(),
                        delay: r = 0,
                        document: a = document,
                        autoModify: s = !1,
                        keyboardMap: c = o.defaultKeyMap
                    } = t, u = {
                        delay: r,
                        document: a,
                        autoModify: s,
                        keyboardMap: c
                    };
                    return {
                        promise: (0, i.keyboardImplementation)(e, u, n),
                        state: n,
                        releaseAllKeys: () => (0, i.releaseAllKeys)(u, n)
                    }
                }

                function l() {
                    return {
                        activeElement: null,
                        pressed: [],
                        carryChar: "",
                        modifiers: {
                            alt: !1,
                            caps: !1,
                            ctrl: !1,
                            meta: !1,
                            shift: !1
                        }
                    }
                }
            },
            6240: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.defaultKeyMap = void 0;
                var r = n(7343);
                const i = [..."0123456789".split("").map((e => ({
                    code: "Digit".concat(e),
                    key: e
                }))), ...")!@#$%^&*(".split("").map(((e, t) => ({
                    code: "Digit".concat(t),
                    key: e,
                    shiftKey: !0
                }))), ..."abcdefghijklmnopqrstuvwxyz".split("").map((e => ({
                    code: "Key".concat(e.toUpperCase()),
                    key: e
                }))), ..."ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("").map((e => ({
                    code: "Key".concat(e),
                    key: e,
                    shiftKey: !0
                }))), {
                    code: "Space",
                    key: " "
                }, {
                    code: "AltLeft",
                    key: "Alt",
                    location: r.DOM_KEY_LOCATION.LEFT,
                    keyCode: 18
                }, {
                    code: "AltRight",
                    key: "Alt",
                    location: r.DOM_KEY_LOCATION.RIGHT,
                    keyCode: 18
                }, {
                    code: "ShiftLeft",
                    key: "Shift",
                    location: r.DOM_KEY_LOCATION.LEFT,
                    keyCode: 16
                }, {
                    code: "ShiftRight",
                    key: "Shift",
                    location: r.DOM_KEY_LOCATION.RIGHT,
                    keyCode: 16
                }, {
                    code: "ControlLeft",
                    key: "Control",
                    location: r.DOM_KEY_LOCATION.LEFT,
                    keyCode: 17
                }, {
                    code: "ControlRight",
                    key: "Control",
                    location: r.DOM_KEY_LOCATION.RIGHT,
                    keyCode: 17
                }, {
                    code: "MetaLeft",
                    key: "Meta",
                    location: r.DOM_KEY_LOCATION.LEFT,
                    keyCode: 93
                }, {
                    code: "MetaRight",
                    key: "Meta",
                    location: r.DOM_KEY_LOCATION.RIGHT,
                    keyCode: 93
                }, {
                    code: "OSLeft",
                    key: "OS",
                    location: r.DOM_KEY_LOCATION.LEFT,
                    keyCode: 91
                }, {
                    code: "OSRight",
                    key: "OS",
                    location: r.DOM_KEY_LOCATION.RIGHT,
                    keyCode: 91
                }, {
                    code: "CapsLock",
                    key: "CapsLock",
                    keyCode: 20
                }, {
                    code: "Backspace",
                    key: "Backspace",
                    keyCode: 8
                }, {
                    code: "Enter",
                    key: "Enter",
                    keyCode: 13
                }, {
                    code: "Escape",
                    key: "Escape",
                    keyCode: 27
                }, {
                    code: "ArrowUp",
                    key: "ArrowUp",
                    keyCode: 38
                }, {
                    code: "ArrowDown",
                    key: "ArrowDown",
                    keyCode: 40
                }, {
                    code: "ArrowLeft",
                    key: "ArrowLeft",
                    keyCode: 37
                }, {
                    code: "ArrowRight",
                    key: "ArrowRight",
                    keyCode: 39
                }, {
                    code: "Home",
                    key: "Home",
                    keyCode: 36
                }, {
                    code: "End",
                    key: "End",
                    keyCode: 35
                }, {
                    code: "Delete",
                    key: "Delete",
                    keyCode: 46
                }, {
                    code: "PageUp",
                    key: "PageUp",
                    keyCode: 33
                }, {
                    code: "PageDown",
                    key: "PageDown",
                    keyCode: 34
                }];
                t.defaultKeyMap = i
            },
            152: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.keyboardImplementation = async function e(t, n, l) {
                    var h;
                    const {
                        document: p
                    } = n, f = () => c(p), {
                        keyDef: m,
                        consumedLength: g,
                        releasePrevious: v,
                        releaseSelf: y,
                        repeat: b
                    } = null != (h = l.repeatKey) ? h : (0, o.getNextKeyDef)(t, n);
                    if (!d(a.replaceBehavior, m, f(), n, l)) {
                        const e = l.pressed.find((e => e.keyDef === m));
                        if (e && !l.repeatKey && u(m, f, n, l, e.unpreventedDefault), !v) {
                            const e = function(e, t, n, i) {
                                const o = t();
                                o !== i.activeElement && (i.carryValue = void 0, i.carryChar = "");
                                i.activeElement = o, d(a.preKeydownBehavior, e, o, n, i);
                                const l = r.fireEvent.keyDown(o, (0, s.getKeyEventProps)(e, i));
                                i.pressed.push({
                                    keyDef: e,
                                    unpreventedDefault: l
                                }), l && d(a.keydownBehavior, e, t(), n, i);
                                return l
                            }(m, f, n, l);
                            e && function(e, t) {
                                var n;
                                return (1 === (null == (n = e.key) ? void 0 : n.length) || "Enter" === e.key) && !t.modifiers.ctrl && !t.modifiers.alt
                            }(m, l) && function(e, t, n, i) {
                                const o = t(),
                                    l = r.fireEvent.keyPress(o, (0, s.getKeyEventProps)(e, i));
                                l && d(a.keypressBehavior, e, t(), n, i)
                            }(m, f, n, l), y && b <= 1 && u(m, f, n, l, e)
                        }
                    }
                    b > 1 ? l.repeatKey = {
                        consumedLength: 0,
                        keyDef: m,
                        releasePrevious: v,
                        releaseSelf: y,
                        repeat: b - 1
                    } : delete l.repeatKey;
                    if (t.length > g || b > 1) return n.delay > 0 && await (0, i.wait)(n.delay), e(t.slice(g), n, l);
                    return
                }, t.releaseAllKeys = function(e, t) {
                    const n = () => c(e.document);
                    for (const r of t.pressed) u(r.keyDef, n, e, t, r.unpreventedDefault)
                };
                var r = n(6902),
                    i = n(3104),
                    o = n(4453),
                    a = function(e, t) {
                        if (!t && e && e.__esModule) return e;
                        if (null === e || "object" !== typeof e && "function" !== typeof e) return {
                            default: e
                        };
                        var n = l(t);
                        if (n && n.has(e)) return n.get(e);
                        var r = {},
                            i = Object.defineProperty && Object.getOwnPropertyDescriptor;
                        for (var o in e)
                            if ("default" !== o && Object.prototype.hasOwnProperty.call(e, o)) {
                                var a = i ? Object.getOwnPropertyDescriptor(e, o) : null;
                                a && (a.get || a.set) ? Object.defineProperty(r, o, a) : r[o] = e[o]
                            }
                        r.default = e, n && n.set(e, r);
                        return r
                    }(n(6520)),
                    s = n(3640);

                function l(e) {
                    if ("function" !== typeof WeakMap) return null;
                    var t = new WeakMap,
                        n = new WeakMap;
                    return (l = function(e) {
                        return e ? n : t
                    })(e)
                }

                function c(e) {
                    var t;
                    return null != (t = (0, i.getActiveElement)(e)) ? t : e.body
                }

                function u(e, t, n, i, o) {
                    const l = t();
                    d(a.preKeyupBehavior, e, l, n, i);
                    const c = r.fireEvent.keyUp(l, (0, s.getKeyEventProps)(e, i));
                    o && c && d(a.keyupBehavior, e, t(), n, i), i.pressed = i.pressed.filter((t => t.keyDef !== e)), d(a.postKeyupBehavior, e, l, n, i)
                }

                function d(e, t, n, r, i) {
                    const o = e.find((e => e.matches(t, n, r, i)));
                    return o && o.handle(t, n, r, i), !!o
                }
            },
            92: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.keydownBehavior = void 0;
                var r = n(3104);
                const i = [{
                    matches: (e, t) => ("ArrowLeft" === e.key || "ArrowRight" === e.key) && (0, r.isElementType)(t, ["input", "textarea"]),
                    handle: (e, t) => {
                        var n;
                        const {
                            selectionStart: i,
                            selectionEnd: o
                        } = (0, r.getSelectionRange)(t), a = "ArrowLeft" === e.key ? -1 : 1, s = null != (n = i === o ? (null != i ? i : 0) + a : a < 0 ? i : o) ? n : 0;
                        (0, r.setSelectionRange)(t, s, s)
                    }
                }];
                t.keydownBehavior = i
            },
            7112: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.keypressBehavior = void 0;
                var r = n(6902),
                    i = n(2876),
                    o = n(3104);
                const a = [{
                    matches: (e, t) => {
                        var n;
                        return 1 === (null == (n = e.key) ? void 0 : n.length) && (0, o.isElementType)(t, "input", {
                            type: "time",
                            readOnly: !1
                        })
                    },
                    handle: (e, t, n, r) => {
                        var a;
                        let s = e.key;
                        const l = (null != (a = r.carryValue) ? a : "") + s,
                            c = (0, o.buildTimeValue)(l);
                        (0, o.isValidInputTimeValue)(t, c) && (s = c);
                        const {
                            newValue: u,
                            newSelectionStart: d
                        } = (0, o.calculateNewValue)(s, t), h = (0, o.getValue)(t);
                        h !== u && (0, i.fireInputEvent)(t, {
                            newValue: u,
                            newSelectionStart: d,
                            eventOverrides: {
                                data: e.key,
                                inputType: "insertText"
                            }
                        }), (0, i.fireChangeForInputTimeIfValid)(t, h, c), r.carryValue = l
                    }
                }, {
                    matches: (e, t) => {
                        var n;
                        return 1 === (null == (n = e.key) ? void 0 : n.length) && (0, o.isElementType)(t, "input", {
                            type: "date",
                            readOnly: !1
                        })
                    },
                    handle: (e, t, n, a) => {
                        var s;
                        let l = e.key;
                        const c = (null != (s = a.carryValue) ? s : "") + l,
                            u = (0, o.isValidDateValue)(t, c);
                        u && (l = c);
                        const {
                            newValue: d,
                            newSelectionStart: h
                        } = (0, o.calculateNewValue)(l, t);
                        (0, o.getValue)(t) !== d && (0, i.fireInputEvent)(t, {
                            newValue: d,
                            newSelectionStart: h,
                            eventOverrides: {
                                data: e.key,
                                inputType: "insertText"
                            }
                        }), u && r.fireEvent.change(t, {
                            target: {
                                value: c
                            }
                        }), a.carryValue = c
                    }
                }, {
                    matches: (e, t) => {
                        var n;
                        return 1 === (null == (n = e.key) ? void 0 : n.length) && (0, o.isElementType)(t, "input", {
                            type: "number",
                            readOnly: !1
                        })
                    },
                    handle: (e, t, n, r) => {
                        var a, s, l, c;
                        if (!/[\d.\-e]/.test(e.key)) return;
                        const u = null != (a = null != (s = r.carryValue) ? s : (0, o.getValue)(t)) ? a : "",
                            {
                                newValue: d,
                                newSelectionStart: h
                            } = (0, o.calculateNewValue)(e.key, t, u),
                            p = d.split("e", 2);
                        if (Number(null == (l = d.match(/-/g)) ? void 0 : l.length) > 2 || Number(null == (c = d.match(/\./g)) ? void 0 : c.length) > 1 || p[1] && !/^-?\d*$/.test(p[1])) return;
                        (0, i.fireInputEvent)(t, {
                            newValue: d,
                            newSelectionStart: h,
                            eventOverrides: {
                                data: e.key,
                                inputType: "insertText"
                            }
                        });
                        const f = (0, o.getValue)(t);
                        r.carryValue = f === d ? void 0 : d
                    }
                }, {
                    matches: (e, t) => {
                        var n;
                        return 1 === (null == (n = e.key) ? void 0 : n.length) && ((0, o.isElementType)(t, ["input", "textarea"], {
                            readOnly: !1
                        }) && !(0, o.isClickableInput)(t) || (0, o.isContentEditable)(t)) && 0 !== (0, o.getSpaceUntilMaxLength)(t)
                    },
                    handle: (e, t) => {
                        const {
                            newValue: n,
                            newSelectionStart: r
                        } = (0, o.calculateNewValue)(e.key, t);
                        (0, i.fireInputEvent)(t, {
                            newValue: n,
                            newSelectionStart: r,
                            eventOverrides: {
                                data: e.key,
                                inputType: "insertText"
                            }
                        })
                    }
                }, {
                    matches: (e, t) => "Enter" === e.key && ((0, o.isElementType)(t, "textarea", {
                        readOnly: !1
                    }) || (0, o.isContentEditable)(t)) && 0 !== (0, o.getSpaceUntilMaxLength)(t),
                    handle: (e, t, n, r) => {
                        const {
                            newValue: a,
                            newSelectionStart: s
                        } = (0, o.calculateNewValue)("\n", t), l = (0, o.isContentEditable)(t) && !r.modifiers.shift ? "insertParagraph" : "insertLineBreak";
                        (0, i.fireInputEvent)(t, {
                            newValue: a,
                            newSelectionStart: s,
                            eventOverrides: {
                                inputType: l
                            }
                        })
                    }
                }];
                t.keypressBehavior = a
            },
            3964: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.keydownBehavior = void 0;
                var r = n(3104),
                    i = n(2876);
                const o = [{
                    matches: (e, t) => ("Home" === e.key || "End" === e.key) && ((0, r.isElementType)(t, ["input", "textarea"]) || (0, r.isContentEditable)(t)),
                    handle: (e, t) => {
                        if ("Home" === e.key)(0, r.setSelectionRange)(t, 0, 0);
                        else {
                            var n, i;
                            const e = null != (n = null == (i = (0, r.getValue)(t)) ? void 0 : i.length) ? n : 0;
                            (0, r.setSelectionRange)(t, e, e)
                        }
                    }
                }, {
                    matches: (e, t) => ("PageUp" === e.key || "PageDown" === e.key) && (0, r.isElementType)(t, ["input"]),
                    handle: (e, t) => {
                        if ("PageUp" === e.key)(0, r.setSelectionRange)(t, 0, 0);
                        else {
                            var n, i;
                            const e = null != (n = null == (i = (0, r.getValue)(t)) ? void 0 : i.length) ? n : 0;
                            (0, r.setSelectionRange)(t, e, e)
                        }
                    }
                }, {
                    matches: (e, t) => "Delete" === e.key && (0, r.isEditable)(t) && !(0, r.isCursorAtEnd)(t),
                    handle: (e, t, n, o) => {
                        const {
                            newValue: a,
                            newSelectionStart: s
                        } = (0, r.calculateNewValue)("", t, o.carryValue, void 0, "forward");
                        (0, i.fireInputEvent)(t, {
                            newValue: a,
                            newSelectionStart: s,
                            eventOverrides: {
                                inputType: "deleteContentForward"
                            }
                        }), (0, i.carryValue)(t, o, a)
                    }
                }];
                t.keydownBehavior = o
            },
            2348: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.preKeyupBehavior = t.preKeydownBehavior = t.postKeyupBehavior = t.keyupBehavior = t.keypressBehavior = t.keydownBehavior = void 0;
                var r = n(6902),
                    i = n(3104),
                    o = n(3640),
                    a = n(2876);
                const s = {
                        Alt: "alt",
                        Control: "ctrl",
                        Shift: "shift",
                        Meta: "meta"
                    },
                    l = [...Object.entries(s).map((e => {
                        let [t, n] = e;
                        return {
                            matches: e => e.key === t,
                            handle: (e, t, r, i) => {
                                i.modifiers[n] = !0
                            }
                        }
                    })), {
                        matches: e => "AltGraph" === e.key,
                        handle: (e, t, n, i) => {
                            var a;
                            const s = null != (a = n.keyboardMap.find((e => "Control" === e.key))) ? a : {
                                key: "Control",
                                code: "Control"
                            };
                            r.fireEvent.keyDown(t, (0, o.getKeyEventProps)(s, i))
                        }
                    }];
                t.preKeydownBehavior = l;
                const c = [{
                    matches: e => "CapsLock" === e.key,
                    handle: (e, t, n, r) => {
                        r.modifiers.caps = !r.modifiers.caps
                    }
                }, {
                    matches: (e, t) => "Backspace" === e.key && (0, i.isEditable)(t) && !(0, i.isCursorAtStart)(t),
                    handle: (e, t, n, r) => {
                        const {
                            newValue: o,
                            newSelectionStart: s
                        } = (0, i.calculateNewValue)("", t, r.carryValue, void 0, "backward");
                        (0, a.fireInputEvent)(t, {
                            newValue: o,
                            newSelectionStart: s,
                            eventOverrides: {
                                inputType: "deleteContentBackward"
                            }
                        }), (0, a.carryValue)(t, r, o)
                    }
                }];
                t.keydownBehavior = c;
                const u = [{
                    matches: (e, t) => "Enter" === e.key && (0, i.isElementType)(t, "input") && ["checkbox", "radio"].includes(t.type),
                    handle: (e, t) => {
                        const n = t.form;
                        (0, i.hasFormSubmit)(n) && r.fireEvent.submit(n)
                    }
                }, {
                    matches: (e, t) => "Enter" === e.key && ((0, i.isClickableInput)(t) || (0, i.isElementType)(t, "a") && Boolean(t.href)),
                    handle: (e, t, n, i) => {
                        r.fireEvent.click(t, (0, o.getMouseEventProps)(i))
                    }
                }, {
                    matches: (e, t) => "Enter" === e.key && (0, i.isElementType)(t, "input"),
                    handle: (e, t) => {
                        const n = t.form;
                        n && (1 === n.querySelectorAll("input").length || (0, i.hasFormSubmit)(n)) && r.fireEvent.submit(n)
                    }
                }];
                t.keypressBehavior = u;
                const d = [...Object.entries(s).map((e => {
                    let [t, n] = e;
                    return {
                        matches: e => e.key === t,
                        handle: (e, t, r, i) => {
                            i.modifiers[n] = !1
                        }
                    }
                }))];
                t.preKeyupBehavior = d;
                const h = [{
                    matches: (e, t) => " " === e.key && (0, i.isClickableInput)(t),
                    handle: (e, t, n, i) => {
                        r.fireEvent.click(t, (0, o.getMouseEventProps)(i))
                    }
                }];
                t.keyupBehavior = h;
                const p = [{
                    matches: e => "AltGraph" === e.key,
                    handle: (e, t, n, i) => {
                        var a;
                        const s = null != (a = n.keyboardMap.find((e => "Control" === e.key))) ? a : {
                            key: "Control",
                            code: "Control"
                        };
                        r.fireEvent.keyUp(t, (0, o.getKeyEventProps)(s, i))
                    }
                }];
                t.postKeyupBehavior = p
            },
            6520: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.replaceBehavior = t.preKeyupBehavior = t.preKeydownBehavior = t.postKeyupBehavior = t.keyupBehavior = t.keypressBehavior = t.keydownBehavior = void 0;
                var r = n(3104),
                    i = c(n(92)),
                    o = c(n(3964)),
                    a = c(n(7112)),
                    s = c(n(2348));

                function l(e) {
                    if ("function" !== typeof WeakMap) return null;
                    var t = new WeakMap,
                        n = new WeakMap;
                    return (l = function(e) {
                        return e ? n : t
                    })(e)
                }

                function c(e, t) {
                    if (!t && e && e.__esModule) return e;
                    if (null === e || "object" !== typeof e && "function" !== typeof e) return {
                        default: e
                    };
                    var n = l(t);
                    if (n && n.has(e)) return n.get(e);
                    var r = {},
                        i = Object.defineProperty && Object.getOwnPropertyDescriptor;
                    for (var o in e)
                        if ("default" !== o && Object.prototype.hasOwnProperty.call(e, o)) {
                            var a = i ? Object.getOwnPropertyDescriptor(e, o) : null;
                            a && (a.get || a.set) ? Object.defineProperty(r, o, a) : r[o] = e[o]
                        }
                    return r.default = e, n && n.set(e, r), r
                }
                const u = [{
                    matches: (e, t) => "selectall" === e.key && (0, r.isElementType)(t, ["input", "textarea"]),
                    handle: (e, t, n, i) => {
                        var o;
                        (0, r.setSelectionRange)(t, 0, (null != (o = i.carryValue) ? o : t.value).length)
                    }
                }];
                t.replaceBehavior = u;
                const d = [...s.preKeydownBehavior];
                t.preKeydownBehavior = d;
                const h = [...i.keydownBehavior, ...o.keydownBehavior, ...s.keydownBehavior];
                t.keydownBehavior = h;
                const p = [...s.keypressBehavior, ...a.keypressBehavior];
                t.keypressBehavior = p;
                const f = [...s.preKeyupBehavior];
                t.preKeyupBehavior = f;
                const m = [...s.keyupBehavior];
                t.keyupBehavior = m;
                const g = [...s.postKeyupBehavior];
                t.postKeyupBehavior = g
            },
            8312: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.carryValue = function(e, t, n) {
                    const i = (0, r.getValue)(e);
                    t.carryValue = i !== n && "" === i && (0, r.hasUnreliableEmptyValue)(e) ? n : void 0
                };
                var r = n(3104)
            },
            2928: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.fireChangeForInputTimeIfValid = function(e, t, n) {
                    (0, i.isValidInputTimeValue)(e, n) && t !== n && r.fireEvent.change(e, {
                        target: {
                            value: n
                        }
                    })
                };
                var r = n(6902),
                    i = n(3104)
            },
            16: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.fireInputEvent = function(e, t) {
                    let {
                        newValue: n,
                        newSelectionStart: o,
                        eventOverrides: a
                    } = t;
                    if ((0, i.isContentEditable)(e)) s(e, "textContent", n);
                    else {
                        if (!(0, i.isElementType)(e, ["input", "textarea"])) throw new Error("Invalid Element");
                        s(e, "value", n)
                    }(function(e, t) {
                        (0, i.setSelectionRange)(e, t, t)
                    })(e, o), r.fireEvent.input(e, { ...a
                        }),
                        function(e, t, n) {
                            const r = (0, i.getValue)(e),
                                o = "" === r && (0, i.hasUnreliableEmptyValue)(e);
                            if (!o && r === t) {
                                const {
                                    selectionStart: t
                                } = (0, i.getSelectionRange)(e);
                                t === r.length && (0, i.setSelectionRange)(e, n, n)
                            }
                        }(e, n, o)
                };
                var r = n(6902),
                    i = n(3104);
                const o = Symbol("initial input value/textContent"),
                    a = Symbol("onBlur");

                function s(e, t, n) {
                    const i = Object.getOwnPropertyDescriptor(e, t),
                        s = Object.getOwnPropertyDescriptor(e.constructor.prototype, t);
                    var l;
                    (i && s && Object.defineProperty(e, t, s), void 0 === e[o] && (e[o] = String(e[t])), e[t] = n, e[a]) || (null == (l = e.ownerDocument.defaultView) || l.addEventListener("blur", e[a] = () => {
                        const n = e[o];
                        delete e[a], delete e[o], String(e[t]) !== n && r.fireEvent.change(e)
                    }, {
                        capture: !0,
                        once: !0
                    }));
                    i && Object.defineProperty(e, t, i)
                }
            },
            2876: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var r = n(8312);
                Object.keys(r).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === r[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return r[e]
                        }
                    }))
                }));
                var i = n(2928);
                Object.keys(i).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === i[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return i[e]
                        }
                    }))
                }));
                var o = n(16);
                Object.keys(o).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === o[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return o[e]
                        }
                    }))
                }))
            },
            6100: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.specialCharMap = void 0;
                t.specialCharMap = {
                    arrowLeft: "{arrowleft}",
                    arrowRight: "{arrowright}",
                    arrowDown: "{arrowdown}",
                    arrowUp: "{arrowup}",
                    enter: "{enter}",
                    escape: "{esc}",
                    delete: "{del}",
                    backspace: "{backspace}",
                    home: "{home}",
                    end: "{end}",
                    selectAll: "{selectall}",
                    space: "{space}",
                    whitespace: " ",
                    pageUp: "{pageUp}",
                    pageDown: "{pageDown}"
                }
            },
            7343: (e, t) => {
                "use strict";
                let n;
                Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.DOM_KEY_LOCATION = void 0, t.DOM_KEY_LOCATION = n,
                    function(e) {
                        e[e.STANDARD = 0] = "STANDARD", e[e.LEFT = 1] = "LEFT", e[e.RIGHT = 2] = "RIGHT", e[e.NUMPAD = 3] = "NUMPAD"
                    }(n || (t.DOM_KEY_LOCATION = n = {}))
            },
            2692: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.paste = function(e, t, n) {
                    let {
                        initialSelectionStart: o,
                        initialSelectionEnd: a
                    } = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                    if (! function(e) {
                            return (0, i.isElementType)(e, "input") && Boolean(i.editableInputTypes[e.type]) || (0, i.isElementType)(e, "textarea")
                        }(e)) throw new TypeError("The given ".concat(e.tagName, " element is currently unsupported.\n      A PR extending this implementation would be very much welcome at https://github.com/testing-library/user-event"));
                    if ((0, i.isDisabled)(e)) return;
                    (0, i.eventWrapper)((() => e.focus())), 0 === e.selectionStart && 0 === e.selectionEnd && (0, i.setSelectionRange)(e, null != o ? o : e.value.length, null != a ? a : e.value.length);
                    if (r.fireEvent.paste(e, n), e.readOnly) return;
                    t = t.substr(0, (0, i.getSpaceUntilMaxLength)(e));
                    const {
                        newValue: s,
                        newSelectionStart: l
                    } = (0, i.calculateNewValue)(t, e);
                    r.fireEvent.input(e, {
                        inputType: "insertFromPaste",
                        target: {
                            value: s
                        }
                    }), (0, i.setSelectionRange)(e, {
                        newSelectionStart: l,
                        selectionEnd: l
                    }, {})
                };
                var r = n(6902),
                    i = n(3104)
            },
            7320: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.selectOptions = t.deselectOptions = void 0;
                var r = n(6902),
                    i = n(3104),
                    o = n(4340),
                    a = n(9507),
                    s = n(3628);

                function l(e, t, n, l) {
                    let {
                        skipPointerEventsCheck: c = !1
                    } = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {};
                    if (!e && !t.multiple) throw (0, r.getConfig)().getElementError("Unable to deselect an option in a non-multiple select. Use selectOptions to change the selection instead.", t);
                    const u = Array.isArray(n) ? n : [n],
                        d = Array.from(t.querySelectorAll('option, [role="option"]')),
                        h = u.map((e => {
                            if ("string" !== typeof e && d.includes(e)) return e; {
                                const n = d.find((t => t.value === e || t.innerHTML === e));
                                if (n) return n;
                                throw (0, r.getConfig)().getElementError('Value "'.concat(String(e), '" not found in options'), t)
                            }
                        })).filter((e => !(0, i.isDisabled)(e)));
                    if (!(0, i.isDisabled)(t) && h.length)
                        if ((0, i.isElementType)(t, "select"))
                            if (t.multiple)
                                for (const o of h) {
                                    const e = !!c || (0, i.hasPointerEvents)(o);
                                    e && (r.fireEvent.pointerOver(o, l), r.fireEvent.pointerEnter(t, l), r.fireEvent.mouseOver(o), r.fireEvent.mouseEnter(t), r.fireEvent.pointerMove(o, l), r.fireEvent.mouseMove(o, l), r.fireEvent.pointerDown(o, l), r.fireEvent.mouseDown(o, l)), (0, a.focus)(t), e && (r.fireEvent.pointerUp(o, l), r.fireEvent.mouseUp(o, l)), p(o), e && r.fireEvent.click(o, l)
                                } else {
                                    if (1 !== h.length) throw (0, r.getConfig)().getElementError("Cannot select multiple options on a non-multiple select", t); {
                                        const e = !!c || (0, i.hasPointerEvents)(t);
                                        e ? (0, o.click)(t, l, {
                                            skipPointerEventsCheck: c
                                        }) : (0, a.focus)(t), p(h[0]), e && (r.fireEvent.pointerOver(t, l), r.fireEvent.pointerEnter(t, l), r.fireEvent.mouseOver(t), r.fireEvent.mouseEnter(t), r.fireEvent.pointerUp(t, l), r.fireEvent.mouseUp(t, l), r.fireEvent.click(t, l))
                                    }
                                } else {
                                    if ("listbox" !== t.getAttribute("role")) throw (0, r.getConfig)().getElementError("Cannot select options on elements that are neither select nor listbox elements", t);
                                    h.forEach((e => {
                                        (0, s.hover)(e, l, {
                                            skipPointerEventsCheck: c
                                        }), (0, o.click)(e, l, {
                                            skipPointerEventsCheck: c
                                        }), (0, s.unhover)(e, l, {
                                            skipPointerEventsCheck: c
                                        })
                                    }))
                                }

                    function p(n) {
                        n.selected = e, (0, r.fireEvent)(t, (0, r.createEvent)("input", t, {
                            bubbles: !0,
                            cancelable: !1,
                            composed: !0,
                            ...l
                        })), r.fireEvent.change(t, l)
                    }
                }
                const c = l.bind(null, !0);
                t.selectOptions = c;
                const u = l.bind(null, !1);
                t.deselectOptions = u
            },
            5052: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.tab = function() {
                    let {
                        shift: e = !1,
                        focusTrap: t
                    } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    var n, s;
                    const l = null != (n = null == (s = t) ? void 0 : s.ownerDocument) ? n : document,
                        c = (0, i.getActiveElement)(l);
                    t || (t = l);
                    const u = t.querySelectorAll(i.FOCUSABLE_SELECTOR),
                        d = Array.from(u).filter((e => e === c || "-1" !== e.getAttribute("tabindex") && !(0, i.isDisabled)(e) && (0, i.isVisible)(e)));
                    if (0 === d.length) return;
                    const h = d.map(((e, t) => ({
                            el: e,
                            idx: t
                        }))).sort(((e, t) => {
                            if (c && "-1" === c.getAttribute("tabindex")) return e.idx - t.idx;
                            const n = Number(e.el.getAttribute("tabindex")) - Number(t.el.getAttribute("tabindex"));
                            return 0 === n ? e.idx - t.idx : n
                        })).map((e => {
                            let {
                                el: t
                            } = e;
                            return t
                        })),
                        p = {};
                    let f = [];
                    h.forEach((e => {
                        const t = e;
                        if ("radio" === t.type && t.name) {
                            const e = c;
                            if (e && e.type === t.type && e.name === t.name) return void(t === e && f.push(t));
                            if (t.checked) return f = f.filter((e => e.type !== t.type || e.name !== t.name)), f.push(t), void(p[t.name] = t);
                            if ("undefined" !== typeof p[t.name]) return
                        }
                        f.push(t)
                    }));
                    const m = function(e, t, n, r) {
                            if ((0, i.isDocument)(r) && (0 === e && t || e === n.length - 1 && !t)) return r.body;
                            const o = t ? e - 1 : e + 1,
                                a = t ? n.length - 1 : 0;
                            return n[o] || n[a]
                        }(f.findIndex((e => e === c)), e, f, t),
                        g = {
                            key: "Shift",
                            keyCode: 16,
                            shiftKey: !0
                        },
                        v = {
                            key: "Tab",
                            keyCode: 9,
                            shiftKey: e
                        };
                    let y = !0;
                    c && (e && r.fireEvent.keyDown(c, { ...g
                    }), y = r.fireEvent.keyDown(c, { ...v
                    }));
                    const b = !y && c ? c : m;
                    y && (m === l.body ? c && (0, a.blur)(c) : (0, o.focus)(m));
                    r.fireEvent.keyUp(b, { ...v
                    }), e && r.fireEvent.keyUp(b, { ...g,
                        shiftKey: !1
                    })
                };
                var r = n(6902),
                    i = n(3104),
                    o = n(9507),
                    a = n(7384)
            },
            3812: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.type = function(e, t) {
                    let {
                        delay: n = 0,
                        ...o
                    } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    return n > 0 ? (0, r.getConfig)().asyncWrapper((() => (0, i.typeImplementation)(e, t, {
                        delay: n,
                        ...o
                    }))) : void(0, i.typeImplementation)(e, t, {
                        delay: n,
                        ...o
                    }).catch(console.error)
                };
                var r = n(6902),
                    i = n(6264)
            },
            6264: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.typeImplementation = async function(e, t, n) {
                    let {
                        delay: a,
                        skipClick: s = !1,
                        skipAutoClose: l = !1,
                        initialSelectionStart: c,
                        initialSelectionEnd: u
                    } = n;
                    if (e.disabled) return;
                    s || (0, i.click)(e);
                    const d = () => (0, r.getActiveElement)(e.ownerDocument),
                        h = (0, r.getValue)(d()),
                        {
                            selectionStart: p,
                            selectionEnd: f
                        } = (0, r.getSelectionRange)(e);
                    null == h || null !== p && 0 !== p || null !== f && 0 !== f || (0, r.setSelectionRange)(d(), null != c ? c : h.length, null != u ? u : h.length);
                    const {
                        promise: m,
                        releaseAllKeys: g
                    } = (0, o.keyboardImplementationWrapper)(t, {
                        delay: a,
                        document: e.ownerDocument
                    });
                    a > 0 && await m;
                    l || g();
                    return m
                };
                var r = n(3104),
                    i = n(4340),
                    o = n(6792)
            },
            1452: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.upload = function(e, t, n) {
                    let {
                        applyAccept: l = !1
                    } = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                    var c;
                    const u = (0, s.isElementType)(e, "label") ? e.control : e;
                    if (!u || !(0, s.isElementType)(u, "input", {
                            type: "file"
                        })) throw new TypeError("The ".concat(u === e ? "given" : "associated", " ").concat(null == u ? void 0 : u.tagName, " element does not accept file uploads"));
                    if ((0, s.isDisabled)(e)) return;
                    (0, i.click)(e, null == n ? void 0 : n.clickInit);
                    const d = (Array.isArray(t) ? t : [t]).filter((e => !l || function(e, t) {
                        if (!t) return !0;
                        const n = ["audio/*", "image/*", "video/*"];
                        return t.split(",").some((t => t.startsWith(".") ? e.name.endsWith(t) : n.includes(t) ? e.type.startsWith(t.substr(0, t.length - 1)) : e.type === t))
                    }(e, u.accept))).slice(0, u.multiple ? void 0 : 1);
                    if ((0, o.blur)(e), (0, a.focus)(e), d.length === (null == (c = u.files) ? void 0 : c.length) && d.every(((e, t) => {
                            var n;
                            return e === (null == (n = u.files) ? void 0 : n.item(t))
                        }))) return;
                    const h = { ...d,
                        length: d.length,
                        item: e => d[e],
                        [Symbol.iterator]() {
                            let e = 0;
                            return {
                                next: () => ({
                                    done: e >= d.length,
                                    value: d[e++]
                                })
                            }
                        }
                    };
                    (0, r.fireEvent)(u, (0, r.createEvent)("input", u, {
                        target: {
                            files: h
                        },
                        bubbles: !0,
                        cancelable: !1,
                        composed: !0
                    })), r.fireEvent.change(u, {
                        target: {
                            files: h
                        },
                        ...null == n ? void 0 : n.changeInit
                    })
                };
                var r = n(6902),
                    i = n(4340),
                    o = n(7384),
                    a = n(9507),
                    s = n(3104)
            },
            5864: (e, t) => {
                "use strict";

                function n(e) {
                    return "mousedown" === e || "mouseup" === e || "click" === e || "dblclick" === e
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getMouseEventOptions = function(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                    var r;
                    return t = null != (r = t) ? r : {}, { ...t,
                        detail: "mousedown" === e || "mouseup" === e || "click" === e ? 1 + n : n,
                        buttons: a(e, t, "buttons"),
                        button: a(e, t, "button")
                    }
                };
                const r = {
                        none: 0,
                        primary: 1,
                        secondary: 2,
                        auxiliary: 4
                    },
                    i = {
                        primary: 0,
                        auxiliary: 1,
                        secondary: 2
                    };

                function o(e, t) {
                    var n;
                    const [o, a] = "button" === t ? [i, r] : [r, i], s = null == (n = Object.entries(o).find((t => {
                        let [, n] = t;
                        return n === e
                    }))) ? void 0 : n[0];
                    return s && Object.prototype.hasOwnProperty.call(a, s) ? a[s] : 0
                }

                function a(e, t, r) {
                    return n(e) ? "number" === typeof t[r] ? t[r] : "button" === r && "number" === typeof t.buttons ? o(t.buttons, "buttons") : "buttons" === r && "number" === typeof t.button ? o(t.button, "button") : "button" != r && n(e) ? 1 : 0 : 0
                }
            },
            5120: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.isClickableInput = function(e) {
                    return (0, r.isElementType)(e, "button") || (0, r.isElementType)(e, "input") && i.includes(e.type)
                };
                var r = n(7440);
                const i = ["button", "color", "file", "image", "reset", "submit", "checkbox", "radio"]
            },
            7004: (e, t) => {
                "use strict";

                function n(e, t) {
                    const n = e.slice(0, t),
                        r = Math.min(parseInt(n, 10), 23),
                        i = e.slice(t),
                        o = parseInt(i, 10),
                        a = Math.min(o, 59);
                    return "".concat(r.toString().padStart(2, "0"), ":").concat(a.toString().padStart(2, "0"))
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.buildTimeValue = function(e) {
                    const t = e.replace(/\D/g, "");
                    if (t.length < 2) return e;
                    const r = parseInt(t[0], 10),
                        i = parseInt(t[1], 10);
                    if (r >= 3 || 2 === r && i >= 4) {
                        let e;
                        return e = r >= 3 ? 1 : 2, n(t, e)
                    }
                    if (2 === e.length) return e;
                    return n(t, 2)
                }
            },
            5944: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.calculateNewValue = function(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : (() => {
                            var e;
                            return null != (e = (0, i.getValue)(t)) ? e : ""
                        })(),
                        s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : (0, r.getSelectionRange)(t),
                        l = arguments.length > 4 ? arguments[4] : void 0;
                    const c = null === s.selectionStart ? n.length : s.selectionStart,
                        u = null === s.selectionEnd ? n.length : s.selectionEnd,
                        d = Math.max(0, c === u && "backward" === l ? c - 1 : c),
                        h = n.substring(0, d),
                        p = Math.min(n.length, c === u && "forward" === l ? u + 1 : u),
                        f = n.substring(p, n.length);
                    let m = "".concat(h).concat(e).concat(f);
                    const g = d + e.length;
                    "date" !== t.type || (0, o.isValidDateValue)(t, m) || (m = n);
                    "time" !== t.type || (0, a.isValidInputTimeValue)(t, m) || (m = (0, a.isValidInputTimeValue)(t, e) ? e : n);
                    return {
                        newValue: m,
                        newSelectionStart: g
                    }
                };
                var r = n(2320),
                    i = n(8900),
                    o = n(3268),
                    a = n(5964)
            },
            1400: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.isCursorAtEnd = function(e) {
                    var t;
                    const {
                        selectionStart: n,
                        selectionEnd: o
                    } = (0, r.getSelectionRange)(e);
                    return n === o && (null != n ? n : 0) === (null != (t = (0, i.getValue)(e)) ? t : "").length
                }, t.isCursorAtStart = function(e) {
                    const {
                        selectionStart: t,
                        selectionEnd: n
                    } = (0, r.getSelectionRange)(e);
                    return t === n && 0 === (null != t ? t : 0)
                };
                var r = n(2320),
                    i = n(8900)
            },
            8900: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getValue = function(e) {
                    if (!e) return null;
                    if ((0, r.isContentEditable)(e)) return e.textContent;
                    return e.value
                };
                var r = n(1192)
            },
            4760: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.hasUnreliableEmptyValue = function(e) {
                    return (0, i.isElementType)(e, "input") && Boolean(r[e.type])
                };
                var r, i = n(7440);
                ! function(e) {
                    e.number = "number"
                }(r || (r = {}))
            },
            1192: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.isContentEditable = function(e) {
                    return e.hasAttribute("contenteditable") && ("true" == e.getAttribute("contenteditable") || "" == e.getAttribute("contenteditable"))
                }
            },
            6428: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.editableInputTypes = void 0, t.isEditable = function(e) {
                    return a(e) || (0, r.isElementType)(e, "textarea", {
                        readOnly: !1
                    }) || (0, i.isContentEditable)(e)
                }, t.isEditableInput = a;
                var r = n(7440),
                    i = n(1192);
                let o;

                function a(e) {
                    return (0, r.isElementType)(e, "input", {
                        readOnly: !1
                    }) && Boolean(o[e.type])
                }
                t.editableInputTypes = o,
                    function(e) {
                        e.text = "text", e.date = "date", e["datetime-local"] = "datetime-local", e.email = "email", e.month = "month", e.number = "number", e.password = "password", e.search = "search", e.tel = "tel", e.time = "time", e.url = "url", e.week = "week"
                    }(o || (t.editableInputTypes = o = {}))
            },
            3268: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.isValidDateValue = function(e, t) {
                    const n = e.cloneNode();
                    return n.value = t, n.value === t
                }
            },
            5964: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.isValidInputTimeValue = function(e, t) {
                    const n = e.cloneNode();
                    return n.value = t, n.value === t
                }
            },
            7224: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getSpaceUntilMaxLength = function(e) {
                    const t = (0, o.getValue)(e);
                    if (null === t) return;
                    const n = function(e) {
                        var t;
                        if (! function(e) {
                                return (0, i.isElementType)(e, "textarea") || (0, i.isElementType)(e, "input") && Boolean(r[e.type])
                            }(e)) return;
                        const n = null != (t = e.getAttribute("maxlength")) ? t : "";
                        return /^\d+$/.test(n) && Number(n) >= 0 ? Number(n) : void 0
                    }(e);
                    return n ? n - t.length : void 0
                };
                var r, i = n(7440),
                    o = n(8900);
                ! function(e) {
                    e.email = "email", e.password = "password", e.search = "search", e.telephone = "telephone", e.text = "text", e.url = "url"
                }(r || (r = {}))
            },
            2320: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getSelectionRange = s, t.hasSelectionSupport = a, t.setSelectionRange = function(e, t, n) {
                    const {
                        selectionStart: r,
                        selectionEnd: l
                    } = s(e);
                    if (r === t && l === n) return;
                    a(e) && e.setSelectionRange(t, n);
                    (0, i.isElementType)(e, "input") && (e[o] = {
                        selectionStart: t,
                        selectionEnd: n
                    });
                    if ((0, i.isElementType)(e, "input") || (0, i.isElementType)(e, "textarea")) return;
                    const c = e.ownerDocument.createRange();
                    c.selectNodeContents(e), e.firstChild && (c.setStart(e.firstChild, t), c.setEnd(e.firstChild, n));
                    const u = e.ownerDocument.getSelection();
                    u && (u.removeAllRanges(), u.addRange(c))
                };
                var r, i = n(7440);
                ! function(e) {
                    e.text = "text", e.search = "search", e.url = "url", e.tel = "tel", e.password = "password"
                }(r || (r = {}));
                const o = Symbol("inputSelection");

                function a(e) {
                    return (0, i.isElementType)(e, "textarea") || (0, i.isElementType)(e, "input") && Boolean(r[e.type])
                }

                function s(e) {
                    if (a(e)) return {
                        selectionStart: e.selectionStart,
                        selectionEnd: e.selectionEnd
                    };
                    var t;
                    if ((0, i.isElementType)(e, "input")) return null != (t = e[o]) ? t : {
                        selectionStart: null,
                        selectionEnd: null
                    };
                    const n = e.ownerDocument.getSelection();
                    if (null != n && n.rangeCount && e.contains(n.focusNode)) {
                        const e = n.getRangeAt(0);
                        return {
                            selectionStart: e.startOffset,
                            selectionEnd: e.endOffset
                        }
                    }
                    return {
                        selectionStart: null,
                        selectionEnd: null
                    }
                }
            },
            1907: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getActiveElement = function e(t) {
                    const n = t.activeElement;
                    return null != n && n.shadowRoot ? e(n.shadowRoot) : (0, r.isDisabled)(n) ? t.ownerDocument ? t.ownerDocument.body : t.body : n
                };
                var r = n(8064)
            },
            8952: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.isFocusable = function(e) {
                    return !(0, r.isLabelWithInternallyDisabledControl)(e) && e.matches(i.FOCUSABLE_SELECTOR)
                };
                var r = n(5268),
                    i = n(876)
            },
            876: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.FOCUSABLE_SELECTOR = void 0;
                const n = ["input:not([type=hidden]):not([disabled])", "button:not([disabled])", "select:not([disabled])", "textarea:not([disabled])", '[contenteditable=""]', '[contenteditable="true"]', "a[href]", "[tabindex]:not([disabled])"].join(", ");
                t.FOCUSABLE_SELECTOR = n
            },
            3104: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var r = n(5864);
                Object.keys(r).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === r[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return r[e]
                        }
                    }))
                }));
                var i = n(5120);
                Object.keys(i).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === i[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return i[e]
                        }
                    }))
                }));
                var o = n(7004);
                Object.keys(o).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === o[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return o[e]
                        }
                    }))
                }));
                var a = n(5944);
                Object.keys(a).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === a[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return a[e]
                        }
                    }))
                }));
                var s = n(1400);
                Object.keys(s).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === s[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return s[e]
                        }
                    }))
                }));
                var l = n(8900);
                Object.keys(l).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === l[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return l[e]
                        }
                    }))
                }));
                var c = n(4760);
                Object.keys(c).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === c[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return c[e]
                        }
                    }))
                }));
                var u = n(1192);
                Object.keys(u).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === u[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return u[e]
                        }
                    }))
                }));
                var d = n(6428);
                Object.keys(d).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === d[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return d[e]
                        }
                    }))
                }));
                var h = n(3268);
                Object.keys(h).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === h[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return h[e]
                        }
                    }))
                }));
                var p = n(5964);
                Object.keys(p).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === p[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return p[e]
                        }
                    }))
                }));
                var f = n(7224);
                Object.keys(f).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === f[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return f[e]
                        }
                    }))
                }));
                var m = n(2320);
                Object.keys(m).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === m[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return m[e]
                        }
                    }))
                }));
                var g = n(1907);
                Object.keys(g).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === g[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return g[e]
                        }
                    }))
                }));
                var v = n(8952);
                Object.keys(v).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === v[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return v[e]
                        }
                    }))
                }));
                var y = n(876);
                Object.keys(y).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === y[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return y[e]
                        }
                    }))
                }));
                var b = n(6136);
                Object.keys(b).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === b[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return b[e]
                        }
                    }))
                }));
                var x = n(7440);
                Object.keys(x).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === x[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return x[e]
                        }
                    }))
                }));
                var _ = n(5268);
                Object.keys(_).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === _[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return _[e]
                        }
                    }))
                }));
                var M = n(816);
                Object.keys(M).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === M[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return M[e]
                        }
                    }))
                }));
                var w = n(8064);
                Object.keys(w).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === w[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return w[e]
                        }
                    }))
                }));
                var A = n(6404);
                Object.keys(A).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === A[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return A[e]
                        }
                    }))
                }));
                var S = n(9976);
                Object.keys(S).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === S[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return S[e]
                        }
                    }))
                }));
                var E = n(7484);
                Object.keys(E).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === E[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return E[e]
                        }
                    }))
                }));
                var C = n(9844);
                Object.keys(C).forEach((function(e) {
                    "default" !== e && "__esModule" !== e && (e in t && t[e] === C[e] || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return C[e]
                        }
                    }))
                }))
            },
            6136: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.eventWrapper = function(e) {
                    let t;
                    return (0, r.getConfig)().eventWrapper((() => {
                        t = e()
                    })), t
                };
                var r = n(6902)
            },
            9844: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.hasFormSubmit = void 0;
                t.hasFormSubmit = e => !(!e || !e.querySelector('input[type="submit"]') && !e.querySelector('button[type="submit"]'))
            },
            7484: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.hasPointerEvents = function(e) {
                    const t = (0, r.getWindowFromNode)(e);
                    for (let r = e; null != (n = r) && n.ownerDocument; r = r.parentElement) {
                        var n;
                        const e = t.getComputedStyle(r).pointerEvents;
                        if (e && !["inherit", "unset"].includes(e)) return "none" !== e
                    }
                    return !0
                };
                var r = n(2540)
            },
            8064: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.isDisabled = function(e) {
                    return Boolean(e && e.disabled)
                }
            },
            6404: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.isDocument = function(e) {
                    return e.nodeType === e.DOCUMENT_NODE
                }
            },
            7440: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.isElementType = function(e, t, n) {
                    if (e.namespaceURI && "http://www.w3.org/1999/xhtml" !== e.namespaceURI) return !1;
                    if (!(t = Array.isArray(t) ? t : [t]).includes(e.tagName.toLowerCase())) return !1;
                    if (n) return Object.entries(n).every((t => {
                        let [n, r] = t;
                        return e[n] === r
                    }));
                    return !0
                }
            },
            5268: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.isLabelWithInternallyDisabledControl = function(e) {
                    if (!(0, i.isElementType)(e, "label")) return !1;
                    const t = e.control;
                    return Boolean(t && e.contains(t) && (0, r.isDisabled)(t))
                };
                var r = n(8064),
                    i = n(7440)
            },
            816: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.isVisible = function(e) {
                    const t = (0, r.getWindowFromNode)(e);
                    for (let r = e; null != (n = r) && n.ownerDocument; r = r.parentElement) {
                        var n;
                        if ("none" === t.getComputedStyle(r).display) return !1
                    }
                    return !0
                };
                var r = n(2540)
            },
            9976: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.wait = function(e) {
                    return new Promise((t => setTimeout((() => t()), e)))
                }
            },
            3368: e => {
                "use strict";
                e.exports = function() {
                    let {
                        onlyFirst: e = !1
                    } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    const t = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
                    return new RegExp(t, e ? void 0 : "g")
                }
            },
            6296: (e, t, n) => {
                "use strict";
                var r = n(6396)("ArrayBuffer.prototype.byteLength", !0),
                    i = n(3596);
                e.exports = function(e) {
                    return i(e) ? r ? r(e) : e.byteLength : NaN
                }
            },
            6396: (e, t, n) => {
                "use strict";
                var r = n(6344),
                    i = n(5520),
                    o = i(r("String.prototype.indexOf"));
                e.exports = function(e, t) {
                    var n = r(e, !!t);
                    return "function" === typeof n && o(e, ".prototype.") > -1 ? i(n) : n
                }
            },
            5520: (e, t, n) => {
                "use strict";
                var r = n(6160),
                    i = n(6344),
                    o = n(804),
                    a = n(7896),
                    s = i("%Function.prototype.apply%"),
                    l = i("%Function.prototype.call%"),
                    c = i("%Reflect.apply%", !0) || r.call(l, s),
                    u = n(3384),
                    d = i("%Math.max%");
                e.exports = function(e) {
                    if ("function" !== typeof e) throw new a("a function is required");
                    var t = c(r, l, arguments);
                    return o(t, 1 + d(0, e.length - (arguments.length - 1)), !0)
                };
                var h = function() {
                    return c(r, s, arguments)
                };
                u ? u(e.exports, "apply", {
                    value: h
                }) : e.exports.apply = h
            },
            6776: e => {
                function t(e, t, n) {
                    var r, i, o, a, s;

                    function l() {
                        var c = Date.now() - a;
                        c < t && c >= 0 ? r = setTimeout(l, t - c) : (r = null, n || (s = e.apply(o, i), o = i = null))
                    }
                    null == t && (t = 100);
                    var c = function() {
                        o = this, i = arguments, a = Date.now();
                        var c = n && !r;
                        return r || (r = setTimeout(l, t)), c && (s = e.apply(o, i), o = i = null), s
                    };
                    return c.clear = function() {
                        r && (clearTimeout(r), r = null)
                    }, c.flush = function() {
                        r && (s = e.apply(o, i), o = i = null, clearTimeout(r), r = null)
                    }, c
                }
                t.debounce = t, e.exports = t
            },
            7859: (e, t, n) => {
                "use strict";
                var r = n(2380),
                    i = n(6396),
                    o = n(8912),
                    a = n(6344),
                    s = n(7500),
                    l = n(5208),
                    c = n(7360),
                    u = n(8512),
                    d = n(5399),
                    h = n(3596),
                    p = n(5028),
                    f = n(6420),
                    m = n(2952),
                    g = n(8564),
                    v = n(9756),
                    y = n(676),
                    b = n(4244),
                    x = n(6296),
                    _ = i("SharedArrayBuffer.prototype.byteLength", !0),
                    M = i("Date.prototype.getTime"),
                    w = Object.getPrototypeOf,
                    A = i("Object.prototype.toString"),
                    S = a("%Set%", !0),
                    E = i("Map.prototype.has", !0),
                    C = i("Map.prototype.get", !0),
                    T = i("Map.prototype.size", !0),
                    P = i("Set.prototype.add", !0),
                    R = i("Set.prototype.delete", !0),
                    I = i("Set.prototype.has", !0),
                    O = i("Set.prototype.size", !0);

                function B(e, t, n, r) {
                    for (var i, o = s(e);
                        (i = o.next()) && !i.done;)
                        if (F(t, i.value, n, r)) return R(e, i.value), !0;
                    return !1
                }

                function L(e) {
                    return "undefined" === typeof e ? null : "object" !== typeof e ? "symbol" !== typeof e && ("string" !== typeof e && "number" !== typeof e || +e === +e) : void 0
                }

                function D(e, t, n, i, o, a) {
                    var s = L(n);
                    if (null != s) return s;
                    var l = C(t, s),
                        c = r({}, o, {
                            strict: !1
                        });
                    return !("undefined" === typeof l && !E(t, s) || !F(i, l, c, a)) && (!E(e, s) && F(i, l, c, a))
                }

                function N(e, t, n) {
                    var r = L(n);
                    return null != r ? r : I(t, r) && !I(e, r)
                }

                function k(e, t, n, r, i, o) {
                    for (var a, l, c = s(e);
                        (a = c.next()) && !a.done;)
                        if (F(n, l = a.value, i, o) && F(r, C(t, l), i, o)) return R(e, l), !0;
                    return !1
                }

                function F(e, t, n, i) {
                    var a = n || {};
                    if (a.strict ? c(e, t) : e === t) return !0;
                    if (v(e) !== v(t)) return !1;
                    if (!e || !t || "object" !== typeof e && "object" !== typeof t) return a.strict ? c(e, t) : e == t;
                    var l, R = i.has(e),
                        L = i.has(t);
                    if (R && L) {
                        if (i.get(e) === i.get(t)) return !0
                    } else l = {};
                    return R || i.set(e, l), L || i.set(t, l),
                        function(e, t, n, i) {
                            var a, l;
                            if (typeof e !== typeof t) return !1;
                            if (null == e || null == t) return !1;
                            if (A(e) !== A(t)) return !1;
                            if (u(e) !== u(t)) return !1;
                            var c = d(e),
                                v = d(t);
                            if (c !== v) return !1;
                            var R = e instanceof Error,
                                L = t instanceof Error;
                            if (R !== L) return !1;
                            if ((R || L) && (e.name !== t.name || e.message !== t.message)) return !1;
                            var z = f(e),
                                H = f(t);
                            if (z !== H) return !1;
                            if ((z || H) && (e.source !== t.source || o(e) !== o(t))) return !1;
                            var j = p(e),
                                G = p(t);
                            if (j !== G) return !1;
                            if ((j || G) && M(e) !== M(t)) return !1;
                            if (n.strict && w && w(e) !== w(t)) return !1;
                            var V = b(e),
                                q = b(t);
                            if (V !== q) return !1;
                            if (V || q) {
                                if (e.length !== t.length) return !1;
                                for (a = 0; a < e.length; a++)
                                    if (e[a] !== t[a]) return !1;
                                return !0
                            }
                            var W = U(e),
                                X = U(t);
                            if (W !== X) return !1;
                            if (W || X) {
                                if (e.length !== t.length) return !1;
                                for (a = 0; a < e.length; a++)
                                    if (e[a] !== t[a]) return !1;
                                return !0
                            }
                            var K = h(e),
                                J = h(t);
                            if (K !== J) return !1;
                            if (K || J) return x(e) === x(t) && ("function" === typeof Uint8Array && F(new Uint8Array(e), new Uint8Array(t), n, i));
                            var Y = m(e),
                                Q = m(t);
                            if (Y !== Q) return !1;
                            if (Y || Q) return _(e) === _(t) && ("function" === typeof Uint8Array && F(new Uint8Array(e), new Uint8Array(t), n, i));
                            if (typeof e !== typeof t) return !1;
                            var Z = g(e),
                                $ = g(t);
                            if (Z.length !== $.length) return !1;
                            for (Z.sort(), $.sort(), a = Z.length - 1; a >= 0; a--)
                                if (Z[a] != $[a]) return !1;
                            for (a = Z.length - 1; a >= 0; a--)
                                if (!F(e[l = Z[a]], t[l], n, i)) return !1;
                            var ee = y(e),
                                te = y(t);
                            if (ee !== te) return !1;
                            if ("Set" === ee || "Set" === te) return function(e, t, n, r) {
                                if (O(e) !== O(t)) return !1;
                                var i, o, a, l = s(e),
                                    c = s(t);
                                for (;
                                    (i = l.next()) && !i.done;)
                                    if (i.value && "object" === typeof i.value) a || (a = new S), P(a, i.value);
                                    else if (!I(t, i.value)) {
                                    if (n.strict) return !1;
                                    if (!N(e, t, i.value)) return !1;
                                    a || (a = new S), P(a, i.value)
                                }
                                if (a) {
                                    for (;
                                        (o = c.next()) && !o.done;)
                                        if (o.value && "object" === typeof o.value) {
                                            if (!B(a, o.value, n.strict, r)) return !1
                                        } else if (!n.strict && !I(e, o.value) && !B(a, o.value, n.strict, r)) return !1;
                                    return 0 === O(a)
                                }
                                return !0
                            }(e, t, n, i);
                            if ("Map" === ee) return function(e, t, n, i) {
                                if (T(e) !== T(t)) return !1;
                                var o, a, l, c, u, d, h = s(e),
                                    p = s(t);
                                for (;
                                    (o = h.next()) && !o.done;)
                                    if (c = o.value[0], u = o.value[1], c && "object" === typeof c) l || (l = new S), P(l, c);
                                    else if ("undefined" === typeof(d = C(t, c)) && !E(t, c) || !F(u, d, n, i)) {
                                    if (n.strict) return !1;
                                    if (!D(e, t, c, u, n, i)) return !1;
                                    l || (l = new S), P(l, c)
                                }
                                if (l) {
                                    for (;
                                        (a = p.next()) && !a.done;)
                                        if (c = a.value[0], d = a.value[1], c && "object" === typeof c) {
                                            if (!k(l, e, c, d, n, i)) return !1
                                        } else if (!n.strict && (!e.has(c) || !F(C(e, c), d, n, i)) && !k(l, e, c, d, r({}, n, {
                                            strict: !1
                                        }), i)) return !1;
                                    return 0 === O(l)
                                }
                                return !0
                            }(e, t, n, i);
                            return !0
                        }(e, t, a, i)
                }

                function U(e) {
                    return !(!e || "object" !== typeof e || "number" !== typeof e.length) && ("function" === typeof e.copy && "function" === typeof e.slice && (!(e.length > 0 && "number" !== typeof e[0]) && !!(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e))))
                }
                e.exports = function(e, t, n) {
                    return F(e, t, n, l())
                }
            },
            4152: (e, t, n) => {
                "use strict";
                var r = n(3384),
                    i = n(2612),
                    o = n(7896),
                    a = n(6948);
                e.exports = function(e, t, n) {
                    if (!e || "object" !== typeof e && "function" !== typeof e) throw new o("`obj` must be an object or a function`");
                    if ("string" !== typeof t && "symbol" !== typeof t) throw new o("`property` must be a string or a symbol`");
                    if (arguments.length > 3 && "boolean" !== typeof arguments[3] && null !== arguments[3]) throw new o("`nonEnumerable`, if provided, must be a boolean or null");
                    if (arguments.length > 4 && "boolean" !== typeof arguments[4] && null !== arguments[4]) throw new o("`nonWritable`, if provided, must be a boolean or null");
                    if (arguments.length > 5 && "boolean" !== typeof arguments[5] && null !== arguments[5]) throw new o("`nonConfigurable`, if provided, must be a boolean or null");
                    if (arguments.length > 6 && "boolean" !== typeof arguments[6]) throw new o("`loose`, if provided, must be a boolean");
                    var s = arguments.length > 3 ? arguments[3] : null,
                        l = arguments.length > 4 ? arguments[4] : null,
                        c = arguments.length > 5 ? arguments[5] : null,
                        u = arguments.length > 6 && arguments[6],
                        d = !!a && a(e, t);
                    if (r) r(e, t, {
                        configurable: null === c && d ? d.configurable : !c,
                        enumerable: null === s && d ? d.enumerable : !s,
                        value: n,
                        writable: null === l && d ? d.writable : !l
                    });
                    else {
                        if (!u && (s || l || c)) throw new i("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
                        e[t] = n
                    }
                }
            },
            108: (e, t, n) => {
                "use strict";
                var r = n(8564),
                    i = "function" === typeof Symbol && "symbol" === typeof Symbol("foo"),
                    o = Object.prototype.toString,
                    a = Array.prototype.concat,
                    s = n(4152),
                    l = n(1040)(),
                    c = function(e, t, n, r) {
                        if (t in e)
                            if (!0 === r) {
                                if (e[t] === n) return
                            } else if ("function" !== typeof(i = r) || "[object Function]" !== o.call(i) || !r()) return;
                        var i;
                        l ? s(e, t, n, !0) : s(e, t, n)
                    },
                    u = function(e, t) {
                        var n = arguments.length > 2 ? arguments[2] : {},
                            o = r(t);
                        i && (o = a.call(o, Object.getOwnPropertySymbols(t)));
                        for (var s = 0; s < o.length; s += 1) c(e, o[s], t[o[s]], n[o[s]])
                    };
                u.supportsDescriptors = !!l, e.exports = u
            },
            3384: (e, t, n) => {
                "use strict";
                var r = n(6344)("%Object.defineProperty%", !0) || !1;
                if (r) try {
                    r({}, "a", {
                        value: 1
                    })
                } catch (i) {
                    r = !1
                }
                e.exports = r
            },
            9560: e => {
                "use strict";
                e.exports = EvalError
            },
            4128: e => {
                "use strict";
                e.exports = Error
            },
            7372: e => {
                "use strict";
                e.exports = RangeError
            },
            4376: e => {
                "use strict";
                e.exports = ReferenceError
            },
            2612: e => {
                "use strict";
                e.exports = SyntaxError
            },
            7896: e => {
                "use strict";
                e.exports = TypeError
            },
            5004: e => {
                "use strict";
                e.exports = URIError
            },
            6964: (e, t, n) => {
                "use strict";
                var r = n(5332),
                    i = Object.prototype.toString,
                    o = Object.prototype.hasOwnProperty;
                e.exports = function(e, t, n) {
                    if (!r(t)) throw new TypeError("iterator must be a function");
                    var a;
                    arguments.length >= 3 && (a = n), "[object Array]" === i.call(e) ? function(e, t, n) {
                        for (var r = 0, i = e.length; r < i; r++) o.call(e, r) && (null == n ? t(e[r], r, e) : t.call(n, e[r], r, e))
                    }(e, t, a) : "string" === typeof e ? function(e, t, n) {
                        for (var r = 0, i = e.length; r < i; r++) null == n ? t(e.charAt(r), r, e) : t.call(n, e.charAt(r), r, e)
                    }(e, t, a) : function(e, t, n) {
                        for (var r in e) o.call(e, r) && (null == n ? t(e[r], r, e) : t.call(n, e[r], r, e))
                    }(e, t, a)
                }
            },
            8016: e => {
                "use strict";
                var t = Object.prototype.toString,
                    n = Math.max,
                    r = function(e, t) {
                        for (var n = [], r = 0; r < e.length; r += 1) n[r] = e[r];
                        for (var i = 0; i < t.length; i += 1) n[i + e.length] = t[i];
                        return n
                    };
                e.exports = function(e) {
                    var i = this;
                    if ("function" !== typeof i || "[object Function]" !== t.apply(i)) throw new TypeError("Function.prototype.bind called on incompatible " + i);
                    for (var o, a = function(e, t) {
                            for (var n = [], r = t || 0, i = 0; r < e.length; r += 1, i += 1) n[i] = e[r];
                            return n
                        }(arguments, 1), s = n(0, i.length - a.length), l = [], c = 0; c < s; c++) l[c] = "$" + c;
                    if (o = Function("binder", "return function (" + function(e, t) {
                            for (var n = "", r = 0; r < e.length; r += 1) n += e[r], r + 1 < e.length && (n += t);
                            return n
                        }(l, ",") + "){ return binder.apply(this,arguments); }")((function() {
                            if (this instanceof o) {
                                var t = i.apply(this, r(a, arguments));
                                return Object(t) === t ? t : this
                            }
                            return i.apply(e, r(a, arguments))
                        })), i.prototype) {
                        var u = function() {};
                        u.prototype = i.prototype, o.prototype = new u, u.prototype = null
                    }
                    return o
                }
            },
            6160: (e, t, n) => {
                "use strict";
                var r = n(8016);
                e.exports = Function.prototype.bind || r
            },
            3672: e => {
                "use strict";
                var t = function() {
                        return "string" === typeof
                        function() {}.name
                    },
                    n = Object.getOwnPropertyDescriptor;
                if (n) try {
                    n([], "length")
                } catch (i) {
                    n = null
                }
                t.functionsHaveConfigurableNames = function() {
                    if (!t() || !n) return !1;
                    var e = n((function() {}), "name");
                    return !!e && !!e.configurable
                };
                var r = Function.prototype.bind;
                t.boundFunctionsHaveNames = function() {
                    return t() && "function" === typeof r && "" !== function() {}.bind().name
                }, e.exports = t
            },
            6344: (e, t, n) => {
                "use strict";
                var r, i = n(4128),
                    o = n(9560),
                    a = n(7372),
                    s = n(4376),
                    l = n(2612),
                    c = n(7896),
                    u = n(5004),
                    d = Function,
                    h = function(e) {
                        try {
                            return d('"use strict"; return (' + e + ").constructor;")()
                        } catch (t) {}
                    },
                    p = Object.getOwnPropertyDescriptor;
                if (p) try {
                    p({}, "")
                } catch (D) {
                    p = null
                }
                var f = function() {
                        throw new c
                    },
                    m = p ? function() {
                        try {
                            return f
                        } catch (e) {
                            try {
                                return p(arguments, "callee").get
                            } catch (t) {
                                return f
                            }
                        }
                    }() : f,
                    g = n(7740)(),
                    v = n(3588)(),
                    y = Object.getPrototypeOf || (v ? function(e) {
                        return e.__proto__
                    } : null),
                    b = {},
                    x = "undefined" !== typeof Uint8Array && y ? y(Uint8Array) : r,
                    _ = {
                        __proto__: null,
                        "%AggregateError%": "undefined" === typeof AggregateError ? r : AggregateError,
                        "%Array%": Array,
                        "%ArrayBuffer%": "undefined" === typeof ArrayBuffer ? r : ArrayBuffer,
                        "%ArrayIteratorPrototype%": g && y ? y([][Symbol.iterator]()) : r,
                        "%AsyncFromSyncIteratorPrototype%": r,
                        "%AsyncFunction%": b,
                        "%AsyncGenerator%": b,
                        "%AsyncGeneratorFunction%": b,
                        "%AsyncIteratorPrototype%": b,
                        "%Atomics%": "undefined" === typeof Atomics ? r : Atomics,
                        "%BigInt%": "undefined" === typeof BigInt ? r : BigInt,
                        "%BigInt64Array%": "undefined" === typeof BigInt64Array ? r : BigInt64Array,
                        "%BigUint64Array%": "undefined" === typeof BigUint64Array ? r : BigUint64Array,
                        "%Boolean%": Boolean,
                        "%DataView%": "undefined" === typeof DataView ? r : DataView,
                        "%Date%": Date,
                        "%decodeURI%": decodeURI,
                        "%decodeURIComponent%": decodeURIComponent,
                        "%encodeURI%": encodeURI,
                        "%encodeURIComponent%": encodeURIComponent,
                        "%Error%": i,
                        "%eval%": eval,
                        "%EvalError%": o,
                        "%Float32Array%": "undefined" === typeof Float32Array ? r : Float32Array,
                        "%Float64Array%": "undefined" === typeof Float64Array ? r : Float64Array,
                        "%FinalizationRegistry%": "undefined" === typeof FinalizationRegistry ? r : FinalizationRegistry,
                        "%Function%": d,
                        "%GeneratorFunction%": b,
                        "%Int8Array%": "undefined" === typeof Int8Array ? r : Int8Array,
                        "%Int16Array%": "undefined" === typeof Int16Array ? r : Int16Array,
                        "%Int32Array%": "undefined" === typeof Int32Array ? r : Int32Array,
                        "%isFinite%": isFinite,
                        "%isNaN%": isNaN,
                        "%IteratorPrototype%": g && y ? y(y([][Symbol.iterator]())) : r,
                        "%JSON%": "object" === typeof JSON ? JSON : r,
                        "%Map%": "undefined" === typeof Map ? r : Map,
                        "%MapIteratorPrototype%": "undefined" !== typeof Map && g && y ? y((new Map)[Symbol.iterator]()) : r,
                        "%Math%": Math,
                        "%Number%": Number,
                        "%Object%": Object,
                        "%parseFloat%": parseFloat,
                        "%parseInt%": parseInt,
                        "%Promise%": "undefined" === typeof Promise ? r : Promise,
                        "%Proxy%": "undefined" === typeof Proxy ? r : Proxy,
                        "%RangeError%": a,
                        "%ReferenceError%": s,
                        "%Reflect%": "undefined" === typeof Reflect ? r : Reflect,
                        "%RegExp%": RegExp,
                        "%Set%": "undefined" === typeof Set ? r : Set,
                        "%SetIteratorPrototype%": "undefined" !== typeof Set && g && y ? y((new Set)[Symbol.iterator]()) : r,
                        "%SharedArrayBuffer%": "undefined" === typeof SharedArrayBuffer ? r : SharedArrayBuffer,
                        "%String%": String,
                        "%StringIteratorPrototype%": g && y ? y("" [Symbol.iterator]()) : r,
                        "%Symbol%": g ? Symbol : r,
                        "%SyntaxError%": l,
                        "%ThrowTypeError%": m,
                        "%TypedArray%": x,
                        "%TypeError%": c,
                        "%Uint8Array%": "undefined" === typeof Uint8Array ? r : Uint8Array,
                        "%Uint8ClampedArray%": "undefined" === typeof Uint8ClampedArray ? r : Uint8ClampedArray,
                        "%Uint16Array%": "undefined" === typeof Uint16Array ? r : Uint16Array,
                        "%Uint32Array%": "undefined" === typeof Uint32Array ? r : Uint32Array,
                        "%URIError%": u,
                        "%WeakMap%": "undefined" === typeof WeakMap ? r : WeakMap,
                        "%WeakRef%": "undefined" === typeof WeakRef ? r : WeakRef,
                        "%WeakSet%": "undefined" === typeof WeakSet ? r : WeakSet
                    };
                if (y) try {
                    null.error
                } catch (D) {
                    var M = y(y(D));
                    _["%Error.prototype%"] = M
                }
                var w = function e(t) {
                        var n;
                        if ("%AsyncFunction%" === t) n = h("async function () {}");
                        else if ("%GeneratorFunction%" === t) n = h("function* () {}");
                        else if ("%AsyncGeneratorFunction%" === t) n = h("async function* () {}");
                        else if ("%AsyncGenerator%" === t) {
                            var r = e("%AsyncGeneratorFunction%");
                            r && (n = r.prototype)
                        } else if ("%AsyncIteratorPrototype%" === t) {
                            var i = e("%AsyncGenerator%");
                            i && y && (n = y(i.prototype))
                        }
                        return _[t] = n, n
                    },
                    A = {
                        __proto__: null,
                        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
                        "%ArrayPrototype%": ["Array", "prototype"],
                        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
                        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
                        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
                        "%ArrayProto_values%": ["Array", "prototype", "values"],
                        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
                        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
                        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
                        "%BooleanPrototype%": ["Boolean", "prototype"],
                        "%DataViewPrototype%": ["DataView", "prototype"],
                        "%DatePrototype%": ["Date", "prototype"],
                        "%ErrorPrototype%": ["Error", "prototype"],
                        "%EvalErrorPrototype%": ["EvalError", "prototype"],
                        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
                        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
                        "%FunctionPrototype%": ["Function", "prototype"],
                        "%Generator%": ["GeneratorFunction", "prototype"],
                        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
                        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
                        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
                        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
                        "%JSONParse%": ["JSON", "parse"],
                        "%JSONStringify%": ["JSON", "stringify"],
                        "%MapPrototype%": ["Map", "prototype"],
                        "%NumberPrototype%": ["Number", "prototype"],
                        "%ObjectPrototype%": ["Object", "prototype"],
                        "%ObjProto_toString%": ["Object", "prototype", "toString"],
                        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
                        "%PromisePrototype%": ["Promise", "prototype"],
                        "%PromiseProto_then%": ["Promise", "prototype", "then"],
                        "%Promise_all%": ["Promise", "all"],
                        "%Promise_reject%": ["Promise", "reject"],
                        "%Promise_resolve%": ["Promise", "resolve"],
                        "%RangeErrorPrototype%": ["RangeError", "prototype"],
                        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
                        "%RegExpPrototype%": ["RegExp", "prototype"],
                        "%SetPrototype%": ["Set", "prototype"],
                        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
                        "%StringPrototype%": ["String", "prototype"],
                        "%SymbolPrototype%": ["Symbol", "prototype"],
                        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
                        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
                        "%TypeErrorPrototype%": ["TypeError", "prototype"],
                        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
                        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
                        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
                        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
                        "%URIErrorPrototype%": ["URIError", "prototype"],
                        "%WeakMapPrototype%": ["WeakMap", "prototype"],
                        "%WeakSetPrototype%": ["WeakSet", "prototype"]
                    },
                    S = n(6160),
                    E = n(7344),
                    C = S.call(Function.call, Array.prototype.concat),
                    T = S.call(Function.apply, Array.prototype.splice),
                    P = S.call(Function.call, String.prototype.replace),
                    R = S.call(Function.call, String.prototype.slice),
                    I = S.call(Function.call, RegExp.prototype.exec),
                    O = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
                    B = /\\(\\)?/g,
                    L = function(e, t) {
                        var n, r = e;
                        if (E(A, r) && (r = "%" + (n = A[r])[0] + "%"), E(_, r)) {
                            var i = _[r];
                            if (i === b && (i = w(r)), "undefined" === typeof i && !t) throw new c("intrinsic " + e + " exists, but is not available. Please file an issue!");
                            return {
                                alias: n,
                                name: r,
                                value: i
                            }
                        }
                        throw new l("intrinsic " + e + " does not exist!")
                    };
                e.exports = function(e, t) {
                    if ("string" !== typeof e || 0 === e.length) throw new c("intrinsic name must be a non-empty string");
                    if (arguments.length > 1 && "boolean" !== typeof t) throw new c('"allowMissing" argument must be a boolean');
                    if (null === I(/^%?[^%]*%?$/, e)) throw new l("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
                    var n = function(e) {
                            var t = R(e, 0, 1),
                                n = R(e, -1);
                            if ("%" === t && "%" !== n) throw new l("invalid intrinsic syntax, expected closing `%`");
                            if ("%" === n && "%" !== t) throw new l("invalid intrinsic syntax, expected opening `%`");
                            var r = [];
                            return P(e, O, (function(e, t, n, i) {
                                r[r.length] = n ? P(i, B, "$1") : t || e
                            })), r
                        }(e),
                        r = n.length > 0 ? n[0] : "",
                        i = L("%" + r + "%", t),
                        o = i.name,
                        a = i.value,
                        s = !1,
                        u = i.alias;
                    u && (r = u[0], T(n, C([0, 1], u)));
                    for (var d = 1, h = !0; d < n.length; d += 1) {
                        var f = n[d],
                            m = R(f, 0, 1),
                            g = R(f, -1);
                        if (('"' === m || "'" === m || "`" === m || '"' === g || "'" === g || "`" === g) && m !== g) throw new l("property names with quotes must have matching quotes");
                        if ("constructor" !== f && h || (s = !0), E(_, o = "%" + (r += "." + f) + "%")) a = _[o];
                        else if (null != a) {
                            if (!(f in a)) {
                                if (!t) throw new c("base intrinsic for " + e + " exists, but the property is not available.");
                                return
                            }
                            if (p && d + 1 >= n.length) {
                                var v = p(a, f);
                                a = (h = !!v) && "get" in v && !("originalValue" in v.get) ? v.get : a[f]
                            } else h = E(a, f), a = a[f];
                            h && !s && (_[o] = a)
                        }
                    }
                    return a
                }
            },
            6948: (e, t, n) => {
                "use strict";
                var r = n(6344)("%Object.getOwnPropertyDescriptor%", !0);
                if (r) try {
                    r([], "length")
                } catch (i) {
                    r = null
                }
                e.exports = r
            },
            3168: e => {
                "use strict";
                var t = "undefined" !== typeof BigInt && BigInt;
                e.exports = function() {
                    return "function" === typeof t && "function" === typeof BigInt && "bigint" === typeof t(42) && "bigint" === typeof BigInt(42)
                }
            },
            1040: (e, t, n) => {
                "use strict";
                var r = n(3384),
                    i = function() {
                        return !!r
                    };
                i.hasArrayLengthDefineBug = function() {
                    if (!r) return null;
                    try {
                        return 1 !== r([], "length", {
                            value: 1
                        }).length
                    } catch (e) {
                        return !0
                    }
                }, e.exports = i
            },
            3588: e => {
                "use strict";
                var t = {
                        foo: {}
                    },
                    n = Object;
                e.exports = function() {
                    return {
                        __proto__: t
                    }.foo === t.foo && !({
                            __proto__: null
                        }
                        instanceof n)
                }
            },
            7740: (e, t, n) => {
                "use strict";
                var r = "undefined" !== typeof Symbol && Symbol,
                    i = n(472);
                e.exports = function() {
                    return "function" === typeof r && ("function" === typeof Symbol && ("symbol" === typeof r("foo") && ("symbol" === typeof Symbol("bar") && i())))
                }
            },
            472: e => {
                "use strict";
                e.exports = function() {
                    if ("function" !== typeof Symbol || "function" !== typeof Object.getOwnPropertySymbols) return !1;
                    if ("symbol" === typeof Symbol.iterator) return !0;
                    var e = {},
                        t = Symbol("test"),
                        n = Object(t);
                    if ("string" === typeof t) return !1;
                    if ("[object Symbol]" !== Object.prototype.toString.call(t)) return !1;
                    if ("[object Symbol]" !== Object.prototype.toString.call(n)) return !1;
                    for (t in e[t] = 42, e) return !1;
                    if ("function" === typeof Object.keys && 0 !== Object.keys(e).length) return !1;
                    if ("function" === typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(e).length) return !1;
                    var r = Object.getOwnPropertySymbols(e);
                    if (1 !== r.length || r[0] !== t) return !1;
                    if (!Object.prototype.propertyIsEnumerable.call(e, t)) return !1;
                    if ("function" === typeof Object.getOwnPropertyDescriptor) {
                        var i = Object.getOwnPropertyDescriptor(e, t);
                        if (42 !== i.value || !0 !== i.enumerable) return !1
                    }
                    return !0
                }
            },
            2728: (e, t, n) => {
                "use strict";
                var r = n(472);
                e.exports = function() {
                    return r() && !!Symbol.toStringTag
                }
            },
            7344: (e, t, n) => {
                "use strict";
                var r = Function.prototype.call,
                    i = Object.prototype.hasOwnProperty,
                    o = n(6160);
                e.exports = o.call(r, i)
            },
            6484: (e, t, n) => {
                "use strict";
                var r = n(7344),
                    i = n(5208)(),
                    o = n(7896),
                    a = {
                        assert: function(e, t) {
                            if (!e || "object" !== typeof e && "function" !== typeof e) throw new o("`O` is not an object");
                            if ("string" !== typeof t) throw new o("`slot` must be a string");
                            if (i.assert(e), !a.has(e, t)) throw new o("`" + t + "` is not present on `O`")
                        },
                        get: function(e, t) {
                            if (!e || "object" !== typeof e && "function" !== typeof e) throw new o("`O` is not an object");
                            if ("string" !== typeof t) throw new o("`slot` must be a string");
                            var n = i.get(e);
                            return n && n["$" + t]
                        },
                        has: function(e, t) {
                            if (!e || "object" !== typeof e && "function" !== typeof e) throw new o("`O` is not an object");
                            if ("string" !== typeof t) throw new o("`slot` must be a string");
                            var n = i.get(e);
                            return !!n && r(n, "$" + t)
                        },
                        set: function(e, t, n) {
                            if (!e || "object" !== typeof e && "function" !== typeof e) throw new o("`O` is not an object");
                            if ("string" !== typeof t) throw new o("`slot` must be a string");
                            var r = i.get(e);
                            r || (r = {}, i.set(e, r)), r["$" + t] = n
                        }
                    };
                Object.freeze && Object.freeze(a), e.exports = a
            },
            8512: (e, t, n) => {
                "use strict";
                var r = n(2728)(),
                    i = n(6396)("Object.prototype.toString"),
                    o = function(e) {
                        return !(r && e && "object" === typeof e && Symbol.toStringTag in e) && "[object Arguments]" === i(e)
                    },
                    a = function(e) {
                        return !!o(e) || null !== e && "object" === typeof e && "number" === typeof e.length && e.length >= 0 && "[object Array]" !== i(e) && "[object Function]" === i(e.callee)
                    },
                    s = function() {
                        return o(arguments)
                    }();
                o.isLegacyArguments = a, e.exports = s ? o : a
            },
            3596: (e, t, n) => {
                "use strict";
                var r = n(5520),
                    i = n(6396),
                    o = n(6344)("%ArrayBuffer%", !0),
                    a = i("ArrayBuffer.prototype.byteLength", !0),
                    s = i("Object.prototype.toString"),
                    l = !!o && !a && new o(0).slice,
                    c = !!l && r(l);
                e.exports = a || c ? function(e) {
                    if (!e || "object" !== typeof e) return !1;
                    try {
                        return a ? a(e) : c(e, 0), !0
                    } catch (t) {
                        return !1
                    }
                } : o ? function(e) {
                    return "[object ArrayBuffer]" === s(e)
                } : function(e) {
                    return !1
                }
            },
            9168: (e, t, n) => {
                "use strict";
                if (n(3168)()) {
                    var r = BigInt.prototype.valueOf;
                    e.exports = function(e) {
                        return null !== e && "undefined" !== typeof e && "boolean" !== typeof e && "string" !== typeof e && "number" !== typeof e && "symbol" !== typeof e && "function" !== typeof e && ("bigint" === typeof e || function(e) {
                            try {
                                return r.call(e), !0
                            } catch (t) {}
                            return !1
                        }(e))
                    }
                } else e.exports = function(e) {
                    return !1
                }
            },
            9120: (e, t, n) => {
                "use strict";
                var r = n(6396),
                    i = r("Boolean.prototype.toString"),
                    o = r("Object.prototype.toString"),
                    a = n(2728)();
                e.exports = function(e) {
                    return "boolean" === typeof e || null !== e && "object" === typeof e && (a && Symbol.toStringTag in e ? function(e) {
                        try {
                            return i(e), !0
                        } catch (t) {
                            return !1
                        }
                    }(e) : "[object Boolean]" === o(e))
                }
            },
            5332: e => {
                "use strict";
                var t, n, r = Function.prototype.toString,
                    i = "object" === typeof Reflect && null !== Reflect && Reflect.apply;
                if ("function" === typeof i && "function" === typeof Object.defineProperty) try {
                    t = Object.defineProperty({}, "length", {
                        get: function() {
                            throw n
                        }
                    }), n = {}, i((function() {
                        throw 42
                    }), null, t)
                } catch (p) {
                    p !== n && (i = null)
                } else i = null;
                var o = /^\s*class\b/,
                    a = function(e) {
                        try {
                            var t = r.call(e);
                            return o.test(t)
                        } catch (n) {
                            return !1
                        }
                    },
                    s = function(e) {
                        try {
                            return !a(e) && (r.call(e), !0)
                        } catch (t) {
                            return !1
                        }
                    },
                    l = Object.prototype.toString,
                    c = "function" === typeof Symbol && !!Symbol.toStringTag,
                    u = !(0 in [, ]),
                    d = function() {
                        return !1
                    };
                if ("object" === typeof document) {
                    var h = document.all;
                    l.call(h) === l.call(document.all) && (d = function(e) {
                        if ((u || !e) && ("undefined" === typeof e || "object" === typeof e)) try {
                            var t = l.call(e);
                            return ("[object HTMLAllCollection]" === t || "[object HTML document.all class]" === t || "[object HTMLCollection]" === t || "[object Object]" === t) && null == e("")
                        } catch (n) {}
                        return !1
                    })
                }
                e.exports = i ? function(e) {
                    if (d(e)) return !0;
                    if (!e) return !1;
                    if ("function" !== typeof e && "object" !== typeof e) return !1;
                    try {
                        i(e, null, t)
                    } catch (r) {
                        if (r !== n) return !1
                    }
                    return !a(e) && s(e)
                } : function(e) {
                    if (d(e)) return !0;
                    if (!e) return !1;
                    if ("function" !== typeof e && "object" !== typeof e) return !1;
                    if (c) return s(e);
                    if (a(e)) return !1;
                    var t = l.call(e);
                    return !("[object Function]" !== t && "[object GeneratorFunction]" !== t && !/^\[object HTML/.test(t)) && s(e)
                }
            },
            5028: (e, t, n) => {
                "use strict";
                var r = Date.prototype.getDay,
                    i = Object.prototype.toString,
                    o = n(2728)();
                e.exports = function(e) {
                    return "object" === typeof e && null !== e && (o ? function(e) {
                        try {
                            return r.call(e), !0
                        } catch (t) {
                            return !1
                        }
                    }(e) : "[object Date]" === i.call(e))
                }
            },
            3612: e => {
                "use strict";
                var t, n = "function" === typeof Map && Map.prototype ? Map : null,
                    r = "function" === typeof Set && Set.prototype ? Set : null;
                n || (t = function(e) {
                    return !1
                });
                var i = n ? Map.prototype.has : null,
                    o = r ? Set.prototype.has : null;
                t || i || (t = function(e) {
                    return !1
                }), e.exports = t || function(e) {
                    if (!e || "object" !== typeof e) return !1;
                    try {
                        if (i.call(e), o) try {
                            o.call(e)
                        } catch (t) {
                            return !0
                        }
                        return e instanceof n
                    } catch (t) {}
                    return !1
                }
            },
            9212: (e, t, n) => {
                "use strict";
                var r = Number.prototype.toString,
                    i = Object.prototype.toString,
                    o = n(2728)();
                e.exports = function(e) {
                    return "number" === typeof e || "object" === typeof e && (o ? function(e) {
                        try {
                            return r.call(e), !0
                        } catch (t) {
                            return !1
                        }
                    }(e) : "[object Number]" === i.call(e))
                }
            },
            6420: (e, t, n) => {
                "use strict";
                var r, i, o, a, s = n(6396),
                    l = n(2728)();
                if (l) {
                    r = s("Object.prototype.hasOwnProperty"), i = s("RegExp.prototype.exec"), o = {};
                    var c = function() {
                        throw o
                    };
                    a = {
                        toString: c,
                        valueOf: c
                    }, "symbol" === typeof Symbol.toPrimitive && (a[Symbol.toPrimitive] = c)
                }
                var u = s("Object.prototype.toString"),
                    d = Object.getOwnPropertyDescriptor;
                e.exports = l ? function(e) {
                    if (!e || "object" !== typeof e) return !1;
                    var t = d(e, "lastIndex");
                    if (!(t && r(t, "value"))) return !1;
                    try {
                        i(e, a)
                    } catch (n) {
                        return n === o
                    }
                } : function(e) {
                    return !(!e || "object" !== typeof e && "function" !== typeof e) && "[object RegExp]" === u(e)
                }
            },
            32: e => {
                "use strict";
                var t, n = "function" === typeof Map && Map.prototype ? Map : null,
                    r = "function" === typeof Set && Set.prototype ? Set : null;
                r || (t = function(e) {
                    return !1
                });
                var i = n ? Map.prototype.has : null,
                    o = r ? Set.prototype.has : null;
                t || o || (t = function(e) {
                    return !1
                }), e.exports = t || function(e) {
                    if (!e || "object" !== typeof e) return !1;
                    try {
                        if (o.call(e), i) try {
                            i.call(e)
                        } catch (t) {
                            return !0
                        }
                        return e instanceof r
                    } catch (t) {}
                    return !1
                }
            },
            2952: (e, t, n) => {
                "use strict";
                var r = n(6396)("SharedArrayBuffer.prototype.byteLength", !0);
                e.exports = r ? function(e) {
                    if (!e || "object" !== typeof e) return !1;
                    try {
                        return r(e), !0
                    } catch (t) {
                        return !1
                    }
                } : function(e) {
                    return !1
                }
            },
            5224: (e, t, n) => {
                "use strict";
                var r = String.prototype.valueOf,
                    i = Object.prototype.toString,
                    o = n(2728)();
                e.exports = function(e) {
                    return "string" === typeof e || "object" === typeof e && (o ? function(e) {
                        try {
                            return r.call(e), !0
                        } catch (t) {
                            return !1
                        }
                    }(e) : "[object String]" === i.call(e))
                }
            },
            3960: (e, t, n) => {
                "use strict";
                var r = Object.prototype.toString;
                if (n(7740)()) {
                    var i = Symbol.prototype.toString,
                        o = /^Symbol\(.*\)$/;
                    e.exports = function(e) {
                        if ("symbol" === typeof e) return !0;
                        if ("[object Symbol]" !== r.call(e)) return !1;
                        try {
                            return function(e) {
                                return "symbol" === typeof e.valueOf() && o.test(i.call(e))
                            }(e)
                        } catch (t) {
                            return !1
                        }
                    }
                } else e.exports = function(e) {
                    return !1
                }
            },
            6968: e => {
                "use strict";
                var t, n = "function" === typeof WeakMap && WeakMap.prototype ? WeakMap : null,
                    r = "function" === typeof WeakSet && WeakSet.prototype ? WeakSet : null;
                n || (t = function(e) {
                    return !1
                });
                var i = n ? n.prototype.has : null,
                    o = r ? r.prototype.has : null;
                t || i || (t = function(e) {
                    return !1
                }), e.exports = t || function(e) {
                    if (!e || "object" !== typeof e) return !1;
                    try {
                        if (i.call(e, i), o) try {
                            o.call(e, o)
                        } catch (t) {
                            return !0
                        }
                        return e instanceof n
                    } catch (t) {}
                    return !1
                }
            },
            8332: (e, t, n) => {
                "use strict";
                var r = n(6344),
                    i = n(6396),
                    o = r("%WeakSet%", !0),
                    a = i("WeakSet.prototype.has", !0);
                if (a) {
                    var s = i("WeakMap.prototype.has", !0);
                    e.exports = function(e) {
                        if (!e || "object" !== typeof e) return !1;
                        try {
                            if (a(e, a), s) try {
                                s(e, s)
                            } catch (t) {
                                return !0
                            }
                            return e instanceof o
                        } catch (t) {}
                        return !1
                    }
                } else e.exports = function(e) {
                    return !1
                }
            },
            5399: e => {
                var t = {}.toString;
                e.exports = Array.isArray || function(e) {
                    return "[object Array]" == t.call(e)
                }
            },
            6711: (e, t, n) => {
                var r, i = function() {
                    var e = String.fromCharCode,
                        t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                        n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$",
                        r = {};

                    function i(e, t) {
                        if (!r[e]) {
                            r[e] = {};
                            for (var n = 0; n < e.length; n++) r[e][e.charAt(n)] = n
                        }
                        return r[e][t]
                    }
                    var o = {
                        compressToBase64: function(e) {
                            if (null == e) return "";
                            var n = o._compress(e, 6, (function(e) {
                                return t.charAt(e)
                            }));
                            switch (n.length % 4) {
                                default:
                                    case 0:
                                    return n;
                                case 1:
                                        return n + "===";
                                case 2:
                                        return n + "==";
                                case 3:
                                        return n + "="
                            }
                        },
                        decompressFromBase64: function(e) {
                            return null == e ? "" : "" == e ? null : o._decompress(e.length, 32, (function(n) {
                                return i(t, e.charAt(n))
                            }))
                        },
                        compressToUTF16: function(t) {
                            return null == t ? "" : o._compress(t, 15, (function(t) {
                                return e(t + 32)
                            })) + " "
                        },
                        decompressFromUTF16: function(e) {
                            return null == e ? "" : "" == e ? null : o._decompress(e.length, 16384, (function(t) {
                                return e.charCodeAt(t) - 32
                            }))
                        },
                        compressToUint8Array: function(e) {
                            for (var t = o.compress(e), n = new Uint8Array(2 * t.length), r = 0, i = t.length; r < i; r++) {
                                var a = t.charCodeAt(r);
                                n[2 * r] = a >>> 8, n[2 * r + 1] = a % 256
                            }
                            return n
                        },
                        decompressFromUint8Array: function(t) {
                            if (null === t || void 0 === t) return o.decompress(t);
                            for (var n = new Array(t.length / 2), r = 0, i = n.length; r < i; r++) n[r] = 256 * t[2 * r] + t[2 * r + 1];
                            var a = [];
                            return n.forEach((function(t) {
                                a.push(e(t))
                            })), o.decompress(a.join(""))
                        },
                        compressToEncodedURIComponent: function(e) {
                            return null == e ? "" : o._compress(e, 6, (function(e) {
                                return n.charAt(e)
                            }))
                        },
                        decompressFromEncodedURIComponent: function(e) {
                            return null == e ? "" : "" == e ? null : (e = e.replace(/ /g, "+"), o._decompress(e.length, 32, (function(t) {
                                return i(n, e.charAt(t))
                            })))
                        },
                        compress: function(t) {
                            return o._compress(t, 16, (function(t) {
                                return e(t)
                            }))
                        },
                        _compress: function(e, t, n) {
                            if (null == e) return "";
                            var r, i, o, a = {},
                                s = {},
                                l = "",
                                c = "",
                                u = "",
                                d = 2,
                                h = 3,
                                p = 2,
                                f = [],
                                m = 0,
                                g = 0;
                            for (o = 0; o < e.length; o += 1)
                                if (l = e.charAt(o), Object.prototype.hasOwnProperty.call(a, l) || (a[l] = h++, s[l] = !0), c = u + l, Object.prototype.hasOwnProperty.call(a, c)) u = c;
                                else {
                                    if (Object.prototype.hasOwnProperty.call(s, u)) {
                                        if (u.charCodeAt(0) < 256) {
                                            for (r = 0; r < p; r++) m <<= 1, g == t - 1 ? (g = 0, f.push(n(m)), m = 0) : g++;
                                            for (i = u.charCodeAt(0), r = 0; r < 8; r++) m = m << 1 | 1 & i, g == t - 1 ? (g = 0, f.push(n(m)), m = 0) : g++, i >>= 1
                                        } else {
                                            for (i = 1, r = 0; r < p; r++) m = m << 1 | i, g == t - 1 ? (g = 0, f.push(n(m)), m = 0) : g++, i = 0;
                                            for (i = u.charCodeAt(0), r = 0; r < 16; r++) m = m << 1 | 1 & i, g == t - 1 ? (g = 0, f.push(n(m)), m = 0) : g++, i >>= 1
                                        }
                                        0 == --d && (d = Math.pow(2, p), p++), delete s[u]
                                    } else
                                        for (i = a[u], r = 0; r < p; r++) m = m << 1 | 1 & i, g == t - 1 ? (g = 0, f.push(n(m)), m = 0) : g++, i >>= 1;
                                    0 == --d && (d = Math.pow(2, p), p++), a[c] = h++, u = String(l)
                                }
                            if ("" !== u) {
                                if (Object.prototype.hasOwnProperty.call(s, u)) {
                                    if (u.charCodeAt(0) < 256) {
                                        for (r = 0; r < p; r++) m <<= 1, g == t - 1 ? (g = 0, f.push(n(m)), m = 0) : g++;
                                        for (i = u.charCodeAt(0), r = 0; r < 8; r++) m = m << 1 | 1 & i, g == t - 1 ? (g = 0, f.push(n(m)), m = 0) : g++, i >>= 1
                                    } else {
                                        for (i = 1, r = 0; r < p; r++) m = m << 1 | i, g == t - 1 ? (g = 0, f.push(n(m)), m = 0) : g++, i = 0;
                                        for (i = u.charCodeAt(0), r = 0; r < 16; r++) m = m << 1 | 1 & i, g == t - 1 ? (g = 0, f.push(n(m)), m = 0) : g++, i >>= 1
                                    }
                                    0 == --d && (d = Math.pow(2, p), p++), delete s[u]
                                } else
                                    for (i = a[u], r = 0; r < p; r++) m = m << 1 | 1 & i, g == t - 1 ? (g = 0, f.push(n(m)), m = 0) : g++, i >>= 1;
                                0 == --d && (d = Math.pow(2, p), p++)
                            }
                            for (i = 2, r = 0; r < p; r++) m = m << 1 | 1 & i, g == t - 1 ? (g = 0, f.push(n(m)), m = 0) : g++, i >>= 1;
                            for (;;) {
                                if (m <<= 1, g == t - 1) {
                                    f.push(n(m));
                                    break
                                }
                                g++
                            }
                            return f.join("")
                        },
                        decompress: function(e) {
                            return null == e ? "" : "" == e ? null : o._decompress(e.length, 32768, (function(t) {
                                return e.charCodeAt(t)
                            }))
                        },
                        _decompress: function(t, n, r) {
                            var i, o, a, s, l, c, u, d = [],
                                h = 4,
                                p = 4,
                                f = 3,
                                m = "",
                                g = [],
                                v = {
                                    val: r(0),
                                    position: n,
                                    index: 1
                                };
                            for (i = 0; i < 3; i += 1) d[i] = i;
                            for (a = 0, l = Math.pow(2, 2), c = 1; c != l;) s = v.val & v.position, v.position >>= 1, 0 == v.position && (v.position = n, v.val = r(v.index++)), a |= (s > 0 ? 1 : 0) * c, c <<= 1;
                            switch (a) {
                                case 0:
                                    for (a = 0, l = Math.pow(2, 8), c = 1; c != l;) s = v.val & v.position, v.position >>= 1, 0 == v.position && (v.position = n, v.val = r(v.index++)), a |= (s > 0 ? 1 : 0) * c, c <<= 1;
                                    u = e(a);
                                    break;
                                case 1:
                                    for (a = 0, l = Math.pow(2, 16), c = 1; c != l;) s = v.val & v.position, v.position >>= 1, 0 == v.position && (v.position = n, v.val = r(v.index++)), a |= (s > 0 ? 1 : 0) * c, c <<= 1;
                                    u = e(a);
                                    break;
                                case 2:
                                    return ""
                            }
                            for (d[3] = u, o = u, g.push(u);;) {
                                if (v.index > t) return "";
                                for (a = 0, l = Math.pow(2, f), c = 1; c != l;) s = v.val & v.position, v.position >>= 1, 0 == v.position && (v.position = n, v.val = r(v.index++)), a |= (s > 0 ? 1 : 0) * c, c <<= 1;
                                switch (u = a) {
                                    case 0:
                                        for (a = 0, l = Math.pow(2, 8), c = 1; c != l;) s = v.val & v.position, v.position >>= 1, 0 == v.position && (v.position = n, v.val = r(v.index++)), a |= (s > 0 ? 1 : 0) * c, c <<= 1;
                                        d[p++] = e(a), u = p - 1, h--;
                                        break;
                                    case 1:
                                        for (a = 0, l = Math.pow(2, 16), c = 1; c != l;) s = v.val & v.position, v.position >>= 1, 0 == v.position && (v.position = n, v.val = r(v.index++)), a |= (s > 0 ? 1 : 0) * c, c <<= 1;
                                        d[p++] = e(a), u = p - 1, h--;
                                        break;
                                    case 2:
                                        return g.join("")
                                }
                                if (0 == h && (h = Math.pow(2, f), f++), d[u]) m = d[u];
                                else {
                                    if (u !== p) return null;
                                    m = o + o.charAt(0)
                                }
                                g.push(m), d[p++] = o + m.charAt(0), o = m, 0 == --h && (h = Math.pow(2, f), f++)
                            }
                        }
                    };
                    return o
                }();
                void 0 === (r = function() {
                    return i
                }.call(t, n, t, e)) || (e.exports = r)
            },
            3136: (e, t, n) => {
                var r = "function" === typeof Map && Map.prototype,
                    i = Object.getOwnPropertyDescriptor && r ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null,
                    o = r && i && "function" === typeof i.get ? i.get : null,
                    a = r && Map.prototype.forEach,
                    s = "function" === typeof Set && Set.prototype,
                    l = Object.getOwnPropertyDescriptor && s ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null,
                    c = s && l && "function" === typeof l.get ? l.get : null,
                    u = s && Set.prototype.forEach,
                    d = "function" === typeof WeakMap && WeakMap.prototype ? WeakMap.prototype.has : null,
                    h = "function" === typeof WeakSet && WeakSet.prototype ? WeakSet.prototype.has : null,
                    p = "function" === typeof WeakRef && WeakRef.prototype ? WeakRef.prototype.deref : null,
                    f = Boolean.prototype.valueOf,
                    m = Object.prototype.toString,
                    g = Function.prototype.toString,
                    v = String.prototype.match,
                    y = String.prototype.slice,
                    b = String.prototype.replace,
                    x = String.prototype.toUpperCase,
                    _ = String.prototype.toLowerCase,
                    M = RegExp.prototype.test,
                    w = Array.prototype.concat,
                    A = Array.prototype.join,
                    S = Array.prototype.slice,
                    E = Math.floor,
                    C = "function" === typeof BigInt ? BigInt.prototype.valueOf : null,
                    T = Object.getOwnPropertySymbols,
                    P = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? Symbol.prototype.toString : null,
                    R = "function" === typeof Symbol && "object" === typeof Symbol.iterator,
                    I = "function" === typeof Symbol && Symbol.toStringTag && (typeof Symbol.toStringTag === R || "symbol") ? Symbol.toStringTag : null,
                    O = Object.prototype.propertyIsEnumerable,
                    B = ("function" === typeof Reflect ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(e) {
                        return e.__proto__
                    } : null);

                function L(e, t) {
                    if (e === 1 / 0 || e === -1 / 0 || e !== e || e && e > -1e3 && e < 1e3 || M.call(/e/, t)) return t;
                    var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
                    if ("number" === typeof e) {
                        var r = e < 0 ? -E(-e) : E(e);
                        if (r !== e) {
                            var i = String(r),
                                o = y.call(t, i.length + 1);
                            return b.call(i, n, "$&_") + "." + b.call(b.call(o, /([0-9]{3})/g, "$&_"), /_$/, "")
                        }
                    }
                    return b.call(t, n, "$&_")
                }
                var D = n(6204),
                    N = D.custom,
                    k = j(N) ? N : null;

                function F(e, t, n) {
                    var r = "double" === (n.quoteStyle || t) ? '"' : "'";
                    return r + e + r
                }

                function U(e) {
                    return b.call(String(e), /"/g, "&quot;")
                }

                function z(e) {
                    return "[object Array]" === q(e) && (!I || !("object" === typeof e && I in e))
                }

                function H(e) {
                    return "[object RegExp]" === q(e) && (!I || !("object" === typeof e && I in e))
                }

                function j(e) {
                    if (R) return e && "object" === typeof e && e instanceof Symbol;
                    if ("symbol" === typeof e) return !0;
                    if (!e || "object" !== typeof e || !P) return !1;
                    try {
                        return P.call(e), !0
                    } catch (t) {}
                    return !1
                }
                e.exports = function e(t, r, i, s) {
                    var l = r || {};
                    if (V(l, "quoteStyle") && "single" !== l.quoteStyle && "double" !== l.quoteStyle) throw new TypeError('option "quoteStyle" must be "single" or "double"');
                    if (V(l, "maxStringLength") && ("number" === typeof l.maxStringLength ? l.maxStringLength < 0 && l.maxStringLength !== 1 / 0 : null !== l.maxStringLength)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
                    var m = !V(l, "customInspect") || l.customInspect;
                    if ("boolean" !== typeof m && "symbol" !== m) throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
                    if (V(l, "indent") && null !== l.indent && "\t" !== l.indent && !(parseInt(l.indent, 10) === l.indent && l.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
                    if (V(l, "numericSeparator") && "boolean" !== typeof l.numericSeparator) throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
                    var x = l.numericSeparator;
                    if ("undefined" === typeof t) return "undefined";
                    if (null === t) return "null";
                    if ("boolean" === typeof t) return t ? "true" : "false";
                    if ("string" === typeof t) return X(t, l);
                    if ("number" === typeof t) {
                        if (0 === t) return 1 / 0 / t > 0 ? "0" : "-0";
                        var M = String(t);
                        return x ? L(t, M) : M
                    }
                    if ("bigint" === typeof t) {
                        var E = String(t) + "n";
                        return x ? L(t, E) : E
                    }
                    var T = "undefined" === typeof l.depth ? 5 : l.depth;
                    if ("undefined" === typeof i && (i = 0), i >= T && T > 0 && "object" === typeof t) return z(t) ? "[Array]" : "[Object]";
                    var N = function(e, t) {
                        var n;
                        if ("\t" === e.indent) n = "\t";
                        else {
                            if (!("number" === typeof e.indent && e.indent > 0)) return null;
                            n = A.call(Array(e.indent + 1), " ")
                        }
                        return {
                            base: n,
                            prev: A.call(Array(t + 1), n)
                        }
                    }(l, i);
                    if ("undefined" === typeof s) s = [];
                    else if (W(s, t) >= 0) return "[Circular]";

                    function G(t, n, r) {
                        if (n && (s = S.call(s)).push(n), r) {
                            var o = {
                                depth: l.depth
                            };
                            return V(l, "quoteStyle") && (o.quoteStyle = l.quoteStyle), e(t, o, i + 1, s)
                        }
                        return e(t, l, i + 1, s)
                    }
                    if ("function" === typeof t && !H(t)) {
                        var K = function(e) {
                                if (e.name) return e.name;
                                var t = v.call(g.call(e), /^function\s*([\w$]+)/);
                                if (t) return t[1];
                                return null
                            }(t),
                            ee = $(t, G);
                        return "[Function" + (K ? ": " + K : " (anonymous)") + "]" + (ee.length > 0 ? " { " + A.call(ee, ", ") + " }" : "")
                    }
                    if (j(t)) {
                        var te = R ? b.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1") : P.call(t);
                        return "object" !== typeof t || R ? te : J(te)
                    }
                    if (function(e) {
                            if (!e || "object" !== typeof e) return !1;
                            if ("undefined" !== typeof HTMLElement && e instanceof HTMLElement) return !0;
                            return "string" === typeof e.nodeName && "function" === typeof e.getAttribute
                        }(t)) {
                        for (var ne = "<" + _.call(String(t.nodeName)), re = t.attributes || [], ie = 0; ie < re.length; ie++) ne += " " + re[ie].name + "=" + F(U(re[ie].value), "double", l);
                        return ne += ">", t.childNodes && t.childNodes.length && (ne += "..."), ne += "</" + _.call(String(t.nodeName)) + ">"
                    }
                    if (z(t)) {
                        if (0 === t.length) return "[]";
                        var oe = $(t, G);
                        return N && ! function(e) {
                            for (var t = 0; t < e.length; t++)
                                if (W(e[t], "\n") >= 0) return !1;
                            return !0
                        }(oe) ? "[" + Z(oe, N) + "]" : "[ " + A.call(oe, ", ") + " ]"
                    }
                    if (function(e) {
                            return "[object Error]" === q(e) && (!I || !("object" === typeof e && I in e))
                        }(t)) {
                        var ae = $(t, G);
                        return "cause" in Error.prototype || !("cause" in t) || O.call(t, "cause") ? 0 === ae.length ? "[" + String(t) + "]" : "{ [" + String(t) + "] " + A.call(ae, ", ") + " }" : "{ [" + String(t) + "] " + A.call(w.call("[cause]: " + G(t.cause), ae), ", ") + " }"
                    }
                    if ("object" === typeof t && m) {
                        if (k && "function" === typeof t[k] && D) return D(t, {
                            depth: T - i
                        });
                        if ("symbol" !== m && "function" === typeof t.inspect) return t.inspect()
                    }
                    if (function(e) {
                            if (!o || !e || "object" !== typeof e) return !1;
                            try {
                                o.call(e);
                                try {
                                    c.call(e)
                                } catch (ne) {
                                    return !0
                                }
                                return e instanceof Map
                            } catch (t) {}
                            return !1
                        }(t)) {
                        var se = [];
                        return a && a.call(t, (function(e, n) {
                            se.push(G(n, t, !0) + " => " + G(e, t))
                        })), Q("Map", o.call(t), se, N)
                    }
                    if (function(e) {
                            if (!c || !e || "object" !== typeof e) return !1;
                            try {
                                c.call(e);
                                try {
                                    o.call(e)
                                } catch (t) {
                                    return !0
                                }
                                return e instanceof Set
                            } catch (n) {}
                            return !1
                        }(t)) {
                        var le = [];
                        return u && u.call(t, (function(e) {
                            le.push(G(e, t))
                        })), Q("Set", c.call(t), le, N)
                    }
                    if (function(e) {
                            if (!d || !e || "object" !== typeof e) return !1;
                            try {
                                d.call(e, d);
                                try {
                                    h.call(e, h)
                                } catch (ne) {
                                    return !0
                                }
                                return e instanceof WeakMap
                            } catch (t) {}
                            return !1
                        }(t)) return Y("WeakMap");
                    if (function(e) {
                            if (!h || !e || "object" !== typeof e) return !1;
                            try {
                                h.call(e, h);
                                try {
                                    d.call(e, d)
                                } catch (ne) {
                                    return !0
                                }
                                return e instanceof WeakSet
                            } catch (t) {}
                            return !1
                        }(t)) return Y("WeakSet");
                    if (function(e) {
                            if (!p || !e || "object" !== typeof e) return !1;
                            try {
                                return p.call(e), !0
                            } catch (t) {}
                            return !1
                        }(t)) return Y("WeakRef");
                    if (function(e) {
                            return "[object Number]" === q(e) && (!I || !("object" === typeof e && I in e))
                        }(t)) return J(G(Number(t)));
                    if (function(e) {
                            if (!e || "object" !== typeof e || !C) return !1;
                            try {
                                return C.call(e), !0
                            } catch (t) {}
                            return !1
                        }(t)) return J(G(C.call(t)));
                    if (function(e) {
                            return "[object Boolean]" === q(e) && (!I || !("object" === typeof e && I in e))
                        }(t)) return J(f.call(t));
                    if (function(e) {
                            return "[object String]" === q(e) && (!I || !("object" === typeof e && I in e))
                        }(t)) return J(G(String(t)));
                    if ("undefined" !== typeof window && t === window) return "{ [object Window] }";
                    if (t === n.g) return "{ [object globalThis] }";
                    if (! function(e) {
                            return "[object Date]" === q(e) && (!I || !("object" === typeof e && I in e))
                        }(t) && !H(t)) {
                        var ce = $(t, G),
                            ue = B ? B(t) === Object.prototype : t instanceof Object || t.constructor === Object,
                            de = t instanceof Object ? "" : "null prototype",
                            he = !ue && I && Object(t) === t && I in t ? y.call(q(t), 8, -1) : de ? "Object" : "",
                            pe = (ue || "function" !== typeof t.constructor ? "" : t.constructor.name ? t.constructor.name + " " : "") + (he || de ? "[" + A.call(w.call([], he || [], de || []), ": ") + "] " : "");
                        return 0 === ce.length ? pe + "{}" : N ? pe + "{" + Z(ce, N) + "}" : pe + "{ " + A.call(ce, ", ") + " }"
                    }
                    return String(t)
                };
                var G = Object.prototype.hasOwnProperty || function(e) {
                    return e in this
                };

                function V(e, t) {
                    return G.call(e, t)
                }

                function q(e) {
                    return m.call(e)
                }

                function W(e, t) {
                    if (e.indexOf) return e.indexOf(t);
                    for (var n = 0, r = e.length; n < r; n++)
                        if (e[n] === t) return n;
                    return -1
                }

                function X(e, t) {
                    if (e.length > t.maxStringLength) {
                        var n = e.length - t.maxStringLength,
                            r = "... " + n + " more character" + (n > 1 ? "s" : "");
                        return X(y.call(e, 0, t.maxStringLength), t) + r
                    }
                    return F(b.call(b.call(e, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, K), "single", t)
                }

                function K(e) {
                    var t = e.charCodeAt(0),
                        n = {
                            8: "b",
                            9: "t",
                            10: "n",
                            12: "f",
                            13: "r"
                        }[t];
                    return n ? "\\" + n : "\\x" + (t < 16 ? "0" : "") + x.call(t.toString(16))
                }

                function J(e) {
                    return "Object(" + e + ")"
                }

                function Y(e) {
                    return e + " { ? }"
                }

                function Q(e, t, n, r) {
                    return e + " (" + t + ") {" + (r ? Z(n, r) : A.call(n, ", ")) + "}"
                }

                function Z(e, t) {
                    if (0 === e.length) return "";
                    var n = "\n" + t.prev + t.base;
                    return n + A.call(e, "," + n) + "\n" + t.prev
                }

                function $(e, t) {
                    var n = z(e),
                        r = [];
                    if (n) {
                        r.length = e.length;
                        for (var i = 0; i < e.length; i++) r[i] = V(e, i) ? t(e[i], e) : ""
                    }
                    var o, a = "function" === typeof T ? T(e) : [];
                    if (R) {
                        o = {};
                        for (var s = 0; s < a.length; s++) o["$" + a[s]] = a[s]
                    }
                    for (var l in e) V(e, l) && (n && String(Number(l)) === l && l < e.length || R && o["$" + l] instanceof Symbol || (M.call(/[^\w$]/, l) ? r.push(t(l, e) + ": " + t(e[l], e)) : r.push(l + ": " + t(e[l], e))));
                    if ("function" === typeof T)
                        for (var c = 0; c < a.length; c++) O.call(e, a[c]) && r.push("[" + t(a[c]) + "]: " + t(e[a[c]], e));
                    return r
                }
            },
            6412: e => {
                "use strict";
                var t = function(e) {
                    return e !== e
                };
                e.exports = function(e, n) {
                    return 0 === e && 0 === n ? 1 / e === 1 / n : e === n || !(!t(e) || !t(n))
                }
            },
            7360: (e, t, n) => {
                "use strict";
                var r = n(108),
                    i = n(5520),
                    o = n(6412),
                    a = n(2816),
                    s = n(9800),
                    l = i(a(), Object);
                r(l, {
                    getPolyfill: a,
                    implementation: o,
                    shim: s
                }), e.exports = l
            },
            2816: (e, t, n) => {
                "use strict";
                var r = n(6412);
                e.exports = function() {
                    return "function" === typeof Object.is ? Object.is : r
                }
            },
            9800: (e, t, n) => {
                "use strict";
                var r = n(2816),
                    i = n(108);
                e.exports = function() {
                    var e = r();
                    return i(Object, {
                        is: e
                    }, {
                        is: function() {
                            return Object.is !== e
                        }
                    }), e
                }
            },
            9488: (e, t, n) => {
                "use strict";
                var r;
                if (!Object.keys) {
                    var i = Object.prototype.hasOwnProperty,
                        o = Object.prototype.toString,
                        a = n(2048),
                        s = Object.prototype.propertyIsEnumerable,
                        l = !s.call({
                            toString: null
                        }, "toString"),
                        c = s.call((function() {}), "prototype"),
                        u = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"],
                        d = function(e) {
                            var t = e.constructor;
                            return t && t.prototype === e
                        },
                        h = {
                            $applicationCache: !0,
                            $console: !0,
                            $external: !0,
                            $frame: !0,
                            $frameElement: !0,
                            $frames: !0,
                            $innerHeight: !0,
                            $innerWidth: !0,
                            $onmozfullscreenchange: !0,
                            $onmozfullscreenerror: !0,
                            $outerHeight: !0,
                            $outerWidth: !0,
                            $pageXOffset: !0,
                            $pageYOffset: !0,
                            $parent: !0,
                            $scrollLeft: !0,
                            $scrollTop: !0,
                            $scrollX: !0,
                            $scrollY: !0,
                            $self: !0,
                            $webkitIndexedDB: !0,
                            $webkitStorageInfo: !0,
                            $window: !0
                        },
                        p = function() {
                            if ("undefined" === typeof window) return !1;
                            for (var e in window) try {
                                if (!h["$" + e] && i.call(window, e) && null !== window[e] && "object" === typeof window[e]) try {
                                    d(window[e])
                                } catch (t) {
                                    return !0
                                }
                            } catch (t) {
                                return !0
                            }
                            return !1
                        }();
                    r = function(e) {
                        var t = null !== e && "object" === typeof e,
                            n = "[object Function]" === o.call(e),
                            r = a(e),
                            s = t && "[object String]" === o.call(e),
                            h = [];
                        if (!t && !n && !r) throw new TypeError("Object.keys called on a non-object");
                        var f = c && n;
                        if (s && e.length > 0 && !i.call(e, 0))
                            for (var m = 0; m < e.length; ++m) h.push(String(m));
                        if (r && e.length > 0)
                            for (var g = 0; g < e.length; ++g) h.push(String(g));
                        else
                            for (var v in e) f && "prototype" === v || !i.call(e, v) || h.push(String(v));
                        if (l)
                            for (var y = function(e) {
                                    if ("undefined" === typeof window || !p) return d(e);
                                    try {
                                        return d(e)
                                    } catch (t) {
                                        return !1
                                    }
                                }(e), b = 0; b < u.length; ++b) y && "constructor" === u[b] || !i.call(e, u[b]) || h.push(u[b]);
                        return h
                    }
                }
                e.exports = r
            },
            8564: (e, t, n) => {
                "use strict";
                var r = Array.prototype.slice,
                    i = n(2048),
                    o = Object.keys,
                    a = o ? function(e) {
                        return o(e)
                    } : n(9488),
                    s = Object.keys;
                a.shim = function() {
                    if (Object.keys) {
                        var e = function() {
                            var e = Object.keys(arguments);
                            return e && e.length === arguments.length
                        }(1, 2);
                        e || (Object.keys = function(e) {
                            return i(e) ? s(r.call(e)) : s(e)
                        })
                    } else Object.keys = a;
                    return Object.keys || a
                }, e.exports = a
            },
            2048: e => {
                "use strict";
                var t = Object.prototype.toString;
                e.exports = function(e) {
                    var n = t.call(e),
                        r = "[object Arguments]" === n;
                    return r || (r = "[object Array]" !== n && null !== e && "object" === typeof e && "number" === typeof e.length && e.length >= 0 && "[object Function]" === t.call(e.callee)), r
                }
            },
            7700: (e, t, n) => {
                "use strict";
                var r = n(8564),
                    i = n(472)(),
                    o = n(6396),
                    a = Object,
                    s = o("Array.prototype.push"),
                    l = o("Object.prototype.propertyIsEnumerable"),
                    c = i ? Object.getOwnPropertySymbols : null;
                e.exports = function(e, t) {
                    if (null == e) throw new TypeError("target must be an object");
                    var n = a(e);
                    if (1 === arguments.length) return n;
                    for (var o = 1; o < arguments.length; ++o) {
                        var u = a(arguments[o]),
                            d = r(u),
                            h = i && (Object.getOwnPropertySymbols || c);
                        if (h)
                            for (var p = h(u), f = 0; f < p.length; ++f) {
                                var m = p[f];
                                l(u, m) && s(d, m)
                            }
                        for (var g = 0; g < d.length; ++g) {
                            var v = d[g];
                            if (l(u, v)) {
                                var y = u[v];
                                n[v] = y
                            }
                        }
                    }
                    return n
                }
            },
            2380: (e, t, n) => {
                "use strict";
                var r = n(108),
                    i = n(5520),
                    o = n(7700),
                    a = n(4584),
                    s = n(9272),
                    l = i.apply(a()),
                    c = function(e, t) {
                        return l(Object, arguments)
                    };
                r(c, {
                    getPolyfill: a,
                    implementation: o,
                    shim: s
                }), e.exports = c
            },
            4584: (e, t, n) => {
                "use strict";
                var r = n(7700);
                e.exports = function() {
                    return Object.assign ? function() {
                        if (!Object.assign) return !1;
                        for (var e = "abcdefghijklmnopqrst", t = e.split(""), n = {}, r = 0; r < t.length; ++r) n[t[r]] = t[r];
                        var i = Object.assign({}, n),
                            o = "";
                        for (var a in i) o += a;
                        return e !== o
                    }() || function() {
                        if (!Object.assign || !Object.preventExtensions) return !1;
                        var e = Object.preventExtensions({
                            1: 2
                        });
                        try {
                            Object.assign(e, "xy")
                        } catch (t) {
                            return "y" === e[1]
                        }
                        return !1
                    }() ? r : Object.assign : r
                }
            },
            9272: (e, t, n) => {
                "use strict";
                var r = n(108),
                    i = n(4584);
                e.exports = function() {
                    var e = i();
                    return r(Object, {
                        assign: e
                    }, {
                        assign: function() {
                            return Object.assign !== e
                        }
                    }), e
                }
            },
            5652: (e, t, n) => {
                "use strict";
                var r = n(9584),
                    i = n(8024);

                function o(e) {
                    for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++) t += "&args[]=" + encodeURIComponent(arguments[n]);
                    return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
                }
                var a = new Set,
                    s = {};

                function l(e, t) {
                    c(e, t), c(e + "Capture", t)
                }

                function c(e, t) {
                    for (s[e] = t, e = 0; e < t.length; e++) a.add(t[e])
                }
                var u = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement),
                    d = Object.prototype.hasOwnProperty,
                    h = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
                    p = {},
                    f = {};

                function m(e, t, n, r, i, o, a) {
                    this.acceptsBooleans = 2 === t || 3 === t || 4 === t, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = o, this.removeEmptyString = a
                }
                var g = {};
                "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e) {
                    g[e] = new m(e, 0, !1, e, null, !1, !1)
                })), [
                    ["acceptCharset", "accept-charset"],
                    ["className", "class"],
                    ["htmlFor", "for"],
                    ["httpEquiv", "http-equiv"]
                ].forEach((function(e) {
                    var t = e[0];
                    g[t] = new m(t, 1, !1, e[1], null, !1, !1)
                })), ["contentEditable", "draggable", "spellCheck", "value"].forEach((function(e) {
                    g[e] = new m(e, 2, !1, e.toLowerCase(), null, !1, !1)
                })), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach((function(e) {
                    g[e] = new m(e, 2, !1, e, null, !1, !1)
                })), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e) {
                    g[e] = new m(e, 3, !1, e.toLowerCase(), null, !1, !1)
                })), ["checked", "multiple", "muted", "selected"].forEach((function(e) {
                    g[e] = new m(e, 3, !0, e, null, !1, !1)
                })), ["capture", "download"].forEach((function(e) {
                    g[e] = new m(e, 4, !1, e, null, !1, !1)
                })), ["cols", "rows", "size", "span"].forEach((function(e) {
                    g[e] = new m(e, 6, !1, e, null, !1, !1)
                })), ["rowSpan", "start"].forEach((function(e) {
                    g[e] = new m(e, 5, !1, e.toLowerCase(), null, !1, !1)
                }));
                var v = /[\-:]([a-z])/g;

                function y(e) {
                    return e[1].toUpperCase()
                }

                function b(e, t, n, r) {
                    var i = g.hasOwnProperty(t) ? g[t] : null;
                    (null !== i ? 0 !== i.type : r || !(2 < t.length) || "o" !== t[0] && "O" !== t[0] || "n" !== t[1] && "N" !== t[1]) && (function(e, t, n, r) {
                        if (null === t || "undefined" === typeof t || function(e, t, n, r) {
                                if (null !== n && 0 === n.type) return !1;
                                switch (typeof t) {
                                    case "function":
                                    case "symbol":
                                        return !0;
                                    case "boolean":
                                        return !r && (null !== n ? !n.acceptsBooleans : "data-" !== (e = e.toLowerCase().slice(0, 5)) && "aria-" !== e);
                                    default:
                                        return !1
                                }
                            }(e, t, n, r)) return !0;
                        if (r) return !1;
                        if (null !== n) switch (n.type) {
                            case 3:
                                return !t;
                            case 4:
                                return !1 === t;
                            case 5:
                                return isNaN(t);
                            case 6:
                                return isNaN(t) || 1 > t
                        }
                        return !1
                    }(t, n, i, r) && (n = null), r || null === i ? function(e) {
                        return !!d.call(f, e) || !d.call(p, e) && (h.test(e) ? f[e] = !0 : (p[e] = !0, !1))
                    }(t) && (null === n ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = null === n ? 3 !== i.type && "" : n : (t = i.attributeName, r = i.attributeNamespace, null === n ? e.removeAttribute(t) : (n = 3 === (i = i.type) || 4 === i && !0 === n ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))))
                }
                "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e) {
                    var t = e.replace(v, y);
                    g[t] = new m(t, 1, !1, e, null, !1, !1)
                })), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e) {
                    var t = e.replace(v, y);
                    g[t] = new m(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1)
                })), ["xml:base", "xml:lang", "xml:space"].forEach((function(e) {
                    var t = e.replace(v, y);
                    g[t] = new m(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1)
                })), ["tabIndex", "crossOrigin"].forEach((function(e) {
                    g[e] = new m(e, 1, !1, e.toLowerCase(), null, !1, !1)
                })), g.xlinkHref = new m("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach((function(e) {
                    g[e] = new m(e, 1, !1, e.toLowerCase(), null, !0, !0)
                }));
                var x = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
                    _ = Symbol.for("react.element"),
                    M = Symbol.for("react.portal"),
                    w = Symbol.for("react.fragment"),
                    A = Symbol.for("react.strict_mode"),
                    S = Symbol.for("react.profiler"),
                    E = Symbol.for("react.provider"),
                    C = Symbol.for("react.context"),
                    T = Symbol.for("react.forward_ref"),
                    P = Symbol.for("react.suspense"),
                    R = Symbol.for("react.suspense_list"),
                    I = Symbol.for("react.memo"),
                    O = Symbol.for("react.lazy");
                Symbol.for("react.scope"), Symbol.for("react.debug_trace_mode");
                var B = Symbol.for("react.offscreen");
                Symbol.for("react.legacy_hidden"), Symbol.for("react.cache"), Symbol.for("react.tracing_marker");
                var L = Symbol.iterator;

                function D(e) {
                    return null === e || "object" !== typeof e ? null : "function" === typeof(e = L && e[L] || e["@@iterator"]) ? e : null
                }
                var N, k = Object.assign;

                function F(e) {
                    if (void 0 === N) try {
                        throw Error()
                    } catch (n) {
                        var t = n.stack.trim().match(/\n( *(at )?)/);
                        N = t && t[1] || ""
                    }
                    return "\n" + N + e
                }
                var U = !1;

                function z(e, t) {
                    if (!e || U) return "";
                    U = !0;
                    var n = Error.prepareStackTrace;
                    Error.prepareStackTrace = void 0;
                    try {
                        if (t)
                            if (t = function() {
                                    throw Error()
                                }, Object.defineProperty(t.prototype, "props", {
                                    set: function() {
                                        throw Error()
                                    }
                                }), "object" === typeof Reflect && Reflect.construct) {
                                try {
                                    Reflect.construct(t, [])
                                } catch (c) {
                                    var r = c
                                }
                                Reflect.construct(e, [], t)
                            } else {
                                try {
                                    t.call()
                                } catch (c) {
                                    r = c
                                }
                                e.call(t.prototype)
                            }
                        else {
                            try {
                                throw Error()
                            } catch (c) {
                                r = c
                            }
                            e()
                        }
                    } catch (c) {
                        if (c && r && "string" === typeof c.stack) {
                            for (var i = c.stack.split("\n"), o = r.stack.split("\n"), a = i.length - 1, s = o.length - 1; 1 <= a && 0 <= s && i[a] !== o[s];) s--;
                            for (; 1 <= a && 0 <= s; a--, s--)
                                if (i[a] !== o[s]) {
                                    if (1 !== a || 1 !== s)
                                        do {
                                            if (a--, 0 > --s || i[a] !== o[s]) {
                                                var l = "\n" + i[a].replace(" at new ", " at ");
                                                return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l
                                            }
                                        } while (1 <= a && 0 <= s);
                                    break
                                }
                        }
                    } finally {
                        U = !1, Error.prepareStackTrace = n
                    }
                    return (e = e ? e.displayName || e.name : "") ? F(e) : ""
                }

                function H(e) {
                    switch (e.tag) {
                        case 5:
                            return F(e.type);
                        case 16:
                            return F("Lazy");
                        case 13:
                            return F("Suspense");
                        case 19:
                            return F("SuspenseList");
                        case 0:
                        case 2:
                        case 15:
                            return e = z(e.type, !1);
                        case 11:
                            return e = z(e.type.render, !1);
                        case 1:
                            return e = z(e.type, !0);
                        default:
                            return ""
                    }
                }

                function j(e) {
                    if (null == e) return null;
                    if ("function" === typeof e) return e.displayName || e.name || null;
                    if ("string" === typeof e) return e;
                    switch (e) {
                        case w:
                            return "Fragment";
                        case M:
                            return "Portal";
                        case S:
                            return "Profiler";
                        case A:
                            return "StrictMode";
                        case P:
                            return "Suspense";
                        case R:
                            return "SuspenseList"
                    }
                    if ("object" === typeof e) switch (e.$$typeof) {
                        case C:
                            return (e.displayName || "Context") + ".Consumer";
                        case E:
                            return (e._context.displayName || "Context") + ".Provider";
                        case T:
                            var t = e.render;
                            return (e = e.displayName) || (e = "" !== (e = t.displayName || t.name || "") ? "ForwardRef(" + e + ")" : "ForwardRef"), e;
                        case I:
                            return null !== (t = e.displayName || null) ? t : j(e.type) || "Memo";
                        case O:
                            t = e._payload, e = e._init;
                            try {
                                return j(e(t))
                            } catch (n) {}
                    }
                    return null
                }

                function G(e) {
                    var t = e.type;
                    switch (e.tag) {
                        case 24:
                            return "Cache";
                        case 9:
                            return (t.displayName || "Context") + ".Consumer";
                        case 10:
                            return (t._context.displayName || "Context") + ".Provider";
                        case 18:
                            return "DehydratedFragment";
                        case 11:
                            return e = (e = t.render).displayName || e.name || "", t.displayName || ("" !== e ? "ForwardRef(" + e + ")" : "ForwardRef");
                        case 7:
                            return "Fragment";
                        case 5:
                            return t;
                        case 4:
                            return "Portal";
                        case 3:
                            return "Root";
                        case 6:
                            return "Text";
                        case 16:
                            return j(t);
                        case 8:
                            return t === A ? "StrictMode" : "Mode";
                        case 22:
                            return "Offscreen";
                        case 12:
                            return "Profiler";
                        case 21:
                            return "Scope";
                        case 13:
                            return "Suspense";
                        case 19:
                            return "SuspenseList";
                        case 25:
                            return "TracingMarker";
                        case 1:
                        case 0:
                        case 17:
                        case 2:
                        case 14:
                        case 15:
                            if ("function" === typeof t) return t.displayName || t.name || null;
                            if ("string" === typeof t) return t
                    }
                    return null
                }

                function V(e) {
                    switch (typeof e) {
                        case "boolean":
                        case "number":
                        case "string":
                        case "undefined":
                        case "object":
                            return e;
                        default:
                            return ""
                    }
                }

                function q(e) {
                    var t = e.type;
                    return (e = e.nodeName) && "input" === e.toLowerCase() && ("checkbox" === t || "radio" === t)
                }

                function W(e) {
                    e._valueTracker || (e._valueTracker = function(e) {
                        var t = q(e) ? "checked" : "value",
                            n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
                            r = "" + e[t];
                        if (!e.hasOwnProperty(t) && "undefined" !== typeof n && "function" === typeof n.get && "function" === typeof n.set) {
                            var i = n.get,
                                o = n.set;
                            return Object.defineProperty(e, t, {
                                configurable: !0,
                                get: function() {
                                    return i.call(this)
                                },
                                set: function(e) {
                                    r = "" + e, o.call(this, e)
                                }
                            }), Object.defineProperty(e, t, {
                                enumerable: n.enumerable
                            }), {
                                getValue: function() {
                                    return r
                                },
                                setValue: function(e) {
                                    r = "" + e
                                },
                                stopTracking: function() {
                                    e._valueTracker = null, delete e[t]
                                }
                            }
                        }
                    }(e))
                }

                function X(e) {
                    if (!e) return !1;
                    var t = e._valueTracker;
                    if (!t) return !0;
                    var n = t.getValue(),
                        r = "";
                    return e && (r = q(e) ? e.checked ? "true" : "false" : e.value), (e = r) !== n && (t.setValue(e), !0)
                }

                function K(e) {
                    if ("undefined" === typeof(e = e || ("undefined" !== typeof document ? document : void 0))) return null;
                    try {
                        return e.activeElement || e.body
                    } catch (t) {
                        return e.body
                    }
                }

                function J(e, t) {
                    var n = t.checked;
                    return k({}, t, {
                        defaultChecked: void 0,
                        defaultValue: void 0,
                        value: void 0,
                        checked: null != n ? n : e._wrapperState.initialChecked
                    })
                }

                function Y(e, t) {
                    var n = null == t.defaultValue ? "" : t.defaultValue,
                        r = null != t.checked ? t.checked : t.defaultChecked;
                    n = V(null != t.value ? t.value : n), e._wrapperState = {
                        initialChecked: r,
                        initialValue: n,
                        controlled: "checkbox" === t.type || "radio" === t.type ? null != t.checked : null != t.value
                    }
                }

                function Q(e, t) {
                    null != (t = t.checked) && b(e, "checked", t, !1)
                }

                function Z(e, t) {
                    Q(e, t);
                    var n = V(t.value),
                        r = t.type;
                    if (null != n) "number" === r ? (0 === n && "" === e.value || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n);
                    else if ("submit" === r || "reset" === r) return void e.removeAttribute("value");
                    t.hasOwnProperty("value") ? ee(e, t.type, n) : t.hasOwnProperty("defaultValue") && ee(e, t.type, V(t.defaultValue)), null == t.checked && null != t.defaultChecked && (e.defaultChecked = !!t.defaultChecked)
                }

                function $(e, t, n) {
                    if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
                        var r = t.type;
                        if (!("submit" !== r && "reset" !== r || void 0 !== t.value && null !== t.value)) return;
                        t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t
                    }
                    "" !== (n = e.name) && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, "" !== n && (e.name = n)
                }

                function ee(e, t, n) {
                    "number" === t && K(e.ownerDocument) === e || (null == n ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n))
                }
                var te = Array.isArray;

                function ne(e, t, n, r) {
                    if (e = e.options, t) {
                        t = {};
                        for (var i = 0; i < n.length; i++) t["$" + n[i]] = !0;
                        for (n = 0; n < e.length; n++) i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0)
                    } else {
                        for (n = "" + V(n), t = null, i = 0; i < e.length; i++) {
                            if (e[i].value === n) return e[i].selected = !0, void(r && (e[i].defaultSelected = !0));
                            null !== t || e[i].disabled || (t = e[i])
                        }
                        null !== t && (t.selected = !0)
                    }
                }

                function re(e, t) {
                    if (null != t.dangerouslySetInnerHTML) throw Error(o(91));
                    return k({}, t, {
                        value: void 0,
                        defaultValue: void 0,
                        children: "" + e._wrapperState.initialValue
                    })
                }

                function ie(e, t) {
                    var n = t.value;
                    if (null == n) {
                        if (n = t.children, t = t.defaultValue, null != n) {
                            if (null != t) throw Error(o(92));
                            if (te(n)) {
                                if (1 < n.length) throw Error(o(93));
                                n = n[0]
                            }
                            t = n
                        }
                        null == t && (t = ""), n = t
                    }
                    e._wrapperState = {
                        initialValue: V(n)
                    }
                }

                function oe(e, t) {
                    var n = V(t.value),
                        r = V(t.defaultValue);
                    null != n && ((n = "" + n) !== e.value && (e.value = n), null == t.defaultValue && e.defaultValue !== n && (e.defaultValue = n)), null != r && (e.defaultValue = "" + r)
                }

                function ae(e) {
                    var t = e.textContent;
                    t === e._wrapperState.initialValue && "" !== t && null !== t && (e.value = t)
                }

                function se(e) {
                    switch (e) {
                        case "svg":
                            return "http://www.w3.org/2000/svg";
                        case "math":
                            return "http://www.w3.org/1998/Math/MathML";
                        default:
                            return "http://www.w3.org/1999/xhtml"
                    }
                }

                function le(e, t) {
                    return null == e || "http://www.w3.org/1999/xhtml" === e ? se(t) : "http://www.w3.org/2000/svg" === e && "foreignObject" === t ? "http://www.w3.org/1999/xhtml" : e
                }
                var ce, ue, de = (ue = function(e, t) {
                    if ("http://www.w3.org/2000/svg" !== e.namespaceURI || "innerHTML" in e) e.innerHTML = t;
                    else {
                        for ((ce = ce || document.createElement("div")).innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = ce.firstChild; e.firstChild;) e.removeChild(e.firstChild);
                        for (; t.firstChild;) e.appendChild(t.firstChild)
                    }
                }, "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(e, t, n, r) {
                    MSApp.execUnsafeLocalFunction((function() {
                        return ue(e, t)
                    }))
                } : ue);

                function he(e, t) {
                    if (t) {
                        var n = e.firstChild;
                        if (n && n === e.lastChild && 3 === n.nodeType) return void(n.nodeValue = t)
                    }
                    e.textContent = t
                }
                var pe = {
                        animationIterationCount: !0,
                        aspectRatio: !0,
                        borderImageOutset: !0,
                        borderImageSlice: !0,
                        borderImageWidth: !0,
                        boxFlex: !0,
                        boxFlexGroup: !0,
                        boxOrdinalGroup: !0,
                        columnCount: !0,
                        columns: !0,
                        flex: !0,
                        flexGrow: !0,
                        flexPositive: !0,
                        flexShrink: !0,
                        flexNegative: !0,
                        flexOrder: !0,
                        gridArea: !0,
                        gridRow: !0,
                        gridRowEnd: !0,
                        gridRowSpan: !0,
                        gridRowStart: !0,
                        gridColumn: !0,
                        gridColumnEnd: !0,
                        gridColumnSpan: !0,
                        gridColumnStart: !0,
                        fontWeight: !0,
                        lineClamp: !0,
                        lineHeight: !0,
                        opacity: !0,
                        order: !0,
                        orphans: !0,
                        tabSize: !0,
                        widows: !0,
                        zIndex: !0,
                        zoom: !0,
                        fillOpacity: !0,
                        floodOpacity: !0,
                        stopOpacity: !0,
                        strokeDasharray: !0,
                        strokeDashoffset: !0,
                        strokeMiterlimit: !0,
                        strokeOpacity: !0,
                        strokeWidth: !0
                    },
                    fe = ["Webkit", "ms", "Moz", "O"];

                function me(e, t, n) {
                    return null == t || "boolean" === typeof t || "" === t ? "" : n || "number" !== typeof t || 0 === t || pe.hasOwnProperty(e) && pe[e] ? ("" + t).trim() : t + "px"
                }

                function ge(e, t) {
                    for (var n in e = e.style, t)
                        if (t.hasOwnProperty(n)) {
                            var r = 0 === n.indexOf("--"),
                                i = me(n, t[n], r);
                            "float" === n && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i
                        }
                }
                Object.keys(pe).forEach((function(e) {
                    fe.forEach((function(t) {
                        t = t + e.charAt(0).toUpperCase() + e.substring(1), pe[t] = pe[e]
                    }))
                }));
                var ve = k({
                    menuitem: !0
                }, {
                    area: !0,
                    base: !0,
                    br: !0,
                    col: !0,
                    embed: !0,
                    hr: !0,
                    img: !0,
                    input: !0,
                    keygen: !0,
                    link: !0,
                    meta: !0,
                    param: !0,
                    source: !0,
                    track: !0,
                    wbr: !0
                });

                function ye(e, t) {
                    if (t) {
                        if (ve[e] && (null != t.children || null != t.dangerouslySetInnerHTML)) throw Error(o(137, e));
                        if (null != t.dangerouslySetInnerHTML) {
                            if (null != t.children) throw Error(o(60));
                            if ("object" !== typeof t.dangerouslySetInnerHTML || !("__html" in t.dangerouslySetInnerHTML)) throw Error(o(61))
                        }
                        if (null != t.style && "object" !== typeof t.style) throw Error(o(62))
                    }
                }

                function be(e, t) {
                    if (-1 === e.indexOf("-")) return "string" === typeof t.is;
                    switch (e) {
                        case "annotation-xml":
                        case "color-profile":
                        case "font-face":
                        case "font-face-src":
                        case "font-face-uri":
                        case "font-face-format":
                        case "font-face-name":
                        case "missing-glyph":
                            return !1;
                        default:
                            return !0
                    }
                }
                var xe = null;

                function _e(e) {
                    return (e = e.target || e.srcElement || window).correspondingUseElement && (e = e.correspondingUseElement), 3 === e.nodeType ? e.parentNode : e
                }
                var Me = null,
                    we = null,
                    Ae = null;

                function Se(e) {
                    if (e = bi(e)) {
                        if ("function" !== typeof Me) throw Error(o(280));
                        var t = e.stateNode;
                        t && (t = _i(t), Me(e.stateNode, e.type, t))
                    }
                }

                function Ee(e) {
                    we ? Ae ? Ae.push(e) : Ae = [e] : we = e
                }

                function Ce() {
                    if (we) {
                        var e = we,
                            t = Ae;
                        if (Ae = we = null, Se(e), t)
                            for (e = 0; e < t.length; e++) Se(t[e])
                    }
                }

                function Te(e, t) {
                    return e(t)
                }

                function Pe() {}
                var Re = !1;

                function Ie(e, t, n) {
                    if (Re) return e(t, n);
                    Re = !0;
                    try {
                        return Te(e, t, n)
                    } finally {
                        Re = !1, (null !== we || null !== Ae) && (Pe(), Ce())
                    }
                }

                function Oe(e, t) {
                    var n = e.stateNode;
                    if (null === n) return null;
                    var r = _i(n);
                    if (null === r) return null;
                    n = r[t];
                    e: switch (t) {
                        case "onClick":
                        case "onClickCapture":
                        case "onDoubleClick":
                        case "onDoubleClickCapture":
                        case "onMouseDown":
                        case "onMouseDownCapture":
                        case "onMouseMove":
                        case "onMouseMoveCapture":
                        case "onMouseUp":
                        case "onMouseUpCapture":
                        case "onMouseEnter":
                            (r = !r.disabled) || (r = !("button" === (e = e.type) || "input" === e || "select" === e || "textarea" === e)), e = !r;
                            break e;
                        default:
                            e = !1
                    }
                    if (e) return null;
                    if (n && "function" !== typeof n) throw Error(o(231, t, typeof n));
                    return n
                }
                var Be = !1;
                if (u) try {
                    var Le = {};
                    Object.defineProperty(Le, "passive", {
                        get: function() {
                            Be = !0
                        }
                    }), window.addEventListener("test", Le, Le), window.removeEventListener("test", Le, Le)
                } catch (ue) {
                    Be = !1
                }

                function De(e, t, n, r, i, o, a, s, l) {
                    var c = Array.prototype.slice.call(arguments, 3);
                    try {
                        t.apply(n, c)
                    } catch (u) {
                        this.onError(u)
                    }
                }
                var Ne = !1,
                    ke = null,
                    Fe = !1,
                    Ue = null,
                    ze = {
                        onError: function(e) {
                            Ne = !0, ke = e
                        }
                    };

                function He(e, t, n, r, i, o, a, s, l) {
                    Ne = !1, ke = null, De.apply(ze, arguments)
                }

                function je(e) {
                    var t = e,
                        n = e;
                    if (e.alternate)
                        for (; t.return;) t = t.return;
                    else {
                        e = t;
                        do {
                            0 !== (4098 & (t = e).flags) && (n = t.return), e = t.return
                        } while (e)
                    }
                    return 3 === t.tag ? n : null
                }

                function Ge(e) {
                    if (13 === e.tag) {
                        var t = e.memoizedState;
                        if (null === t && (null !== (e = e.alternate) && (t = e.memoizedState)), null !== t) return t.dehydrated
                    }
                    return null
                }

                function Ve(e) {
                    if (je(e) !== e) throw Error(o(188))
                }

                function qe(e) {
                    return null !== (e = function(e) {
                        var t = e.alternate;
                        if (!t) {
                            if (null === (t = je(e))) throw Error(o(188));
                            return t !== e ? null : e
                        }
                        for (var n = e, r = t;;) {
                            var i = n.return;
                            if (null === i) break;
                            var a = i.alternate;
                            if (null === a) {
                                if (null !== (r = i.return)) {
                                    n = r;
                                    continue
                                }
                                break
                            }
                            if (i.child === a.child) {
                                for (a = i.child; a;) {
                                    if (a === n) return Ve(i), e;
                                    if (a === r) return Ve(i), t;
                                    a = a.sibling
                                }
                                throw Error(o(188))
                            }
                            if (n.return !== r.return) n = i, r = a;
                            else {
                                for (var s = !1, l = i.child; l;) {
                                    if (l === n) {
                                        s = !0, n = i, r = a;
                                        break
                                    }
                                    if (l === r) {
                                        s = !0, r = i, n = a;
                                        break
                                    }
                                    l = l.sibling
                                }
                                if (!s) {
                                    for (l = a.child; l;) {
                                        if (l === n) {
                                            s = !0, n = a, r = i;
                                            break
                                        }
                                        if (l === r) {
                                            s = !0, r = a, n = i;
                                            break
                                        }
                                        l = l.sibling
                                    }
                                    if (!s) throw Error(o(189))
                                }
                            }
                            if (n.alternate !== r) throw Error(o(190))
                        }
                        if (3 !== n.tag) throw Error(o(188));
                        return n.stateNode.current === n ? e : t
                    }(e)) ? We(e) : null
                }

                function We(e) {
                    if (5 === e.tag || 6 === e.tag) return e;
                    for (e = e.child; null !== e;) {
                        var t = We(e);
                        if (null !== t) return t;
                        e = e.sibling
                    }
                    return null
                }
                var Xe = i.unstable_scheduleCallback,
                    Ke = i.unstable_cancelCallback,
                    Je = i.unstable_shouldYield,
                    Ye = i.unstable_requestPaint,
                    Qe = i.unstable_now,
                    Ze = i.unstable_getCurrentPriorityLevel,
                    $e = i.unstable_ImmediatePriority,
                    et = i.unstable_UserBlockingPriority,
                    tt = i.unstable_NormalPriority,
                    nt = i.unstable_LowPriority,
                    rt = i.unstable_IdlePriority,
                    it = null,
                    ot = null;
                var at = Math.clz32 ? Math.clz32 : function(e) {
                        return e >>>= 0, 0 === e ? 32 : 31 - (st(e) / lt | 0) | 0
                    },
                    st = Math.log,
                    lt = Math.LN2;
                var ct = 64,
                    ut = 4194304;

                function dt(e) {
                    switch (e & -e) {
                        case 1:
                            return 1;
                        case 2:
                            return 2;
                        case 4:
                            return 4;
                        case 8:
                            return 8;
                        case 16:
                            return 16;
                        case 32:
                            return 32;
                        case 64:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                            return 4194240 & e;
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                        case 67108864:
                            return 130023424 & e;
                        case 134217728:
                            return 134217728;
                        case 268435456:
                            return 268435456;
                        case 536870912:
                            return 536870912;
                        case 1073741824:
                            return 1073741824;
                        default:
                            return e
                    }
                }

                function ht(e, t) {
                    var n = e.pendingLanes;
                    if (0 === n) return 0;
                    var r = 0,
                        i = e.suspendedLanes,
                        o = e.pingedLanes,
                        a = 268435455 & n;
                    if (0 !== a) {
                        var s = a & ~i;
                        0 !== s ? r = dt(s) : 0 !== (o &= a) && (r = dt(o))
                    } else 0 !== (a = n & ~i) ? r = dt(a) : 0 !== o && (r = dt(o));
                    if (0 === r) return 0;
                    if (0 !== t && t !== r && 0 === (t & i) && ((i = r & -r) >= (o = t & -t) || 16 === i && 0 !== (4194240 & o))) return t;
                    if (0 !== (4 & r) && (r |= 16 & n), 0 !== (t = e.entangledLanes))
                        for (e = e.entanglements, t &= r; 0 < t;) i = 1 << (n = 31 - at(t)), r |= e[n], t &= ~i;
                    return r
                }

                function pt(e, t) {
                    switch (e) {
                        case 1:
                        case 2:
                        case 4:
                            return t + 250;
                        case 8:
                        case 16:
                        case 32:
                        case 64:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                            return t + 5e3;
                        default:
                            return -1
                    }
                }

                function ft(e) {
                    return 0 !== (e = -1073741825 & e.pendingLanes) ? e : 1073741824 & e ? 1073741824 : 0
                }

                function mt() {
                    var e = ct;
                    return 0 === (4194240 & (ct <<= 1)) && (ct = 64), e
                }

                function gt(e) {
                    for (var t = [], n = 0; 31 > n; n++) t.push(e);
                    return t
                }

                function vt(e, t, n) {
                    e.pendingLanes |= t, 536870912 !== t && (e.suspendedLanes = 0, e.pingedLanes = 0), (e = e.eventTimes)[t = 31 - at(t)] = n
                }

                function yt(e, t) {
                    var n = e.entangledLanes |= t;
                    for (e = e.entanglements; n;) {
                        var r = 31 - at(n),
                            i = 1 << r;
                        i & t | e[r] & t && (e[r] |= t), n &= ~i
                    }
                }
                var bt = 0;

                function xt(e) {
                    return 1 < (e &= -e) ? 4 < e ? 0 !== (268435455 & e) ? 16 : 536870912 : 4 : 1
                }
                var _t, Mt, wt, At, St, Et = !1,
                    Ct = [],
                    Tt = null,
                    Pt = null,
                    Rt = null,
                    It = new Map,
                    Ot = new Map,
                    Bt = [],
                    Lt = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

                function Dt(e, t) {
                    switch (e) {
                        case "focusin":
                        case "focusout":
                            Tt = null;
                            break;
                        case "dragenter":
                        case "dragleave":
                            Pt = null;
                            break;
                        case "mouseover":
                        case "mouseout":
                            Rt = null;
                            break;
                        case "pointerover":
                        case "pointerout":
                            It.delete(t.pointerId);
                            break;
                        case "gotpointercapture":
                        case "lostpointercapture":
                            Ot.delete(t.pointerId)
                    }
                }

                function Nt(e, t, n, r, i, o) {
                    return null === e || e.nativeEvent !== o ? (e = {
                        blockedOn: t,
                        domEventName: n,
                        eventSystemFlags: r,
                        nativeEvent: o,
                        targetContainers: [i]
                    }, null !== t && (null !== (t = bi(t)) && Mt(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, null !== i && -1 === t.indexOf(i) && t.push(i), e)
                }

                function kt(e) {
                    var t = yi(e.target);
                    if (null !== t) {
                        var n = je(t);
                        if (null !== n)
                            if (13 === (t = n.tag)) {
                                if (null !== (t = Ge(n))) return e.blockedOn = t, void St(e.priority, (function() {
                                    wt(n)
                                }))
                            } else if (3 === t && n.stateNode.current.memoizedState.isDehydrated) return void(e.blockedOn = 3 === n.tag ? n.stateNode.containerInfo : null)
                    }
                    e.blockedOn = null
                }

                function Ft(e) {
                    if (null !== e.blockedOn) return !1;
                    for (var t = e.targetContainers; 0 < t.length;) {
                        var n = Jt(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
                        if (null !== n) return null !== (t = bi(n)) && Mt(t), e.blockedOn = n, !1;
                        var r = new(n = e.nativeEvent).constructor(n.type, n);
                        xe = r, n.target.dispatchEvent(r), xe = null, t.shift()
                    }
                    return !0
                }

                function Ut(e, t, n) {
                    Ft(e) && n.delete(t)
                }

                function zt() {
                    Et = !1, null !== Tt && Ft(Tt) && (Tt = null), null !== Pt && Ft(Pt) && (Pt = null), null !== Rt && Ft(Rt) && (Rt = null), It.forEach(Ut), Ot.forEach(Ut)
                }

                function Ht(e, t) {
                    e.blockedOn === t && (e.blockedOn = null, Et || (Et = !0, i.unstable_scheduleCallback(i.unstable_NormalPriority, zt)))
                }

                function jt(e) {
                    function t(t) {
                        return Ht(t, e)
                    }
                    if (0 < Ct.length) {
                        Ht(Ct[0], e);
                        for (var n = 1; n < Ct.length; n++) {
                            var r = Ct[n];
                            r.blockedOn === e && (r.blockedOn = null)
                        }
                    }
                    for (null !== Tt && Ht(Tt, e), null !== Pt && Ht(Pt, e), null !== Rt && Ht(Rt, e), It.forEach(t), Ot.forEach(t), n = 0; n < Bt.length; n++)(r = Bt[n]).blockedOn === e && (r.blockedOn = null);
                    for (; 0 < Bt.length && null === (n = Bt[0]).blockedOn;) kt(n), null === n.blockedOn && Bt.shift()
                }
                var Gt = x.ReactCurrentBatchConfig,
                    Vt = !0;

                function qt(e, t, n, r) {
                    var i = bt,
                        o = Gt.transition;
                    Gt.transition = null;
                    try {
                        bt = 1, Xt(e, t, n, r)
                    } finally {
                        bt = i, Gt.transition = o
                    }
                }

                function Wt(e, t, n, r) {
                    var i = bt,
                        o = Gt.transition;
                    Gt.transition = null;
                    try {
                        bt = 4, Xt(e, t, n, r)
                    } finally {
                        bt = i, Gt.transition = o
                    }
                }

                function Xt(e, t, n, r) {
                    if (Vt) {
                        var i = Jt(e, t, n, r);
                        if (null === i) Vr(e, t, r, Kt, n), Dt(e, r);
                        else if (function(e, t, n, r, i) {
                                switch (t) {
                                    case "focusin":
                                        return Tt = Nt(Tt, e, t, n, r, i), !0;
                                    case "dragenter":
                                        return Pt = Nt(Pt, e, t, n, r, i), !0;
                                    case "mouseover":
                                        return Rt = Nt(Rt, e, t, n, r, i), !0;
                                    case "pointerover":
                                        var o = i.pointerId;
                                        return It.set(o, Nt(It.get(o) || null, e, t, n, r, i)), !0;
                                    case "gotpointercapture":
                                        return o = i.pointerId, Ot.set(o, Nt(Ot.get(o) || null, e, t, n, r, i)), !0
                                }
                                return !1
                            }(i, e, t, n, r)) r.stopPropagation();
                        else if (Dt(e, r), 4 & t && -1 < Lt.indexOf(e)) {
                            for (; null !== i;) {
                                var o = bi(i);
                                if (null !== o && _t(o), null === (o = Jt(e, t, n, r)) && Vr(e, t, r, Kt, n), o === i) break;
                                i = o
                            }
                            null !== i && r.stopPropagation()
                        } else Vr(e, t, r, null, n)
                    }
                }
                var Kt = null;

                function Jt(e, t, n, r) {
                    if (Kt = null, null !== (e = yi(e = _e(r))))
                        if (null === (t = je(e))) e = null;
                        else if (13 === (n = t.tag)) {
                        if (null !== (e = Ge(t))) return e;
                        e = null
                    } else if (3 === n) {
                        if (t.stateNode.current.memoizedState.isDehydrated) return 3 === t.tag ? t.stateNode.containerInfo : null;
                        e = null
                    } else t !== e && (e = null);
                    return Kt = e, null
                }

                function Yt(e) {
                    switch (e) {
                        case "cancel":
                        case "click":
                        case "close":
                        case "contextmenu":
                        case "copy":
                        case "cut":
                        case "auxclick":
                        case "dblclick":
                        case "dragend":
                        case "dragstart":
                        case "drop":
                        case "focusin":
                        case "focusout":
                        case "input":
                        case "invalid":
                        case "keydown":
                        case "keypress":
                        case "keyup":
                        case "mousedown":
                        case "mouseup":
                        case "paste":
                        case "pause":
                        case "play":
                        case "pointercancel":
                        case "pointerdown":
                        case "pointerup":
                        case "ratechange":
                        case "reset":
                        case "resize":
                        case "seeked":
                        case "submit":
                        case "touchcancel":
                        case "touchend":
                        case "touchstart":
                        case "volumechange":
                        case "change":
                        case "selectionchange":
                        case "textInput":
                        case "compositionstart":
                        case "compositionend":
                        case "compositionupdate":
                        case "beforeblur":
                        case "afterblur":
                        case "beforeinput":
                        case "blur":
                        case "fullscreenchange":
                        case "focus":
                        case "hashchange":
                        case "popstate":
                        case "select":
                        case "selectstart":
                            return 1;
                        case "drag":
                        case "dragenter":
                        case "dragexit":
                        case "dragleave":
                        case "dragover":
                        case "mousemove":
                        case "mouseout":
                        case "mouseover":
                        case "pointermove":
                        case "pointerout":
                        case "pointerover":
                        case "scroll":
                        case "toggle":
                        case "touchmove":
                        case "wheel":
                        case "mouseenter":
                        case "mouseleave":
                        case "pointerenter":
                        case "pointerleave":
                            return 4;
                        case "message":
                            switch (Ze()) {
                                case $e:
                                    return 1;
                                case et:
                                    return 4;
                                case tt:
                                case nt:
                                    return 16;
                                case rt:
                                    return 536870912;
                                default:
                                    return 16
                            }
                        default:
                            return 16
                    }
                }
                var Qt = null,
                    Zt = null,
                    $t = null;

                function en() {
                    if ($t) return $t;
                    var e, t, n = Zt,
                        r = n.length,
                        i = "value" in Qt ? Qt.value : Qt.textContent,
                        o = i.length;
                    for (e = 0; e < r && n[e] === i[e]; e++);
                    var a = r - e;
                    for (t = 1; t <= a && n[r - t] === i[o - t]; t++);
                    return $t = i.slice(e, 1 < t ? 1 - t : void 0)
                }

                function tn(e) {
                    var t = e.keyCode;
                    return "charCode" in e ? 0 === (e = e.charCode) && 13 === t && (e = 13) : e = t, 10 === e && (e = 13), 32 <= e || 13 === e ? e : 0
                }

                function nn() {
                    return !0
                }

                function rn() {
                    return !1
                }

                function on(e) {
                    function t(t, n, r, i, o) {
                        for (var a in this._reactName = t, this._targetInst = r, this.type = n, this.nativeEvent = i, this.target = o, this.currentTarget = null, e) e.hasOwnProperty(a) && (t = e[a], this[a] = t ? t(i) : i[a]);
                        return this.isDefaultPrevented = (null != i.defaultPrevented ? i.defaultPrevented : !1 === i.returnValue) ? nn : rn, this.isPropagationStopped = rn, this
                    }
                    return k(t.prototype, {
                        preventDefault: function() {
                            this.defaultPrevented = !0;
                            var e = this.nativeEvent;
                            e && (e.preventDefault ? e.preventDefault() : "unknown" !== typeof e.returnValue && (e.returnValue = !1), this.isDefaultPrevented = nn)
                        },
                        stopPropagation: function() {
                            var e = this.nativeEvent;
                            e && (e.stopPropagation ? e.stopPropagation() : "unknown" !== typeof e.cancelBubble && (e.cancelBubble = !0), this.isPropagationStopped = nn)
                        },
                        persist: function() {},
                        isPersistent: nn
                    }), t
                }
                var an, sn, ln, cn = {
                        eventPhase: 0,
                        bubbles: 0,
                        cancelable: 0,
                        timeStamp: function(e) {
                            return e.timeStamp || Date.now()
                        },
                        defaultPrevented: 0,
                        isTrusted: 0
                    },
                    un = on(cn),
                    dn = k({}, cn, {
                        view: 0,
                        detail: 0
                    }),
                    hn = on(dn),
                    pn = k({}, dn, {
                        screenX: 0,
                        screenY: 0,
                        clientX: 0,
                        clientY: 0,
                        pageX: 0,
                        pageY: 0,
                        ctrlKey: 0,
                        shiftKey: 0,
                        altKey: 0,
                        metaKey: 0,
                        getModifierState: Sn,
                        button: 0,
                        buttons: 0,
                        relatedTarget: function(e) {
                            return void 0 === e.relatedTarget ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget
                        },
                        movementX: function(e) {
                            return "movementX" in e ? e.movementX : (e !== ln && (ln && "mousemove" === e.type ? (an = e.screenX - ln.screenX, sn = e.screenY - ln.screenY) : sn = an = 0, ln = e), an)
                        },
                        movementY: function(e) {
                            return "movementY" in e ? e.movementY : sn
                        }
                    }),
                    fn = on(pn),
                    mn = on(k({}, pn, {
                        dataTransfer: 0
                    })),
                    gn = on(k({}, dn, {
                        relatedTarget: 0
                    })),
                    vn = on(k({}, cn, {
                        animationName: 0,
                        elapsedTime: 0,
                        pseudoElement: 0
                    })),
                    yn = k({}, cn, {
                        clipboardData: function(e) {
                            return "clipboardData" in e ? e.clipboardData : window.clipboardData
                        }
                    }),
                    bn = on(yn),
                    xn = on(k({}, cn, {
                        data: 0
                    })),
                    _n = {
                        Esc: "Escape",
                        Spacebar: " ",
                        Left: "ArrowLeft",
                        Up: "ArrowUp",
                        Right: "ArrowRight",
                        Down: "ArrowDown",
                        Del: "Delete",
                        Win: "OS",
                        Menu: "ContextMenu",
                        Apps: "ContextMenu",
                        Scroll: "ScrollLock",
                        MozPrintableKey: "Unidentified"
                    },
                    Mn = {
                        8: "Backspace",
                        9: "Tab",
                        12: "Clear",
                        13: "Enter",
                        16: "Shift",
                        17: "Control",
                        18: "Alt",
                        19: "Pause",
                        20: "CapsLock",
                        27: "Escape",
                        32: " ",
                        33: "PageUp",
                        34: "PageDown",
                        35: "End",
                        36: "Home",
                        37: "ArrowLeft",
                        38: "ArrowUp",
                        39: "ArrowRight",
                        40: "ArrowDown",
                        45: "Insert",
                        46: "Delete",
                        112: "F1",
                        113: "F2",
                        114: "F3",
                        115: "F4",
                        116: "F5",
                        117: "F6",
                        118: "F7",
                        119: "F8",
                        120: "F9",
                        121: "F10",
                        122: "F11",
                        123: "F12",
                        144: "NumLock",
                        145: "ScrollLock",
                        224: "Meta"
                    },
                    wn = {
                        Alt: "altKey",
                        Control: "ctrlKey",
                        Meta: "metaKey",
                        Shift: "shiftKey"
                    };

                function An(e) {
                    var t = this.nativeEvent;
                    return t.getModifierState ? t.getModifierState(e) : !!(e = wn[e]) && !!t[e]
                }

                function Sn() {
                    return An
                }
                var En = k({}, dn, {
                        key: function(e) {
                            if (e.key) {
                                var t = _n[e.key] || e.key;
                                if ("Unidentified" !== t) return t
                            }
                            return "keypress" === e.type ? 13 === (e = tn(e)) ? "Enter" : String.fromCharCode(e) : "keydown" === e.type || "keyup" === e.type ? Mn[e.keyCode] || "Unidentified" : ""
                        },
                        code: 0,
                        location: 0,
                        ctrlKey: 0,
                        shiftKey: 0,
                        altKey: 0,
                        metaKey: 0,
                        repeat: 0,
                        locale: 0,
                        getModifierState: Sn,
                        charCode: function(e) {
                            return "keypress" === e.type ? tn(e) : 0
                        },
                        keyCode: function(e) {
                            return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
                        },
                        which: function(e) {
                            return "keypress" === e.type ? tn(e) : "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
                        }
                    }),
                    Cn = on(En),
                    Tn = on(k({}, pn, {
                        pointerId: 0,
                        width: 0,
                        height: 0,
                        pressure: 0,
                        tangentialPressure: 0,
                        tiltX: 0,
                        tiltY: 0,
                        twist: 0,
                        pointerType: 0,
                        isPrimary: 0
                    })),
                    Pn = on(k({}, dn, {
                        touches: 0,
                        targetTouches: 0,
                        changedTouches: 0,
                        altKey: 0,
                        metaKey: 0,
                        ctrlKey: 0,
                        shiftKey: 0,
                        getModifierState: Sn
                    })),
                    Rn = on(k({}, cn, {
                        propertyName: 0,
                        elapsedTime: 0,
                        pseudoElement: 0
                    })),
                    In = k({}, pn, {
                        deltaX: function(e) {
                            return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0
                        },
                        deltaY: function(e) {
                            return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0
                        },
                        deltaZ: 0,
                        deltaMode: 0
                    }),
                    On = on(In),
                    Bn = [9, 13, 27, 32],
                    Ln = u && "CompositionEvent" in window,
                    Dn = null;
                u && "documentMode" in document && (Dn = document.documentMode);
                var Nn = u && "TextEvent" in window && !Dn,
                    kn = u && (!Ln || Dn && 8 < Dn && 11 >= Dn),
                    Fn = String.fromCharCode(32),
                    Un = !1;

                function zn(e, t) {
                    switch (e) {
                        case "keyup":
                            return -1 !== Bn.indexOf(t.keyCode);
                        case "keydown":
                            return 229 !== t.keyCode;
                        case "keypress":
                        case "mousedown":
                        case "focusout":
                            return !0;
                        default:
                            return !1
                    }
                }

                function Hn(e) {
                    return "object" === typeof(e = e.detail) && "data" in e ? e.data : null
                }
                var jn = !1;
                var Gn = {
                    color: !0,
                    date: !0,
                    datetime: !0,
                    "datetime-local": !0,
                    email: !0,
                    month: !0,
                    number: !0,
                    password: !0,
                    range: !0,
                    search: !0,
                    tel: !0,
                    text: !0,
                    time: !0,
                    url: !0,
                    week: !0
                };

                function Vn(e) {
                    var t = e && e.nodeName && e.nodeName.toLowerCase();
                    return "input" === t ? !!Gn[e.type] : "textarea" === t
                }

                function qn(e, t, n, r) {
                    Ee(r), 0 < (t = Wr(t, "onChange")).length && (n = new un("onChange", "change", null, n, r), e.push({
                        event: n,
                        listeners: t
                    }))
                }
                var Wn = null,
                    Xn = null;

                function Kn(e) {
                    Fr(e, 0)
                }

                function Jn(e) {
                    if (X(xi(e))) return e
                }

                function Yn(e, t) {
                    if ("change" === e) return t
                }
                var Qn = !1;
                if (u) {
                    var Zn;
                    if (u) {
                        var $n = "oninput" in document;
                        if (!$n) {
                            var er = document.createElement("div");
                            er.setAttribute("oninput", "return;"), $n = "function" === typeof er.oninput
                        }
                        Zn = $n
                    } else Zn = !1;
                    Qn = Zn && (!document.documentMode || 9 < document.documentMode)
                }

                function tr() {
                    Wn && (Wn.detachEvent("onpropertychange", nr), Xn = Wn = null)
                }

                function nr(e) {
                    if ("value" === e.propertyName && Jn(Xn)) {
                        var t = [];
                        qn(t, Xn, e, _e(e)), Ie(Kn, t)
                    }
                }

                function rr(e, t, n) {
                    "focusin" === e ? (tr(), Xn = n, (Wn = t).attachEvent("onpropertychange", nr)) : "focusout" === e && tr()
                }

                function ir(e) {
                    if ("selectionchange" === e || "keyup" === e || "keydown" === e) return Jn(Xn)
                }

                function or(e, t) {
                    if ("click" === e) return Jn(t)
                }

                function ar(e, t) {
                    if ("input" === e || "change" === e) return Jn(t)
                }
                var sr = "function" === typeof Object.is ? Object.is : function(e, t) {
                    return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t
                };

                function lr(e, t) {
                    if (sr(e, t)) return !0;
                    if ("object" !== typeof e || null === e || "object" !== typeof t || null === t) return !1;
                    var n = Object.keys(e),
                        r = Object.keys(t);
                    if (n.length !== r.length) return !1;
                    for (r = 0; r < n.length; r++) {
                        var i = n[r];
                        if (!d.call(t, i) || !sr(e[i], t[i])) return !1
                    }
                    return !0
                }

                function cr(e) {
                    for (; e && e.firstChild;) e = e.firstChild;
                    return e
                }

                function ur(e, t) {
                    var n, r = cr(e);
                    for (e = 0; r;) {
                        if (3 === r.nodeType) {
                            if (n = e + r.textContent.length, e <= t && n >= t) return {
                                node: r,
                                offset: t - e
                            };
                            e = n
                        }
                        e: {
                            for (; r;) {
                                if (r.nextSibling) {
                                    r = r.nextSibling;
                                    break e
                                }
                                r = r.parentNode
                            }
                            r = void 0
                        }
                        r = cr(r)
                    }
                }

                function dr(e, t) {
                    return !(!e || !t) && (e === t || (!e || 3 !== e.nodeType) && (t && 3 === t.nodeType ? dr(e, t.parentNode) : "contains" in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t))))
                }

                function hr() {
                    for (var e = window, t = K(); t instanceof e.HTMLIFrameElement;) {
                        try {
                            var n = "string" === typeof t.contentWindow.location.href
                        } catch (r) {
                            n = !1
                        }
                        if (!n) break;
                        t = K((e = t.contentWindow).document)
                    }
                    return t
                }

                function pr(e) {
                    var t = e && e.nodeName && e.nodeName.toLowerCase();
                    return t && ("input" === t && ("text" === e.type || "search" === e.type || "tel" === e.type || "url" === e.type || "password" === e.type) || "textarea" === t || "true" === e.contentEditable)
                }

                function fr(e) {
                    var t = hr(),
                        n = e.focusedElem,
                        r = e.selectionRange;
                    if (t !== n && n && n.ownerDocument && dr(n.ownerDocument.documentElement, n)) {
                        if (null !== r && pr(n))
                            if (t = r.start, void 0 === (e = r.end) && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length);
                            else if ((e = (t = n.ownerDocument || document) && t.defaultView || window).getSelection) {
                            e = e.getSelection();
                            var i = n.textContent.length,
                                o = Math.min(r.start, i);
                            r = void 0 === r.end ? o : Math.min(r.end, i), !e.extend && o > r && (i = r, r = o, o = i), i = ur(n, o);
                            var a = ur(n, r);
                            i && a && (1 !== e.rangeCount || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== a.node || e.focusOffset !== a.offset) && ((t = t.createRange()).setStart(i.node, i.offset), e.removeAllRanges(), o > r ? (e.addRange(t), e.extend(a.node, a.offset)) : (t.setEnd(a.node, a.offset), e.addRange(t)))
                        }
                        for (t = [], e = n; e = e.parentNode;) 1 === e.nodeType && t.push({
                            element: e,
                            left: e.scrollLeft,
                            top: e.scrollTop
                        });
                        for ("function" === typeof n.focus && n.focus(), n = 0; n < t.length; n++)(e = t[n]).element.scrollLeft = e.left, e.element.scrollTop = e.top
                    }
                }
                var mr = u && "documentMode" in document && 11 >= document.documentMode,
                    gr = null,
                    vr = null,
                    yr = null,
                    br = !1;

                function xr(e, t, n) {
                    var r = n.window === n ? n.document : 9 === n.nodeType ? n : n.ownerDocument;
                    br || null == gr || gr !== K(r) || ("selectionStart" in (r = gr) && pr(r) ? r = {
                        start: r.selectionStart,
                        end: r.selectionEnd
                    } : r = {
                        anchorNode: (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection()).anchorNode,
                        anchorOffset: r.anchorOffset,
                        focusNode: r.focusNode,
                        focusOffset: r.focusOffset
                    }, yr && lr(yr, r) || (yr = r, 0 < (r = Wr(vr, "onSelect")).length && (t = new un("onSelect", "select", null, t, n), e.push({
                        event: t,
                        listeners: r
                    }), t.target = gr)))
                }

                function _r(e, t) {
                    var n = {};
                    return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n
                }
                var Mr = {
                        animationend: _r("Animation", "AnimationEnd"),
                        animationiteration: _r("Animation", "AnimationIteration"),
                        animationstart: _r("Animation", "AnimationStart"),
                        transitionend: _r("Transition", "TransitionEnd")
                    },
                    wr = {},
                    Ar = {};

                function Sr(e) {
                    if (wr[e]) return wr[e];
                    if (!Mr[e]) return e;
                    var t, n = Mr[e];
                    for (t in n)
                        if (n.hasOwnProperty(t) && t in Ar) return wr[e] = n[t];
                    return e
                }
                u && (Ar = document.createElement("div").style, "AnimationEvent" in window || (delete Mr.animationend.animation, delete Mr.animationiteration.animation, delete Mr.animationstart.animation), "TransitionEvent" in window || delete Mr.transitionend.transition);
                var Er = Sr("animationend"),
                    Cr = Sr("animationiteration"),
                    Tr = Sr("animationstart"),
                    Pr = Sr("transitionend"),
                    Rr = new Map,
                    Ir = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");

                function Or(e, t) {
                    Rr.set(e, t), l(t, [e])
                }
                for (var Br = 0; Br < Ir.length; Br++) {
                    var Lr = Ir[Br];
                    Or(Lr.toLowerCase(), "on" + (Lr[0].toUpperCase() + Lr.slice(1)))
                }
                Or(Er, "onAnimationEnd"), Or(Cr, "onAnimationIteration"), Or(Tr, "onAnimationStart"), Or("dblclick", "onDoubleClick"), Or("focusin", "onFocus"), Or("focusout", "onBlur"), Or(Pr, "onTransitionEnd"), c("onMouseEnter", ["mouseout", "mouseover"]), c("onMouseLeave", ["mouseout", "mouseover"]), c("onPointerEnter", ["pointerout", "pointerover"]), c("onPointerLeave", ["pointerout", "pointerover"]), l("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), l("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), l("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), l("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
                var Dr = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
                    Nr = new Set("cancel close invalid load scroll toggle".split(" ").concat(Dr));

                function kr(e, t, n) {
                    var r = e.type || "unknown-event";
                    e.currentTarget = n,
                        function(e, t, n, r, i, a, s, l, c) {
                            if (He.apply(this, arguments), Ne) {
                                if (!Ne) throw Error(o(198));
                                var u = ke;
                                Ne = !1, ke = null, Fe || (Fe = !0, Ue = u)
                            }
                        }(r, t, void 0, e), e.currentTarget = null
                }

                function Fr(e, t) {
                    t = 0 !== (4 & t);
                    for (var n = 0; n < e.length; n++) {
                        var r = e[n],
                            i = r.event;
                        r = r.listeners;
                        e: {
                            var o = void 0;
                            if (t)
                                for (var a = r.length - 1; 0 <= a; a--) {
                                    var s = r[a],
                                        l = s.instance,
                                        c = s.currentTarget;
                                    if (s = s.listener, l !== o && i.isPropagationStopped()) break e;
                                    kr(i, s, c), o = l
                                } else
                                    for (a = 0; a < r.length; a++) {
                                        if (l = (s = r[a]).instance, c = s.currentTarget, s = s.listener, l !== o && i.isPropagationStopped()) break e;
                                        kr(i, s, c), o = l
                                    }
                        }
                    }
                    if (Fe) throw e = Ue, Fe = !1, Ue = null, e
                }

                function Ur(e, t) {
                    var n = t[mi];
                    void 0 === n && (n = t[mi] = new Set);
                    var r = e + "__bubble";
                    n.has(r) || (Gr(t, e, 2, !1), n.add(r))
                }

                function zr(e, t, n) {
                    var r = 0;
                    t && (r |= 4), Gr(n, e, r, t)
                }
                var Hr = "_reactListening" + Math.random().toString(36).slice(2);

                function jr(e) {
                    if (!e[Hr]) {
                        e[Hr] = !0, a.forEach((function(t) {
                            "selectionchange" !== t && (Nr.has(t) || zr(t, !1, e), zr(t, !0, e))
                        }));
                        var t = 9 === e.nodeType ? e : e.ownerDocument;
                        null === t || t[Hr] || (t[Hr] = !0, zr("selectionchange", !1, t))
                    }
                }

                function Gr(e, t, n, r) {
                    switch (Yt(t)) {
                        case 1:
                            var i = qt;
                            break;
                        case 4:
                            i = Wt;
                            break;
                        default:
                            i = Xt
                    }
                    n = i.bind(null, t, n, e), i = void 0, !Be || "touchstart" !== t && "touchmove" !== t && "wheel" !== t || (i = !0), r ? void 0 !== i ? e.addEventListener(t, n, {
                        capture: !0,
                        passive: i
                    }) : e.addEventListener(t, n, !0) : void 0 !== i ? e.addEventListener(t, n, {
                        passive: i
                    }) : e.addEventListener(t, n, !1)
                }

                function Vr(e, t, n, r, i) {
                    var o = r;
                    if (0 === (1 & t) && 0 === (2 & t) && null !== r) e: for (;;) {
                        if (null === r) return;
                        var a = r.tag;
                        if (3 === a || 4 === a) {
                            var s = r.stateNode.containerInfo;
                            if (s === i || 8 === s.nodeType && s.parentNode === i) break;
                            if (4 === a)
                                for (a = r.return; null !== a;) {
                                    var l = a.tag;
                                    if ((3 === l || 4 === l) && ((l = a.stateNode.containerInfo) === i || 8 === l.nodeType && l.parentNode === i)) return;
                                    a = a.return
                                }
                            for (; null !== s;) {
                                if (null === (a = yi(s))) return;
                                if (5 === (l = a.tag) || 6 === l) {
                                    r = o = a;
                                    continue e
                                }
                                s = s.parentNode
                            }
                        }
                        r = r.return
                    }
                    Ie((function() {
                        var r = o,
                            i = _e(n),
                            a = [];
                        e: {
                            var s = Rr.get(e);
                            if (void 0 !== s) {
                                var l = un,
                                    c = e;
                                switch (e) {
                                    case "keypress":
                                        if (0 === tn(n)) break e;
                                    case "keydown":
                                    case "keyup":
                                        l = Cn;
                                        break;
                                    case "focusin":
                                        c = "focus", l = gn;
                                        break;
                                    case "focusout":
                                        c = "blur", l = gn;
                                        break;
                                    case "beforeblur":
                                    case "afterblur":
                                        l = gn;
                                        break;
                                    case "click":
                                        if (2 === n.button) break e;
                                    case "auxclick":
                                    case "dblclick":
                                    case "mousedown":
                                    case "mousemove":
                                    case "mouseup":
                                    case "mouseout":
                                    case "mouseover":
                                    case "contextmenu":
                                        l = fn;
                                        break;
                                    case "drag":
                                    case "dragend":
                                    case "dragenter":
                                    case "dragexit":
                                    case "dragleave":
                                    case "dragover":
                                    case "dragstart":
                                    case "drop":
                                        l = mn;
                                        break;
                                    case "touchcancel":
                                    case "touchend":
                                    case "touchmove":
                                    case "touchstart":
                                        l = Pn;
                                        break;
                                    case Er:
                                    case Cr:
                                    case Tr:
                                        l = vn;
                                        break;
                                    case Pr:
                                        l = Rn;
                                        break;
                                    case "scroll":
                                        l = hn;
                                        break;
                                    case "wheel":
                                        l = On;
                                        break;
                                    case "copy":
                                    case "cut":
                                    case "paste":
                                        l = bn;
                                        break;
                                    case "gotpointercapture":
                                    case "lostpointercapture":
                                    case "pointercancel":
                                    case "pointerdown":
                                    case "pointermove":
                                    case "pointerout":
                                    case "pointerover":
                                    case "pointerup":
                                        l = Tn
                                }
                                var u = 0 !== (4 & t),
                                    d = !u && "scroll" === e,
                                    h = u ? null !== s ? s + "Capture" : null : s;
                                u = [];
                                for (var p, f = r; null !== f;) {
                                    var m = (p = f).stateNode;
                                    if (5 === p.tag && null !== m && (p = m, null !== h && (null != (m = Oe(f, h)) && u.push(qr(f, m, p)))), d) break;
                                    f = f.return
                                }
                                0 < u.length && (s = new l(s, c, null, n, i), a.push({
                                    event: s,
                                    listeners: u
                                }))
                            }
                        }
                        if (0 === (7 & t)) {
                            if (l = "mouseout" === e || "pointerout" === e, (!(s = "mouseover" === e || "pointerover" === e) || n === xe || !(c = n.relatedTarget || n.fromElement) || !yi(c) && !c[fi]) && (l || s) && (s = i.window === i ? i : (s = i.ownerDocument) ? s.defaultView || s.parentWindow : window, l ? (l = r, null !== (c = (c = n.relatedTarget || n.toElement) ? yi(c) : null) && (c !== (d = je(c)) || 5 !== c.tag && 6 !== c.tag) && (c = null)) : (l = null, c = r), l !== c)) {
                                if (u = fn, m = "onMouseLeave", h = "onMouseEnter", f = "mouse", "pointerout" !== e && "pointerover" !== e || (u = Tn, m = "onPointerLeave", h = "onPointerEnter", f = "pointer"), d = null == l ? s : xi(l), p = null == c ? s : xi(c), (s = new u(m, f + "leave", l, n, i)).target = d, s.relatedTarget = p, m = null, yi(i) === r && ((u = new u(h, f + "enter", c, n, i)).target = p, u.relatedTarget = d, m = u), d = m, l && c) e: {
                                    for (h = c, f = 0, p = u = l; p; p = Xr(p)) f++;
                                    for (p = 0, m = h; m; m = Xr(m)) p++;
                                    for (; 0 < f - p;) u = Xr(u),
                                    f--;
                                    for (; 0 < p - f;) h = Xr(h),
                                    p--;
                                    for (; f--;) {
                                        if (u === h || null !== h && u === h.alternate) break e;
                                        u = Xr(u), h = Xr(h)
                                    }
                                    u = null
                                }
                                else u = null;
                                null !== l && Kr(a, s, l, u, !1), null !== c && null !== d && Kr(a, d, c, u, !0)
                            }
                            if ("select" === (l = (s = r ? xi(r) : window).nodeName && s.nodeName.toLowerCase()) || "input" === l && "file" === s.type) var g = Yn;
                            else if (Vn(s))
                                if (Qn) g = ar;
                                else {
                                    g = ir;
                                    var v = rr
                                }
                            else(l = s.nodeName) && "input" === l.toLowerCase() && ("checkbox" === s.type || "radio" === s.type) && (g = or);
                            switch (g && (g = g(e, r)) ? qn(a, g, n, i) : (v && v(e, s, r), "focusout" === e && (v = s._wrapperState) && v.controlled && "number" === s.type && ee(s, "number", s.value)), v = r ? xi(r) : window, e) {
                                case "focusin":
                                    (Vn(v) || "true" === v.contentEditable) && (gr = v, vr = r, yr = null);
                                    break;
                                case "focusout":
                                    yr = vr = gr = null;
                                    break;
                                case "mousedown":
                                    br = !0;
                                    break;
                                case "contextmenu":
                                case "mouseup":
                                case "dragend":
                                    br = !1, xr(a, n, i);
                                    break;
                                case "selectionchange":
                                    if (mr) break;
                                case "keydown":
                                case "keyup":
                                    xr(a, n, i)
                            }
                            var y;
                            if (Ln) e: {
                                switch (e) {
                                    case "compositionstart":
                                        var b = "onCompositionStart";
                                        break e;
                                    case "compositionend":
                                        b = "onCompositionEnd";
                                        break e;
                                    case "compositionupdate":
                                        b = "onCompositionUpdate";
                                        break e
                                }
                                b = void 0
                            }
                            else jn ? zn(e, n) && (b = "onCompositionEnd") : "keydown" === e && 229 === n.keyCode && (b = "onCompositionStart");
                            b && (kn && "ko" !== n.locale && (jn || "onCompositionStart" !== b ? "onCompositionEnd" === b && jn && (y = en()) : (Zt = "value" in (Qt = i) ? Qt.value : Qt.textContent, jn = !0)), 0 < (v = Wr(r, b)).length && (b = new xn(b, e, null, n, i), a.push({
                                event: b,
                                listeners: v
                            }), y ? b.data = y : null !== (y = Hn(n)) && (b.data = y))), (y = Nn ? function(e, t) {
                                switch (e) {
                                    case "compositionend":
                                        return Hn(t);
                                    case "keypress":
                                        return 32 !== t.which ? null : (Un = !0, Fn);
                                    case "textInput":
                                        return (e = t.data) === Fn && Un ? null : e;
                                    default:
                                        return null
                                }
                            }(e, n) : function(e, t) {
                                if (jn) return "compositionend" === e || !Ln && zn(e, t) ? (e = en(), $t = Zt = Qt = null, jn = !1, e) : null;
                                switch (e) {
                                    case "paste":
                                    default:
                                        return null;
                                    case "keypress":
                                        if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
                                            if (t.char && 1 < t.char.length) return t.char;
                                            if (t.which) return String.fromCharCode(t.which)
                                        }
                                        return null;
                                    case "compositionend":
                                        return kn && "ko" !== t.locale ? null : t.data
                                }
                            }(e, n)) && (0 < (r = Wr(r, "onBeforeInput")).length && (i = new xn("onBeforeInput", "beforeinput", null, n, i), a.push({
                                event: i,
                                listeners: r
                            }), i.data = y))
                        }
                        Fr(a, t)
                    }))
                }

                function qr(e, t, n) {
                    return {
                        instance: e,
                        listener: t,
                        currentTarget: n
                    }
                }

                function Wr(e, t) {
                    for (var n = t + "Capture", r = []; null !== e;) {
                        var i = e,
                            o = i.stateNode;
                        5 === i.tag && null !== o && (i = o, null != (o = Oe(e, n)) && r.unshift(qr(e, o, i)), null != (o = Oe(e, t)) && r.push(qr(e, o, i))), e = e.return
                    }
                    return r
                }

                function Xr(e) {
                    if (null === e) return null;
                    do {
                        e = e.return
                    } while (e && 5 !== e.tag);
                    return e || null
                }

                function Kr(e, t, n, r, i) {
                    for (var o = t._reactName, a = []; null !== n && n !== r;) {
                        var s = n,
                            l = s.alternate,
                            c = s.stateNode;
                        if (null !== l && l === r) break;
                        5 === s.tag && null !== c && (s = c, i ? null != (l = Oe(n, o)) && a.unshift(qr(n, l, s)) : i || null != (l = Oe(n, o)) && a.push(qr(n, l, s))), n = n.return
                    }
                    0 !== a.length && e.push({
                        event: t,
                        listeners: a
                    })
                }
                var Jr = /\r\n?/g,
                    Yr = /\u0000|\uFFFD/g;

                function Qr(e) {
                    return ("string" === typeof e ? e : "" + e).replace(Jr, "\n").replace(Yr, "")
                }

                function Zr(e, t, n) {
                    if (t = Qr(t), Qr(e) !== t && n) throw Error(o(425))
                }

                function $r() {}
                var ei = null,
                    ti = null;

                function ni(e, t) {
                    return "textarea" === e || "noscript" === e || "string" === typeof t.children || "number" === typeof t.children || "object" === typeof t.dangerouslySetInnerHTML && null !== t.dangerouslySetInnerHTML && null != t.dangerouslySetInnerHTML.__html
                }
                var ri = "function" === typeof setTimeout ? setTimeout : void 0,
                    ii = "function" === typeof clearTimeout ? clearTimeout : void 0,
                    oi = "function" === typeof Promise ? Promise : void 0,
                    ai = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof oi ? function(e) {
                        return oi.resolve(null).then(e).catch(si)
                    } : ri;

                function si(e) {
                    setTimeout((function() {
                        throw e
                    }))
                }

                function li(e, t) {
                    var n = t,
                        r = 0;
                    do {
                        var i = n.nextSibling;
                        if (e.removeChild(n), i && 8 === i.nodeType)
                            if ("/$" === (n = i.data)) {
                                if (0 === r) return e.removeChild(i), void jt(t);
                                r--
                            } else "$" !== n && "$?" !== n && "$!" !== n || r++;
                        n = i
                    } while (n);
                    jt(t)
                }

                function ci(e) {
                    for (; null != e; e = e.nextSibling) {
                        var t = e.nodeType;
                        if (1 === t || 3 === t) break;
                        if (8 === t) {
                            if ("$" === (t = e.data) || "$!" === t || "$?" === t) break;
                            if ("/$" === t) return null
                        }
                    }
                    return e
                }

                function ui(e) {
                    e = e.previousSibling;
                    for (var t = 0; e;) {
                        if (8 === e.nodeType) {
                            var n = e.data;
                            if ("$" === n || "$!" === n || "$?" === n) {
                                if (0 === t) return e;
                                t--
                            } else "/$" === n && t++
                        }
                        e = e.previousSibling
                    }
                    return null
                }
                var di = Math.random().toString(36).slice(2),
                    hi = "__reactFiber$" + di,
                    pi = "__reactProps$" + di,
                    fi = "__reactContainer$" + di,
                    mi = "__reactEvents$" + di,
                    gi = "__reactListeners$" + di,
                    vi = "__reactHandles$" + di;

                function yi(e) {
                    var t = e[hi];
                    if (t) return t;
                    for (var n = e.parentNode; n;) {
                        if (t = n[fi] || n[hi]) {
                            if (n = t.alternate, null !== t.child || null !== n && null !== n.child)
                                for (e = ui(e); null !== e;) {
                                    if (n = e[hi]) return n;
                                    e = ui(e)
                                }
                            return t
                        }
                        n = (e = n).parentNode
                    }
                    return null
                }

                function bi(e) {
                    return !(e = e[hi] || e[fi]) || 5 !== e.tag && 6 !== e.tag && 13 !== e.tag && 3 !== e.tag ? null : e
                }

                function xi(e) {
                    if (5 === e.tag || 6 === e.tag) return e.stateNode;
                    throw Error(o(33))
                }

                function _i(e) {
                    return e[pi] || null
                }
                var Mi = [],
                    wi = -1;

                function Ai(e) {
                    return {
                        current: e
                    }
                }

                function Si(e) {
                    0 > wi || (e.current = Mi[wi], Mi[wi] = null, wi--)
                }

                function Ei(e, t) {
                    wi++, Mi[wi] = e.current, e.current = t
                }
                var Ci = {},
                    Ti = Ai(Ci),
                    Pi = Ai(!1),
                    Ri = Ci;

                function Ii(e, t) {
                    var n = e.type.contextTypes;
                    if (!n) return Ci;
                    var r = e.stateNode;
                    if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext;
                    var i, o = {};
                    for (i in n) o[i] = t[i];
                    return r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = o), o
                }

                function Oi(e) {
                    return null !== (e = e.childContextTypes) && void 0 !== e
                }

                function Bi() {
                    Si(Pi), Si(Ti)
                }

                function Li(e, t, n) {
                    if (Ti.current !== Ci) throw Error(o(168));
                    Ei(Ti, t), Ei(Pi, n)
                }

                function Di(e, t, n) {
                    var r = e.stateNode;
                    if (t = t.childContextTypes, "function" !== typeof r.getChildContext) return n;
                    for (var i in r = r.getChildContext())
                        if (!(i in t)) throw Error(o(108, G(e) || "Unknown", i));
                    return k({}, n, r)
                }

                function Ni(e) {
                    return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Ci, Ri = Ti.current, Ei(Ti, e), Ei(Pi, Pi.current), !0
                }

                function ki(e, t, n) {
                    var r = e.stateNode;
                    if (!r) throw Error(o(169));
                    n ? (e = Di(e, t, Ri), r.__reactInternalMemoizedMergedChildContext = e, Si(Pi), Si(Ti), Ei(Ti, e)) : Si(Pi), Ei(Pi, n)
                }
                var Fi = null,
                    Ui = !1,
                    zi = !1;

                function Hi(e) {
                    null === Fi ? Fi = [e] : Fi.push(e)
                }

                function ji() {
                    if (!zi && null !== Fi) {
                        zi = !0;
                        var e = 0,
                            t = bt;
                        try {
                            var n = Fi;
                            for (bt = 1; e < n.length; e++) {
                                var r = n[e];
                                do {
                                    r = r(!0)
                                } while (null !== r)
                            }
                            Fi = null, Ui = !1
                        } catch (i) {
                            throw null !== Fi && (Fi = Fi.slice(e + 1)), Xe($e, ji), i
                        } finally {
                            bt = t, zi = !1
                        }
                    }
                    return null
                }
                var Gi = [],
                    Vi = 0,
                    qi = null,
                    Wi = 0,
                    Xi = [],
                    Ki = 0,
                    Ji = null,
                    Yi = 1,
                    Qi = "";

                function Zi(e, t) {
                    Gi[Vi++] = Wi, Gi[Vi++] = qi, qi = e, Wi = t
                }

                function $i(e, t, n) {
                    Xi[Ki++] = Yi, Xi[Ki++] = Qi, Xi[Ki++] = Ji, Ji = e;
                    var r = Yi;
                    e = Qi;
                    var i = 32 - at(r) - 1;
                    r &= ~(1 << i), n += 1;
                    var o = 32 - at(t) + i;
                    if (30 < o) {
                        var a = i - i % 5;
                        o = (r & (1 << a) - 1).toString(32), r >>= a, i -= a, Yi = 1 << 32 - at(t) + i | n << i | r, Qi = o + e
                    } else Yi = 1 << o | n << i | r, Qi = e
                }

                function eo(e) {
                    null !== e.return && (Zi(e, 1), $i(e, 1, 0))
                }

                function to(e) {
                    for (; e === qi;) qi = Gi[--Vi], Gi[Vi] = null, Wi = Gi[--Vi], Gi[Vi] = null;
                    for (; e === Ji;) Ji = Xi[--Ki], Xi[Ki] = null, Qi = Xi[--Ki], Xi[Ki] = null, Yi = Xi[--Ki], Xi[Ki] = null
                }
                var no = null,
                    ro = null,
                    io = !1,
                    oo = null;

                function ao(e, t) {
                    var n = Oc(5, null, null, 0);
                    n.elementType = "DELETED", n.stateNode = t, n.return = e, null === (t = e.deletions) ? (e.deletions = [n], e.flags |= 16) : t.push(n)
                }

                function so(e, t) {
                    switch (e.tag) {
                        case 5:
                            var n = e.type;
                            return null !== (t = 1 !== t.nodeType || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t) && (e.stateNode = t, no = e, ro = ci(t.firstChild), !0);
                        case 6:
                            return null !== (t = "" === e.pendingProps || 3 !== t.nodeType ? null : t) && (e.stateNode = t, no = e, ro = null, !0);
                        case 13:
                            return null !== (t = 8 !== t.nodeType ? null : t) && (n = null !== Ji ? {
                                id: Yi,
                                overflow: Qi
                            } : null, e.memoizedState = {
                                dehydrated: t,
                                treeContext: n,
                                retryLane: 1073741824
                            }, (n = Oc(18, null, null, 0)).stateNode = t, n.return = e, e.child = n, no = e, ro = null, !0);
                        default:
                            return !1
                    }
                }

                function lo(e) {
                    return 0 !== (1 & e.mode) && 0 === (128 & e.flags)
                }

                function co(e) {
                    if (io) {
                        var t = ro;
                        if (t) {
                            var n = t;
                            if (!so(e, t)) {
                                if (lo(e)) throw Error(o(418));
                                t = ci(n.nextSibling);
                                var r = no;
                                t && so(e, t) ? ao(r, n) : (e.flags = -4097 & e.flags | 2, io = !1, no = e)
                            }
                        } else {
                            if (lo(e)) throw Error(o(418));
                            e.flags = -4097 & e.flags | 2, io = !1, no = e
                        }
                    }
                }

                function uo(e) {
                    for (e = e.return; null !== e && 5 !== e.tag && 3 !== e.tag && 13 !== e.tag;) e = e.return;
                    no = e
                }

                function ho(e) {
                    if (e !== no) return !1;
                    if (!io) return uo(e), io = !0, !1;
                    var t;
                    if ((t = 3 !== e.tag) && !(t = 5 !== e.tag) && (t = "head" !== (t = e.type) && "body" !== t && !ni(e.type, e.memoizedProps)), t && (t = ro)) {
                        if (lo(e)) throw po(), Error(o(418));
                        for (; t;) ao(e, t), t = ci(t.nextSibling)
                    }
                    if (uo(e), 13 === e.tag) {
                        if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null)) throw Error(o(317));
                        e: {
                            for (e = e.nextSibling, t = 0; e;) {
                                if (8 === e.nodeType) {
                                    var n = e.data;
                                    if ("/$" === n) {
                                        if (0 === t) {
                                            ro = ci(e.nextSibling);
                                            break e
                                        }
                                        t--
                                    } else "$" !== n && "$!" !== n && "$?" !== n || t++
                                }
                                e = e.nextSibling
                            }
                            ro = null
                        }
                    } else ro = no ? ci(e.stateNode.nextSibling) : null;
                    return !0
                }

                function po() {
                    for (var e = ro; e;) e = ci(e.nextSibling)
                }

                function fo() {
                    ro = no = null, io = !1
                }

                function mo(e) {
                    null === oo ? oo = [e] : oo.push(e)
                }
                var go = x.ReactCurrentBatchConfig;

                function vo(e, t) {
                    if (e && e.defaultProps) {
                        for (var n in t = k({}, t), e = e.defaultProps) void 0 === t[n] && (t[n] = e[n]);
                        return t
                    }
                    return t
                }
                var yo = Ai(null),
                    bo = null,
                    xo = null,
                    _o = null;

                function Mo() {
                    _o = xo = bo = null
                }

                function wo(e) {
                    var t = yo.current;
                    Si(yo), e._currentValue = t
                }

                function Ao(e, t, n) {
                    for (; null !== e;) {
                        var r = e.alternate;
                        if ((e.childLanes & t) !== t ? (e.childLanes |= t, null !== r && (r.childLanes |= t)) : null !== r && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break;
                        e = e.return
                    }
                }

                function So(e, t) {
                    bo = e, _o = xo = null, null !== (e = e.dependencies) && null !== e.firstContext && (0 !== (e.lanes & t) && (xs = !0), e.firstContext = null)
                }

                function Eo(e) {
                    var t = e._currentValue;
                    if (_o !== e)
                        if (e = {
                                context: e,
                                memoizedValue: t,
                                next: null
                            }, null === xo) {
                            if (null === bo) throw Error(o(308));
                            xo = e, bo.dependencies = {
                                lanes: 0,
                                firstContext: e
                            }
                        } else xo = xo.next = e;
                    return t
                }
                var Co = null;

                function To(e) {
                    null === Co ? Co = [e] : Co.push(e)
                }

                function Po(e, t, n, r) {
                    var i = t.interleaved;
                    return null === i ? (n.next = n, To(t)) : (n.next = i.next, i.next = n), t.interleaved = n, Ro(e, r)
                }

                function Ro(e, t) {
                    e.lanes |= t;
                    var n = e.alternate;
                    for (null !== n && (n.lanes |= t), n = e, e = e.return; null !== e;) e.childLanes |= t, null !== (n = e.alternate) && (n.childLanes |= t), n = e, e = e.return;
                    return 3 === n.tag ? n.stateNode : null
                }
                var Io = !1;

                function Oo(e) {
                    e.updateQueue = {
                        baseState: e.memoizedState,
                        firstBaseUpdate: null,
                        lastBaseUpdate: null,
                        shared: {
                            pending: null,
                            interleaved: null,
                            lanes: 0
                        },
                        effects: null
                    }
                }

                function Bo(e, t) {
                    e = e.updateQueue, t.updateQueue === e && (t.updateQueue = {
                        baseState: e.baseState,
                        firstBaseUpdate: e.firstBaseUpdate,
                        lastBaseUpdate: e.lastBaseUpdate,
                        shared: e.shared,
                        effects: e.effects
                    })
                }

                function Lo(e, t) {
                    return {
                        eventTime: e,
                        lane: t,
                        tag: 0,
                        payload: null,
                        callback: null,
                        next: null
                    }
                }

                function Do(e, t, n) {
                    var r = e.updateQueue;
                    if (null === r) return null;
                    if (r = r.shared, 0 !== (2 & Pl)) {
                        var i = r.pending;
                        return null === i ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, Ro(e, n)
                    }
                    return null === (i = r.interleaved) ? (t.next = t, To(r)) : (t.next = i.next, i.next = t), r.interleaved = t, Ro(e, n)
                }

                function No(e, t, n) {
                    if (null !== (t = t.updateQueue) && (t = t.shared, 0 !== (4194240 & n))) {
                        var r = t.lanes;
                        n |= r &= e.pendingLanes, t.lanes = n, yt(e, n)
                    }
                }

                function ko(e, t) {
                    var n = e.updateQueue,
                        r = e.alternate;
                    if (null !== r && n === (r = r.updateQueue)) {
                        var i = null,
                            o = null;
                        if (null !== (n = n.firstBaseUpdate)) {
                            do {
                                var a = {
                                    eventTime: n.eventTime,
                                    lane: n.lane,
                                    tag: n.tag,
                                    payload: n.payload,
                                    callback: n.callback,
                                    next: null
                                };
                                null === o ? i = o = a : o = o.next = a, n = n.next
                            } while (null !== n);
                            null === o ? i = o = t : o = o.next = t
                        } else i = o = t;
                        return n = {
                            baseState: r.baseState,
                            firstBaseUpdate: i,
                            lastBaseUpdate: o,
                            shared: r.shared,
                            effects: r.effects
                        }, void(e.updateQueue = n)
                    }
                    null === (e = n.lastBaseUpdate) ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t
                }

                function Fo(e, t, n, r) {
                    var i = e.updateQueue;
                    Io = !1;
                    var o = i.firstBaseUpdate,
                        a = i.lastBaseUpdate,
                        s = i.shared.pending;
                    if (null !== s) {
                        i.shared.pending = null;
                        var l = s,
                            c = l.next;
                        l.next = null, null === a ? o = c : a.next = c, a = l;
                        var u = e.alternate;
                        null !== u && ((s = (u = u.updateQueue).lastBaseUpdate) !== a && (null === s ? u.firstBaseUpdate = c : s.next = c, u.lastBaseUpdate = l))
                    }
                    if (null !== o) {
                        var d = i.baseState;
                        for (a = 0, u = c = l = null, s = o;;) {
                            var h = s.lane,
                                p = s.eventTime;
                            if ((r & h) === h) {
                                null !== u && (u = u.next = {
                                    eventTime: p,
                                    lane: 0,
                                    tag: s.tag,
                                    payload: s.payload,
                                    callback: s.callback,
                                    next: null
                                });
                                e: {
                                    var f = e,
                                        m = s;
                                    switch (h = t, p = n, m.tag) {
                                        case 1:
                                            if ("function" === typeof(f = m.payload)) {
                                                d = f.call(p, d, h);
                                                break e
                                            }
                                            d = f;
                                            break e;
                                        case 3:
                                            f.flags = -65537 & f.flags | 128;
                                        case 0:
                                            if (null === (h = "function" === typeof(f = m.payload) ? f.call(p, d, h) : f) || void 0 === h) break e;
                                            d = k({}, d, h);
                                            break e;
                                        case 2:
                                            Io = !0
                                    }
                                }
                                null !== s.callback && 0 !== s.lane && (e.flags |= 64, null === (h = i.effects) ? i.effects = [s] : h.push(s))
                            } else p = {
                                eventTime: p,
                                lane: h,
                                tag: s.tag,
                                payload: s.payload,
                                callback: s.callback,
                                next: null
                            }, null === u ? (c = u = p, l = d) : u = u.next = p, a |= h;
                            if (null === (s = s.next)) {
                                if (null === (s = i.shared.pending)) break;
                                s = (h = s).next, h.next = null, i.lastBaseUpdate = h, i.shared.pending = null
                            }
                        }
                        if (null === u && (l = d), i.baseState = l, i.firstBaseUpdate = c, i.lastBaseUpdate = u, null !== (t = i.shared.interleaved)) {
                            i = t;
                            do {
                                a |= i.lane, i = i.next
                            } while (i !== t)
                        } else null === o && (i.shared.lanes = 0);
                        kl |= a, e.lanes = a, e.memoizedState = d
                    }
                }

                function Uo(e, t, n) {
                    if (e = t.effects, t.effects = null, null !== e)
                        for (t = 0; t < e.length; t++) {
                            var r = e[t],
                                i = r.callback;
                            if (null !== i) {
                                if (r.callback = null, r = n, "function" !== typeof i) throw Error(o(191, i));
                                i.call(r)
                            }
                        }
                }
                var zo = (new r.Component).refs;

                function Ho(e, t, n, r) {
                    n = null === (n = n(r, t = e.memoizedState)) || void 0 === n ? t : k({}, t, n), e.memoizedState = n, 0 === e.lanes && (e.updateQueue.baseState = n)
                }
                var jo = {
                    isMounted: function(e) {
                        return !!(e = e._reactInternals) && je(e) === e
                    },
                    enqueueSetState: function(e, t, n) {
                        e = e._reactInternals;
                        var r = tc(),
                            i = nc(e),
                            o = Lo(r, i);
                        o.payload = t, void 0 !== n && null !== n && (o.callback = n), null !== (t = Do(e, o, i)) && (rc(t, e, i, r), No(t, e, i))
                    },
                    enqueueReplaceState: function(e, t, n) {
                        e = e._reactInternals;
                        var r = tc(),
                            i = nc(e),
                            o = Lo(r, i);
                        o.tag = 1, o.payload = t, void 0 !== n && null !== n && (o.callback = n), null !== (t = Do(e, o, i)) && (rc(t, e, i, r), No(t, e, i))
                    },
                    enqueueForceUpdate: function(e, t) {
                        e = e._reactInternals;
                        var n = tc(),
                            r = nc(e),
                            i = Lo(n, r);
                        i.tag = 2, void 0 !== t && null !== t && (i.callback = t), null !== (t = Do(e, i, r)) && (rc(t, e, r, n), No(t, e, r))
                    }
                };

                function Go(e, t, n, r, i, o, a) {
                    return "function" === typeof(e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(r, o, a) : !t.prototype || !t.prototype.isPureReactComponent || (!lr(n, r) || !lr(i, o))
                }

                function Vo(e, t, n) {
                    var r = !1,
                        i = Ci,
                        o = t.contextType;
                    return "object" === typeof o && null !== o ? o = Eo(o) : (i = Oi(t) ? Ri : Ti.current, o = (r = null !== (r = t.contextTypes) && void 0 !== r) ? Ii(e, i) : Ci), t = new t(n, o), e.memoizedState = null !== t.state && void 0 !== t.state ? t.state : null, t.updater = jo, e.stateNode = t, t._reactInternals = e, r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = o), t
                }

                function qo(e, t, n, r) {
                    e = t.state, "function" === typeof t.componentWillReceiveProps && t.componentWillReceiveProps(n, r), "function" === typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && jo.enqueueReplaceState(t, t.state, null)
                }

                function Wo(e, t, n, r) {
                    var i = e.stateNode;
                    i.props = n, i.state = e.memoizedState, i.refs = zo, Oo(e);
                    var o = t.contextType;
                    "object" === typeof o && null !== o ? i.context = Eo(o) : (o = Oi(t) ? Ri : Ti.current, i.context = Ii(e, o)), i.state = e.memoizedState, "function" === typeof(o = t.getDerivedStateFromProps) && (Ho(e, t, o, n), i.state = e.memoizedState), "function" === typeof t.getDerivedStateFromProps || "function" === typeof i.getSnapshotBeforeUpdate || "function" !== typeof i.UNSAFE_componentWillMount && "function" !== typeof i.componentWillMount || (t = i.state, "function" === typeof i.componentWillMount && i.componentWillMount(), "function" === typeof i.UNSAFE_componentWillMount && i.UNSAFE_componentWillMount(), t !== i.state && jo.enqueueReplaceState(i, i.state, null), Fo(e, n, i, r), i.state = e.memoizedState), "function" === typeof i.componentDidMount && (e.flags |= 4194308)
                }

                function Xo(e, t, n) {
                    if (null !== (e = n.ref) && "function" !== typeof e && "object" !== typeof e) {
                        if (n._owner) {
                            if (n = n._owner) {
                                if (1 !== n.tag) throw Error(o(309));
                                var r = n.stateNode
                            }
                            if (!r) throw Error(o(147, e));
                            var i = r,
                                a = "" + e;
                            return null !== t && null !== t.ref && "function" === typeof t.ref && t.ref._stringRef === a ? t.ref : (t = function(e) {
                                var t = i.refs;
                                t === zo && (t = i.refs = {}), null === e ? delete t[a] : t[a] = e
                            }, t._stringRef = a, t)
                        }
                        if ("string" !== typeof e) throw Error(o(284));
                        if (!n._owner) throw Error(o(290, e))
                    }
                    return e
                }

                function Ko(e, t) {
                    throw e = Object.prototype.toString.call(t), Error(o(31, "[object Object]" === e ? "object with keys {" + Object.keys(t).join(", ") + "}" : e))
                }

                function Jo(e) {
                    return (0, e._init)(e._payload)
                }

                function Yo(e) {
                    function t(t, n) {
                        if (e) {
                            var r = t.deletions;
                            null === r ? (t.deletions = [n], t.flags |= 16) : r.push(n)
                        }
                    }

                    function n(n, r) {
                        if (!e) return null;
                        for (; null !== r;) t(n, r), r = r.sibling;
                        return null
                    }

                    function r(e, t) {
                        for (e = new Map; null !== t;) null !== t.key ? e.set(t.key, t) : e.set(t.index, t), t = t.sibling;
                        return e
                    }

                    function i(e, t) {
                        return (e = Lc(e, t)).index = 0, e.sibling = null, e
                    }

                    function a(t, n, r) {
                        return t.index = r, e ? null !== (r = t.alternate) ? (r = r.index) < n ? (t.flags |= 2, n) : r : (t.flags |= 2, n) : (t.flags |= 1048576, n)
                    }

                    function s(t) {
                        return e && null === t.alternate && (t.flags |= 2), t
                    }

                    function l(e, t, n, r) {
                        return null === t || 6 !== t.tag ? ((t = Fc(n, e.mode, r)).return = e, t) : ((t = i(t, n)).return = e, t)
                    }

                    function c(e, t, n, r) {
                        var o = n.type;
                        return o === w ? d(e, t, n.props.children, r, n.key) : null !== t && (t.elementType === o || "object" === typeof o && null !== o && o.$$typeof === O && Jo(o) === t.type) ? ((r = i(t, n.props)).ref = Xo(e, t, n), r.return = e, r) : ((r = Dc(n.type, n.key, n.props, null, e.mode, r)).ref = Xo(e, t, n), r.return = e, r)
                    }

                    function u(e, t, n, r) {
                        return null === t || 4 !== t.tag || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? ((t = Uc(n, e.mode, r)).return = e, t) : ((t = i(t, n.children || [])).return = e, t)
                    }

                    function d(e, t, n, r, o) {
                        return null === t || 7 !== t.tag ? ((t = Nc(n, e.mode, r, o)).return = e, t) : ((t = i(t, n)).return = e, t)
                    }

                    function h(e, t, n) {
                        if ("string" === typeof t && "" !== t || "number" === typeof t) return (t = Fc("" + t, e.mode, n)).return = e, t;
                        if ("object" === typeof t && null !== t) {
                            switch (t.$$typeof) {
                                case _:
                                    return (n = Dc(t.type, t.key, t.props, null, e.mode, n)).ref = Xo(e, null, t), n.return = e, n;
                                case M:
                                    return (t = Uc(t, e.mode, n)).return = e, t;
                                case O:
                                    return h(e, (0, t._init)(t._payload), n)
                            }
                            if (te(t) || D(t)) return (t = Nc(t, e.mode, n, null)).return = e, t;
                            Ko(e, t)
                        }
                        return null
                    }

                    function p(e, t, n, r) {
                        var i = null !== t ? t.key : null;
                        if ("string" === typeof n && "" !== n || "number" === typeof n) return null !== i ? null : l(e, t, "" + n, r);
                        if ("object" === typeof n && null !== n) {
                            switch (n.$$typeof) {
                                case _:
                                    return n.key === i ? c(e, t, n, r) : null;
                                case M:
                                    return n.key === i ? u(e, t, n, r) : null;
                                case O:
                                    return p(e, t, (i = n._init)(n._payload), r)
                            }
                            if (te(n) || D(n)) return null !== i ? null : d(e, t, n, r, null);
                            Ko(e, n)
                        }
                        return null
                    }

                    function f(e, t, n, r, i) {
                        if ("string" === typeof r && "" !== r || "number" === typeof r) return l(t, e = e.get(n) || null, "" + r, i);
                        if ("object" === typeof r && null !== r) {
                            switch (r.$$typeof) {
                                case _:
                                    return c(t, e = e.get(null === r.key ? n : r.key) || null, r, i);
                                case M:
                                    return u(t, e = e.get(null === r.key ? n : r.key) || null, r, i);
                                case O:
                                    return f(e, t, n, (0, r._init)(r._payload), i)
                            }
                            if (te(r) || D(r)) return d(t, e = e.get(n) || null, r, i, null);
                            Ko(t, r)
                        }
                        return null
                    }

                    function m(i, o, s, l) {
                        for (var c = null, u = null, d = o, m = o = 0, g = null; null !== d && m < s.length; m++) {
                            d.index > m ? (g = d, d = null) : g = d.sibling;
                            var v = p(i, d, s[m], l);
                            if (null === v) {
                                null === d && (d = g);
                                break
                            }
                            e && d && null === v.alternate && t(i, d), o = a(v, o, m), null === u ? c = v : u.sibling = v, u = v, d = g
                        }
                        if (m === s.length) return n(i, d), io && Zi(i, m), c;
                        if (null === d) {
                            for (; m < s.length; m++) null !== (d = h(i, s[m], l)) && (o = a(d, o, m), null === u ? c = d : u.sibling = d, u = d);
                            return io && Zi(i, m), c
                        }
                        for (d = r(i, d); m < s.length; m++) null !== (g = f(d, i, m, s[m], l)) && (e && null !== g.alternate && d.delete(null === g.key ? m : g.key), o = a(g, o, m), null === u ? c = g : u.sibling = g, u = g);
                        return e && d.forEach((function(e) {
                            return t(i, e)
                        })), io && Zi(i, m), c
                    }

                    function g(i, s, l, c) {
                        var u = D(l);
                        if ("function" !== typeof u) throw Error(o(150));
                        if (null == (l = u.call(l))) throw Error(o(151));
                        for (var d = u = null, m = s, g = s = 0, v = null, y = l.next(); null !== m && !y.done; g++, y = l.next()) {
                            m.index > g ? (v = m, m = null) : v = m.sibling;
                            var b = p(i, m, y.value, c);
                            if (null === b) {
                                null === m && (m = v);
                                break
                            }
                            e && m && null === b.alternate && t(i, m), s = a(b, s, g), null === d ? u = b : d.sibling = b, d = b, m = v
                        }
                        if (y.done) return n(i, m), io && Zi(i, g), u;
                        if (null === m) {
                            for (; !y.done; g++, y = l.next()) null !== (y = h(i, y.value, c)) && (s = a(y, s, g), null === d ? u = y : d.sibling = y, d = y);
                            return io && Zi(i, g), u
                        }
                        for (m = r(i, m); !y.done; g++, y = l.next()) null !== (y = f(m, i, g, y.value, c)) && (e && null !== y.alternate && m.delete(null === y.key ? g : y.key), s = a(y, s, g), null === d ? u = y : d.sibling = y, d = y);
                        return e && m.forEach((function(e) {
                            return t(i, e)
                        })), io && Zi(i, g), u
                    }
                    return function e(r, o, a, l) {
                        if ("object" === typeof a && null !== a && a.type === w && null === a.key && (a = a.props.children), "object" === typeof a && null !== a) {
                            switch (a.$$typeof) {
                                case _:
                                    e: {
                                        for (var c = a.key, u = o; null !== u;) {
                                            if (u.key === c) {
                                                if ((c = a.type) === w) {
                                                    if (7 === u.tag) {
                                                        n(r, u.sibling), (o = i(u, a.props.children)).return = r, r = o;
                                                        break e
                                                    }
                                                } else if (u.elementType === c || "object" === typeof c && null !== c && c.$$typeof === O && Jo(c) === u.type) {
                                                    n(r, u.sibling), (o = i(u, a.props)).ref = Xo(r, u, a), o.return = r, r = o;
                                                    break e
                                                }
                                                n(r, u);
                                                break
                                            }
                                            t(r, u), u = u.sibling
                                        }
                                        a.type === w ? ((o = Nc(a.props.children, r.mode, l, a.key)).return = r, r = o) : ((l = Dc(a.type, a.key, a.props, null, r.mode, l)).ref = Xo(r, o, a), l.return = r, r = l)
                                    }
                                    return s(r);
                                case M:
                                    e: {
                                        for (u = a.key; null !== o;) {
                                            if (o.key === u) {
                                                if (4 === o.tag && o.stateNode.containerInfo === a.containerInfo && o.stateNode.implementation === a.implementation) {
                                                    n(r, o.sibling), (o = i(o, a.children || [])).return = r, r = o;
                                                    break e
                                                }
                                                n(r, o);
                                                break
                                            }
                                            t(r, o), o = o.sibling
                                        }(o = Uc(a, r.mode, l)).return = r,
                                        r = o
                                    }
                                    return s(r);
                                case O:
                                    return e(r, o, (u = a._init)(a._payload), l)
                            }
                            if (te(a)) return m(r, o, a, l);
                            if (D(a)) return g(r, o, a, l);
                            Ko(r, a)
                        }
                        return "string" === typeof a && "" !== a || "number" === typeof a ? (a = "" + a, null !== o && 6 === o.tag ? (n(r, o.sibling), (o = i(o, a)).return = r, r = o) : (n(r, o), (o = Fc(a, r.mode, l)).return = r, r = o), s(r)) : n(r, o)
                    }
                }
                var Qo = Yo(!0),
                    Zo = Yo(!1),
                    $o = {},
                    ea = Ai($o),
                    ta = Ai($o),
                    na = Ai($o);

                function ra(e) {
                    if (e === $o) throw Error(o(174));
                    return e
                }

                function ia(e, t) {
                    switch (Ei(na, t), Ei(ta, e), Ei(ea, $o), e = t.nodeType) {
                        case 9:
                        case 11:
                            t = (t = t.documentElement) ? t.namespaceURI : le(null, "");
                            break;
                        default:
                            t = le(t = (e = 8 === e ? t.parentNode : t).namespaceURI || null, e = e.tagName)
                    }
                    Si(ea), Ei(ea, t)
                }

                function oa() {
                    Si(ea), Si(ta), Si(na)
                }

                function aa(e) {
                    ra(na.current);
                    var t = ra(ea.current),
                        n = le(t, e.type);
                    t !== n && (Ei(ta, e), Ei(ea, n))
                }

                function sa(e) {
                    ta.current === e && (Si(ea), Si(ta))
                }
                var la = Ai(0);

                function ca(e) {
                    for (var t = e; null !== t;) {
                        if (13 === t.tag) {
                            var n = t.memoizedState;
                            if (null !== n && (null === (n = n.dehydrated) || "$?" === n.data || "$!" === n.data)) return t
                        } else if (19 === t.tag && void 0 !== t.memoizedProps.revealOrder) {
                            if (0 !== (128 & t.flags)) return t
                        } else if (null !== t.child) {
                            t.child.return = t, t = t.child;
                            continue
                        }
                        if (t === e) break;
                        for (; null === t.sibling;) {
                            if (null === t.return || t.return === e) return null;
                            t = t.return
                        }
                        t.sibling.return = t.return, t = t.sibling
                    }
                    return null
                }
                var ua = [];

                function da() {
                    for (var e = 0; e < ua.length; e++) ua[e]._workInProgressVersionPrimary = null;
                    ua.length = 0
                }
                var ha = x.ReactCurrentDispatcher,
                    pa = x.ReactCurrentBatchConfig,
                    fa = 0,
                    ma = null,
                    ga = null,
                    va = null,
                    ya = !1,
                    ba = !1,
                    xa = 0,
                    _a = 0;

                function Ma() {
                    throw Error(o(321))
                }

                function wa(e, t) {
                    if (null === t) return !1;
                    for (var n = 0; n < t.length && n < e.length; n++)
                        if (!sr(e[n], t[n])) return !1;
                    return !0
                }

                function Aa(e, t, n, r, i, a) {
                    if (fa = a, ma = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, ha.current = null === e || null === e.memoizedState ? ss : ls, e = n(r, i), ba) {
                        a = 0;
                        do {
                            if (ba = !1, xa = 0, 25 <= a) throw Error(o(301));
                            a += 1, va = ga = null, t.updateQueue = null, ha.current = cs, e = n(r, i)
                        } while (ba)
                    }
                    if (ha.current = as, t = null !== ga && null !== ga.next, fa = 0, va = ga = ma = null, ya = !1, t) throw Error(o(300));
                    return e
                }

                function Sa() {
                    var e = 0 !== xa;
                    return xa = 0, e
                }

                function Ea() {
                    var e = {
                        memoizedState: null,
                        baseState: null,
                        baseQueue: null,
                        queue: null,
                        next: null
                    };
                    return null === va ? ma.memoizedState = va = e : va = va.next = e, va
                }

                function Ca() {
                    if (null === ga) {
                        var e = ma.alternate;
                        e = null !== e ? e.memoizedState : null
                    } else e = ga.next;
                    var t = null === va ? ma.memoizedState : va.next;
                    if (null !== t) va = t, ga = e;
                    else {
                        if (null === e) throw Error(o(310));
                        e = {
                            memoizedState: (ga = e).memoizedState,
                            baseState: ga.baseState,
                            baseQueue: ga.baseQueue,
                            queue: ga.queue,
                            next: null
                        }, null === va ? ma.memoizedState = va = e : va = va.next = e
                    }
                    return va
                }

                function Ta(e, t) {
                    return "function" === typeof t ? t(e) : t
                }

                function Pa(e) {
                    var t = Ca(),
                        n = t.queue;
                    if (null === n) throw Error(o(311));
                    n.lastRenderedReducer = e;
                    var r = ga,
                        i = r.baseQueue,
                        a = n.pending;
                    if (null !== a) {
                        if (null !== i) {
                            var s = i.next;
                            i.next = a.next, a.next = s
                        }
                        r.baseQueue = i = a, n.pending = null
                    }
                    if (null !== i) {
                        a = i.next, r = r.baseState;
                        var l = s = null,
                            c = null,
                            u = a;
                        do {
                            var d = u.lane;
                            if ((fa & d) === d) null !== c && (c = c.next = {
                                lane: 0,
                                action: u.action,
                                hasEagerState: u.hasEagerState,
                                eagerState: u.eagerState,
                                next: null
                            }), r = u.hasEagerState ? u.eagerState : e(r, u.action);
                            else {
                                var h = {
                                    lane: d,
                                    action: u.action,
                                    hasEagerState: u.hasEagerState,
                                    eagerState: u.eagerState,
                                    next: null
                                };
                                null === c ? (l = c = h, s = r) : c = c.next = h, ma.lanes |= d, kl |= d
                            }
                            u = u.next
                        } while (null !== u && u !== a);
                        null === c ? s = r : c.next = l, sr(r, t.memoizedState) || (xs = !0), t.memoizedState = r, t.baseState = s, t.baseQueue = c, n.lastRenderedState = r
                    }
                    if (null !== (e = n.interleaved)) {
                        i = e;
                        do {
                            a = i.lane, ma.lanes |= a, kl |= a, i = i.next
                        } while (i !== e)
                    } else null === i && (n.lanes = 0);
                    return [t.memoizedState, n.dispatch]
                }

                function Ra(e) {
                    var t = Ca(),
                        n = t.queue;
                    if (null === n) throw Error(o(311));
                    n.lastRenderedReducer = e;
                    var r = n.dispatch,
                        i = n.pending,
                        a = t.memoizedState;
                    if (null !== i) {
                        n.pending = null;
                        var s = i = i.next;
                        do {
                            a = e(a, s.action), s = s.next
                        } while (s !== i);
                        sr(a, t.memoizedState) || (xs = !0), t.memoizedState = a, null === t.baseQueue && (t.baseState = a), n.lastRenderedState = a
                    }
                    return [a, r]
                }

                function Ia() {}

                function Oa(e, t) {
                    var n = ma,
                        r = Ca(),
                        i = t(),
                        a = !sr(r.memoizedState, i);
                    if (a && (r.memoizedState = i, xs = !0), r = r.queue, Va(Da.bind(null, n, r, e), [e]), r.getSnapshot !== t || a || null !== va && 1 & va.memoizedState.tag) {
                        if (n.flags |= 2048, Ua(9, La.bind(null, n, r, i, t), void 0, null), null === Rl) throw Error(o(349));
                        0 !== (30 & fa) || Ba(n, t, i)
                    }
                    return i
                }

                function Ba(e, t, n) {
                    e.flags |= 16384, e = {
                        getSnapshot: t,
                        value: n
                    }, null === (t = ma.updateQueue) ? (t = {
                        lastEffect: null,
                        stores: null
                    }, ma.updateQueue = t, t.stores = [e]) : null === (n = t.stores) ? t.stores = [e] : n.push(e)
                }

                function La(e, t, n, r) {
                    t.value = n, t.getSnapshot = r, Na(t) && ka(e)
                }

                function Da(e, t, n) {
                    return n((function() {
                        Na(t) && ka(e)
                    }))
                }

                function Na(e) {
                    var t = e.getSnapshot;
                    e = e.value;
                    try {
                        var n = t();
                        return !sr(e, n)
                    } catch (r) {
                        return !0
                    }
                }

                function ka(e) {
                    var t = Ro(e, 1);
                    null !== t && rc(t, e, 1, -1)
                }

                function Fa(e) {
                    var t = Ea();
                    return "function" === typeof e && (e = e()), t.memoizedState = t.baseState = e, e = {
                        pending: null,
                        interleaved: null,
                        lanes: 0,
                        dispatch: null,
                        lastRenderedReducer: Ta,
                        lastRenderedState: e
                    }, t.queue = e, e = e.dispatch = ns.bind(null, ma, e), [t.memoizedState, e]
                }

                function Ua(e, t, n, r) {
                    return e = {
                        tag: e,
                        create: t,
                        destroy: n,
                        deps: r,
                        next: null
                    }, null === (t = ma.updateQueue) ? (t = {
                        lastEffect: null,
                        stores: null
                    }, ma.updateQueue = t, t.lastEffect = e.next = e) : null === (n = t.lastEffect) ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e), e
                }

                function za() {
                    return Ca().memoizedState
                }

                function Ha(e, t, n, r) {
                    var i = Ea();
                    ma.flags |= e, i.memoizedState = Ua(1 | t, n, void 0, void 0 === r ? null : r)
                }

                function ja(e, t, n, r) {
                    var i = Ca();
                    r = void 0 === r ? null : r;
                    var o = void 0;
                    if (null !== ga) {
                        var a = ga.memoizedState;
                        if (o = a.destroy, null !== r && wa(r, a.deps)) return void(i.memoizedState = Ua(t, n, o, r))
                    }
                    ma.flags |= e, i.memoizedState = Ua(1 | t, n, o, r)
                }

                function Ga(e, t) {
                    return Ha(8390656, 8, e, t)
                }

                function Va(e, t) {
                    return ja(2048, 8, e, t)
                }

                function qa(e, t) {
                    return ja(4, 2, e, t)
                }

                function Wa(e, t) {
                    return ja(4, 4, e, t)
                }

                function Xa(e, t) {
                    return "function" === typeof t ? (e = e(), t(e), function() {
                        t(null)
                    }) : null !== t && void 0 !== t ? (e = e(), t.current = e, function() {
                        t.current = null
                    }) : void 0
                }

                function Ka(e, t, n) {
                    return n = null !== n && void 0 !== n ? n.concat([e]) : null, ja(4, 4, Xa.bind(null, t, e), n)
                }

                function Ja() {}

                function Ya(e, t) {
                    var n = Ca();
                    t = void 0 === t ? null : t;
                    var r = n.memoizedState;
                    return null !== r && null !== t && wa(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e)
                }

                function Qa(e, t) {
                    var n = Ca();
                    t = void 0 === t ? null : t;
                    var r = n.memoizedState;
                    return null !== r && null !== t && wa(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e)
                }

                function Za(e, t, n) {
                    return 0 === (21 & fa) ? (e.baseState && (e.baseState = !1, xs = !0), e.memoizedState = n) : (sr(n, t) || (n = mt(), ma.lanes |= n, kl |= n, e.baseState = !0), t)
                }

                function $a(e, t) {
                    var n = bt;
                    bt = 0 !== n && 4 > n ? n : 4, e(!0);
                    var r = pa.transition;
                    pa.transition = {};
                    try {
                        e(!1), t()
                    } finally {
                        bt = n, pa.transition = r
                    }
                }

                function es() {
                    return Ca().memoizedState
                }

                function ts(e, t, n) {
                    var r = nc(e);
                    if (n = {
                            lane: r,
                            action: n,
                            hasEagerState: !1,
                            eagerState: null,
                            next: null
                        }, rs(e)) is(t, n);
                    else if (null !== (n = Po(e, t, n, r))) {
                        rc(n, e, r, tc()), os(n, t, r)
                    }
                }

                function ns(e, t, n) {
                    var r = nc(e),
                        i = {
                            lane: r,
                            action: n,
                            hasEagerState: !1,
                            eagerState: null,
                            next: null
                        };
                    if (rs(e)) is(t, i);
                    else {
                        var o = e.alternate;
                        if (0 === e.lanes && (null === o || 0 === o.lanes) && null !== (o = t.lastRenderedReducer)) try {
                            var a = t.lastRenderedState,
                                s = o(a, n);
                            if (i.hasEagerState = !0, i.eagerState = s, sr(s, a)) {
                                var l = t.interleaved;
                                return null === l ? (i.next = i, To(t)) : (i.next = l.next, l.next = i), void(t.interleaved = i)
                            }
                        } catch (c) {}
                        null !== (n = Po(e, t, i, r)) && (rc(n, e, r, i = tc()), os(n, t, r))
                    }
                }

                function rs(e) {
                    var t = e.alternate;
                    return e === ma || null !== t && t === ma
                }

                function is(e, t) {
                    ba = ya = !0;
                    var n = e.pending;
                    null === n ? t.next = t : (t.next = n.next, n.next = t), e.pending = t
                }

                function os(e, t, n) {
                    if (0 !== (4194240 & n)) {
                        var r = t.lanes;
                        n |= r &= e.pendingLanes, t.lanes = n, yt(e, n)
                    }
                }
                var as = {
                        readContext: Eo,
                        useCallback: Ma,
                        useContext: Ma,
                        useEffect: Ma,
                        useImperativeHandle: Ma,
                        useInsertionEffect: Ma,
                        useLayoutEffect: Ma,
                        useMemo: Ma,
                        useReducer: Ma,
                        useRef: Ma,
                        useState: Ma,
                        useDebugValue: Ma,
                        useDeferredValue: Ma,
                        useTransition: Ma,
                        useMutableSource: Ma,
                        useSyncExternalStore: Ma,
                        useId: Ma,
                        unstable_isNewReconciler: !1
                    },
                    ss = {
                        readContext: Eo,
                        useCallback: function(e, t) {
                            return Ea().memoizedState = [e, void 0 === t ? null : t], e
                        },
                        useContext: Eo,
                        useEffect: Ga,
                        useImperativeHandle: function(e, t, n) {
                            return n = null !== n && void 0 !== n ? n.concat([e]) : null, Ha(4194308, 4, Xa.bind(null, t, e), n)
                        },
                        useLayoutEffect: function(e, t) {
                            return Ha(4194308, 4, e, t)
                        },
                        useInsertionEffect: function(e, t) {
                            return Ha(4, 2, e, t)
                        },
                        useMemo: function(e, t) {
                            var n = Ea();
                            return t = void 0 === t ? null : t, e = e(), n.memoizedState = [e, t], e
                        },
                        useReducer: function(e, t, n) {
                            var r = Ea();
                            return t = void 0 !== n ? n(t) : t, r.memoizedState = r.baseState = t, e = {
                                pending: null,
                                interleaved: null,
                                lanes: 0,
                                dispatch: null,
                                lastRenderedReducer: e,
                                lastRenderedState: t
                            }, r.queue = e, e = e.dispatch = ts.bind(null, ma, e), [r.memoizedState, e]
                        },
                        useRef: function(e) {
                            return e = {
                                current: e
                            }, Ea().memoizedState = e
                        },
                        useState: Fa,
                        useDebugValue: Ja,
                        useDeferredValue: function(e) {
                            return Ea().memoizedState = e
                        },
                        useTransition: function() {
                            var e = Fa(!1),
                                t = e[0];
                            return e = $a.bind(null, e[1]), Ea().memoizedState = e, [t, e]
                        },
                        useMutableSource: function() {},
                        useSyncExternalStore: function(e, t, n) {
                            var r = ma,
                                i = Ea();
                            if (io) {
                                if (void 0 === n) throw Error(o(407));
                                n = n()
                            } else {
                                if (n = t(), null === Rl) throw Error(o(349));
                                0 !== (30 & fa) || Ba(r, t, n)
                            }
                            i.memoizedState = n;
                            var a = {
                                value: n,
                                getSnapshot: t
                            };
                            return i.queue = a, Ga(Da.bind(null, r, a, e), [e]), r.flags |= 2048, Ua(9, La.bind(null, r, a, n, t), void 0, null), n
                        },
                        useId: function() {
                            var e = Ea(),
                                t = Rl.identifierPrefix;
                            if (io) {
                                var n = Qi;
                                t = ":" + t + "R" + (n = (Yi & ~(1 << 32 - at(Yi) - 1)).toString(32) + n), 0 < (n = xa++) && (t += "H" + n.toString(32)), t += ":"
                            } else t = ":" + t + "r" + (n = _a++).toString(32) + ":";
                            return e.memoizedState = t
                        },
                        unstable_isNewReconciler: !1
                    },
                    ls = {
                        readContext: Eo,
                        useCallback: Ya,
                        useContext: Eo,
                        useEffect: Va,
                        useImperativeHandle: Ka,
                        useInsertionEffect: qa,
                        useLayoutEffect: Wa,
                        useMemo: Qa,
                        useReducer: Pa,
                        useRef: za,
                        useState: function() {
                            return Pa(Ta)
                        },
                        useDebugValue: Ja,
                        useDeferredValue: function(e) {
                            return Za(Ca(), ga.memoizedState, e)
                        },
                        useTransition: function() {
                            return [Pa(Ta)[0], Ca().memoizedState]
                        },
                        useMutableSource: Ia,
                        useSyncExternalStore: Oa,
                        useId: es,
                        unstable_isNewReconciler: !1
                    },
                    cs = {
                        readContext: Eo,
                        useCallback: Ya,
                        useContext: Eo,
                        useEffect: Va,
                        useImperativeHandle: Ka,
                        useInsertionEffect: qa,
                        useLayoutEffect: Wa,
                        useMemo: Qa,
                        useReducer: Ra,
                        useRef: za,
                        useState: function() {
                            return Ra(Ta)
                        },
                        useDebugValue: Ja,
                        useDeferredValue: function(e) {
                            var t = Ca();
                            return null === ga ? t.memoizedState = e : Za(t, ga.memoizedState, e)
                        },
                        useTransition: function() {
                            return [Ra(Ta)[0], Ca().memoizedState]
                        },
                        useMutableSource: Ia,
                        useSyncExternalStore: Oa,
                        useId: es,
                        unstable_isNewReconciler: !1
                    };

                function us(e, t) {
                    try {
                        var n = "",
                            r = t;
                        do {
                            n += H(r), r = r.return
                        } while (r);
                        var i = n
                    } catch (o) {
                        i = "\nError generating stack: " + o.message + "\n" + o.stack
                    }
                    return {
                        value: e,
                        source: t,
                        stack: i,
                        digest: null
                    }
                }

                function ds(e, t, n) {
                    return {
                        value: e,
                        source: null,
                        stack: null != n ? n : null,
                        digest: null != t ? t : null
                    }
                }

                function hs(e, t) {
                    try {
                        console.error(t.value)
                    } catch (n) {
                        setTimeout((function() {
                            throw n
                        }))
                    }
                }
                var ps = "function" === typeof WeakMap ? WeakMap : Map;

                function fs(e, t, n) {
                    (n = Lo(-1, n)).tag = 3, n.payload = {
                        element: null
                    };
                    var r = t.value;
                    return n.callback = function() {
                        ql || (ql = !0, Wl = r), hs(0, t)
                    }, n
                }

                function ms(e, t, n) {
                    (n = Lo(-1, n)).tag = 3;
                    var r = e.type.getDerivedStateFromError;
                    if ("function" === typeof r) {
                        var i = t.value;
                        n.payload = function() {
                            return r(i)
                        }, n.callback = function() {
                            hs(0, t)
                        }
                    }
                    var o = e.stateNode;
                    return null !== o && "function" === typeof o.componentDidCatch && (n.callback = function() {
                        hs(0, t), "function" !== typeof r && (null === Xl ? Xl = new Set([this]) : Xl.add(this));
                        var e = t.stack;
                        this.componentDidCatch(t.value, {
                            componentStack: null !== e ? e : ""
                        })
                    }), n
                }

                function gs(e, t, n) {
                    var r = e.pingCache;
                    if (null === r) {
                        r = e.pingCache = new ps;
                        var i = new Set;
                        r.set(t, i)
                    } else void 0 === (i = r.get(t)) && (i = new Set, r.set(t, i));
                    i.has(n) || (i.add(n), e = Ec.bind(null, e, t, n), t.then(e, e))
                }

                function vs(e) {
                    do {
                        var t;
                        if ((t = 13 === e.tag) && (t = null === (t = e.memoizedState) || null !== t.dehydrated), t) return e;
                        e = e.return
                    } while (null !== e);
                    return null
                }

                function ys(e, t, n, r, i) {
                    return 0 === (1 & e.mode) ? (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, 1 === n.tag && (null === n.alternate ? n.tag = 17 : ((t = Lo(-1, 1)).tag = 2, Do(n, t, 1))), n.lanes |= 1), e) : (e.flags |= 65536, e.lanes = i, e)
                }
                var bs = x.ReactCurrentOwner,
                    xs = !1;

                function _s(e, t, n, r) {
                    t.child = null === e ? Zo(t, null, n, r) : Qo(t, e.child, n, r)
                }

                function Ms(e, t, n, r, i) {
                    n = n.render;
                    var o = t.ref;
                    return So(t, i), r = Aa(e, t, n, r, o, i), n = Sa(), null === e || xs ? (io && n && eo(t), t.flags |= 1, _s(e, t, r, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, qs(e, t, i))
                }

                function ws(e, t, n, r, i) {
                    if (null === e) {
                        var o = n.type;
                        return "function" !== typeof o || Bc(o) || void 0 !== o.defaultProps || null !== n.compare || void 0 !== n.defaultProps ? ((e = Dc(n.type, null, r, t, t.mode, i)).ref = t.ref, e.return = t, t.child = e) : (t.tag = 15, t.type = o, As(e, t, o, r, i))
                    }
                    if (o = e.child, 0 === (e.lanes & i)) {
                        var a = o.memoizedProps;
                        if ((n = null !== (n = n.compare) ? n : lr)(a, r) && e.ref === t.ref) return qs(e, t, i)
                    }
                    return t.flags |= 1, (e = Lc(o, r)).ref = t.ref, e.return = t, t.child = e
                }

                function As(e, t, n, r, i) {
                    if (null !== e) {
                        var o = e.memoizedProps;
                        if (lr(o, r) && e.ref === t.ref) {
                            if (xs = !1, t.pendingProps = r = o, 0 === (e.lanes & i)) return t.lanes = e.lanes, qs(e, t, i);
                            0 !== (131072 & e.flags) && (xs = !0)
                        }
                    }
                    return Cs(e, t, n, r, i)
                }

                function Ss(e, t, n) {
                    var r = t.pendingProps,
                        i = r.children,
                        o = null !== e ? e.memoizedState : null;
                    if ("hidden" === r.mode)
                        if (0 === (1 & t.mode)) t.memoizedState = {
                            baseLanes: 0,
                            cachePool: null,
                            transitions: null
                        }, Ei(Ll, Bl), Bl |= n;
                        else {
                            if (0 === (1073741824 & n)) return e = null !== o ? o.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = {
                                baseLanes: e,
                                cachePool: null,
                                transitions: null
                            }, t.updateQueue = null, Ei(Ll, Bl), Bl |= e, null;
                            t.memoizedState = {
                                baseLanes: 0,
                                cachePool: null,
                                transitions: null
                            }, r = null !== o ? o.baseLanes : n, Ei(Ll, Bl), Bl |= r
                        }
                    else null !== o ? (r = o.baseLanes | n, t.memoizedState = null) : r = n, Ei(Ll, Bl), Bl |= r;
                    return _s(e, t, i, n), t.child
                }

                function Es(e, t) {
                    var n = t.ref;
                    (null === e && null !== n || null !== e && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152)
                }

                function Cs(e, t, n, r, i) {
                    var o = Oi(n) ? Ri : Ti.current;
                    return o = Ii(t, o), So(t, i), n = Aa(e, t, n, r, o, i), r = Sa(), null === e || xs ? (io && r && eo(t), t.flags |= 1, _s(e, t, n, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, qs(e, t, i))
                }

                function Ts(e, t, n, r, i) {
                    if (Oi(n)) {
                        var o = !0;
                        Ni(t)
                    } else o = !1;
                    if (So(t, i), null === t.stateNode) Vs(e, t), Vo(t, n, r), Wo(t, n, r, i), r = !0;
                    else if (null === e) {
                        var a = t.stateNode,
                            s = t.memoizedProps;
                        a.props = s;
                        var l = a.context,
                            c = n.contextType;
                        "object" === typeof c && null !== c ? c = Eo(c) : c = Ii(t, c = Oi(n) ? Ri : Ti.current);
                        var u = n.getDerivedStateFromProps,
                            d = "function" === typeof u || "function" === typeof a.getSnapshotBeforeUpdate;
                        d || "function" !== typeof a.UNSAFE_componentWillReceiveProps && "function" !== typeof a.componentWillReceiveProps || (s !== r || l !== c) && qo(t, a, r, c), Io = !1;
                        var h = t.memoizedState;
                        a.state = h, Fo(t, r, a, i), l = t.memoizedState, s !== r || h !== l || Pi.current || Io ? ("function" === typeof u && (Ho(t, n, u, r), l = t.memoizedState), (s = Io || Go(t, n, s, r, h, l, c)) ? (d || "function" !== typeof a.UNSAFE_componentWillMount && "function" !== typeof a.componentWillMount || ("function" === typeof a.componentWillMount && a.componentWillMount(), "function" === typeof a.UNSAFE_componentWillMount && a.UNSAFE_componentWillMount()), "function" === typeof a.componentDidMount && (t.flags |= 4194308)) : ("function" === typeof a.componentDidMount && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = l), a.props = r, a.state = l, a.context = c, r = s) : ("function" === typeof a.componentDidMount && (t.flags |= 4194308), r = !1)
                    } else {
                        a = t.stateNode, Bo(e, t), s = t.memoizedProps, c = t.type === t.elementType ? s : vo(t.type, s), a.props = c, d = t.pendingProps, h = a.context, "object" === typeof(l = n.contextType) && null !== l ? l = Eo(l) : l = Ii(t, l = Oi(n) ? Ri : Ti.current);
                        var p = n.getDerivedStateFromProps;
                        (u = "function" === typeof p || "function" === typeof a.getSnapshotBeforeUpdate) || "function" !== typeof a.UNSAFE_componentWillReceiveProps && "function" !== typeof a.componentWillReceiveProps || (s !== d || h !== l) && qo(t, a, r, l), Io = !1, h = t.memoizedState, a.state = h, Fo(t, r, a, i);
                        var f = t.memoizedState;
                        s !== d || h !== f || Pi.current || Io ? ("function" === typeof p && (Ho(t, n, p, r), f = t.memoizedState), (c = Io || Go(t, n, c, r, h, f, l) || !1) ? (u || "function" !== typeof a.UNSAFE_componentWillUpdate && "function" !== typeof a.componentWillUpdate || ("function" === typeof a.componentWillUpdate && a.componentWillUpdate(r, f, l), "function" === typeof a.UNSAFE_componentWillUpdate && a.UNSAFE_componentWillUpdate(r, f, l)), "function" === typeof a.componentDidUpdate && (t.flags |= 4), "function" === typeof a.getSnapshotBeforeUpdate && (t.flags |= 1024)) : ("function" !== typeof a.componentDidUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), "function" !== typeof a.getSnapshotBeforeUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = f), a.props = r, a.state = f, a.context = l, r = c) : ("function" !== typeof a.componentDidUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), "function" !== typeof a.getSnapshotBeforeUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), r = !1)
                    }
                    return Ps(e, t, n, r, o, i)
                }

                function Ps(e, t, n, r, i, o) {
                    Es(e, t);
                    var a = 0 !== (128 & t.flags);
                    if (!r && !a) return i && ki(t, n, !1), qs(e, t, o);
                    r = t.stateNode, bs.current = t;
                    var s = a && "function" !== typeof n.getDerivedStateFromError ? null : r.render();
                    return t.flags |= 1, null !== e && a ? (t.child = Qo(t, e.child, null, o), t.child = Qo(t, null, s, o)) : _s(e, t, s, o), t.memoizedState = r.state, i && ki(t, n, !0), t.child
                }

                function Rs(e) {
                    var t = e.stateNode;
                    t.pendingContext ? Li(0, t.pendingContext, t.pendingContext !== t.context) : t.context && Li(0, t.context, !1), ia(e, t.containerInfo)
                }

                function Is(e, t, n, r, i) {
                    return fo(), mo(i), t.flags |= 256, _s(e, t, n, r), t.child
                }
                var Os, Bs, Ls, Ds, Ns = {
                    dehydrated: null,
                    treeContext: null,
                    retryLane: 0
                };

                function ks(e) {
                    return {
                        baseLanes: e,
                        cachePool: null,
                        transitions: null
                    }
                }

                function Fs(e, t, n) {
                    var r, i = t.pendingProps,
                        a = la.current,
                        s = !1,
                        l = 0 !== (128 & t.flags);
                    if ((r = l) || (r = (null === e || null !== e.memoizedState) && 0 !== (2 & a)), r ? (s = !0, t.flags &= -129) : null !== e && null === e.memoizedState || (a |= 1), Ei(la, 1 & a), null === e) return co(t), null !== (e = t.memoizedState) && null !== (e = e.dehydrated) ? (0 === (1 & t.mode) ? t.lanes = 1 : "$!" === e.data ? t.lanes = 8 : t.lanes = 1073741824, null) : (l = i.children, e = i.fallback, s ? (i = t.mode, s = t.child, l = {
                        mode: "hidden",
                        children: l
                    }, 0 === (1 & i) && null !== s ? (s.childLanes = 0, s.pendingProps = l) : s = kc(l, i, 0, null), e = Nc(e, i, n, null), s.return = t, e.return = t, s.sibling = e, t.child = s, t.child.memoizedState = ks(n), t.memoizedState = Ns, e) : Us(t, l));
                    if (null !== (a = e.memoizedState) && null !== (r = a.dehydrated)) return function(e, t, n, r, i, a, s) {
                        if (n) return 256 & t.flags ? (t.flags &= -257, zs(e, t, s, r = ds(Error(o(422))))) : null !== t.memoizedState ? (t.child = e.child, t.flags |= 128, null) : (a = r.fallback, i = t.mode, r = kc({
                            mode: "visible",
                            children: r.children
                        }, i, 0, null), (a = Nc(a, i, s, null)).flags |= 2, r.return = t, a.return = t, r.sibling = a, t.child = r, 0 !== (1 & t.mode) && Qo(t, e.child, null, s), t.child.memoizedState = ks(s), t.memoizedState = Ns, a);
                        if (0 === (1 & t.mode)) return zs(e, t, s, null);
                        if ("$!" === i.data) {
                            if (r = i.nextSibling && i.nextSibling.dataset) var l = r.dgst;
                            return r = l, zs(e, t, s, r = ds(a = Error(o(419)), r, void 0))
                        }
                        if (l = 0 !== (s & e.childLanes), xs || l) {
                            if (null !== (r = Rl)) {
                                switch (s & -s) {
                                    case 4:
                                        i = 2;
                                        break;
                                    case 16:
                                        i = 8;
                                        break;
                                    case 64:
                                    case 128:
                                    case 256:
                                    case 512:
                                    case 1024:
                                    case 2048:
                                    case 4096:
                                    case 8192:
                                    case 16384:
                                    case 32768:
                                    case 65536:
                                    case 131072:
                                    case 262144:
                                    case 524288:
                                    case 1048576:
                                    case 2097152:
                                    case 4194304:
                                    case 8388608:
                                    case 16777216:
                                    case 33554432:
                                    case 67108864:
                                        i = 32;
                                        break;
                                    case 536870912:
                                        i = 268435456;
                                        break;
                                    default:
                                        i = 0
                                }
                                0 !== (i = 0 !== (i & (r.suspendedLanes | s)) ? 0 : i) && i !== a.retryLane && (a.retryLane = i, Ro(e, i), rc(r, e, i, -1))
                            }
                            return gc(), zs(e, t, s, r = ds(Error(o(421))))
                        }
                        return "$?" === i.data ? (t.flags |= 128, t.child = e.child, t = Tc.bind(null, e), i._reactRetry = t, null) : (e = a.treeContext, ro = ci(i.nextSibling), no = t, io = !0, oo = null, null !== e && (Xi[Ki++] = Yi, Xi[Ki++] = Qi, Xi[Ki++] = Ji, Yi = e.id, Qi = e.overflow, Ji = t), t = Us(t, r.children), t.flags |= 4096, t)
                    }(e, t, l, i, r, a, n);
                    if (s) {
                        s = i.fallback, l = t.mode, r = (a = e.child).sibling;
                        var c = {
                            mode: "hidden",
                            children: i.children
                        };
                        return 0 === (1 & l) && t.child !== a ? ((i = t.child).childLanes = 0, i.pendingProps = c, t.deletions = null) : (i = Lc(a, c)).subtreeFlags = 14680064 & a.subtreeFlags, null !== r ? s = Lc(r, s) : (s = Nc(s, l, n, null)).flags |= 2, s.return = t, i.return = t, i.sibling = s, t.child = i, i = s, s = t.child, l = null === (l = e.child.memoizedState) ? ks(n) : {
                            baseLanes: l.baseLanes | n,
                            cachePool: null,
                            transitions: l.transitions
                        }, s.memoizedState = l, s.childLanes = e.childLanes & ~n, t.memoizedState = Ns, i
                    }
                    return e = (s = e.child).sibling, i = Lc(s, {
                        mode: "visible",
                        children: i.children
                    }), 0 === (1 & t.mode) && (i.lanes = n), i.return = t, i.sibling = null, null !== e && (null === (n = t.deletions) ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = i, t.memoizedState = null, i
                }

                function Us(e, t) {
                    return (t = kc({
                        mode: "visible",
                        children: t
                    }, e.mode, 0, null)).return = e, e.child = t
                }

                function zs(e, t, n, r) {
                    return null !== r && mo(r), Qo(t, e.child, null, n), (e = Us(t, t.pendingProps.children)).flags |= 2, t.memoizedState = null, e
                }

                function Hs(e, t, n) {
                    e.lanes |= t;
                    var r = e.alternate;
                    null !== r && (r.lanes |= t), Ao(e.return, t, n)
                }

                function js(e, t, n, r, i) {
                    var o = e.memoizedState;
                    null === o ? e.memoizedState = {
                        isBackwards: t,
                        rendering: null,
                        renderingStartTime: 0,
                        last: r,
                        tail: n,
                        tailMode: i
                    } : (o.isBackwards = t, o.rendering = null, o.renderingStartTime = 0, o.last = r, o.tail = n, o.tailMode = i)
                }

                function Gs(e, t, n) {
                    var r = t.pendingProps,
                        i = r.revealOrder,
                        o = r.tail;
                    if (_s(e, t, r.children, n), 0 !== (2 & (r = la.current))) r = 1 & r | 2, t.flags |= 128;
                    else {
                        if (null !== e && 0 !== (128 & e.flags)) e: for (e = t.child; null !== e;) {
                            if (13 === e.tag) null !== e.memoizedState && Hs(e, n, t);
                            else if (19 === e.tag) Hs(e, n, t);
                            else if (null !== e.child) {
                                e.child.return = e, e = e.child;
                                continue
                            }
                            if (e === t) break e;
                            for (; null === e.sibling;) {
                                if (null === e.return || e.return === t) break e;
                                e = e.return
                            }
                            e.sibling.return = e.return, e = e.sibling
                        }
                        r &= 1
                    }
                    if (Ei(la, r), 0 === (1 & t.mode)) t.memoizedState = null;
                    else switch (i) {
                        case "forwards":
                            for (n = t.child, i = null; null !== n;) null !== (e = n.alternate) && null === ca(e) && (i = n), n = n.sibling;
                            null === (n = i) ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), js(t, !1, i, n, o);
                            break;
                        case "backwards":
                            for (n = null, i = t.child, t.child = null; null !== i;) {
                                if (null !== (e = i.alternate) && null === ca(e)) {
                                    t.child = i;
                                    break
                                }
                                e = i.sibling, i.sibling = n, n = i, i = e
                            }
                            js(t, !0, n, null, o);
                            break;
                        case "together":
                            js(t, !1, null, null, void 0);
                            break;
                        default:
                            t.memoizedState = null
                    }
                    return t.child
                }

                function Vs(e, t) {
                    0 === (1 & t.mode) && null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2)
                }

                function qs(e, t, n) {
                    if (null !== e && (t.dependencies = e.dependencies), kl |= t.lanes, 0 === (n & t.childLanes)) return null;
                    if (null !== e && t.child !== e.child) throw Error(o(153));
                    if (null !== t.child) {
                        for (n = Lc(e = t.child, e.pendingProps), t.child = n, n.return = t; null !== e.sibling;) e = e.sibling, (n = n.sibling = Lc(e, e.pendingProps)).return = t;
                        n.sibling = null
                    }
                    return t.child
                }

                function Ws(e, t) {
                    if (!io) switch (e.tailMode) {
                        case "hidden":
                            t = e.tail;
                            for (var n = null; null !== t;) null !== t.alternate && (n = t), t = t.sibling;
                            null === n ? e.tail = null : n.sibling = null;
                            break;
                        case "collapsed":
                            n = e.tail;
                            for (var r = null; null !== n;) null !== n.alternate && (r = n), n = n.sibling;
                            null === r ? t || null === e.tail ? e.tail = null : e.tail.sibling = null : r.sibling = null
                    }
                }

                function Xs(e) {
                    var t = null !== e.alternate && e.alternate.child === e.child,
                        n = 0,
                        r = 0;
                    if (t)
                        for (var i = e.child; null !== i;) n |= i.lanes | i.childLanes, r |= 14680064 & i.subtreeFlags, r |= 14680064 & i.flags, i.return = e, i = i.sibling;
                    else
                        for (i = e.child; null !== i;) n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling;
                    return e.subtreeFlags |= r, e.childLanes = n, t
                }

                function Ks(e, t, n) {
                    var r = t.pendingProps;
                    switch (to(t), t.tag) {
                        case 2:
                        case 16:
                        case 15:
                        case 0:
                        case 11:
                        case 7:
                        case 8:
                        case 12:
                        case 9:
                        case 14:
                            return Xs(t), null;
                        case 1:
                        case 17:
                            return Oi(t.type) && Bi(), Xs(t), null;
                        case 3:
                            return r = t.stateNode, oa(), Si(Pi), Si(Ti), da(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), null !== e && null !== e.child || (ho(t) ? t.flags |= 4 : null === e || e.memoizedState.isDehydrated && 0 === (256 & t.flags) || (t.flags |= 1024, null !== oo && (sc(oo), oo = null))), Bs(e, t), Xs(t), null;
                        case 5:
                            sa(t);
                            var i = ra(na.current);
                            if (n = t.type, null !== e && null != t.stateNode) Ls(e, t, n, r, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152);
                            else {
                                if (!r) {
                                    if (null === t.stateNode) throw Error(o(166));
                                    return Xs(t), null
                                }
                                if (e = ra(ea.current), ho(t)) {
                                    r = t.stateNode, n = t.type;
                                    var a = t.memoizedProps;
                                    switch (r[hi] = t, r[pi] = a, e = 0 !== (1 & t.mode), n) {
                                        case "dialog":
                                            Ur("cancel", r), Ur("close", r);
                                            break;
                                        case "iframe":
                                        case "object":
                                        case "embed":
                                            Ur("load", r);
                                            break;
                                        case "video":
                                        case "audio":
                                            for (i = 0; i < Dr.length; i++) Ur(Dr[i], r);
                                            break;
                                        case "source":
                                            Ur("error", r);
                                            break;
                                        case "img":
                                        case "image":
                                        case "link":
                                            Ur("error", r), Ur("load", r);
                                            break;
                                        case "details":
                                            Ur("toggle", r);
                                            break;
                                        case "input":
                                            Y(r, a), Ur("invalid", r);
                                            break;
                                        case "select":
                                            r._wrapperState = {
                                                wasMultiple: !!a.multiple
                                            }, Ur("invalid", r);
                                            break;
                                        case "textarea":
                                            ie(r, a), Ur("invalid", r)
                                    }
                                    for (var l in ye(n, a), i = null, a)
                                        if (a.hasOwnProperty(l)) {
                                            var c = a[l];
                                            "children" === l ? "string" === typeof c ? r.textContent !== c && (!0 !== a.suppressHydrationWarning && Zr(r.textContent, c, e), i = ["children", c]) : "number" === typeof c && r.textContent !== "" + c && (!0 !== a.suppressHydrationWarning && Zr(r.textContent, c, e), i = ["children", "" + c]) : s.hasOwnProperty(l) && null != c && "onScroll" === l && Ur("scroll", r)
                                        }
                                    switch (n) {
                                        case "input":
                                            W(r), $(r, a, !0);
                                            break;
                                        case "textarea":
                                            W(r), ae(r);
                                            break;
                                        case "select":
                                        case "option":
                                            break;
                                        default:
                                            "function" === typeof a.onClick && (r.onclick = $r)
                                    }
                                    r = i, t.updateQueue = r, null !== r && (t.flags |= 4)
                                } else {
                                    l = 9 === i.nodeType ? i : i.ownerDocument, "http://www.w3.org/1999/xhtml" === e && (e = se(n)), "http://www.w3.org/1999/xhtml" === e ? "script" === n ? ((e = l.createElement("div")).innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : "string" === typeof r.is ? e = l.createElement(n, {
                                        is: r.is
                                    }) : (e = l.createElement(n), "select" === n && (l = e, r.multiple ? l.multiple = !0 : r.size && (l.size = r.size))) : e = l.createElementNS(e, n), e[hi] = t, e[pi] = r, Os(e, t, !1, !1), t.stateNode = e;
                                    e: {
                                        switch (l = be(n, r), n) {
                                            case "dialog":
                                                Ur("cancel", e), Ur("close", e), i = r;
                                                break;
                                            case "iframe":
                                            case "object":
                                            case "embed":
                                                Ur("load", e), i = r;
                                                break;
                                            case "video":
                                            case "audio":
                                                for (i = 0; i < Dr.length; i++) Ur(Dr[i], e);
                                                i = r;
                                                break;
                                            case "source":
                                                Ur("error", e), i = r;
                                                break;
                                            case "img":
                                            case "image":
                                            case "link":
                                                Ur("error", e), Ur("load", e), i = r;
                                                break;
                                            case "details":
                                                Ur("toggle", e), i = r;
                                                break;
                                            case "input":
                                                Y(e, r), i = J(e, r), Ur("invalid", e);
                                                break;
                                            case "option":
                                            default:
                                                i = r;
                                                break;
                                            case "select":
                                                e._wrapperState = {
                                                    wasMultiple: !!r.multiple
                                                }, i = k({}, r, {
                                                    value: void 0
                                                }), Ur("invalid", e);
                                                break;
                                            case "textarea":
                                                ie(e, r), i = re(e, r), Ur("invalid", e)
                                        }
                                        for (a in ye(n, i), c = i)
                                            if (c.hasOwnProperty(a)) {
                                                var u = c[a];
                                                "style" === a ? ge(e, u) : "dangerouslySetInnerHTML" === a ? null != (u = u ? u.__html : void 0) && de(e, u) : "children" === a ? "string" === typeof u ? ("textarea" !== n || "" !== u) && he(e, u) : "number" === typeof u && he(e, "" + u) : "suppressContentEditableWarning" !== a && "suppressHydrationWarning" !== a && "autoFocus" !== a && (s.hasOwnProperty(a) ? null != u && "onScroll" === a && Ur("scroll", e) : null != u && b(e, a, u, l))
                                            }
                                        switch (n) {
                                            case "input":
                                                W(e), $(e, r, !1);
                                                break;
                                            case "textarea":
                                                W(e), ae(e);
                                                break;
                                            case "option":
                                                null != r.value && e.setAttribute("value", "" + V(r.value));
                                                break;
                                            case "select":
                                                e.multiple = !!r.multiple, null != (a = r.value) ? ne(e, !!r.multiple, a, !1) : null != r.defaultValue && ne(e, !!r.multiple, r.defaultValue, !0);
                                                break;
                                            default:
                                                "function" === typeof i.onClick && (e.onclick = $r)
                                        }
                                        switch (n) {
                                            case "button":
                                            case "input":
                                            case "select":
                                            case "textarea":
                                                r = !!r.autoFocus;
                                                break e;
                                            case "img":
                                                r = !0;
                                                break e;
                                            default:
                                                r = !1
                                        }
                                    }
                                    r && (t.flags |= 4)
                                }
                                null !== t.ref && (t.flags |= 512, t.flags |= 2097152)
                            }
                            return Xs(t), null;
                        case 6:
                            if (e && null != t.stateNode) Ds(e, t, e.memoizedProps, r);
                            else {
                                if ("string" !== typeof r && null === t.stateNode) throw Error(o(166));
                                if (n = ra(na.current), ra(ea.current), ho(t)) {
                                    if (r = t.stateNode, n = t.memoizedProps, r[hi] = t, (a = r.nodeValue !== n) && null !== (e = no)) switch (e.tag) {
                                        case 3:
                                            Zr(r.nodeValue, n, 0 !== (1 & e.mode));
                                            break;
                                        case 5:
                                            !0 !== e.memoizedProps.suppressHydrationWarning && Zr(r.nodeValue, n, 0 !== (1 & e.mode))
                                    }
                                    a && (t.flags |= 4)
                                } else(r = (9 === n.nodeType ? n : n.ownerDocument).createTextNode(r))[hi] = t, t.stateNode = r
                            }
                            return Xs(t), null;
                        case 13:
                            if (Si(la), r = t.memoizedState, null === e || null !== e.memoizedState && null !== e.memoizedState.dehydrated) {
                                if (io && null !== ro && 0 !== (1 & t.mode) && 0 === (128 & t.flags)) po(), fo(), t.flags |= 98560, a = !1;
                                else if (a = ho(t), null !== r && null !== r.dehydrated) {
                                    if (null === e) {
                                        if (!a) throw Error(o(318));
                                        if (!(a = null !== (a = t.memoizedState) ? a.dehydrated : null)) throw Error(o(317));
                                        a[hi] = t
                                    } else fo(), 0 === (128 & t.flags) && (t.memoizedState = null), t.flags |= 4;
                                    Xs(t), a = !1
                                } else null !== oo && (sc(oo), oo = null), a = !0;
                                if (!a) return 65536 & t.flags ? t : null
                            }
                            return 0 !== (128 & t.flags) ? (t.lanes = n, t) : ((r = null !== r) !== (null !== e && null !== e.memoizedState) && r && (t.child.flags |= 8192, 0 !== (1 & t.mode) && (null === e || 0 !== (1 & la.current) ? 0 === Dl && (Dl = 3) : gc())), null !== t.updateQueue && (t.flags |= 4), Xs(t), null);
                        case 4:
                            return oa(), Bs(e, t), null === e && jr(t.stateNode.containerInfo), Xs(t), null;
                        case 10:
                            return wo(t.type._context), Xs(t), null;
                        case 19:
                            if (Si(la), null === (a = t.memoizedState)) return Xs(t), null;
                            if (r = 0 !== (128 & t.flags), null === (l = a.rendering))
                                if (r) Ws(a, !1);
                                else {
                                    if (0 !== Dl || null !== e && 0 !== (128 & e.flags))
                                        for (e = t.child; null !== e;) {
                                            if (null !== (l = ca(e))) {
                                                for (t.flags |= 128, Ws(a, !1), null !== (r = l.updateQueue) && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; null !== n;) e = r, (a = n).flags &= 14680066, null === (l = a.alternate) ? (a.childLanes = 0, a.lanes = e, a.child = null, a.subtreeFlags = 0, a.memoizedProps = null, a.memoizedState = null, a.updateQueue = null, a.dependencies = null, a.stateNode = null) : (a.childLanes = l.childLanes, a.lanes = l.lanes, a.child = l.child, a.subtreeFlags = 0, a.deletions = null, a.memoizedProps = l.memoizedProps, a.memoizedState = l.memoizedState, a.updateQueue = l.updateQueue, a.type = l.type, e = l.dependencies, a.dependencies = null === e ? null : {
                                                    lanes: e.lanes,
                                                    firstContext: e.firstContext
                                                }), n = n.sibling;
                                                return Ei(la, 1 & la.current | 2), t.child
                                            }
                                            e = e.sibling
                                        }
                                    null !== a.tail && Qe() > Gl && (t.flags |= 128, r = !0, Ws(a, !1), t.lanes = 4194304)
                                }
                            else {
                                if (!r)
                                    if (null !== (e = ca(l))) {
                                        if (t.flags |= 128, r = !0, null !== (n = e.updateQueue) && (t.updateQueue = n, t.flags |= 4), Ws(a, !0), null === a.tail && "hidden" === a.tailMode && !l.alternate && !io) return Xs(t), null
                                    } else 2 * Qe() - a.renderingStartTime > Gl && 1073741824 !== n && (t.flags |= 128, r = !0, Ws(a, !1), t.lanes = 4194304);
                                a.isBackwards ? (l.sibling = t.child, t.child = l) : (null !== (n = a.last) ? n.sibling = l : t.child = l, a.last = l)
                            }
                            return null !== a.tail ? (t = a.tail, a.rendering = t, a.tail = t.sibling, a.renderingStartTime = Qe(), t.sibling = null, n = la.current, Ei(la, r ? 1 & n | 2 : 1 & n), t) : (Xs(t), null);
                        case 22:
                        case 23:
                            return hc(), r = null !== t.memoizedState, null !== e && null !== e.memoizedState !== r && (t.flags |= 8192), r && 0 !== (1 & t.mode) ? 0 !== (1073741824 & Bl) && (Xs(t), 6 & t.subtreeFlags && (t.flags |= 8192)) : Xs(t), null;
                        case 24:
                        case 25:
                            return null
                    }
                    throw Error(o(156, t.tag))
                }

                function Js(e, t) {
                    switch (to(t), t.tag) {
                        case 1:
                            return Oi(t.type) && Bi(), 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null;
                        case 3:
                            return oa(), Si(Pi), Si(Ti), da(), 0 !== (65536 & (e = t.flags)) && 0 === (128 & e) ? (t.flags = -65537 & e | 128, t) : null;
                        case 5:
                            return sa(t), null;
                        case 13:
                            if (Si(la), null !== (e = t.memoizedState) && null !== e.dehydrated) {
                                if (null === t.alternate) throw Error(o(340));
                                fo()
                            }
                            return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null;
                        case 19:
                            return Si(la), null;
                        case 4:
                            return oa(), null;
                        case 10:
                            return wo(t.type._context), null;
                        case 22:
                        case 23:
                            return hc(), null;
                        default:
                            return null
                    }
                }
                Os = function(e, t) {
                    for (var n = t.child; null !== n;) {
                        if (5 === n.tag || 6 === n.tag) e.appendChild(n.stateNode);
                        else if (4 !== n.tag && null !== n.child) {
                            n.child.return = n, n = n.child;
                            continue
                        }
                        if (n === t) break;
                        for (; null === n.sibling;) {
                            if (null === n.return || n.return === t) return;
                            n = n.return
                        }
                        n.sibling.return = n.return, n = n.sibling
                    }
                }, Bs = function() {}, Ls = function(e, t, n, r) {
                    var i = e.memoizedProps;
                    if (i !== r) {
                        e = t.stateNode, ra(ea.current);
                        var o, a = null;
                        switch (n) {
                            case "input":
                                i = J(e, i), r = J(e, r), a = [];
                                break;
                            case "select":
                                i = k({}, i, {
                                    value: void 0
                                }), r = k({}, r, {
                                    value: void 0
                                }), a = [];
                                break;
                            case "textarea":
                                i = re(e, i), r = re(e, r), a = [];
                                break;
                            default:
                                "function" !== typeof i.onClick && "function" === typeof r.onClick && (e.onclick = $r)
                        }
                        for (u in ye(n, r), n = null, i)
                            if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && null != i[u])
                                if ("style" === u) {
                                    var l = i[u];
                                    for (o in l) l.hasOwnProperty(o) && (n || (n = {}), n[o] = "")
                                } else "dangerouslySetInnerHTML" !== u && "children" !== u && "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && "autoFocus" !== u && (s.hasOwnProperty(u) ? a || (a = []) : (a = a || []).push(u, null));
                        for (u in r) {
                            var c = r[u];
                            if (l = null != i ? i[u] : void 0, r.hasOwnProperty(u) && c !== l && (null != c || null != l))
                                if ("style" === u)
                                    if (l) {
                                        for (o in l) !l.hasOwnProperty(o) || c && c.hasOwnProperty(o) || (n || (n = {}), n[o] = "");
                                        for (o in c) c.hasOwnProperty(o) && l[o] !== c[o] && (n || (n = {}), n[o] = c[o])
                                    } else n || (a || (a = []), a.push(u, n)), n = c;
                            else "dangerouslySetInnerHTML" === u ? (c = c ? c.__html : void 0, l = l ? l.__html : void 0, null != c && l !== c && (a = a || []).push(u, c)) : "children" === u ? "string" !== typeof c && "number" !== typeof c || (a = a || []).push(u, "" + c) : "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && (s.hasOwnProperty(u) ? (null != c && "onScroll" === u && Ur("scroll", e), a || l === c || (a = [])) : (a = a || []).push(u, c))
                        }
                        n && (a = a || []).push("style", n);
                        var u = a;
                        (t.updateQueue = u) && (t.flags |= 4)
                    }
                }, Ds = function(e, t, n, r) {
                    n !== r && (t.flags |= 4)
                };
                var Ys = !1,
                    Qs = !1,
                    Zs = "function" === typeof WeakSet ? WeakSet : Set,
                    $s = null;

                function el(e, t) {
                    var n = e.ref;
                    if (null !== n)
                        if ("function" === typeof n) try {
                            n(null)
                        } catch (r) {
                            Sc(e, t, r)
                        } else n.current = null
                }

                function tl(e, t, n) {
                    try {
                        n()
                    } catch (r) {
                        Sc(e, t, r)
                    }
                }
                var nl = !1;

                function rl(e, t, n) {
                    var r = t.updateQueue;
                    if (null !== (r = null !== r ? r.lastEffect : null)) {
                        var i = r = r.next;
                        do {
                            if ((i.tag & e) === e) {
                                var o = i.destroy;
                                i.destroy = void 0, void 0 !== o && tl(t, n, o)
                            }
                            i = i.next
                        } while (i !== r)
                    }
                }

                function il(e, t) {
                    if (null !== (t = null !== (t = t.updateQueue) ? t.lastEffect : null)) {
                        var n = t = t.next;
                        do {
                            if ((n.tag & e) === e) {
                                var r = n.create;
                                n.destroy = r()
                            }
                            n = n.next
                        } while (n !== t)
                    }
                }

                function ol(e) {
                    var t = e.ref;
                    if (null !== t) {
                        var n = e.stateNode;
                        e.tag, e = n, "function" === typeof t ? t(e) : t.current = e
                    }
                }

                function al(e) {
                    var t = e.alternate;
                    null !== t && (e.alternate = null, al(t)), e.child = null, e.deletions = null, e.sibling = null, 5 === e.tag && (null !== (t = e.stateNode) && (delete t[hi], delete t[pi], delete t[mi], delete t[gi], delete t[vi])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null
                }

                function sl(e) {
                    return 5 === e.tag || 3 === e.tag || 4 === e.tag
                }

                function ll(e) {
                    e: for (;;) {
                        for (; null === e.sibling;) {
                            if (null === e.return || sl(e.return)) return null;
                            e = e.return
                        }
                        for (e.sibling.return = e.return, e = e.sibling; 5 !== e.tag && 6 !== e.tag && 18 !== e.tag;) {
                            if (2 & e.flags) continue e;
                            if (null === e.child || 4 === e.tag) continue e;
                            e.child.return = e, e = e.child
                        }
                        if (!(2 & e.flags)) return e.stateNode
                    }
                }

                function cl(e, t, n) {
                    var r = e.tag;
                    if (5 === r || 6 === r) e = e.stateNode, t ? 8 === n.nodeType ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (8 === n.nodeType ? (t = n.parentNode).insertBefore(e, n) : (t = n).appendChild(e), null !== (n = n._reactRootContainer) && void 0 !== n || null !== t.onclick || (t.onclick = $r));
                    else if (4 !== r && null !== (e = e.child))
                        for (cl(e, t, n), e = e.sibling; null !== e;) cl(e, t, n), e = e.sibling
                }

                function ul(e, t, n) {
                    var r = e.tag;
                    if (5 === r || 6 === r) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e);
                    else if (4 !== r && null !== (e = e.child))
                        for (ul(e, t, n), e = e.sibling; null !== e;) ul(e, t, n), e = e.sibling
                }
                var dl = null,
                    hl = !1;

                function pl(e, t, n) {
                    for (n = n.child; null !== n;) fl(e, t, n), n = n.sibling
                }

                function fl(e, t, n) {
                    if (ot && "function" === typeof ot.onCommitFiberUnmount) try {
                        ot.onCommitFiberUnmount(it, n)
                    } catch (s) {}
                    switch (n.tag) {
                        case 5:
                            Qs || el(n, t);
                        case 6:
                            var r = dl,
                                i = hl;
                            dl = null, pl(e, t, n), hl = i, null !== (dl = r) && (hl ? (e = dl, n = n.stateNode, 8 === e.nodeType ? e.parentNode.removeChild(n) : e.removeChild(n)) : dl.removeChild(n.stateNode));
                            break;
                        case 18:
                            null !== dl && (hl ? (e = dl, n = n.stateNode, 8 === e.nodeType ? li(e.parentNode, n) : 1 === e.nodeType && li(e, n), jt(e)) : li(dl, n.stateNode));
                            break;
                        case 4:
                            r = dl, i = hl, dl = n.stateNode.containerInfo, hl = !0, pl(e, t, n), dl = r, hl = i;
                            break;
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            if (!Qs && (null !== (r = n.updateQueue) && null !== (r = r.lastEffect))) {
                                i = r = r.next;
                                do {
                                    var o = i,
                                        a = o.destroy;
                                    o = o.tag, void 0 !== a && (0 !== (2 & o) || 0 !== (4 & o)) && tl(n, t, a), i = i.next
                                } while (i !== r)
                            }
                            pl(e, t, n);
                            break;
                        case 1:
                            if (!Qs && (el(n, t), "function" === typeof(r = n.stateNode).componentWillUnmount)) try {
                                r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount()
                            } catch (s) {
                                Sc(n, t, s)
                            }
                            pl(e, t, n);
                            break;
                        case 21:
                            pl(e, t, n);
                            break;
                        case 22:
                            1 & n.mode ? (Qs = (r = Qs) || null !== n.memoizedState, pl(e, t, n), Qs = r) : pl(e, t, n);
                            break;
                        default:
                            pl(e, t, n)
                    }
                }

                function ml(e) {
                    var t = e.updateQueue;
                    if (null !== t) {
                        e.updateQueue = null;
                        var n = e.stateNode;
                        null === n && (n = e.stateNode = new Zs), t.forEach((function(t) {
                            var r = Pc.bind(null, e, t);
                            n.has(t) || (n.add(t), t.then(r, r))
                        }))
                    }
                }

                function gl(e, t) {
                    var n = t.deletions;
                    if (null !== n)
                        for (var r = 0; r < n.length; r++) {
                            var i = n[r];
                            try {
                                var a = e,
                                    s = t,
                                    l = s;
                                e: for (; null !== l;) {
                                    switch (l.tag) {
                                        case 5:
                                            dl = l.stateNode, hl = !1;
                                            break e;
                                        case 3:
                                        case 4:
                                            dl = l.stateNode.containerInfo, hl = !0;
                                            break e
                                    }
                                    l = l.return
                                }
                                if (null === dl) throw Error(o(160));
                                fl(a, s, i), dl = null, hl = !1;
                                var c = i.alternate;
                                null !== c && (c.return = null), i.return = null
                            } catch (u) {
                                Sc(i, t, u)
                            }
                        }
                    if (12854 & t.subtreeFlags)
                        for (t = t.child; null !== t;) vl(t, e), t = t.sibling
                }

                function vl(e, t) {
                    var n = e.alternate,
                        r = e.flags;
                    switch (e.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            if (gl(t, e), yl(e), 4 & r) {
                                try {
                                    rl(3, e, e.return), il(3, e)
                                } catch (g) {
                                    Sc(e, e.return, g)
                                }
                                try {
                                    rl(5, e, e.return)
                                } catch (g) {
                                    Sc(e, e.return, g)
                                }
                            }
                            break;
                        case 1:
                            gl(t, e), yl(e), 512 & r && null !== n && el(n, n.return);
                            break;
                        case 5:
                            if (gl(t, e), yl(e), 512 & r && null !== n && el(n, n.return), 32 & e.flags) {
                                var i = e.stateNode;
                                try {
                                    he(i, "")
                                } catch (g) {
                                    Sc(e, e.return, g)
                                }
                            }
                            if (4 & r && null != (i = e.stateNode)) {
                                var a = e.memoizedProps,
                                    s = null !== n ? n.memoizedProps : a,
                                    l = e.type,
                                    c = e.updateQueue;
                                if (e.updateQueue = null, null !== c) try {
                                    "input" === l && "radio" === a.type && null != a.name && Q(i, a), be(l, s);
                                    var u = be(l, a);
                                    for (s = 0; s < c.length; s += 2) {
                                        var d = c[s],
                                            h = c[s + 1];
                                        "style" === d ? ge(i, h) : "dangerouslySetInnerHTML" === d ? de(i, h) : "children" === d ? he(i, h) : b(i, d, h, u)
                                    }
                                    switch (l) {
                                        case "input":
                                            Z(i, a);
                                            break;
                                        case "textarea":
                                            oe(i, a);
                                            break;
                                        case "select":
                                            var p = i._wrapperState.wasMultiple;
                                            i._wrapperState.wasMultiple = !!a.multiple;
                                            var f = a.value;
                                            null != f ? ne(i, !!a.multiple, f, !1) : p !== !!a.multiple && (null != a.defaultValue ? ne(i, !!a.multiple, a.defaultValue, !0) : ne(i, !!a.multiple, a.multiple ? [] : "", !1))
                                    }
                                    i[pi] = a
                                } catch (g) {
                                    Sc(e, e.return, g)
                                }
                            }
                            break;
                        case 6:
                            if (gl(t, e), yl(e), 4 & r) {
                                if (null === e.stateNode) throw Error(o(162));
                                i = e.stateNode, a = e.memoizedProps;
                                try {
                                    i.nodeValue = a
                                } catch (g) {
                                    Sc(e, e.return, g)
                                }
                            }
                            break;
                        case 3:
                            if (gl(t, e), yl(e), 4 & r && null !== n && n.memoizedState.isDehydrated) try {
                                jt(t.containerInfo)
                            } catch (g) {
                                Sc(e, e.return, g)
                            }
                            break;
                        case 4:
                        default:
                            gl(t, e), yl(e);
                            break;
                        case 13:
                            gl(t, e), yl(e), 8192 & (i = e.child).flags && (a = null !== i.memoizedState, i.stateNode.isHidden = a, !a || null !== i.alternate && null !== i.alternate.memoizedState || (jl = Qe())), 4 & r && ml(e);
                            break;
                        case 22:
                            if (d = null !== n && null !== n.memoizedState, 1 & e.mode ? (Qs = (u = Qs) || d, gl(t, e), Qs = u) : gl(t, e), yl(e), 8192 & r) {
                                if (u = null !== e.memoizedState, (e.stateNode.isHidden = u) && !d && 0 !== (1 & e.mode))
                                    for ($s = e, d = e.child; null !== d;) {
                                        for (h = $s = d; null !== $s;) {
                                            switch (f = (p = $s).child, p.tag) {
                                                case 0:
                                                case 11:
                                                case 14:
                                                case 15:
                                                    rl(4, p, p.return);
                                                    break;
                                                case 1:
                                                    el(p, p.return);
                                                    var m = p.stateNode;
                                                    if ("function" === typeof m.componentWillUnmount) {
                                                        r = p, n = p.return;
                                                        try {
                                                            t = r, m.props = t.memoizedProps, m.state = t.memoizedState, m.componentWillUnmount()
                                                        } catch (g) {
                                                            Sc(r, n, g)
                                                        }
                                                    }
                                                    break;
                                                case 5:
                                                    el(p, p.return);
                                                    break;
                                                case 22:
                                                    if (null !== p.memoizedState) {
                                                        Ml(h);
                                                        continue
                                                    }
                                            }
                                            null !== f ? (f.return = p, $s = f) : Ml(h)
                                        }
                                        d = d.sibling
                                    }
                                e: for (d = null, h = e;;) {
                                    if (5 === h.tag) {
                                        if (null === d) {
                                            d = h;
                                            try {
                                                i = h.stateNode, u ? "function" === typeof(a = i.style).setProperty ? a.setProperty("display", "none", "important") : a.display = "none" : (l = h.stateNode, s = void 0 !== (c = h.memoizedProps.style) && null !== c && c.hasOwnProperty("display") ? c.display : null, l.style.display = me("display", s))
                                            } catch (g) {
                                                Sc(e, e.return, g)
                                            }
                                        }
                                    } else if (6 === h.tag) {
                                        if (null === d) try {
                                            h.stateNode.nodeValue = u ? "" : h.memoizedProps
                                        } catch (g) {
                                            Sc(e, e.return, g)
                                        }
                                    } else if ((22 !== h.tag && 23 !== h.tag || null === h.memoizedState || h === e) && null !== h.child) {
                                        h.child.return = h, h = h.child;
                                        continue
                                    }
                                    if (h === e) break e;
                                    for (; null === h.sibling;) {
                                        if (null === h.return || h.return === e) break e;
                                        d === h && (d = null), h = h.return
                                    }
                                    d === h && (d = null), h.sibling.return = h.return, h = h.sibling
                                }
                            }
                            break;
                        case 19:
                            gl(t, e), yl(e), 4 & r && ml(e);
                        case 21:
                    }
                }

                function yl(e) {
                    var t = e.flags;
                    if (2 & t) {
                        try {
                            e: {
                                for (var n = e.return; null !== n;) {
                                    if (sl(n)) {
                                        var r = n;
                                        break e
                                    }
                                    n = n.return
                                }
                                throw Error(o(160))
                            }
                            switch (r.tag) {
                                case 5:
                                    var i = r.stateNode;
                                    32 & r.flags && (he(i, ""), r.flags &= -33), ul(e, ll(e), i);
                                    break;
                                case 3:
                                case 4:
                                    var a = r.stateNode.containerInfo;
                                    cl(e, ll(e), a);
                                    break;
                                default:
                                    throw Error(o(161))
                            }
                        }
                        catch (s) {
                            Sc(e, e.return, s)
                        }
                        e.flags &= -3
                    }
                    4096 & t && (e.flags &= -4097)
                }

                function bl(e, t, n) {
                    $s = e, xl(e, t, n)
                }

                function xl(e, t, n) {
                    for (var r = 0 !== (1 & e.mode); null !== $s;) {
                        var i = $s,
                            o = i.child;
                        if (22 === i.tag && r) {
                            var a = null !== i.memoizedState || Ys;
                            if (!a) {
                                var s = i.alternate,
                                    l = null !== s && null !== s.memoizedState || Qs;
                                s = Ys;
                                var c = Qs;
                                if (Ys = a, (Qs = l) && !c)
                                    for ($s = i; null !== $s;) l = (a = $s).child, 22 === a.tag && null !== a.memoizedState ? wl(i) : null !== l ? (l.return = a, $s = l) : wl(i);
                                for (; null !== o;) $s = o, xl(o, t, n), o = o.sibling;
                                $s = i, Ys = s, Qs = c
                            }
                            _l(e)
                        } else 0 !== (8772 & i.subtreeFlags) && null !== o ? (o.return = i, $s = o) : _l(e)
                    }
                }

                function _l(e) {
                    for (; null !== $s;) {
                        var t = $s;
                        if (0 !== (8772 & t.flags)) {
                            var n = t.alternate;
                            try {
                                if (0 !== (8772 & t.flags)) switch (t.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Qs || il(5, t);
                                        break;
                                    case 1:
                                        var r = t.stateNode;
                                        if (4 & t.flags && !Qs)
                                            if (null === n) r.componentDidMount();
                                            else {
                                                var i = t.elementType === t.type ? n.memoizedProps : vo(t.type, n.memoizedProps);
                                                r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                                            }
                                        var a = t.updateQueue;
                                        null !== a && Uo(t, a, r);
                                        break;
                                    case 3:
                                        var s = t.updateQueue;
                                        if (null !== s) {
                                            if (n = null, null !== t.child) switch (t.child.tag) {
                                                case 5:
                                                case 1:
                                                    n = t.child.stateNode
                                            }
                                            Uo(t, s, n)
                                        }
                                        break;
                                    case 5:
                                        var l = t.stateNode;
                                        if (null === n && 4 & t.flags) {
                                            n = l;
                                            var c = t.memoizedProps;
                                            switch (t.type) {
                                                case "button":
                                                case "input":
                                                case "select":
                                                case "textarea":
                                                    c.autoFocus && n.focus();
                                                    break;
                                                case "img":
                                                    c.src && (n.src = c.src)
                                            }
                                        }
                                        break;
                                    case 6:
                                    case 4:
                                    case 12:
                                    case 19:
                                    case 17:
                                    case 21:
                                    case 22:
                                    case 23:
                                    case 25:
                                        break;
                                    case 13:
                                        if (null === t.memoizedState) {
                                            var u = t.alternate;
                                            if (null !== u) {
                                                var d = u.memoizedState;
                                                if (null !== d) {
                                                    var h = d.dehydrated;
                                                    null !== h && jt(h)
                                                }
                                            }
                                        }
                                        break;
                                    default:
                                        throw Error(o(163))
                                }
                                Qs || 512 & t.flags && ol(t)
                            } catch (p) {
                                Sc(t, t.return, p)
                            }
                        }
                        if (t === e) {
                            $s = null;
                            break
                        }
                        if (null !== (n = t.sibling)) {
                            n.return = t.return, $s = n;
                            break
                        }
                        $s = t.return
                    }
                }

                function Ml(e) {
                    for (; null !== $s;) {
                        var t = $s;
                        if (t === e) {
                            $s = null;
                            break
                        }
                        var n = t.sibling;
                        if (null !== n) {
                            n.return = t.return, $s = n;
                            break
                        }
                        $s = t.return
                    }
                }

                function wl(e) {
                    for (; null !== $s;) {
                        var t = $s;
                        try {
                            switch (t.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    var n = t.return;
                                    try {
                                        il(4, t)
                                    } catch (l) {
                                        Sc(t, n, l)
                                    }
                                    break;
                                case 1:
                                    var r = t.stateNode;
                                    if ("function" === typeof r.componentDidMount) {
                                        var i = t.return;
                                        try {
                                            r.componentDidMount()
                                        } catch (l) {
                                            Sc(t, i, l)
                                        }
                                    }
                                    var o = t.return;
                                    try {
                                        ol(t)
                                    } catch (l) {
                                        Sc(t, o, l)
                                    }
                                    break;
                                case 5:
                                    var a = t.return;
                                    try {
                                        ol(t)
                                    } catch (l) {
                                        Sc(t, a, l)
                                    }
                            }
                        } catch (l) {
                            Sc(t, t.return, l)
                        }
                        if (t === e) {
                            $s = null;
                            break
                        }
                        var s = t.sibling;
                        if (null !== s) {
                            s.return = t.return, $s = s;
                            break
                        }
                        $s = t.return
                    }
                }
                var Al, Sl = Math.ceil,
                    El = x.ReactCurrentDispatcher,
                    Cl = x.ReactCurrentOwner,
                    Tl = x.ReactCurrentBatchConfig,
                    Pl = 0,
                    Rl = null,
                    Il = null,
                    Ol = 0,
                    Bl = 0,
                    Ll = Ai(0),
                    Dl = 0,
                    Nl = null,
                    kl = 0,
                    Fl = 0,
                    Ul = 0,
                    zl = null,
                    Hl = null,
                    jl = 0,
                    Gl = 1 / 0,
                    Vl = null,
                    ql = !1,
                    Wl = null,
                    Xl = null,
                    Kl = !1,
                    Jl = null,
                    Yl = 0,
                    Ql = 0,
                    Zl = null,
                    $l = -1,
                    ec = 0;

                function tc() {
                    return 0 !== (6 & Pl) ? Qe() : -1 !== $l ? $l : $l = Qe()
                }

                function nc(e) {
                    return 0 === (1 & e.mode) ? 1 : 0 !== (2 & Pl) && 0 !== Ol ? Ol & -Ol : null !== go.transition ? (0 === ec && (ec = mt()), ec) : 0 !== (e = bt) ? e : e = void 0 === (e = window.event) ? 16 : Yt(e.type)
                }

                function rc(e, t, n, r) {
                    if (50 < Ql) throw Ql = 0, Zl = null, Error(o(185));
                    vt(e, n, r), 0 !== (2 & Pl) && e === Rl || (e === Rl && (0 === (2 & Pl) && (Fl |= n), 4 === Dl && lc(e, Ol)), ic(e, r), 1 === n && 0 === Pl && 0 === (1 & t.mode) && (Gl = Qe() + 500, Ui && ji()))
                }

                function ic(e, t) {
                    var n = e.callbackNode;
                    ! function(e, t) {
                        for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, o = e.pendingLanes; 0 < o;) {
                            var a = 31 - at(o),
                                s = 1 << a,
                                l = i[a]; - 1 === l ? 0 !== (s & n) && 0 === (s & r) || (i[a] = pt(s, t)) : l <= t && (e.expiredLanes |= s), o &= ~s
                        }
                    }(e, t);
                    var r = ht(e, e === Rl ? Ol : 0);
                    if (0 === r) null !== n && Ke(n), e.callbackNode = null, e.callbackPriority = 0;
                    else if (t = r & -r, e.callbackPriority !== t) {
                        if (null != n && Ke(n), 1 === t) 0 === e.tag ? function(e) {
                            Ui = !0, Hi(e)
                        }(cc.bind(null, e)) : Hi(cc.bind(null, e)), ai((function() {
                            0 === (6 & Pl) && ji()
                        })), n = null;
                        else {
                            switch (xt(r)) {
                                case 1:
                                    n = $e;
                                    break;
                                case 4:
                                    n = et;
                                    break;
                                case 16:
                                default:
                                    n = tt;
                                    break;
                                case 536870912:
                                    n = rt
                            }
                            n = Rc(n, oc.bind(null, e))
                        }
                        e.callbackPriority = t, e.callbackNode = n
                    }
                }

                function oc(e, t) {
                    if ($l = -1, ec = 0, 0 !== (6 & Pl)) throw Error(o(327));
                    var n = e.callbackNode;
                    if (wc() && e.callbackNode !== n) return null;
                    var r = ht(e, e === Rl ? Ol : 0);
                    if (0 === r) return null;
                    if (0 !== (30 & r) || 0 !== (r & e.expiredLanes) || t) t = vc(e, r);
                    else {
                        t = r;
                        var i = Pl;
                        Pl |= 2;
                        var a = mc();
                        for (Rl === e && Ol === t || (Vl = null, Gl = Qe() + 500, pc(e, t));;) try {
                            bc();
                            break
                        } catch (l) {
                            fc(e, l)
                        }
                        Mo(), El.current = a, Pl = i, null !== Il ? t = 0 : (Rl = null, Ol = 0, t = Dl)
                    }
                    if (0 !== t) {
                        if (2 === t && (0 !== (i = ft(e)) && (r = i, t = ac(e, i))), 1 === t) throw n = Nl, pc(e, 0), lc(e, r), ic(e, Qe()), n;
                        if (6 === t) lc(e, r);
                        else {
                            if (i = e.current.alternate, 0 === (30 & r) && ! function(e) {
                                    for (var t = e;;) {
                                        if (16384 & t.flags) {
                                            var n = t.updateQueue;
                                            if (null !== n && null !== (n = n.stores))
                                                for (var r = 0; r < n.length; r++) {
                                                    var i = n[r],
                                                        o = i.getSnapshot;
                                                    i = i.value;
                                                    try {
                                                        if (!sr(o(), i)) return !1
                                                    } catch (s) {
                                                        return !1
                                                    }
                                                }
                                        }
                                        if (n = t.child, 16384 & t.subtreeFlags && null !== n) n.return = t, t = n;
                                        else {
                                            if (t === e) break;
                                            for (; null === t.sibling;) {
                                                if (null === t.return || t.return === e) return !0;
                                                t = t.return
                                            }
                                            t.sibling.return = t.return, t = t.sibling
                                        }
                                    }
                                    return !0
                                }(i) && (2 === (t = vc(e, r)) && (0 !== (a = ft(e)) && (r = a, t = ac(e, a))), 1 === t)) throw n = Nl, pc(e, 0), lc(e, r), ic(e, Qe()), n;
                            switch (e.finishedWork = i, e.finishedLanes = r, t) {
                                case 0:
                                case 1:
                                    throw Error(o(345));
                                case 2:
                                case 5:
                                    Mc(e, Hl, Vl);
                                    break;
                                case 3:
                                    if (lc(e, r), (130023424 & r) === r && 10 < (t = jl + 500 - Qe())) {
                                        if (0 !== ht(e, 0)) break;
                                        if (((i = e.suspendedLanes) & r) !== r) {
                                            tc(), e.pingedLanes |= e.suspendedLanes & i;
                                            break
                                        }
                                        e.timeoutHandle = ri(Mc.bind(null, e, Hl, Vl), t);
                                        break
                                    }
                                    Mc(e, Hl, Vl);
                                    break;
                                case 4:
                                    if (lc(e, r), (4194240 & r) === r) break;
                                    for (t = e.eventTimes, i = -1; 0 < r;) {
                                        var s = 31 - at(r);
                                        a = 1 << s, (s = t[s]) > i && (i = s), r &= ~a
                                    }
                                    if (r = i, 10 < (r = (120 > (r = Qe() - r) ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * Sl(r / 1960)) - r)) {
                                        e.timeoutHandle = ri(Mc.bind(null, e, Hl, Vl), r);
                                        break
                                    }
                                    Mc(e, Hl, Vl);
                                    break;
                                default:
                                    throw Error(o(329))
                            }
                        }
                    }
                    return ic(e, Qe()), e.callbackNode === n ? oc.bind(null, e) : null
                }

                function ac(e, t) {
                    var n = zl;
                    return e.current.memoizedState.isDehydrated && (pc(e, t).flags |= 256), 2 !== (e = vc(e, t)) && (t = Hl, Hl = n, null !== t && sc(t)), e
                }

                function sc(e) {
                    null === Hl ? Hl = e : Hl.push.apply(Hl, e)
                }

                function lc(e, t) {
                    for (t &= ~Ul, t &= ~Fl, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) {
                        var n = 31 - at(t),
                            r = 1 << n;
                        e[n] = -1, t &= ~r
                    }
                }

                function cc(e) {
                    if (0 !== (6 & Pl)) throw Error(o(327));
                    wc();
                    var t = ht(e, 0);
                    if (0 === (1 & t)) return ic(e, Qe()), null;
                    var n = vc(e, t);
                    if (0 !== e.tag && 2 === n) {
                        var r = ft(e);
                        0 !== r && (t = r, n = ac(e, r))
                    }
                    if (1 === n) throw n = Nl, pc(e, 0), lc(e, t), ic(e, Qe()), n;
                    if (6 === n) throw Error(o(345));
                    return e.finishedWork = e.current.alternate, e.finishedLanes = t, Mc(e, Hl, Vl), ic(e, Qe()), null
                }

                function uc(e, t) {
                    var n = Pl;
                    Pl |= 1;
                    try {
                        return e(t)
                    } finally {
                        0 === (Pl = n) && (Gl = Qe() + 500, Ui && ji())
                    }
                }

                function dc(e) {
                    null !== Jl && 0 === Jl.tag && 0 === (6 & Pl) && wc();
                    var t = Pl;
                    Pl |= 1;
                    var n = Tl.transition,
                        r = bt;
                    try {
                        if (Tl.transition = null, bt = 1, e) return e()
                    } finally {
                        bt = r, Tl.transition = n, 0 === (6 & (Pl = t)) && ji()
                    }
                }

                function hc() {
                    Bl = Ll.current, Si(Ll)
                }

                function pc(e, t) {
                    e.finishedWork = null, e.finishedLanes = 0;
                    var n = e.timeoutHandle;
                    if (-1 !== n && (e.timeoutHandle = -1, ii(n)), null !== Il)
                        for (n = Il.return; null !== n;) {
                            var r = n;
                            switch (to(r), r.tag) {
                                case 1:
                                    null !== (r = r.type.childContextTypes) && void 0 !== r && Bi();
                                    break;
                                case 3:
                                    oa(), Si(Pi), Si(Ti), da();
                                    break;
                                case 5:
                                    sa(r);
                                    break;
                                case 4:
                                    oa();
                                    break;
                                case 13:
                                case 19:
                                    Si(la);
                                    break;
                                case 10:
                                    wo(r.type._context);
                                    break;
                                case 22:
                                case 23:
                                    hc()
                            }
                            n = n.return
                        }
                    if (Rl = e, Il = e = Lc(e.current, null), Ol = Bl = t, Dl = 0, Nl = null, Ul = Fl = kl = 0, Hl = zl = null, null !== Co) {
                        for (t = 0; t < Co.length; t++)
                            if (null !== (r = (n = Co[t]).interleaved)) {
                                n.interleaved = null;
                                var i = r.next,
                                    o = n.pending;
                                if (null !== o) {
                                    var a = o.next;
                                    o.next = i, r.next = a
                                }
                                n.pending = r
                            }
                        Co = null
                    }
                    return e
                }

                function fc(e, t) {
                    for (;;) {
                        var n = Il;
                        try {
                            if (Mo(), ha.current = as, ya) {
                                for (var r = ma.memoizedState; null !== r;) {
                                    var i = r.queue;
                                    null !== i && (i.pending = null), r = r.next
                                }
                                ya = !1
                            }
                            if (fa = 0, va = ga = ma = null, ba = !1, xa = 0, Cl.current = null, null === n || null === n.return) {
                                Dl = 1, Nl = t, Il = null;
                                break
                            }
                            e: {
                                var a = e,
                                    s = n.return,
                                    l = n,
                                    c = t;
                                if (t = Ol, l.flags |= 32768, null !== c && "object" === typeof c && "function" === typeof c.then) {
                                    var u = c,
                                        d = l,
                                        h = d.tag;
                                    if (0 === (1 & d.mode) && (0 === h || 11 === h || 15 === h)) {
                                        var p = d.alternate;
                                        p ? (d.updateQueue = p.updateQueue, d.memoizedState = p.memoizedState, d.lanes = p.lanes) : (d.updateQueue = null, d.memoizedState = null)
                                    }
                                    var f = vs(s);
                                    if (null !== f) {
                                        f.flags &= -257, ys(f, s, l, 0, t), 1 & f.mode && gs(a, u, t), c = u;
                                        var m = (t = f).updateQueue;
                                        if (null === m) {
                                            var g = new Set;
                                            g.add(c), t.updateQueue = g
                                        } else m.add(c);
                                        break e
                                    }
                                    if (0 === (1 & t)) {
                                        gs(a, u, t), gc();
                                        break e
                                    }
                                    c = Error(o(426))
                                } else if (io && 1 & l.mode) {
                                    var v = vs(s);
                                    if (null !== v) {
                                        0 === (65536 & v.flags) && (v.flags |= 256), ys(v, s, l, 0, t), mo(us(c, l));
                                        break e
                                    }
                                }
                                a = c = us(c, l),
                                4 !== Dl && (Dl = 2),
                                null === zl ? zl = [a] : zl.push(a),
                                a = s;do {
                                    switch (a.tag) {
                                        case 3:
                                            a.flags |= 65536, t &= -t, a.lanes |= t, ko(a, fs(0, c, t));
                                            break e;
                                        case 1:
                                            l = c;
                                            var y = a.type,
                                                b = a.stateNode;
                                            if (0 === (128 & a.flags) && ("function" === typeof y.getDerivedStateFromError || null !== b && "function" === typeof b.componentDidCatch && (null === Xl || !Xl.has(b)))) {
                                                a.flags |= 65536, t &= -t, a.lanes |= t, ko(a, ms(a, l, t));
                                                break e
                                            }
                                    }
                                    a = a.return
                                } while (null !== a)
                            }
                            _c(n)
                        } catch (x) {
                            t = x, Il === n && null !== n && (Il = n = n.return);
                            continue
                        }
                        break
                    }
                }

                function mc() {
                    var e = El.current;
                    return El.current = as, null === e ? as : e
                }

                function gc() {
                    0 !== Dl && 3 !== Dl && 2 !== Dl || (Dl = 4), null === Rl || 0 === (268435455 & kl) && 0 === (268435455 & Fl) || lc(Rl, Ol)
                }

                function vc(e, t) {
                    var n = Pl;
                    Pl |= 2;
                    var r = mc();
                    for (Rl === e && Ol === t || (Vl = null, pc(e, t));;) try {
                        yc();
                        break
                    } catch (i) {
                        fc(e, i)
                    }
                    if (Mo(), Pl = n, El.current = r, null !== Il) throw Error(o(261));
                    return Rl = null, Ol = 0, Dl
                }

                function yc() {
                    for (; null !== Il;) xc(Il)
                }

                function bc() {
                    for (; null !== Il && !Je();) xc(Il)
                }

                function xc(e) {
                    var t = Al(e.alternate, e, Bl);
                    e.memoizedProps = e.pendingProps, null === t ? _c(e) : Il = t, Cl.current = null
                }

                function _c(e) {
                    var t = e;
                    do {
                        var n = t.alternate;
                        if (e = t.return, 0 === (32768 & t.flags)) {
                            if (null !== (n = Ks(n, t, Bl))) return void(Il = n)
                        } else {
                            if (null !== (n = Js(n, t))) return n.flags &= 32767, void(Il = n);
                            if (null === e) return Dl = 6, void(Il = null);
                            e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null
                        }
                        if (null !== (t = t.sibling)) return void(Il = t);
                        Il = t = e
                    } while (null !== t);
                    0 === Dl && (Dl = 5)
                }

                function Mc(e, t, n) {
                    var r = bt,
                        i = Tl.transition;
                    try {
                        Tl.transition = null, bt = 1,
                            function(e, t, n, r) {
                                do {
                                    wc()
                                } while (null !== Jl);
                                if (0 !== (6 & Pl)) throw Error(o(327));
                                n = e.finishedWork;
                                var i = e.finishedLanes;
                                if (null === n) return null;
                                if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(o(177));
                                e.callbackNode = null, e.callbackPriority = 0;
                                var a = n.lanes | n.childLanes;
                                if (function(e, t) {
                                        var n = e.pendingLanes & ~t;
                                        e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements;
                                        var r = e.eventTimes;
                                        for (e = e.expirationTimes; 0 < n;) {
                                            var i = 31 - at(n),
                                                o = 1 << i;
                                            t[i] = 0, r[i] = -1, e[i] = -1, n &= ~o
                                        }
                                    }(e, a), e === Rl && (Il = Rl = null, Ol = 0), 0 === (2064 & n.subtreeFlags) && 0 === (2064 & n.flags) || Kl || (Kl = !0, Rc(tt, (function() {
                                        return wc(), null
                                    }))), a = 0 !== (15990 & n.flags), 0 !== (15990 & n.subtreeFlags) || a) {
                                    a = Tl.transition, Tl.transition = null;
                                    var s = bt;
                                    bt = 1;
                                    var l = Pl;
                                    Pl |= 4, Cl.current = null,
                                        function(e, t) {
                                            if (ei = Vt, pr(e = hr())) {
                                                if ("selectionStart" in e) var n = {
                                                    start: e.selectionStart,
                                                    end: e.selectionEnd
                                                };
                                                else e: {
                                                    var r = (n = (n = e.ownerDocument) && n.defaultView || window).getSelection && n.getSelection();
                                                    if (r && 0 !== r.rangeCount) {
                                                        n = r.anchorNode;
                                                        var i = r.anchorOffset,
                                                            a = r.focusNode;
                                                        r = r.focusOffset;
                                                        try {
                                                            n.nodeType, a.nodeType
                                                        } catch (_) {
                                                            n = null;
                                                            break e
                                                        }
                                                        var s = 0,
                                                            l = -1,
                                                            c = -1,
                                                            u = 0,
                                                            d = 0,
                                                            h = e,
                                                            p = null;
                                                        t: for (;;) {
                                                            for (var f; h !== n || 0 !== i && 3 !== h.nodeType || (l = s + i), h !== a || 0 !== r && 3 !== h.nodeType || (c = s + r), 3 === h.nodeType && (s += h.nodeValue.length), null !== (f = h.firstChild);) p = h, h = f;
                                                            for (;;) {
                                                                if (h === e) break t;
                                                                if (p === n && ++u === i && (l = s), p === a && ++d === r && (c = s), null !== (f = h.nextSibling)) break;
                                                                p = (h = p).parentNode
                                                            }
                                                            h = f
                                                        }
                                                        n = -1 === l || -1 === c ? null : {
                                                            start: l,
                                                            end: c
                                                        }
                                                    } else n = null
                                                }
                                                n = n || {
                                                    start: 0,
                                                    end: 0
                                                }
                                            } else n = null;
                                            for (ti = {
                                                    focusedElem: e,
                                                    selectionRange: n
                                                }, Vt = !1, $s = t; null !== $s;)
                                                if (e = (t = $s).child, 0 !== (1028 & t.subtreeFlags) && null !== e) e.return = t, $s = e;
                                                else
                                                    for (; null !== $s;) {
                                                        t = $s;
                                                        try {
                                                            var m = t.alternate;
                                                            if (0 !== (1024 & t.flags)) switch (t.tag) {
                                                                case 0:
                                                                case 11:
                                                                case 15:
                                                                case 5:
                                                                case 6:
                                                                case 4:
                                                                case 17:
                                                                    break;
                                                                case 1:
                                                                    if (null !== m) {
                                                                        var g = m.memoizedProps,
                                                                            v = m.memoizedState,
                                                                            y = t.stateNode,
                                                                            b = y.getSnapshotBeforeUpdate(t.elementType === t.type ? g : vo(t.type, g), v);
                                                                        y.__reactInternalSnapshotBeforeUpdate = b
                                                                    }
                                                                    break;
                                                                case 3:
                                                                    var x = t.stateNode.containerInfo;
                                                                    1 === x.nodeType ? x.textContent = "" : 9 === x.nodeType && x.documentElement && x.removeChild(x.documentElement);
                                                                    break;
                                                                default:
                                                                    throw Error(o(163))
                                                            }
                                                        } catch (_) {
                                                            Sc(t, t.return, _)
                                                        }
                                                        if (null !== (e = t.sibling)) {
                                                            e.return = t.return, $s = e;
                                                            break
                                                        }
                                                        $s = t.return
                                                    }
                                            m = nl, nl = !1
                                        }(e, n), vl(n, e), fr(ti), Vt = !!ei, ti = ei = null, e.current = n, bl(n, e, i), Ye(), Pl = l, bt = s, Tl.transition = a
                                } else e.current = n;
                                if (Kl && (Kl = !1, Jl = e, Yl = i), a = e.pendingLanes, 0 === a && (Xl = null), function(e) {
                                        if (ot && "function" === typeof ot.onCommitFiberRoot) try {
                                            ot.onCommitFiberRoot(it, e, void 0, 128 === (128 & e.current.flags))
                                        } catch (t) {}
                                    }(n.stateNode), ic(e, Qe()), null !== t)
                                    for (r = e.onRecoverableError, n = 0; n < t.length; n++) i = t[n], r(i.value, {
                                        componentStack: i.stack,
                                        digest: i.digest
                                    });
                                if (ql) throw ql = !1, e = Wl, Wl = null, e;
                                0 !== (1 & Yl) && 0 !== e.tag && wc(), a = e.pendingLanes, 0 !== (1 & a) ? e === Zl ? Ql++ : (Ql = 0, Zl = e) : Ql = 0, ji()
                            }(e, t, n, r)
                    } finally {
                        Tl.transition = i, bt = r
                    }
                    return null
                }

                function wc() {
                    if (null !== Jl) {
                        var e = xt(Yl),
                            t = Tl.transition,
                            n = bt;
                        try {
                            if (Tl.transition = null, bt = 16 > e ? 16 : e, null === Jl) var r = !1;
                            else {
                                if (e = Jl, Jl = null, Yl = 0, 0 !== (6 & Pl)) throw Error(o(331));
                                var i = Pl;
                                for (Pl |= 4, $s = e.current; null !== $s;) {
                                    var a = $s,
                                        s = a.child;
                                    if (0 !== (16 & $s.flags)) {
                                        var l = a.deletions;
                                        if (null !== l) {
                                            for (var c = 0; c < l.length; c++) {
                                                var u = l[c];
                                                for ($s = u; null !== $s;) {
                                                    var d = $s;
                                                    switch (d.tag) {
                                                        case 0:
                                                        case 11:
                                                        case 15:
                                                            rl(8, d, a)
                                                    }
                                                    var h = d.child;
                                                    if (null !== h) h.return = d, $s = h;
                                                    else
                                                        for (; null !== $s;) {
                                                            var p = (d = $s).sibling,
                                                                f = d.return;
                                                            if (al(d), d === u) {
                                                                $s = null;
                                                                break
                                                            }
                                                            if (null !== p) {
                                                                p.return = f, $s = p;
                                                                break
                                                            }
                                                            $s = f
                                                        }
                                                }
                                            }
                                            var m = a.alternate;
                                            if (null !== m) {
                                                var g = m.child;
                                                if (null !== g) {
                                                    m.child = null;
                                                    do {
                                                        var v = g.sibling;
                                                        g.sibling = null, g = v
                                                    } while (null !== g)
                                                }
                                            }
                                            $s = a
                                        }
                                    }
                                    if (0 !== (2064 & a.subtreeFlags) && null !== s) s.return = a, $s = s;
                                    else e: for (; null !== $s;) {
                                        if (0 !== (2048 & (a = $s).flags)) switch (a.tag) {
                                            case 0:
                                            case 11:
                                            case 15:
                                                rl(9, a, a.return)
                                        }
                                        var y = a.sibling;
                                        if (null !== y) {
                                            y.return = a.return, $s = y;
                                            break e
                                        }
                                        $s = a.return
                                    }
                                }
                                var b = e.current;
                                for ($s = b; null !== $s;) {
                                    var x = (s = $s).child;
                                    if (0 !== (2064 & s.subtreeFlags) && null !== x) x.return = s, $s = x;
                                    else e: for (s = b; null !== $s;) {
                                        if (0 !== (2048 & (l = $s).flags)) try {
                                            switch (l.tag) {
                                                case 0:
                                                case 11:
                                                case 15:
                                                    il(9, l)
                                            }
                                        } catch (M) {
                                            Sc(l, l.return, M)
                                        }
                                        if (l === s) {
                                            $s = null;
                                            break e
                                        }
                                        var _ = l.sibling;
                                        if (null !== _) {
                                            _.return = l.return, $s = _;
                                            break e
                                        }
                                        $s = l.return
                                    }
                                }
                                if (Pl = i, ji(), ot && "function" === typeof ot.onPostCommitFiberRoot) try {
                                    ot.onPostCommitFiberRoot(it, e)
                                } catch (M) {}
                                r = !0
                            }
                            return r
                        } finally {
                            bt = n, Tl.transition = t
                        }
                    }
                    return !1
                }

                function Ac(e, t, n) {
                    e = Do(e, t = fs(0, t = us(n, t), 1), 1), t = tc(), null !== e && (vt(e, 1, t), ic(e, t))
                }

                function Sc(e, t, n) {
                    if (3 === e.tag) Ac(e, e, n);
                    else
                        for (; null !== t;) {
                            if (3 === t.tag) {
                                Ac(t, e, n);
                                break
                            }
                            if (1 === t.tag) {
                                var r = t.stateNode;
                                if ("function" === typeof t.type.getDerivedStateFromError || "function" === typeof r.componentDidCatch && (null === Xl || !Xl.has(r))) {
                                    t = Do(t, e = ms(t, e = us(n, e), 1), 1), e = tc(), null !== t && (vt(t, 1, e), ic(t, e));
                                    break
                                }
                            }
                            t = t.return
                        }
                }

                function Ec(e, t, n) {
                    var r = e.pingCache;
                    null !== r && r.delete(t), t = tc(), e.pingedLanes |= e.suspendedLanes & n, Rl === e && (Ol & n) === n && (4 === Dl || 3 === Dl && (130023424 & Ol) === Ol && 500 > Qe() - jl ? pc(e, 0) : Ul |= n), ic(e, t)
                }

                function Cc(e, t) {
                    0 === t && (0 === (1 & e.mode) ? t = 1 : (t = ut, 0 === (130023424 & (ut <<= 1)) && (ut = 4194304)));
                    var n = tc();
                    null !== (e = Ro(e, t)) && (vt(e, t, n), ic(e, n))
                }

                function Tc(e) {
                    var t = e.memoizedState,
                        n = 0;
                    null !== t && (n = t.retryLane), Cc(e, n)
                }

                function Pc(e, t) {
                    var n = 0;
                    switch (e.tag) {
                        case 13:
                            var r = e.stateNode,
                                i = e.memoizedState;
                            null !== i && (n = i.retryLane);
                            break;
                        case 19:
                            r = e.stateNode;
                            break;
                        default:
                            throw Error(o(314))
                    }
                    null !== r && r.delete(t), Cc(e, n)
                }

                function Rc(e, t) {
                    return Xe(e, t)
                }

                function Ic(e, t, n, r) {
                    this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
                }

                function Oc(e, t, n, r) {
                    return new Ic(e, t, n, r)
                }

                function Bc(e) {
                    return !(!(e = e.prototype) || !e.isReactComponent)
                }

                function Lc(e, t) {
                    var n = e.alternate;
                    return null === n ? ((n = Oc(e.tag, t, e.key, e.mode)).elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = 14680064 & e.flags, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = null === t ? null : {
                        lanes: t.lanes,
                        firstContext: t.firstContext
                    }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n
                }

                function Dc(e, t, n, r, i, a) {
                    var s = 2;
                    if (r = e, "function" === typeof e) Bc(e) && (s = 1);
                    else if ("string" === typeof e) s = 5;
                    else e: switch (e) {
                        case w:
                            return Nc(n.children, i, a, t);
                        case A:
                            s = 8, i |= 8;
                            break;
                        case S:
                            return (e = Oc(12, n, t, 2 | i)).elementType = S, e.lanes = a, e;
                        case P:
                            return (e = Oc(13, n, t, i)).elementType = P, e.lanes = a, e;
                        case R:
                            return (e = Oc(19, n, t, i)).elementType = R, e.lanes = a, e;
                        case B:
                            return kc(n, i, a, t);
                        default:
                            if ("object" === typeof e && null !== e) switch (e.$$typeof) {
                                case E:
                                    s = 10;
                                    break e;
                                case C:
                                    s = 9;
                                    break e;
                                case T:
                                    s = 11;
                                    break e;
                                case I:
                                    s = 14;
                                    break e;
                                case O:
                                    s = 16, r = null;
                                    break e
                            }
                            throw Error(o(130, null == e ? e : typeof e, ""))
                    }
                    return (t = Oc(s, n, t, i)).elementType = e, t.type = r, t.lanes = a, t
                }

                function Nc(e, t, n, r) {
                    return (e = Oc(7, e, r, t)).lanes = n, e
                }

                function kc(e, t, n, r) {
                    return (e = Oc(22, e, r, t)).elementType = B, e.lanes = n, e.stateNode = {
                        isHidden: !1
                    }, e
                }

                function Fc(e, t, n) {
                    return (e = Oc(6, e, null, t)).lanes = n, e
                }

                function Uc(e, t, n) {
                    return (t = Oc(4, null !== e.children ? e.children : [], e.key, t)).lanes = n, t.stateNode = {
                        containerInfo: e.containerInfo,
                        pendingChildren: null,
                        implementation: e.implementation
                    }, t
                }

                function zc(e, t, n, r, i) {
                    this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = gt(0), this.expirationTimes = gt(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = gt(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null
                }

                function Hc(e, t, n, r, i, o, a, s, l) {
                    return e = new zc(e, t, n, s, l), 1 === t ? (t = 1, !0 === o && (t |= 8)) : t = 0, o = Oc(3, null, null, t), e.current = o, o.stateNode = e, o.memoizedState = {
                        element: r,
                        isDehydrated: n,
                        cache: null,
                        transitions: null,
                        pendingSuspenseBoundaries: null
                    }, Oo(o), e
                }

                function jc(e) {
                    if (!e) return Ci;
                    e: {
                        if (je(e = e._reactInternals) !== e || 1 !== e.tag) throw Error(o(170));
                        var t = e;do {
                            switch (t.tag) {
                                case 3:
                                    t = t.stateNode.context;
                                    break e;
                                case 1:
                                    if (Oi(t.type)) {
                                        t = t.stateNode.__reactInternalMemoizedMergedChildContext;
                                        break e
                                    }
                            }
                            t = t.return
                        } while (null !== t);
                        throw Error(o(171))
                    }
                    if (1 === e.tag) {
                        var n = e.type;
                        if (Oi(n)) return Di(e, n, t)
                    }
                    return t
                }

                function Gc(e, t, n, r, i, o, a, s, l) {
                    return (e = Hc(n, r, !0, e, 0, o, 0, s, l)).context = jc(null), n = e.current, (o = Lo(r = tc(), i = nc(n))).callback = void 0 !== t && null !== t ? t : null, Do(n, o, i), e.current.lanes = i, vt(e, i, r), ic(e, r), e
                }

                function Vc(e, t, n, r) {
                    var i = t.current,
                        o = tc(),
                        a = nc(i);
                    return n = jc(n), null === t.context ? t.context = n : t.pendingContext = n, (t = Lo(o, a)).payload = {
                        element: e
                    }, null !== (r = void 0 === r ? null : r) && (t.callback = r), null !== (e = Do(i, t, a)) && (rc(e, i, a, o), No(e, i, a)), a
                }

                function qc(e) {
                    return (e = e.current).child ? (e.child.tag, e.child.stateNode) : null
                }

                function Wc(e, t) {
                    if (null !== (e = e.memoizedState) && null !== e.dehydrated) {
                        var n = e.retryLane;
                        e.retryLane = 0 !== n && n < t ? n : t
                    }
                }

                function Xc(e, t) {
                    Wc(e, t), (e = e.alternate) && Wc(e, t)
                }
                Al = function(e, t, n) {
                    if (null !== e)
                        if (e.memoizedProps !== t.pendingProps || Pi.current) xs = !0;
                        else {
                            if (0 === (e.lanes & n) && 0 === (128 & t.flags)) return xs = !1,
                                function(e, t, n) {
                                    switch (t.tag) {
                                        case 3:
                                            Rs(t), fo();
                                            break;
                                        case 5:
                                            aa(t);
                                            break;
                                        case 1:
                                            Oi(t.type) && Ni(t);
                                            break;
                                        case 4:
                                            ia(t, t.stateNode.containerInfo);
                                            break;
                                        case 10:
                                            var r = t.type._context,
                                                i = t.memoizedProps.value;
                                            Ei(yo, r._currentValue), r._currentValue = i;
                                            break;
                                        case 13:
                                            if (null !== (r = t.memoizedState)) return null !== r.dehydrated ? (Ei(la, 1 & la.current), t.flags |= 128, null) : 0 !== (n & t.child.childLanes) ? Fs(e, t, n) : (Ei(la, 1 & la.current), null !== (e = qs(e, t, n)) ? e.sibling : null);
                                            Ei(la, 1 & la.current);
                                            break;
                                        case 19:
                                            if (r = 0 !== (n & t.childLanes), 0 !== (128 & e.flags)) {
                                                if (r) return Gs(e, t, n);
                                                t.flags |= 128
                                            }
                                            if (null !== (i = t.memoizedState) && (i.rendering = null, i.tail = null, i.lastEffect = null), Ei(la, la.current), r) break;
                                            return null;
                                        case 22:
                                        case 23:
                                            return t.lanes = 0, Ss(e, t, n)
                                    }
                                    return qs(e, t, n)
                                }(e, t, n);
                            xs = 0 !== (131072 & e.flags)
                        }
                    else xs = !1, io && 0 !== (1048576 & t.flags) && $i(t, Wi, t.index);
                    switch (t.lanes = 0, t.tag) {
                        case 2:
                            var r = t.type;
                            Vs(e, t), e = t.pendingProps;
                            var i = Ii(t, Ti.current);
                            So(t, n), i = Aa(null, t, r, e, i, n);
                            var a = Sa();
                            return t.flags |= 1, "object" === typeof i && null !== i && "function" === typeof i.render && void 0 === i.$$typeof ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Oi(r) ? (a = !0, Ni(t)) : a = !1, t.memoizedState = null !== i.state && void 0 !== i.state ? i.state : null, Oo(t), i.updater = jo, t.stateNode = i, i._reactInternals = t, Wo(t, r, e, n), t = Ps(null, t, r, !0, a, n)) : (t.tag = 0, io && a && eo(t), _s(null, t, i, n), t = t.child), t;
                        case 16:
                            r = t.elementType;
                            e: {
                                switch (Vs(e, t), e = t.pendingProps, r = (i = r._init)(r._payload), t.type = r, i = t.tag = function(e) {
                                    if ("function" === typeof e) return Bc(e) ? 1 : 0;
                                    if (void 0 !== e && null !== e) {
                                        if ((e = e.$$typeof) === T) return 11;
                                        if (e === I) return 14
                                    }
                                    return 2
                                }(r), e = vo(r, e), i) {
                                    case 0:
                                        t = Cs(null, t, r, e, n);
                                        break e;
                                    case 1:
                                        t = Ts(null, t, r, e, n);
                                        break e;
                                    case 11:
                                        t = Ms(null, t, r, e, n);
                                        break e;
                                    case 14:
                                        t = ws(null, t, r, vo(r.type, e), n);
                                        break e
                                }
                                throw Error(o(306, r, ""))
                            }
                            return t;
                        case 0:
                            return r = t.type, i = t.pendingProps, Cs(e, t, r, i = t.elementType === r ? i : vo(r, i), n);
                        case 1:
                            return r = t.type, i = t.pendingProps, Ts(e, t, r, i = t.elementType === r ? i : vo(r, i), n);
                        case 3:
                            e: {
                                if (Rs(t), null === e) throw Error(o(387));r = t.pendingProps,
                                i = (a = t.memoizedState).element,
                                Bo(e, t),
                                Fo(t, r, null, n);
                                var s = t.memoizedState;
                                if (r = s.element, a.isDehydrated) {
                                    if (a = {
                                            element: r,
                                            isDehydrated: !1,
                                            cache: s.cache,
                                            pendingSuspenseBoundaries: s.pendingSuspenseBoundaries,
                                            transitions: s.transitions
                                        }, t.updateQueue.baseState = a, t.memoizedState = a, 256 & t.flags) {
                                        t = Is(e, t, r, n, i = us(Error(o(423)), t));
                                        break e
                                    }
                                    if (r !== i) {
                                        t = Is(e, t, r, n, i = us(Error(o(424)), t));
                                        break e
                                    }
                                    for (ro = ci(t.stateNode.containerInfo.firstChild), no = t, io = !0, oo = null, n = Zo(t, null, r, n), t.child = n; n;) n.flags = -3 & n.flags | 4096, n = n.sibling
                                } else {
                                    if (fo(), r === i) {
                                        t = qs(e, t, n);
                                        break e
                                    }
                                    _s(e, t, r, n)
                                }
                                t = t.child
                            }
                            return t;
                        case 5:
                            return aa(t), null === e && co(t), r = t.type, i = t.pendingProps, a = null !== e ? e.memoizedProps : null, s = i.children, ni(r, i) ? s = null : null !== a && ni(r, a) && (t.flags |= 32), Es(e, t), _s(e, t, s, n), t.child;
                        case 6:
                            return null === e && co(t), null;
                        case 13:
                            return Fs(e, t, n);
                        case 4:
                            return ia(t, t.stateNode.containerInfo), r = t.pendingProps, null === e ? t.child = Qo(t, null, r, n) : _s(e, t, r, n), t.child;
                        case 11:
                            return r = t.type, i = t.pendingProps, Ms(e, t, r, i = t.elementType === r ? i : vo(r, i), n);
                        case 7:
                            return _s(e, t, t.pendingProps, n), t.child;
                        case 8:
                        case 12:
                            return _s(e, t, t.pendingProps.children, n), t.child;
                        case 10:
                            e: {
                                if (r = t.type._context, i = t.pendingProps, a = t.memoizedProps, s = i.value, Ei(yo, r._currentValue), r._currentValue = s, null !== a)
                                    if (sr(a.value, s)) {
                                        if (a.children === i.children && !Pi.current) {
                                            t = qs(e, t, n);
                                            break e
                                        }
                                    } else
                                        for (null !== (a = t.child) && (a.return = t); null !== a;) {
                                            var l = a.dependencies;
                                            if (null !== l) {
                                                s = a.child;
                                                for (var c = l.firstContext; null !== c;) {
                                                    if (c.context === r) {
                                                        if (1 === a.tag) {
                                                            (c = Lo(-1, n & -n)).tag = 2;
                                                            var u = a.updateQueue;
                                                            if (null !== u) {
                                                                var d = (u = u.shared).pending;
                                                                null === d ? c.next = c : (c.next = d.next, d.next = c), u.pending = c
                                                            }
                                                        }
                                                        a.lanes |= n, null !== (c = a.alternate) && (c.lanes |= n), Ao(a.return, n, t), l.lanes |= n;
                                                        break
                                                    }
                                                    c = c.next
                                                }
                                            } else if (10 === a.tag) s = a.type === t.type ? null : a.child;
                                            else if (18 === a.tag) {
                                                if (null === (s = a.return)) throw Error(o(341));
                                                s.lanes |= n, null !== (l = s.alternate) && (l.lanes |= n), Ao(s, n, t), s = a.sibling
                                            } else s = a.child;
                                            if (null !== s) s.return = a;
                                            else
                                                for (s = a; null !== s;) {
                                                    if (s === t) {
                                                        s = null;
                                                        break
                                                    }
                                                    if (null !== (a = s.sibling)) {
                                                        a.return = s.return, s = a;
                                                        break
                                                    }
                                                    s = s.return
                                                }
                                            a = s
                                        }
                                _s(e, t, i.children, n),
                                t = t.child
                            }
                            return t;
                        case 9:
                            return i = t.type, r = t.pendingProps.children, So(t, n), r = r(i = Eo(i)), t.flags |= 1, _s(e, t, r, n), t.child;
                        case 14:
                            return i = vo(r = t.type, t.pendingProps), ws(e, t, r, i = vo(r.type, i), n);
                        case 15:
                            return As(e, t, t.type, t.pendingProps, n);
                        case 17:
                            return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : vo(r, i), Vs(e, t), t.tag = 1, Oi(r) ? (e = !0, Ni(t)) : e = !1, So(t, n), Vo(t, r, i), Wo(t, r, i, n), Ps(null, t, r, !0, e, n);
                        case 19:
                            return Gs(e, t, n);
                        case 22:
                            return Ss(e, t, n)
                    }
                    throw Error(o(156, t.tag))
                };
                var Kc = "function" === typeof reportError ? reportError : function(e) {
                    console.error(e)
                };

                function Jc(e) {
                    this._internalRoot = e
                }

                function Yc(e) {
                    this._internalRoot = e
                }

                function Qc(e) {
                    return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType)
                }

                function Zc(e) {
                    return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType && (8 !== e.nodeType || " react-mount-point-unstable " !== e.nodeValue))
                }

                function $c() {}

                function eu(e, t, n, r, i) {
                    var o = n._reactRootContainer;
                    if (o) {
                        var a = o;
                        if ("function" === typeof i) {
                            var s = i;
                            i = function() {
                                var e = qc(a);
                                s.call(e)
                            }
                        }
                        Vc(t, a, e, i)
                    } else a = function(e, t, n, r, i) {
                        if (i) {
                            if ("function" === typeof r) {
                                var o = r;
                                r = function() {
                                    var e = qc(a);
                                    o.call(e)
                                }
                            }
                            var a = Gc(t, r, e, 0, null, !1, 0, "", $c);
                            return e._reactRootContainer = a, e[fi] = a.current, jr(8 === e.nodeType ? e.parentNode : e), dc(), a
                        }
                        for (; i = e.lastChild;) e.removeChild(i);
                        if ("function" === typeof r) {
                            var s = r;
                            r = function() {
                                var e = qc(l);
                                s.call(e)
                            }
                        }
                        var l = Hc(e, 0, !1, null, 0, !1, 0, "", $c);
                        return e._reactRootContainer = l, e[fi] = l.current, jr(8 === e.nodeType ? e.parentNode : e), dc((function() {
                            Vc(t, l, n, r)
                        })), l
                    }(n, t, e, i, r);
                    return qc(a)
                }
                Yc.prototype.render = Jc.prototype.render = function(e) {
                    var t = this._internalRoot;
                    if (null === t) throw Error(o(409));
                    Vc(e, t, null, null)
                }, Yc.prototype.unmount = Jc.prototype.unmount = function() {
                    var e = this._internalRoot;
                    if (null !== e) {
                        this._internalRoot = null;
                        var t = e.containerInfo;
                        dc((function() {
                            Vc(null, e, null, null)
                        })), t[fi] = null
                    }
                }, Yc.prototype.unstable_scheduleHydration = function(e) {
                    if (e) {
                        var t = At();
                        e = {
                            blockedOn: null,
                            target: e,
                            priority: t
                        };
                        for (var n = 0; n < Bt.length && 0 !== t && t < Bt[n].priority; n++);
                        Bt.splice(n, 0, e), 0 === n && kt(e)
                    }
                }, _t = function(e) {
                    switch (e.tag) {
                        case 3:
                            var t = e.stateNode;
                            if (t.current.memoizedState.isDehydrated) {
                                var n = dt(t.pendingLanes);
                                0 !== n && (yt(t, 1 | n), ic(t, Qe()), 0 === (6 & Pl) && (Gl = Qe() + 500, ji()))
                            }
                            break;
                        case 13:
                            dc((function() {
                                var t = Ro(e, 1);
                                if (null !== t) {
                                    var n = tc();
                                    rc(t, e, 1, n)
                                }
                            })), Xc(e, 1)
                    }
                }, Mt = function(e) {
                    if (13 === e.tag) {
                        var t = Ro(e, 134217728);
                        if (null !== t) rc(t, e, 134217728, tc());
                        Xc(e, 134217728)
                    }
                }, wt = function(e) {
                    if (13 === e.tag) {
                        var t = nc(e),
                            n = Ro(e, t);
                        if (null !== n) rc(n, e, t, tc());
                        Xc(e, t)
                    }
                }, At = function() {
                    return bt
                }, St = function(e, t) {
                    var n = bt;
                    try {
                        return bt = e, t()
                    } finally {
                        bt = n
                    }
                }, Me = function(e, t, n) {
                    switch (t) {
                        case "input":
                            if (Z(e, n), t = n.name, "radio" === n.type && null != t) {
                                for (n = e; n.parentNode;) n = n.parentNode;
                                for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) {
                                    var r = n[t];
                                    if (r !== e && r.form === e.form) {
                                        var i = _i(r);
                                        if (!i) throw Error(o(90));
                                        X(r), Z(r, i)
                                    }
                                }
                            }
                            break;
                        case "textarea":
                            oe(e, n);
                            break;
                        case "select":
                            null != (t = n.value) && ne(e, !!n.multiple, t, !1)
                    }
                }, Te = uc, Pe = dc;
                var tu = {
                        usingClientEntryPoint: !1,
                        Events: [bi, xi, _i, Ee, Ce, uc]
                    },
                    nu = {
                        findFiberByHostInstance: yi,
                        bundleType: 0,
                        version: "18.2.0",
                        rendererPackageName: "react-dom"
                    },
                    ru = {
                        bundleType: nu.bundleType,
                        version: nu.version,
                        rendererPackageName: nu.rendererPackageName,
                        rendererConfig: nu.rendererConfig,
                        overrideHookState: null,
                        overrideHookStateDeletePath: null,
                        overrideHookStateRenamePath: null,
                        overrideProps: null,
                        overridePropsDeletePath: null,
                        overridePropsRenamePath: null,
                        setErrorHandler: null,
                        setSuspenseHandler: null,
                        scheduleUpdate: null,
                        currentDispatcherRef: x.ReactCurrentDispatcher,
                        findHostInstanceByFiber: function(e) {
                            return null === (e = qe(e)) ? null : e.stateNode
                        },
                        findFiberByHostInstance: nu.findFiberByHostInstance || function() {
                            return null
                        },
                        findHostInstancesForRefresh: null,
                        scheduleRefresh: null,
                        scheduleRoot: null,
                        setRefreshHandler: null,
                        getCurrentFiber: null,
                        reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
                    };
                if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
                    var iu = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                    if (!iu.isDisabled && iu.supportsFiber) try {
                        it = iu.inject(ru), ot = iu
                    } catch (ue) {}
                }
                t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tu, t.createPortal = function(e, t) {
                    var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
                    if (!Qc(t)) throw Error(o(200));
                    return function(e, t, n) {
                        var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
                        return {
                            $$typeof: M,
                            key: null == r ? null : "" + r,
                            children: e,
                            containerInfo: t,
                            implementation: n
                        }
                    }(e, t, null, n)
                }, t.createRoot = function(e, t) {
                    if (!Qc(e)) throw Error(o(299));
                    var n = !1,
                        r = "",
                        i = Kc;
                    return null !== t && void 0 !== t && (!0 === t.unstable_strictMode && (n = !0), void 0 !== t.identifierPrefix && (r = t.identifierPrefix), void 0 !== t.onRecoverableError && (i = t.onRecoverableError)), t = Hc(e, 1, !1, null, 0, n, 0, r, i), e[fi] = t.current, jr(8 === e.nodeType ? e.parentNode : e), new Jc(t)
                }, t.findDOMNode = function(e) {
                    if (null == e) return null;
                    if (1 === e.nodeType) return e;
                    var t = e._reactInternals;
                    if (void 0 === t) {
                        if ("function" === typeof e.render) throw Error(o(188));
                        throw e = Object.keys(e).join(","), Error(o(268, e))
                    }
                    return e = null === (e = qe(t)) ? null : e.stateNode
                }, t.flushSync = function(e) {
                    return dc(e)
                }, t.hydrate = function(e, t, n) {
                    if (!Zc(t)) throw Error(o(200));
                    return eu(null, e, t, !0, n)
                }, t.hydrateRoot = function(e, t, n) {
                    if (!Qc(e)) throw Error(o(405));
                    var r = null != n && n.hydratedSources || null,
                        i = !1,
                        a = "",
                        s = Kc;
                    if (null !== n && void 0 !== n && (!0 === n.unstable_strictMode && (i = !0), void 0 !== n.identifierPrefix && (a = n.identifierPrefix), void 0 !== n.onRecoverableError && (s = n.onRecoverableError)), t = Gc(t, null, e, 1, null != n ? n : null, i, 0, a, s), e[fi] = t.current, jr(e), r)
                        for (e = 0; e < r.length; e++) i = (i = (n = r[e])._getVersion)(n._source), null == t.mutableSourceEagerHydrationData ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i);
                    return new Yc(t)
                }, t.render = function(e, t, n) {
                    if (!Zc(t)) throw Error(o(200));
                    return eu(null, e, t, !1, n)
                }, t.unmountComponentAtNode = function(e) {
                    if (!Zc(e)) throw Error(o(40));
                    return !!e._reactRootContainer && (dc((function() {
                        eu(null, null, e, !1, (function() {
                            e._reactRootContainer = null, e[fi] = null
                        }))
                    })), !0)
                }, t.unstable_batchedUpdates = uc, t.unstable_renderSubtreeIntoContainer = function(e, t, n, r) {
                    if (!Zc(n)) throw Error(o(200));
                    if (null == e || void 0 === e._reactInternals) throw Error(o(38));
                    return eu(e, t, n, !1, r)
                }, t.version = "18.2.0-next-9e3b772b8-20220608"
            },
            7504: (e, t, n) => {
                "use strict";
                var r = n(8828);
                t.createRoot = r.createRoot, t.hydrateRoot = r.hydrateRoot
            },
            8828: (e, t, n) => {
                "use strict";
                ! function e() {
                    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE) try {
                        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)
                    } catch (t) {
                        console.error(t)
                    }
                }(), e.exports = n(5652)
            },
            2992: (e, t, n) => {
                "use strict";
                n.d(t, {
                    m: () => a
                });
                var r = n(568),
                    i = n(1272),
                    o = n(1184),
                    a = new(function(e) {
                        function t() {
                            var t;
                            return (t = e.call(this) || this).setup = function(e) {
                                var t;
                                if (!o.oj && (null == (t = window) ? void 0 : t.addEventListener)) {
                                    var n = function() {
                                        return e()
                                    };
                                    return window.addEventListener("visibilitychange", n, !1), window.addEventListener("focus", n, !1),
                                        function() {
                                            window.removeEventListener("visibilitychange", n), window.removeEventListener("focus", n)
                                        }
                                }
                            }, t
                        }(0, r.c)(t, e);
                        var n = t.prototype;
                        return n.onSubscribe = function() {
                            this.cleanup || this.setEventListener(this.setup)
                        }, n.onUnsubscribe = function() {
                            var e;
                            this.hasListeners() || (null == (e = this.cleanup) || e.call(this), this.cleanup = void 0)
                        }, n.setEventListener = function(e) {
                            var t, n = this;
                            this.setup = e, null == (t = this.cleanup) || t.call(this), this.cleanup = e((function(e) {
                                "boolean" === typeof e ? n.setFocused(e) : n.onFocus()
                            }))
                        }, n.setFocused = function(e) {
                            this.focused = e, e && this.onFocus()
                        }, n.onFocus = function() {
                            this.listeners.forEach((function(e) {
                                e()
                            }))
                        }, n.isFocused = function() {
                            return "boolean" === typeof this.focused ? this.focused : "undefined" === typeof document || [void 0, "visible", "prerender"].includes(document.visibilityState)
                        }, t
                    }(i.Q))
            },
            3936: (e, t, n) => {
                "use strict";
                n.d(t, {
                    QueryCache: () => r.c,
                    QueryClient: () => i.S
                });
                var r = n(6584),
                    i = n(388),
                    o = n(3432);
                n.o(o, "QueryClientProvider") && n.d(t, {
                    QueryClientProvider: function() {
                        return o.QueryClientProvider
                    }
                }), n.o(o, "useQuery") && n.d(t, {
                    useQuery: function() {
                        return o.useQuery
                    }
                }), n.o(o, "useQueryClient") && n.d(t, {
                    useQueryClient: function() {
                        return o.useQueryClient
                    }
                })
            },
            240: (e, t, n) => {
                "use strict";
                n.d(t, {
                    e: () => i,
                    k: () => o
                });
                var r = console;

                function i() {
                    return r
                }

                function o(e) {
                    r = e
                }
            },
            6016: (e, t, n) => {
                "use strict";
                n.d(t, {
                    y: () => i
                });
                var r = n(1184),
                    i = new(function() {
                        function e() {
                            this.queue = [], this.transactions = 0, this.notifyFn = function(e) {
                                e()
                            }, this.batchNotifyFn = function(e) {
                                e()
                            }
                        }
                        var t = e.prototype;
                        return t.batch = function(e) {
                            var t;
                            this.transactions++;
                            try {
                                t = e()
                            } finally {
                                this.transactions--, this.transactions || this.flush()
                            }
                            return t
                        }, t.schedule = function(e) {
                            var t = this;
                            this.transactions ? this.queue.push(e) : (0, r._8)((function() {
                                t.notifyFn(e)
                            }))
                        }, t.batchCalls = function(e) {
                            var t = this;
                            return function() {
                                for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++) r[i] = arguments[i];
                                t.schedule((function() {
                                    e.apply(void 0, r)
                                }))
                            }
                        }, t.flush = function() {
                            var e = this,
                                t = this.queue;
                            this.queue = [], t.length && (0, r._8)((function() {
                                e.batchNotifyFn((function() {
                                    t.forEach((function(t) {
                                        e.notifyFn(t)
                                    }))
                                }))
                            }))
                        }, t.setNotifyFunction = function(e) {
                            this.notifyFn = e
                        }, t.setBatchNotifyFunction = function(e) {
                            this.batchNotifyFn = e
                        }, e
                    }())
            },
            6992: (e, t, n) => {
                "use strict";
                n.d(t, {
                    q: () => a
                });
                var r = n(568),
                    i = n(1272),
                    o = n(1184),
                    a = new(function(e) {
                        function t() {
                            var t;
                            return (t = e.call(this) || this).setup = function(e) {
                                var t;
                                if (!o.oj && (null == (t = window) ? void 0 : t.addEventListener)) {
                                    var n = function() {
                                        return e()
                                    };
                                    return window.addEventListener("online", n, !1), window.addEventListener("offline", n, !1),
                                        function() {
                                            window.removeEventListener("online", n), window.removeEventListener("offline", n)
                                        }
                                }
                            }, t
                        }(0, r.c)(t, e);
                        var n = t.prototype;
                        return n.onSubscribe = function() {
                            this.cleanup || this.setEventListener(this.setup)
                        }, n.onUnsubscribe = function() {
                            var e;
                            this.hasListeners() || (null == (e = this.cleanup) || e.call(this), this.cleanup = void 0)
                        }, n.setEventListener = function(e) {
                            var t, n = this;
                            this.setup = e, null == (t = this.cleanup) || t.call(this), this.cleanup = e((function(e) {
                                "boolean" === typeof e ? n.setOnline(e) : n.onOnline()
                            }))
                        }, n.setOnline = function(e) {
                            this.online = e, e && this.onOnline()
                        }, n.onOnline = function() {
                            this.listeners.forEach((function(e) {
                                e()
                            }))
                        }, n.isOnline = function() {
                            return "boolean" === typeof this.online ? this.online : "undefined" === typeof navigator || "undefined" === typeof navigator.onLine || navigator.onLine
                        }, t
                    }(i.Q))
            },
            6584: (e, t, n) => {
                "use strict";
                n.d(t, {
                    c: () => u
                });
                var r = n(568),
                    i = n(1184),
                    o = n(5072),
                    a = n(6016),
                    s = n(240),
                    l = n(8104),
                    c = function() {
                        function e(e) {
                            this.abortSignalConsumed = !1, this.hadObservers = !1, this.defaultOptions = e.defaultOptions, this.setOptions(e.options), this.observers = [], this.cache = e.cache, this.queryKey = e.queryKey, this.queryHash = e.queryHash, this.initialState = e.state || this.getDefaultState(this.options), this.state = this.initialState, this.meta = e.meta, this.scheduleGc()
                        }
                        var t = e.prototype;
                        return t.setOptions = function(e) {
                            var t;
                            this.options = (0, o.c)({}, this.defaultOptions, e), this.meta = null == e ? void 0 : e.meta, this.cacheTime = Math.max(this.cacheTime || 0, null != (t = this.options.cacheTime) ? t : 3e5)
                        }, t.setDefaultOptions = function(e) {
                            this.defaultOptions = e
                        }, t.scheduleGc = function() {
                            var e = this;
                            this.clearGcTimeout(), (0, i.AT)(this.cacheTime) && (this.gcTimeout = setTimeout((function() {
                                e.optionalRemove()
                            }), this.cacheTime))
                        }, t.clearGcTimeout = function() {
                            this.gcTimeout && (clearTimeout(this.gcTimeout), this.gcTimeout = void 0)
                        }, t.optionalRemove = function() {
                            this.observers.length || (this.state.isFetching ? this.hadObservers && this.scheduleGc() : this.cache.remove(this))
                        }, t.setData = function(e, t) {
                            var n, r, o = this.state.data,
                                a = (0, i.iY)(e, o);
                            return (null == (n = (r = this.options).isDataEqual) ? void 0 : n.call(r, o, a)) ? a = o : !1 !== this.options.structuralSharing && (a = (0, i.CO)(o, a)), this.dispatch({
                                data: a,
                                type: "success",
                                dataUpdatedAt: null == t ? void 0 : t.updatedAt
                            }), a
                        }, t.setState = function(e, t) {
                            this.dispatch({
                                type: "setState",
                                state: e,
                                setStateOptions: t
                            })
                        }, t.cancel = function(e) {
                            var t, n = this.promise;
                            return null == (t = this.retryer) || t.cancel(e), n ? n.then(i.Kw).catch(i.Kw) : Promise.resolve()
                        }, t.destroy = function() {
                            this.clearGcTimeout(), this.cancel({
                                silent: !0
                            })
                        }, t.reset = function() {
                            this.destroy(), this.setState(this.initialState)
                        }, t.isActive = function() {
                            return this.observers.some((function(e) {
                                return !1 !== e.options.enabled
                            }))
                        }, t.isFetching = function() {
                            return this.state.isFetching
                        }, t.isStale = function() {
                            return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some((function(e) {
                                return e.getCurrentResult().isStale
                            }))
                        }, t.isStaleByTime = function(e) {
                            return void 0 === e && (e = 0), this.state.isInvalidated || !this.state.dataUpdatedAt || !(0, i.ob)(this.state.dataUpdatedAt, e)
                        }, t.onFocus = function() {
                            var e, t = this.observers.find((function(e) {
                                return e.shouldFetchOnWindowFocus()
                            }));
                            t && t.refetch(), null == (e = this.retryer) || e.continue()
                        }, t.onOnline = function() {
                            var e, t = this.observers.find((function(e) {
                                return e.shouldFetchOnReconnect()
                            }));
                            t && t.refetch(), null == (e = this.retryer) || e.continue()
                        }, t.addObserver = function(e) {
                            -1 === this.observers.indexOf(e) && (this.observers.push(e), this.hadObservers = !0, this.clearGcTimeout(), this.cache.notify({
                                type: "observerAdded",
                                query: this,
                                observer: e
                            }))
                        }, t.removeObserver = function(e) {
                            -1 !== this.observers.indexOf(e) && (this.observers = this.observers.filter((function(t) {
                                return t !== e
                            })), this.observers.length || (this.retryer && (this.retryer.isTransportCancelable || this.abortSignalConsumed ? this.retryer.cancel({
                                revert: !0
                            }) : this.retryer.cancelRetry()), this.cacheTime ? this.scheduleGc() : this.cache.remove(this)), this.cache.notify({
                                type: "observerRemoved",
                                query: this,
                                observer: e
                            }))
                        }, t.getObserversCount = function() {
                            return this.observers.length
                        }, t.invalidate = function() {
                            this.state.isInvalidated || this.dispatch({
                                type: "invalidate"
                            })
                        }, t.fetch = function(e, t) {
                            var n, r, o, a = this;
                            if (this.state.isFetching)
                                if (this.state.dataUpdatedAt && (null == t ? void 0 : t.cancelRefetch)) this.cancel({
                                    silent: !0
                                });
                                else if (this.promise) {
                                var c;
                                return null == (c = this.retryer) || c.continueRetry(), this.promise
                            }
                            if (e && this.setOptions(e), !this.options.queryFn) {
                                var u = this.observers.find((function(e) {
                                    return e.options.queryFn
                                }));
                                u && this.setOptions(u.options)
                            }
                            var d = (0, i.ye)(this.queryKey),
                                h = (0, i._k)(),
                                p = {
                                    queryKey: d,
                                    pageParam: void 0,
                                    meta: this.meta
                                };
                            Object.defineProperty(p, "signal", {
                                enumerable: !0,
                                get: function() {
                                    if (h) return a.abortSignalConsumed = !0, h.signal
                                }
                            });
                            var f, m, g = {
                                fetchOptions: t,
                                options: this.options,
                                queryKey: d,
                                state: this.state,
                                fetchFn: function() {
                                    return a.options.queryFn ? (a.abortSignalConsumed = !1, a.options.queryFn(p)) : Promise.reject("Missing queryFn")
                                },
                                meta: this.meta
                            };
                            (null == (n = this.options.behavior) ? void 0 : n.onFetch) && (null == (f = this.options.behavior) || f.onFetch(g));
                            (this.revertState = this.state, this.state.isFetching && this.state.fetchMeta === (null == (r = g.fetchOptions) ? void 0 : r.meta)) || this.dispatch({
                                type: "fetch",
                                meta: null == (m = g.fetchOptions) ? void 0 : m.meta
                            });
                            return this.retryer = new l.et({
                                fn: g.fetchFn,
                                abort: null == h || null == (o = h.abort) ? void 0 : o.bind(h),
                                onSuccess: function(e) {
                                    a.setData(e), null == a.cache.config.onSuccess || a.cache.config.onSuccess(e, a), 0 === a.cacheTime && a.optionalRemove()
                                },
                                onError: function(e) {
                                    (0, l.qu)(e) && e.silent || a.dispatch({
                                        type: "error",
                                        error: e
                                    }), (0, l.qu)(e) || (null == a.cache.config.onError || a.cache.config.onError(e, a), (0, s.e)().error(e)), 0 === a.cacheTime && a.optionalRemove()
                                },
                                onFail: function() {
                                    a.dispatch({
                                        type: "failed"
                                    })
                                },
                                onPause: function() {
                                    a.dispatch({
                                        type: "pause"
                                    })
                                },
                                onContinue: function() {
                                    a.dispatch({
                                        type: "continue"
                                    })
                                },
                                retry: g.options.retry,
                                retryDelay: g.options.retryDelay
                            }), this.promise = this.retryer.promise, this.promise
                        }, t.dispatch = function(e) {
                            var t = this;
                            this.state = this.reducer(this.state, e), a.y.batch((function() {
                                t.observers.forEach((function(t) {
                                    t.onQueryUpdate(e)
                                })), t.cache.notify({
                                    query: t,
                                    type: "queryUpdated",
                                    action: e
                                })
                            }))
                        }, t.getDefaultState = function(e) {
                            var t = "function" === typeof e.initialData ? e.initialData() : e.initialData,
                                n = "undefined" !== typeof e.initialData ? "function" === typeof e.initialDataUpdatedAt ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0,
                                r = "undefined" !== typeof t;
                            return {
                                data: t,
                                dataUpdateCount: 0,
                                dataUpdatedAt: r ? null != n ? n : Date.now() : 0,
                                error: null,
                                errorUpdateCount: 0,
                                errorUpdatedAt: 0,
                                fetchFailureCount: 0,
                                fetchMeta: null,
                                isFetching: !1,
                                isInvalidated: !1,
                                isPaused: !1,
                                status: r ? "success" : "idle"
                            }
                        }, t.reducer = function(e, t) {
                            var n, r;
                            switch (t.type) {
                                case "failed":
                                    return (0, o.c)({}, e, {
                                        fetchFailureCount: e.fetchFailureCount + 1
                                    });
                                case "pause":
                                    return (0, o.c)({}, e, {
                                        isPaused: !0
                                    });
                                case "continue":
                                    return (0, o.c)({}, e, {
                                        isPaused: !1
                                    });
                                case "fetch":
                                    return (0, o.c)({}, e, {
                                        fetchFailureCount: 0,
                                        fetchMeta: null != (n = t.meta) ? n : null,
                                        isFetching: !0,
                                        isPaused: !1
                                    }, !e.dataUpdatedAt && {
                                        error: null,
                                        status: "loading"
                                    });
                                case "success":
                                    return (0, o.c)({}, e, {
                                        data: t.data,
                                        dataUpdateCount: e.dataUpdateCount + 1,
                                        dataUpdatedAt: null != (r = t.dataUpdatedAt) ? r : Date.now(),
                                        error: null,
                                        fetchFailureCount: 0,
                                        isFetching: !1,
                                        isInvalidated: !1,
                                        isPaused: !1,
                                        status: "success"
                                    });
                                case "error":
                                    var i = t.error;
                                    return (0, l.qu)(i) && i.revert && this.revertState ? (0, o.c)({}, this.revertState) : (0, o.c)({}, e, {
                                        error: i,
                                        errorUpdateCount: e.errorUpdateCount + 1,
                                        errorUpdatedAt: Date.now(),
                                        fetchFailureCount: e.fetchFailureCount + 1,
                                        isFetching: !1,
                                        isPaused: !1,
                                        status: "error"
                                    });
                                case "invalidate":
                                    return (0, o.c)({}, e, {
                                        isInvalidated: !0
                                    });
                                case "setState":
                                    return (0, o.c)({}, e, t.state);
                                default:
                                    return e
                            }
                        }, e
                    }(),
                    u = function(e) {
                        function t(t) {
                            var n;
                            return (n = e.call(this) || this).config = t || {}, n.queries = [], n.queriesMap = {}, n
                        }(0, r.c)(t, e);
                        var n = t.prototype;
                        return n.build = function(e, t, n) {
                            var r, o = t.queryKey,
                                a = null != (r = t.queryHash) ? r : (0, i.oX)(o, t),
                                s = this.get(a);
                            return s || (s = new c({
                                cache: this,
                                queryKey: o,
                                queryHash: a,
                                options: e.defaultQueryOptions(t),
                                state: n,
                                defaultOptions: e.getQueryDefaults(o),
                                meta: t.meta
                            }), this.add(s)), s
                        }, n.add = function(e) {
                            this.queriesMap[e.queryHash] || (this.queriesMap[e.queryHash] = e, this.queries.push(e), this.notify({
                                type: "queryAdded",
                                query: e
                            }))
                        }, n.remove = function(e) {
                            var t = this.queriesMap[e.queryHash];
                            t && (e.destroy(), this.queries = this.queries.filter((function(t) {
                                return t !== e
                            })), t === e && delete this.queriesMap[e.queryHash], this.notify({
                                type: "queryRemoved",
                                query: e
                            }))
                        }, n.clear = function() {
                            var e = this;
                            a.y.batch((function() {
                                e.queries.forEach((function(t) {
                                    e.remove(t)
                                }))
                            }))
                        }, n.get = function(e) {
                            return this.queriesMap[e]
                        }, n.getAll = function() {
                            return this.queries
                        }, n.find = function(e, t) {
                            var n = (0, i.A7)(e, t)[0];
                            return "undefined" === typeof n.exact && (n.exact = !0), this.queries.find((function(e) {
                                return (0, i._W)(n, e)
                            }))
                        }, n.findAll = function(e, t) {
                            var n = (0, i.A7)(e, t)[0];
                            return Object.keys(n).length > 0 ? this.queries.filter((function(e) {
                                return (0, i._W)(n, e)
                            })) : this.queries
                        }, n.notify = function(e) {
                            var t = this;
                            a.y.batch((function() {
                                t.listeners.forEach((function(t) {
                                    t(e)
                                }))
                            }))
                        }, n.onFocus = function() {
                            var e = this;
                            a.y.batch((function() {
                                e.queries.forEach((function(e) {
                                    e.onFocus()
                                }))
                            }))
                        }, n.onOnline = function() {
                            var e = this;
                            a.y.batch((function() {
                                e.queries.forEach((function(e) {
                                    e.onOnline()
                                }))
                            }))
                        }, t
                    }(n(1272).Q)
            },
            388: (e, t, n) => {
                "use strict";
                n.d(t, {
                    S: () => g
                });
                var r = n(5072),
                    i = n(1184),
                    o = n(6584),
                    a = n(568),
                    s = n(6016),
                    l = n(240),
                    c = n(8104),
                    u = function() {
                        function e(e) {
                            this.options = (0, r.c)({}, e.defaultOptions, e.options), this.mutationId = e.mutationId, this.mutationCache = e.mutationCache, this.observers = [], this.state = e.state || {
                                context: void 0,
                                data: void 0,
                                error: null,
                                failureCount: 0,
                                isPaused: !1,
                                status: "idle",
                                variables: void 0
                            }, this.meta = e.meta
                        }
                        var t = e.prototype;
                        return t.setState = function(e) {
                            this.dispatch({
                                type: "setState",
                                state: e
                            })
                        }, t.addObserver = function(e) {
                            -1 === this.observers.indexOf(e) && this.observers.push(e)
                        }, t.removeObserver = function(e) {
                            this.observers = this.observers.filter((function(t) {
                                return t !== e
                            }))
                        }, t.cancel = function() {
                            return this.retryer ? (this.retryer.cancel(), this.retryer.promise.then(i.Kw).catch(i.Kw)) : Promise.resolve()
                        }, t.continue = function() {
                            return this.retryer ? (this.retryer.continue(), this.retryer.promise) : this.execute()
                        }, t.execute = function() {
                            var e, t = this,
                                n = "loading" === this.state.status,
                                r = Promise.resolve();
                            return n || (this.dispatch({
                                type: "loading",
                                variables: this.options.variables
                            }), r = r.then((function() {
                                null == t.mutationCache.config.onMutate || t.mutationCache.config.onMutate(t.state.variables, t)
                            })).then((function() {
                                return null == t.options.onMutate ? void 0 : t.options.onMutate(t.state.variables)
                            })).then((function(e) {
                                e !== t.state.context && t.dispatch({
                                    type: "loading",
                                    context: e,
                                    variables: t.state.variables
                                })
                            }))), r.then((function() {
                                return t.executeMutation()
                            })).then((function(n) {
                                e = n, null == t.mutationCache.config.onSuccess || t.mutationCache.config.onSuccess(e, t.state.variables, t.state.context, t)
                            })).then((function() {
                                return null == t.options.onSuccess ? void 0 : t.options.onSuccess(e, t.state.variables, t.state.context)
                            })).then((function() {
                                return null == t.options.onSettled ? void 0 : t.options.onSettled(e, null, t.state.variables, t.state.context)
                            })).then((function() {
                                return t.dispatch({
                                    type: "success",
                                    data: e
                                }), e
                            })).catch((function(e) {
                                return null == t.mutationCache.config.onError || t.mutationCache.config.onError(e, t.state.variables, t.state.context, t), (0, l.e)().error(e), Promise.resolve().then((function() {
                                    return null == t.options.onError ? void 0 : t.options.onError(e, t.state.variables, t.state.context)
                                })).then((function() {
                                    return null == t.options.onSettled ? void 0 : t.options.onSettled(void 0, e, t.state.variables, t.state.context)
                                })).then((function() {
                                    throw t.dispatch({
                                        type: "error",
                                        error: e
                                    }), e
                                }))
                            }))
                        }, t.executeMutation = function() {
                            var e, t = this;
                            return this.retryer = new c.et({
                                fn: function() {
                                    return t.options.mutationFn ? t.options.mutationFn(t.state.variables) : Promise.reject("No mutationFn found")
                                },
                                onFail: function() {
                                    t.dispatch({
                                        type: "failed"
                                    })
                                },
                                onPause: function() {
                                    t.dispatch({
                                        type: "pause"
                                    })
                                },
                                onContinue: function() {
                                    t.dispatch({
                                        type: "continue"
                                    })
                                },
                                retry: null != (e = this.options.retry) ? e : 0,
                                retryDelay: this.options.retryDelay
                            }), this.retryer.promise
                        }, t.dispatch = function(e) {
                            var t = this;
                            this.state = function(e, t) {
                                switch (t.type) {
                                    case "failed":
                                        return (0, r.c)({}, e, {
                                            failureCount: e.failureCount + 1
                                        });
                                    case "pause":
                                        return (0, r.c)({}, e, {
                                            isPaused: !0
                                        });
                                    case "continue":
                                        return (0, r.c)({}, e, {
                                            isPaused: !1
                                        });
                                    case "loading":
                                        return (0, r.c)({}, e, {
                                            context: t.context,
                                            data: void 0,
                                            error: null,
                                            isPaused: !1,
                                            status: "loading",
                                            variables: t.variables
                                        });
                                    case "success":
                                        return (0, r.c)({}, e, {
                                            data: t.data,
                                            error: null,
                                            status: "success",
                                            isPaused: !1
                                        });
                                    case "error":
                                        return (0, r.c)({}, e, {
                                            data: void 0,
                                            error: t.error,
                                            failureCount: e.failureCount + 1,
                                            isPaused: !1,
                                            status: "error"
                                        });
                                    case "setState":
                                        return (0, r.c)({}, e, t.state);
                                    default:
                                        return e
                                }
                            }(this.state, e), s.y.batch((function() {
                                t.observers.forEach((function(t) {
                                    t.onMutationUpdate(e)
                                })), t.mutationCache.notify(t)
                            }))
                        }, e
                    }();
                var d = function(e) {
                        function t(t) {
                            var n;
                            return (n = e.call(this) || this).config = t || {}, n.mutations = [], n.mutationId = 0, n
                        }(0, a.c)(t, e);
                        var n = t.prototype;
                        return n.build = function(e, t, n) {
                            var r = new u({
                                mutationCache: this,
                                mutationId: ++this.mutationId,
                                options: e.defaultMutationOptions(t),
                                state: n,
                                defaultOptions: t.mutationKey ? e.getMutationDefaults(t.mutationKey) : void 0,
                                meta: t.meta
                            });
                            return this.add(r), r
                        }, n.add = function(e) {
                            this.mutations.push(e), this.notify(e)
                        }, n.remove = function(e) {
                            this.mutations = this.mutations.filter((function(t) {
                                return t !== e
                            })), e.cancel(), this.notify(e)
                        }, n.clear = function() {
                            var e = this;
                            s.y.batch((function() {
                                e.mutations.forEach((function(t) {
                                    e.remove(t)
                                }))
                            }))
                        }, n.getAll = function() {
                            return this.mutations
                        }, n.find = function(e) {
                            return "undefined" === typeof e.exact && (e.exact = !0), this.mutations.find((function(t) {
                                return (0, i.Yn)(e, t)
                            }))
                        }, n.findAll = function(e) {
                            return this.mutations.filter((function(t) {
                                return (0, i.Yn)(e, t)
                            }))
                        }, n.notify = function(e) {
                            var t = this;
                            s.y.batch((function() {
                                t.listeners.forEach((function(t) {
                                    t(e)
                                }))
                            }))
                        }, n.onFocus = function() {
                            this.resumePausedMutations()
                        }, n.onOnline = function() {
                            this.resumePausedMutations()
                        }, n.resumePausedMutations = function() {
                            var e = this.mutations.filter((function(e) {
                                return e.state.isPaused
                            }));
                            return s.y.batch((function() {
                                return e.reduce((function(e, t) {
                                    return e.then((function() {
                                        return t.continue().catch(i.Kw)
                                    }))
                                }), Promise.resolve())
                            }))
                        }, t
                    }(n(1272).Q),
                    h = n(2992),
                    p = n(6992);

                function f(e, t) {
                    return null == e.getNextPageParam ? void 0 : e.getNextPageParam(t[t.length - 1], t)
                }

                function m(e, t) {
                    return null == e.getPreviousPageParam ? void 0 : e.getPreviousPageParam(t[0], t)
                }
                var g = function() {
                    function e(e) {
                        void 0 === e && (e = {}), this.queryCache = e.queryCache || new o.c, this.mutationCache = e.mutationCache || new d, this.defaultOptions = e.defaultOptions || {}, this.queryDefaults = [], this.mutationDefaults = []
                    }
                    var t = e.prototype;
                    return t.mount = function() {
                        var e = this;
                        this.unsubscribeFocus = h.m.subscribe((function() {
                            h.m.isFocused() && p.q.isOnline() && (e.mutationCache.onFocus(), e.queryCache.onFocus())
                        })), this.unsubscribeOnline = p.q.subscribe((function() {
                            h.m.isFocused() && p.q.isOnline() && (e.mutationCache.onOnline(), e.queryCache.onOnline())
                        }))
                    }, t.unmount = function() {
                        var e, t;
                        null == (e = this.unsubscribeFocus) || e.call(this), null == (t = this.unsubscribeOnline) || t.call(this)
                    }, t.isFetching = function(e, t) {
                        var n = (0, i.A7)(e, t)[0];
                        return n.fetching = !0, this.queryCache.findAll(n).length
                    }, t.isMutating = function(e) {
                        return this.mutationCache.findAll((0, r.c)({}, e, {
                            fetching: !0
                        })).length
                    }, t.getQueryData = function(e, t) {
                        var n;
                        return null == (n = this.queryCache.find(e, t)) ? void 0 : n.state.data
                    }, t.getQueriesData = function(e) {
                        return this.getQueryCache().findAll(e).map((function(e) {
                            return [e.queryKey, e.state.data]
                        }))
                    }, t.setQueryData = function(e, t, n) {
                        var r = (0, i.O2)(e),
                            o = this.defaultQueryOptions(r);
                        return this.queryCache.build(this, o).setData(t, n)
                    }, t.setQueriesData = function(e, t, n) {
                        var r = this;
                        return s.y.batch((function() {
                            return r.getQueryCache().findAll(e).map((function(e) {
                                var i = e.queryKey;
                                return [i, r.setQueryData(i, t, n)]
                            }))
                        }))
                    }, t.getQueryState = function(e, t) {
                        var n;
                        return null == (n = this.queryCache.find(e, t)) ? void 0 : n.state
                    }, t.removeQueries = function(e, t) {
                        var n = (0, i.A7)(e, t)[0],
                            r = this.queryCache;
                        s.y.batch((function() {
                            r.findAll(n).forEach((function(e) {
                                r.remove(e)
                            }))
                        }))
                    }, t.resetQueries = function(e, t, n) {
                        var o = this,
                            a = (0, i.A7)(e, t, n),
                            l = a[0],
                            c = a[1],
                            u = this.queryCache,
                            d = (0, r.c)({}, l, {
                                active: !0
                            });
                        return s.y.batch((function() {
                            return u.findAll(l).forEach((function(e) {
                                e.reset()
                            })), o.refetchQueries(d, c)
                        }))
                    }, t.cancelQueries = function(e, t, n) {
                        var r = this,
                            o = (0, i.A7)(e, t, n),
                            a = o[0],
                            l = o[1],
                            c = void 0 === l ? {} : l;
                        "undefined" === typeof c.revert && (c.revert = !0);
                        var u = s.y.batch((function() {
                            return r.queryCache.findAll(a).map((function(e) {
                                return e.cancel(c)
                            }))
                        }));
                        return Promise.all(u).then(i.Kw).catch(i.Kw)
                    }, t.invalidateQueries = function(e, t, n) {
                        var o, a, l, c = this,
                            u = (0, i.A7)(e, t, n),
                            d = u[0],
                            h = u[1],
                            p = (0, r.c)({}, d, {
                                active: null == (o = null != (a = d.refetchActive) ? a : d.active) || o,
                                inactive: null != (l = d.refetchInactive) && l
                            });
                        return s.y.batch((function() {
                            return c.queryCache.findAll(d).forEach((function(e) {
                                e.invalidate()
                            })), c.refetchQueries(p, h)
                        }))
                    }, t.refetchQueries = function(e, t, n) {
                        var o = this,
                            a = (0, i.A7)(e, t, n),
                            l = a[0],
                            c = a[1],
                            u = s.y.batch((function() {
                                return o.queryCache.findAll(l).map((function(e) {
                                    return e.fetch(void 0, (0, r.c)({}, c, {
                                        meta: {
                                            refetchPage: null == l ? void 0 : l.refetchPage
                                        }
                                    }))
                                }))
                            })),
                            d = Promise.all(u).then(i.Kw);
                        return (null == c ? void 0 : c.throwOnError) || (d = d.catch(i.Kw)), d
                    }, t.fetchQuery = function(e, t, n) {
                        var r = (0, i.O2)(e, t, n),
                            o = this.defaultQueryOptions(r);
                        "undefined" === typeof o.retry && (o.retry = !1);
                        var a = this.queryCache.build(this, o);
                        return a.isStaleByTime(o.staleTime) ? a.fetch(o) : Promise.resolve(a.state.data)
                    }, t.prefetchQuery = function(e, t, n) {
                        return this.fetchQuery(e, t, n).then(i.Kw).catch(i.Kw)
                    }, t.fetchInfiniteQuery = function(e, t, n) {
                        var r = (0, i.O2)(e, t, n);
                        return r.behavior = {
                            onFetch: function(e) {
                                e.fetchFn = function() {
                                    var t, n, r, o, a, s, l, u = null == (t = e.fetchOptions) || null == (n = t.meta) ? void 0 : n.refetchPage,
                                        d = null == (r = e.fetchOptions) || null == (o = r.meta) ? void 0 : o.fetchMore,
                                        h = null == d ? void 0 : d.pageParam,
                                        p = "forward" === (null == d ? void 0 : d.direction),
                                        g = "backward" === (null == d ? void 0 : d.direction),
                                        v = (null == (a = e.state.data) ? void 0 : a.pages) || [],
                                        y = (null == (s = e.state.data) ? void 0 : s.pageParams) || [],
                                        b = (0, i._k)(),
                                        x = null == b ? void 0 : b.signal,
                                        _ = y,
                                        M = !1,
                                        w = e.options.queryFn || function() {
                                            return Promise.reject("Missing queryFn")
                                        },
                                        A = function(e, t, n, r) {
                                            return _ = r ? [t].concat(_) : [].concat(_, [t]), r ? [n].concat(e) : [].concat(e, [n])
                                        },
                                        S = function(t, n, r, i) {
                                            if (M) return Promise.reject("Cancelled");
                                            if ("undefined" === typeof r && !n && t.length) return Promise.resolve(t);
                                            var o = {
                                                    queryKey: e.queryKey,
                                                    signal: x,
                                                    pageParam: r,
                                                    meta: e.meta
                                                },
                                                a = w(o),
                                                s = Promise.resolve(a).then((function(e) {
                                                    return A(t, r, e, i)
                                                }));
                                            return (0, c.k7)(a) && (s.cancel = a.cancel), s
                                        };
                                    if (v.length)
                                        if (p) {
                                            var E = "undefined" !== typeof h,
                                                C = E ? h : f(e.options, v);
                                            l = S(v, E, C)
                                        } else if (g) {
                                        var T = "undefined" !== typeof h,
                                            P = T ? h : m(e.options, v);
                                        l = S(v, T, P, !0)
                                    } else ! function() {
                                        _ = [];
                                        var t = "undefined" === typeof e.options.getNextPageParam,
                                            n = !u || !v[0] || u(v[0], 0, v);
                                        l = n ? S([], t, y[0]) : Promise.resolve(A([], y[0], v[0]));
                                        for (var r = function(n) {
                                                l = l.then((function(r) {
                                                    if (!u || !v[n] || u(v[n], n, v)) {
                                                        var i = t ? y[n] : f(e.options, r);
                                                        return S(r, t, i)
                                                    }
                                                    return Promise.resolve(A(r, y[n], v[n]))
                                                }))
                                            }, i = 1; i < v.length; i++) r(i)
                                    }();
                                    else l = S([]);
                                    var R = l.then((function(e) {
                                        return {
                                            pages: e,
                                            pageParams: _
                                        }
                                    }));
                                    return R.cancel = function() {
                                        M = !0, null == b || b.abort(), (0, c.k7)(l) && l.cancel()
                                    }, R
                                }
                            }
                        }, this.fetchQuery(r)
                    }, t.prefetchInfiniteQuery = function(e, t, n) {
                        return this.fetchInfiniteQuery(e, t, n).then(i.Kw).catch(i.Kw)
                    }, t.cancelMutations = function() {
                        var e = this,
                            t = s.y.batch((function() {
                                return e.mutationCache.getAll().map((function(e) {
                                    return e.cancel()
                                }))
                            }));
                        return Promise.all(t).then(i.Kw).catch(i.Kw)
                    }, t.resumePausedMutations = function() {
                        return this.getMutationCache().resumePausedMutations()
                    }, t.executeMutation = function(e) {
                        return this.mutationCache.build(this, e).execute()
                    }, t.getQueryCache = function() {
                        return this.queryCache
                    }, t.getMutationCache = function() {
                        return this.mutationCache
                    }, t.getDefaultOptions = function() {
                        return this.defaultOptions
                    }, t.setDefaultOptions = function(e) {
                        this.defaultOptions = e
                    }, t.setQueryDefaults = function(e, t) {
                        var n = this.queryDefaults.find((function(t) {
                            return (0, i.aw)(e) === (0, i.aw)(t.queryKey)
                        }));
                        n ? n.defaultOptions = t : this.queryDefaults.push({
                            queryKey: e,
                            defaultOptions: t
                        })
                    }, t.getQueryDefaults = function(e) {
                        var t;
                        return e ? null == (t = this.queryDefaults.find((function(t) {
                            return (0, i.GS)(e, t.queryKey)
                        }))) ? void 0 : t.defaultOptions : void 0
                    }, t.setMutationDefaults = function(e, t) {
                        var n = this.mutationDefaults.find((function(t) {
                            return (0, i.aw)(e) === (0, i.aw)(t.mutationKey)
                        }));
                        n ? n.defaultOptions = t : this.mutationDefaults.push({
                            mutationKey: e,
                            defaultOptions: t
                        })
                    }, t.getMutationDefaults = function(e) {
                        var t;
                        return e ? null == (t = this.mutationDefaults.find((function(t) {
                            return (0, i.GS)(e, t.mutationKey)
                        }))) ? void 0 : t.defaultOptions : void 0
                    }, t.defaultQueryOptions = function(e) {
                        if (null == e ? void 0 : e._defaulted) return e;
                        var t = (0, r.c)({}, this.defaultOptions.queries, this.getQueryDefaults(null == e ? void 0 : e.queryKey), e, {
                            _defaulted: !0
                        });
                        return !t.queryHash && t.queryKey && (t.queryHash = (0, i.oX)(t.queryKey, t)), t
                    }, t.defaultQueryObserverOptions = function(e) {
                        return this.defaultQueryOptions(e)
                    }, t.defaultMutationOptions = function(e) {
                        return (null == e ? void 0 : e._defaulted) ? e : (0, r.c)({}, this.defaultOptions.mutations, this.getMutationDefaults(null == e ? void 0 : e.mutationKey), e, {
                            _defaulted: !0
                        })
                    }, t.clear = function() {
                        this.queryCache.clear(), this.mutationCache.clear()
                    }, e
                }()
            },
            8104: (e, t, n) => {
                "use strict";
                n.d(t, {
                    et: () => u,
                    k7: () => s,
                    qu: () => c
                });
                var r = n(2992),
                    i = n(6992),
                    o = n(1184);

                function a(e) {
                    return Math.min(1e3 * Math.pow(2, e), 3e4)
                }

                function s(e) {
                    return "function" === typeof(null == e ? void 0 : e.cancel)
                }
                var l = function(e) {
                    this.revert = null == e ? void 0 : e.revert, this.silent = null == e ? void 0 : e.silent
                };

                function c(e) {
                    return e instanceof l
                }
                var u = function(e) {
                    var t, n, c, u, d = this,
                        h = !1;
                    this.abort = e.abort, this.cancel = function(e) {
                        return null == t ? void 0 : t(e)
                    }, this.cancelRetry = function() {
                        h = !0
                    }, this.continueRetry = function() {
                        h = !1
                    }, this.continue = function() {
                        return null == n ? void 0 : n()
                    }, this.failureCount = 0, this.isPaused = !1, this.isResolved = !1, this.isTransportCancelable = !1, this.promise = new Promise((function(e, t) {
                        c = e, u = t
                    }));
                    var p = function(t) {
                            d.isResolved || (d.isResolved = !0, null == e.onSuccess || e.onSuccess(t), null == n || n(), c(t))
                        },
                        f = function(t) {
                            d.isResolved || (d.isResolved = !0, null == e.onError || e.onError(t), null == n || n(), u(t))
                        };
                    ! function c() {
                        if (!d.isResolved) {
                            var u;
                            try {
                                u = e.fn()
                            } catch (m) {
                                u = Promise.reject(m)
                            }
                            t = function(e) {
                                if (!d.isResolved && (f(new l(e)), null == d.abort || d.abort(), s(u))) try {
                                    u.cancel()
                                } catch (t) {}
                            }, d.isTransportCancelable = s(u), Promise.resolve(u).then(p).catch((function(t) {
                                var s, l;
                                if (!d.isResolved) {
                                    var u = null != (s = e.retry) ? s : 3,
                                        p = null != (l = e.retryDelay) ? l : a,
                                        m = "function" === typeof p ? p(d.failureCount, t) : p,
                                        g = !0 === u || "number" === typeof u && d.failureCount < u || "function" === typeof u && u(d.failureCount, t);
                                    !h && g ? (d.failureCount++, null == e.onFail || e.onFail(d.failureCount, t), (0, o.W_)(m).then((function() {
                                        if (!r.m.isFocused() || !i.q.isOnline()) return new Promise((function(t) {
                                            n = t, d.isPaused = !0, null == e.onPause || e.onPause()
                                        })).then((function() {
                                            n = void 0, d.isPaused = !1, null == e.onContinue || e.onContinue()
                                        }))
                                    })).then((function() {
                                        h ? f(t) : c()
                                    }))) : f(t)
                                }
                            }))
                        }
                    }()
                }
            },
            1272: (e, t, n) => {
                "use strict";
                n.d(t, {
                    Q: () => r
                });
                var r = function() {
                    function e() {
                        this.listeners = []
                    }
                    var t = e.prototype;
                    return t.subscribe = function(e) {
                        var t = this,
                            n = e || function() {};
                        return this.listeners.push(n), this.onSubscribe(),
                            function() {
                                t.listeners = t.listeners.filter((function(e) {
                                    return e !== n
                                })), t.onUnsubscribe()
                            }
                    }, t.hasListeners = function() {
                        return this.listeners.length > 0
                    }, t.onSubscribe = function() {}, t.onUnsubscribe = function() {}, e
                }()
            },
            3432: () => {},
            1184: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A7: () => d,
                    AT: () => s,
                    CO: () => y,
                    GS: () => g,
                    Kw: () => o,
                    O2: () => u,
                    W_: () => w,
                    Yn: () => p,
                    _8: () => A,
                    _W: () => h,
                    _k: () => S,
                    aw: () => m,
                    iY: () => a,
                    oX: () => f,
                    ob: () => c,
                    oj: () => i,
                    wL: () => b,
                    ye: () => l
                });
                var r = n(5072),
                    i = "undefined" === typeof window;

                function o() {}

                function a(e, t) {
                    return "function" === typeof e ? e(t) : e
                }

                function s(e) {
                    return "number" === typeof e && e >= 0 && e !== 1 / 0
                }

                function l(e) {
                    return Array.isArray(e) ? e : [e]
                }

                function c(e, t) {
                    return Math.max(e + (t || 0) - Date.now(), 0)
                }

                function u(e, t, n) {
                    return M(e) ? "function" === typeof t ? (0, r.c)({}, n, {
                        queryKey: e,
                        queryFn: t
                    }) : (0, r.c)({}, t, {
                        queryKey: e
                    }) : e
                }

                function d(e, t, n) {
                    return M(e) ? [(0, r.c)({}, t, {
                        queryKey: e
                    }), n] : [e || {}, t]
                }

                function h(e, t) {
                    var n = e.active,
                        r = e.exact,
                        i = e.fetching,
                        o = e.inactive,
                        a = e.predicate,
                        s = e.queryKey,
                        l = e.stale;
                    if (M(s))
                        if (r) {
                            if (t.queryHash !== f(s, t.options)) return !1
                        } else if (!g(t.queryKey, s)) return !1;
                    var c = function(e, t) {
                        return !0 === e && !0 === t || null == e && null == t ? "all" : !1 === e && !1 === t ? "none" : (null != e ? e : !t) ? "active" : "inactive"
                    }(n, o);
                    if ("none" === c) return !1;
                    if ("all" !== c) {
                        var u = t.isActive();
                        if ("active" === c && !u) return !1;
                        if ("inactive" === c && u) return !1
                    }
                    return ("boolean" !== typeof l || t.isStale() === l) && (("boolean" !== typeof i || t.isFetching() === i) && !(a && !a(t)))
                }

                function p(e, t) {
                    var n = e.exact,
                        r = e.fetching,
                        i = e.predicate,
                        o = e.mutationKey;
                    if (M(o)) {
                        if (!t.options.mutationKey) return !1;
                        if (n) {
                            if (m(t.options.mutationKey) !== m(o)) return !1
                        } else if (!g(t.options.mutationKey, o)) return !1
                    }
                    return ("boolean" !== typeof r || "loading" === t.state.status === r) && !(i && !i(t))
                }

                function f(e, t) {
                    return ((null == t ? void 0 : t.queryKeyHashFn) || m)(e)
                }

                function m(e) {
                    var t, n = l(e);
                    return t = n, JSON.stringify(t, (function(e, t) {
                        return x(t) ? Object.keys(t).sort().reduce((function(e, n) {
                            return e[n] = t[n], e
                        }), {}) : t
                    }))
                }

                function g(e, t) {
                    return v(l(e), l(t))
                }

                function v(e, t) {
                    return e === t || typeof e === typeof t && (!(!e || !t || "object" !== typeof e || "object" !== typeof t) && !Object.keys(t).some((function(n) {
                        return !v(e[n], t[n])
                    })))
                }

                function y(e, t) {
                    if (e === t) return e;
                    var n = Array.isArray(e) && Array.isArray(t);
                    if (n || x(e) && x(t)) {
                        for (var r = n ? e.length : Object.keys(e).length, i = n ? t : Object.keys(t), o = i.length, a = n ? [] : {}, s = 0, l = 0; l < o; l++) {
                            var c = n ? l : i[l];
                            a[c] = y(e[c], t[c]), a[c] === e[c] && s++
                        }
                        return r === o && s === r ? e : a
                    }
                    return t
                }

                function b(e, t) {
                    if (e && !t || t && !e) return !1;
                    for (var n in e)
                        if (e[n] !== t[n]) return !1;
                    return !0
                }

                function x(e) {
                    if (!_(e)) return !1;
                    var t = e.constructor;
                    if ("undefined" === typeof t) return !0;
                    var n = t.prototype;
                    return !!_(n) && !!n.hasOwnProperty("isPrototypeOf")
                }

                function _(e) {
                    return "[object Object]" === Object.prototype.toString.call(e)
                }

                function M(e) {
                    return "string" === typeof e || Array.isArray(e)
                }

                function w(e) {
                    return new Promise((function(t) {
                        setTimeout(t, e)
                    }))
                }

                function A(e) {
                    Promise.resolve().then(e).catch((function(e) {
                        return setTimeout((function() {
                            throw e
                        }))
                    }))
                }

                function S() {
                    if ("function" === typeof AbortController) return new AbortController
                }
            },
            4752: (e, t, n) => {
                "use strict";
                n.d(t, {
                    QueryCache: () => r.QueryCache,
                    QueryClient: () => r.QueryClient,
                    QueryClientProvider: () => i.QueryClientProvider,
                    useQuery: () => i.useQuery,
                    useQueryClient: () => i.useQueryClient
                });
                var r = n(3936);
                n.o(r, "QueryClientProvider") && n.d(t, {
                    QueryClientProvider: function() {
                        return r.QueryClientProvider
                    }
                }), n.o(r, "useQuery") && n.d(t, {
                    useQuery: function() {
                        return r.useQuery
                    }
                }), n.o(r, "useQueryClient") && n.d(t, {
                    useQueryClient: function() {
                        return r.useQueryClient
                    }
                });
                var i = n(5348)
            },
            5348: (e, t, n) => {
                "use strict";
                n.d(t, {
                    QueryClientProvider: () => h,
                    useQuery: () => C,
                    useQueryClient: () => d
                });
                var r = n(6016),
                    i = n(8828).unstable_batchedUpdates;
                r.y.setBatchNotifyFunction(i);
                var o = n(240),
                    a = console;
                (0, o.k)(a);
                var s = n(9584),
                    l = s.createContext(void 0),
                    c = s.createContext(!1);

                function u(e) {
                    return e && "undefined" !== typeof window ? (window.ReactQueryClientContext || (window.ReactQueryClientContext = l), window.ReactQueryClientContext) : l
                }
                var d = function() {
                        var e = s.useContext(u(s.useContext(c)));
                        if (!e) throw new Error("No QueryClient set, use QueryClientProvider to set one");
                        return e
                    },
                    h = function(e) {
                        var t = e.client,
                            n = e.contextSharing,
                            r = void 0 !== n && n,
                            i = e.children;
                        s.useEffect((function() {
                            return t.mount(),
                                function() {
                                    t.unmount()
                                }
                        }), [t]);
                        var o = u(r);
                        return s.createElement(c.Provider, {
                            value: r
                        }, s.createElement(o.Provider, {
                            value: t
                        }, i))
                    },
                    p = n(5072),
                    f = n(568),
                    m = n(1184),
                    g = n(2992),
                    v = n(1272),
                    y = n(8104),
                    b = function(e) {
                        function t(t, n) {
                            var r;
                            return (r = e.call(this) || this).client = t, r.options = n, r.trackedProps = [], r.selectError = null, r.bindMethods(), r.setOptions(n), r
                        }(0, f.c)(t, e);
                        var n = t.prototype;
                        return n.bindMethods = function() {
                            this.remove = this.remove.bind(this), this.refetch = this.refetch.bind(this)
                        }, n.onSubscribe = function() {
                            1 === this.listeners.length && (this.currentQuery.addObserver(this), x(this.currentQuery, this.options) && this.executeFetch(), this.updateTimers())
                        }, n.onUnsubscribe = function() {
                            this.listeners.length || this.destroy()
                        }, n.shouldFetchOnReconnect = function() {
                            return _(this.currentQuery, this.options, this.options.refetchOnReconnect)
                        }, n.shouldFetchOnWindowFocus = function() {
                            return _(this.currentQuery, this.options, this.options.refetchOnWindowFocus)
                        }, n.destroy = function() {
                            this.listeners = [], this.clearTimers(), this.currentQuery.removeObserver(this)
                        }, n.setOptions = function(e, t) {
                            var n = this.options,
                                r = this.currentQuery;
                            if (this.options = this.client.defaultQueryObserverOptions(e), "undefined" !== typeof this.options.enabled && "boolean" !== typeof this.options.enabled) throw new Error("Expected enabled to be a boolean");
                            this.options.queryKey || (this.options.queryKey = n.queryKey), this.updateQuery();
                            var i = this.hasListeners();
                            i && M(this.currentQuery, r, this.options, n) && this.executeFetch(), this.updateResult(t), !i || this.currentQuery === r && this.options.enabled === n.enabled && this.options.staleTime === n.staleTime || this.updateStaleTimeout();
                            var o = this.computeRefetchInterval();
                            !i || this.currentQuery === r && this.options.enabled === n.enabled && o === this.currentRefetchInterval || this.updateRefetchInterval(o)
                        }, n.getOptimisticResult = function(e) {
                            var t = this.client.defaultQueryObserverOptions(e),
                                n = this.client.getQueryCache().build(this.client, t);
                            return this.createResult(n, t)
                        }, n.getCurrentResult = function() {
                            return this.currentResult
                        }, n.trackResult = function(e, t) {
                            var n = this,
                                r = {},
                                i = function(e) {
                                    n.trackedProps.includes(e) || n.trackedProps.push(e)
                                };
                            return Object.keys(e).forEach((function(t) {
                                Object.defineProperty(r, t, {
                                    configurable: !1,
                                    enumerable: !0,
                                    get: function() {
                                        return i(t), e[t]
                                    }
                                })
                            })), (t.useErrorBoundary || t.suspense) && i("error"), r
                        }, n.getNextResult = function(e) {
                            var t = this;
                            return new Promise((function(n, r) {
                                var i = t.subscribe((function(t) {
                                    t.isFetching || (i(), t.isError && (null == e ? void 0 : e.throwOnError) ? r(t.error) : n(t))
                                }))
                            }))
                        }, n.getCurrentQuery = function() {
                            return this.currentQuery
                        }, n.remove = function() {
                            this.client.getQueryCache().remove(this.currentQuery)
                        }, n.refetch = function(e) {
                            return this.fetch((0, p.c)({}, e, {
                                meta: {
                                    refetchPage: null == e ? void 0 : e.refetchPage
                                }
                            }))
                        }, n.fetchOptimistic = function(e) {
                            var t = this,
                                n = this.client.defaultQueryObserverOptions(e),
                                r = this.client.getQueryCache().build(this.client, n);
                            return r.fetch().then((function() {
                                return t.createResult(r, n)
                            }))
                        }, n.fetch = function(e) {
                            var t = this;
                            return this.executeFetch(e).then((function() {
                                return t.updateResult(), t.currentResult
                            }))
                        }, n.executeFetch = function(e) {
                            this.updateQuery();
                            var t = this.currentQuery.fetch(this.options, e);
                            return (null == e ? void 0 : e.throwOnError) || (t = t.catch(m.Kw)), t
                        }, n.updateStaleTimeout = function() {
                            var e = this;
                            if (this.clearStaleTimeout(), !m.oj && !this.currentResult.isStale && (0, m.AT)(this.options.staleTime)) {
                                var t = (0, m.ob)(this.currentResult.dataUpdatedAt, this.options.staleTime) + 1;
                                this.staleTimeoutId = setTimeout((function() {
                                    e.currentResult.isStale || e.updateResult()
                                }), t)
                            }
                        }, n.computeRefetchInterval = function() {
                            var e;
                            return "function" === typeof this.options.refetchInterval ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : null != (e = this.options.refetchInterval) && e
                        }, n.updateRefetchInterval = function(e) {
                            var t = this;
                            this.clearRefetchInterval(), this.currentRefetchInterval = e, !m.oj && !1 !== this.options.enabled && (0, m.AT)(this.currentRefetchInterval) && 0 !== this.currentRefetchInterval && (this.refetchIntervalId = setInterval((function() {
                                (t.options.refetchIntervalInBackground || g.m.isFocused()) && t.executeFetch()
                            }), this.currentRefetchInterval))
                        }, n.updateTimers = function() {
                            this.updateStaleTimeout(), this.updateRefetchInterval(this.computeRefetchInterval())
                        }, n.clearTimers = function() {
                            this.clearStaleTimeout(), this.clearRefetchInterval()
                        }, n.clearStaleTimeout = function() {
                            this.staleTimeoutId && (clearTimeout(this.staleTimeoutId), this.staleTimeoutId = void 0)
                        }, n.clearRefetchInterval = function() {
                            this.refetchIntervalId && (clearInterval(this.refetchIntervalId), this.refetchIntervalId = void 0)
                        }, n.createResult = function(e, t) {
                            var n, r = this.currentQuery,
                                i = this.options,
                                a = this.currentResult,
                                s = this.currentResultState,
                                l = this.currentResultOptions,
                                c = e !== r,
                                u = c ? e.state : this.currentQueryInitialState,
                                d = c ? this.currentResult : this.previousQueryResult,
                                h = e.state,
                                p = h.dataUpdatedAt,
                                f = h.error,
                                g = h.errorUpdatedAt,
                                v = h.isFetching,
                                y = h.status,
                                b = !1,
                                _ = !1;
                            if (t.optimisticResults) {
                                var A = this.hasListeners(),
                                    S = !A && x(e, t),
                                    E = A && M(e, r, t, i);
                                (S || E) && (v = !0, p || (y = "loading"))
                            }
                            if (t.keepPreviousData && !h.dataUpdateCount && (null == d ? void 0 : d.isSuccess) && "error" !== y) n = d.data, p = d.dataUpdatedAt, y = d.status, b = !0;
                            else if (t.select && "undefined" !== typeof h.data)
                                if (a && h.data === (null == s ? void 0 : s.data) && t.select === this.selectFn) n = this.selectResult;
                                else try {
                                    this.selectFn = t.select, n = t.select(h.data), !1 !== t.structuralSharing && (n = (0, m.CO)(null == a ? void 0 : a.data, n)), this.selectResult = n, this.selectError = null
                                } catch (T) {
                                    (0, o.e)().error(T), this.selectError = T
                                } else n = h.data;
                            if ("undefined" !== typeof t.placeholderData && "undefined" === typeof n && ("loading" === y || "idle" === y)) {
                                var C;
                                if ((null == a ? void 0 : a.isPlaceholderData) && t.placeholderData === (null == l ? void 0 : l.placeholderData)) C = a.data;
                                else if (C = "function" === typeof t.placeholderData ? t.placeholderData() : t.placeholderData, t.select && "undefined" !== typeof C) try {
                                    C = t.select(C), !1 !== t.structuralSharing && (C = (0, m.CO)(null == a ? void 0 : a.data, C)), this.selectError = null
                                } catch (T) {
                                    (0, o.e)().error(T), this.selectError = T
                                }
                                "undefined" !== typeof C && (y = "success", n = C, _ = !0)
                            }
                            return this.selectError && (f = this.selectError, n = this.selectResult, g = Date.now(), y = "error"), {
                                status: y,
                                isLoading: "loading" === y,
                                isSuccess: "success" === y,
                                isError: "error" === y,
                                isIdle: "idle" === y,
                                data: n,
                                dataUpdatedAt: p,
                                error: f,
                                errorUpdatedAt: g,
                                failureCount: h.fetchFailureCount,
                                errorUpdateCount: h.errorUpdateCount,
                                isFetched: h.dataUpdateCount > 0 || h.errorUpdateCount > 0,
                                isFetchedAfterMount: h.dataUpdateCount > u.dataUpdateCount || h.errorUpdateCount > u.errorUpdateCount,
                                isFetching: v,
                                isRefetching: v && "loading" !== y,
                                isLoadingError: "error" === y && 0 === h.dataUpdatedAt,
                                isPlaceholderData: _,
                                isPreviousData: b,
                                isRefetchError: "error" === y && 0 !== h.dataUpdatedAt,
                                isStale: w(e, t),
                                refetch: this.refetch,
                                remove: this.remove
                            }
                        }, n.shouldNotifyListeners = function(e, t) {
                            if (!t) return !0;
                            var n = this.options,
                                r = n.notifyOnChangeProps,
                                i = n.notifyOnChangePropsExclusions;
                            if (!r && !i) return !0;
                            if ("tracked" === r && !this.trackedProps.length) return !0;
                            var o = "tracked" === r ? this.trackedProps : r;
                            return Object.keys(e).some((function(n) {
                                var r = n,
                                    a = e[r] !== t[r],
                                    s = null == o ? void 0 : o.some((function(e) {
                                        return e === n
                                    })),
                                    l = null == i ? void 0 : i.some((function(e) {
                                        return e === n
                                    }));
                                return a && !l && (!o || s)
                            }))
                        }, n.updateResult = function(e) {
                            var t = this.currentResult;
                            if (this.currentResult = this.createResult(this.currentQuery, this.options), this.currentResultState = this.currentQuery.state, this.currentResultOptions = this.options, !(0, m.wL)(this.currentResult, t)) {
                                var n = {
                                    cache: !0
                                };
                                !1 !== (null == e ? void 0 : e.listeners) && this.shouldNotifyListeners(this.currentResult, t) && (n.listeners = !0), this.notify((0, p.c)({}, n, e))
                            }
                        }, n.updateQuery = function() {
                            var e = this.client.getQueryCache().build(this.client, this.options);
                            if (e !== this.currentQuery) {
                                var t = this.currentQuery;
                                this.currentQuery = e, this.currentQueryInitialState = e.state, this.previousQueryResult = this.currentResult, this.hasListeners() && (null == t || t.removeObserver(this), e.addObserver(this))
                            }
                        }, n.onQueryUpdate = function(e) {
                            var t = {};
                            "success" === e.type ? t.onSuccess = !0 : "error" !== e.type || (0, y.qu)(e.error) || (t.onError = !0), this.updateResult(t), this.hasListeners() && this.updateTimers()
                        }, n.notify = function(e) {
                            var t = this;
                            r.y.batch((function() {
                                e.onSuccess ? (null == t.options.onSuccess || t.options.onSuccess(t.currentResult.data), null == t.options.onSettled || t.options.onSettled(t.currentResult.data, null)) : e.onError && (null == t.options.onError || t.options.onError(t.currentResult.error), null == t.options.onSettled || t.options.onSettled(void 0, t.currentResult.error)), e.listeners && t.listeners.forEach((function(e) {
                                    e(t.currentResult)
                                })), e.cache && t.client.getQueryCache().notify({
                                    query: t.currentQuery,
                                    type: "observerResultsUpdated"
                                })
                            }))
                        }, t
                    }(v.Q);

                function x(e, t) {
                    return function(e, t) {
                        return !1 !== t.enabled && !e.state.dataUpdatedAt && !("error" === e.state.status && !1 === t.retryOnMount)
                    }(e, t) || e.state.dataUpdatedAt > 0 && _(e, t, t.refetchOnMount)
                }

                function _(e, t, n) {
                    if (!1 !== t.enabled) {
                        var r = "function" === typeof n ? n(e) : n;
                        return "always" === r || !1 !== r && w(e, t)
                    }
                    return !1
                }

                function M(e, t, n, r) {
                    return !1 !== n.enabled && (e !== t || !1 === r.enabled) && (!n.suspense || "error" !== e.state.status) && w(e, n)
                }

                function w(e, t) {
                    return e.isStaleByTime(t.staleTime)
                }

                function A() {
                    var e = !1;
                    return {
                        clearReset: function() {
                            e = !1
                        },
                        reset: function() {
                            e = !0
                        },
                        isReset: function() {
                            return e
                        }
                    }
                }
                var S = s.createContext(A()),
                    E = function() {
                        return s.useContext(S)
                    };

                function C(e, t, n) {
                    return function(e, t) {
                        var n = s.useRef(!1),
                            i = s.useState(0)[1],
                            o = d(),
                            a = E(),
                            l = o.defaultQueryObserverOptions(e);
                        l.optimisticResults = !0, l.onError && (l.onError = r.y.batchCalls(l.onError)), l.onSuccess && (l.onSuccess = r.y.batchCalls(l.onSuccess)), l.onSettled && (l.onSettled = r.y.batchCalls(l.onSettled)), l.suspense && ("number" !== typeof l.staleTime && (l.staleTime = 1e3), 0 === l.cacheTime && (l.cacheTime = 1)), (l.suspense || l.useErrorBoundary) && (a.isReset() || (l.retryOnMount = !1));
                        var c, u, h, p = s.useState((function() {
                                return new t(o, l)
                            }))[0],
                            f = p.getOptimisticResult(l);
                        if (s.useEffect((function() {
                                n.current = !0, a.clearReset();
                                var e = p.subscribe(r.y.batchCalls((function() {
                                    n.current && i((function(e) {
                                        return e + 1
                                    }))
                                })));
                                return p.updateResult(),
                                    function() {
                                        n.current = !1, e()
                                    }
                            }), [a, p]), s.useEffect((function() {
                                p.setOptions(l, {
                                    listeners: !1
                                })
                            }), [l, p]), l.suspense && f.isLoading) throw p.fetchOptimistic(l).then((function(e) {
                            var t = e.data;
                            null == l.onSuccess || l.onSuccess(t), null == l.onSettled || l.onSettled(t, null)
                        })).catch((function(e) {
                            a.clearReset(), null == l.onError || l.onError(e), null == l.onSettled || l.onSettled(void 0, e)
                        }));
                        if (f.isError && !a.isReset() && !f.isFetching && (c = l.suspense, u = l.useErrorBoundary, h = [f.error, p.getCurrentQuery()], "function" === typeof u ? u.apply(void 0, h) : "boolean" === typeof u ? u : c)) throw f.error;
                        return "tracked" === l.notifyOnChangeProps && (f = p.trackResult(f, l)), f
                    }((0, m.O2)(e, t, n), b)
                }
            },
            2280: (e, t) => {
                "use strict";
                t.ConcurrentRoot = 1, t.ContinuousEventPriority = 4, t.DefaultEventPriority = 16, t.DiscreteEventPriority = 1
            },
            3744: (e, t, n) => {
                e.exports = function(e) {
                    var t = {},
                        r = n(9584),
                        i = n(752),
                        o = Object.assign;

                    function a(e) {
                        for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++) t += "&args[]=" + encodeURIComponent(arguments[n]);
                        return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
                    }
                    var s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
                        l = Symbol.for("react.element"),
                        c = Symbol.for("react.portal"),
                        u = Symbol.for("react.fragment"),
                        d = Symbol.for("react.strict_mode"),
                        h = Symbol.for("react.profiler"),
                        p = Symbol.for("react.provider"),
                        f = Symbol.for("react.context"),
                        m = Symbol.for("react.forward_ref"),
                        g = Symbol.for("react.suspense"),
                        v = Symbol.for("react.suspense_list"),
                        y = Symbol.for("react.memo"),
                        b = Symbol.for("react.lazy");
                    Symbol.for("react.scope"), Symbol.for("react.debug_trace_mode");
                    var x = Symbol.for("react.offscreen");
                    Symbol.for("react.legacy_hidden"), Symbol.for("react.cache"), Symbol.for("react.tracing_marker");
                    var _ = Symbol.iterator;

                    function M(e) {
                        return null === e || "object" !== typeof e ? null : "function" === typeof(e = _ && e[_] || e["@@iterator"]) ? e : null
                    }

                    function w(e) {
                        if (null == e) return null;
                        if ("function" === typeof e) return e.displayName || e.name || null;
                        if ("string" === typeof e) return e;
                        switch (e) {
                            case u:
                                return "Fragment";
                            case c:
                                return "Portal";
                            case h:
                                return "Profiler";
                            case d:
                                return "StrictMode";
                            case g:
                                return "Suspense";
                            case v:
                                return "SuspenseList"
                        }
                        if ("object" === typeof e) switch (e.$$typeof) {
                            case f:
                                return (e.displayName || "Context") + ".Consumer";
                            case p:
                                return (e._context.displayName || "Context") + ".Provider";
                            case m:
                                var t = e.render;
                                return (e = e.displayName) || (e = "" !== (e = t.displayName || t.name || "") ? "ForwardRef(" + e + ")" : "ForwardRef"), e;
                            case y:
                                return null !== (t = e.displayName || null) ? t : w(e.type) || "Memo";
                            case b:
                                t = e._payload, e = e._init;
                                try {
                                    return w(e(t))
                                } catch (n) {}
                        }
                        return null
                    }

                    function A(e) {
                        var t = e.type;
                        switch (e.tag) {
                            case 24:
                                return "Cache";
                            case 9:
                                return (t.displayName || "Context") + ".Consumer";
                            case 10:
                                return (t._context.displayName || "Context") + ".Provider";
                            case 18:
                                return "DehydratedFragment";
                            case 11:
                                return e = (e = t.render).displayName || e.name || "", t.displayName || ("" !== e ? "ForwardRef(" + e + ")" : "ForwardRef");
                            case 7:
                                return "Fragment";
                            case 5:
                                return t;
                            case 4:
                                return "Portal";
                            case 3:
                                return "Root";
                            case 6:
                                return "Text";
                            case 16:
                                return w(t);
                            case 8:
                                return t === d ? "StrictMode" : "Mode";
                            case 22:
                                return "Offscreen";
                            case 12:
                                return "Profiler";
                            case 21:
                                return "Scope";
                            case 13:
                                return "Suspense";
                            case 19:
                                return "SuspenseList";
                            case 25:
                                return "TracingMarker";
                            case 1:
                            case 0:
                            case 17:
                            case 2:
                            case 14:
                            case 15:
                                if ("function" === typeof t) return t.displayName || t.name || null;
                                if ("string" === typeof t) return t
                        }
                        return null
                    }

                    function S(e) {
                        var t = e,
                            n = e;
                        if (e.alternate)
                            for (; t.return;) t = t.return;
                        else {
                            e = t;
                            do {
                                0 !== (4098 & (t = e).flags) && (n = t.return), e = t.return
                            } while (e)
                        }
                        return 3 === t.tag ? n : null
                    }

                    function E(e) {
                        if (S(e) !== e) throw Error(a(188))
                    }

                    function C(e) {
                        var t = e.alternate;
                        if (!t) {
                            if (null === (t = S(e))) throw Error(a(188));
                            return t !== e ? null : e
                        }
                        for (var n = e, r = t;;) {
                            var i = n.return;
                            if (null === i) break;
                            var o = i.alternate;
                            if (null === o) {
                                if (null !== (r = i.return)) {
                                    n = r;
                                    continue
                                }
                                break
                            }
                            if (i.child === o.child) {
                                for (o = i.child; o;) {
                                    if (o === n) return E(i), e;
                                    if (o === r) return E(i), t;
                                    o = o.sibling
                                }
                                throw Error(a(188))
                            }
                            if (n.return !== r.return) n = i, r = o;
                            else {
                                for (var s = !1, l = i.child; l;) {
                                    if (l === n) {
                                        s = !0, n = i, r = o;
                                        break
                                    }
                                    if (l === r) {
                                        s = !0, r = i, n = o;
                                        break
                                    }
                                    l = l.sibling
                                }
                                if (!s) {
                                    for (l = o.child; l;) {
                                        if (l === n) {
                                            s = !0, n = o, r = i;
                                            break
                                        }
                                        if (l === r) {
                                            s = !0, r = o, n = i;
                                            break
                                        }
                                        l = l.sibling
                                    }
                                    if (!s) throw Error(a(189))
                                }
                            }
                            if (n.alternate !== r) throw Error(a(190))
                        }
                        if (3 !== n.tag) throw Error(a(188));
                        return n.stateNode.current === n ? e : t
                    }

                    function T(e) {
                        return null !== (e = C(e)) ? P(e) : null
                    }

                    function P(e) {
                        if (5 === e.tag || 6 === e.tag) return e;
                        for (e = e.child; null !== e;) {
                            var t = P(e);
                            if (null !== t) return t;
                            e = e.sibling
                        }
                        return null
                    }

                    function R(e) {
                        if (5 === e.tag || 6 === e.tag) return e;
                        for (e = e.child; null !== e;) {
                            if (4 !== e.tag) {
                                var t = R(e);
                                if (null !== t) return t
                            }
                            e = e.sibling
                        }
                        return null
                    }
                    var I, O = Array.isArray,
                        B = e.getPublicInstance,
                        L = e.getRootHostContext,
                        D = e.getChildHostContext,
                        N = e.prepareForCommit,
                        k = e.resetAfterCommit,
                        F = e.createInstance,
                        U = e.appendInitialChild,
                        z = e.finalizeInitialChildren,
                        H = e.prepareUpdate,
                        j = e.shouldSetTextContent,
                        G = e.createTextInstance,
                        V = e.scheduleTimeout,
                        q = e.cancelTimeout,
                        W = e.noTimeout,
                        X = e.isPrimaryRenderer,
                        K = e.supportsMutation,
                        J = e.supportsPersistence,
                        Y = e.supportsHydration,
                        Q = e.getInstanceFromNode,
                        Z = e.preparePortalMount,
                        $ = e.getCurrentEventPriority,
                        ee = e.detachDeletedInstance,
                        te = e.supportsMicrotasks,
                        ne = e.scheduleMicrotask,
                        re = e.supportsTestSelectors,
                        ie = e.findFiberRoot,
                        oe = e.getBoundingRect,
                        ae = e.getTextContent,
                        se = e.isHiddenSubtree,
                        le = e.matchAccessibilityRole,
                        ce = e.setFocusIfFocusable,
                        ue = e.setupIntersectionObserver,
                        de = e.appendChild,
                        he = e.appendChildToContainer,
                        pe = e.commitTextUpdate,
                        fe = e.commitMount,
                        me = e.commitUpdate,
                        ge = e.insertBefore,
                        ve = e.insertInContainerBefore,
                        ye = e.removeChild,
                        be = e.removeChildFromContainer,
                        xe = e.resetTextContent,
                        _e = e.hideInstance,
                        Me = e.hideTextInstance,
                        we = e.unhideInstance,
                        Ae = e.unhideTextInstance,
                        Se = e.clearContainer,
                        Ee = e.cloneInstance,
                        Ce = e.createContainerChildSet,
                        Te = e.appendChildToContainerChildSet,
                        Pe = e.finalizeContainerChildren,
                        Re = e.replaceContainerChildren,
                        Ie = e.cloneHiddenInstance,
                        Oe = e.cloneHiddenTextInstance,
                        Be = e.canHydrateInstance,
                        Le = e.canHydrateTextInstance,
                        De = e.canHydrateSuspenseInstance,
                        Ne = e.isSuspenseInstancePending,
                        ke = e.isSuspenseInstanceFallback,
                        Fe = e.registerSuspenseInstanceRetry,
                        Ue = e.getNextHydratableSibling,
                        ze = e.getFirstHydratableChild,
                        He = e.getFirstHydratableChildWithinContainer,
                        je = e.getFirstHydratableChildWithinSuspenseInstance,
                        Ge = e.hydrateInstance,
                        Ve = e.hydrateTextInstance,
                        qe = e.hydrateSuspenseInstance,
                        We = e.getNextHydratableInstanceAfterSuspenseInstance,
                        Xe = e.commitHydratedContainer,
                        Ke = e.commitHydratedSuspenseInstance,
                        Je = e.clearSuspenseBoundary,
                        Ye = e.clearSuspenseBoundaryFromContainer,
                        Qe = e.shouldDeleteUnhydratedTailInstances,
                        Ze = e.didNotMatchHydratedContainerTextInstance,
                        $e = e.didNotMatchHydratedTextInstance;

                    function et(e) {
                        if (void 0 === I) try {
                            throw Error()
                        } catch (n) {
                            var t = n.stack.trim().match(/\n( *(at )?)/);
                            I = t && t[1] || ""
                        }
                        return "\n" + I + e
                    }
                    var tt = !1;

                    function nt(e, t) {
                        if (!e || tt) return "";
                        tt = !0;
                        var n = Error.prepareStackTrace;
                        Error.prepareStackTrace = void 0;
                        try {
                            if (t)
                                if (t = function() {
                                        throw Error()
                                    }, Object.defineProperty(t.prototype, "props", {
                                        set: function() {
                                            throw Error()
                                        }
                                    }), "object" === typeof Reflect && Reflect.construct) {
                                    try {
                                        Reflect.construct(t, [])
                                    } catch (c) {
                                        var r = c
                                    }
                                    Reflect.construct(e, [], t)
                                } else {
                                    try {
                                        t.call()
                                    } catch (c) {
                                        r = c
                                    }
                                    e.call(t.prototype)
                                }
                            else {
                                try {
                                    throw Error()
                                } catch (c) {
                                    r = c
                                }
                                e()
                            }
                        } catch (c) {
                            if (c && r && "string" === typeof c.stack) {
                                for (var i = c.stack.split("\n"), o = r.stack.split("\n"), a = i.length - 1, s = o.length - 1; 1 <= a && 0 <= s && i[a] !== o[s];) s--;
                                for (; 1 <= a && 0 <= s; a--, s--)
                                    if (i[a] !== o[s]) {
                                        if (1 !== a || 1 !== s)
                                            do {
                                                if (a--, 0 > --s || i[a] !== o[s]) {
                                                    var l = "\n" + i[a].replace(" at new ", " at ");
                                                    return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l
                                                }
                                            } while (1 <= a && 0 <= s);
                                        break
                                    }
                            }
                        } finally {
                            tt = !1, Error.prepareStackTrace = n
                        }
                        return (e = e ? e.displayName || e.name : "") ? et(e) : ""
                    }
                    var rt = Object.prototype.hasOwnProperty,
                        it = [],
                        ot = -1;

                    function at(e) {
                        return {
                            current: e
                        }
                    }

                    function st(e) {
                        0 > ot || (e.current = it[ot], it[ot] = null, ot--)
                    }

                    function lt(e, t) {
                        ot++, it[ot] = e.current, e.current = t
                    }
                    var ct = {},
                        ut = at(ct),
                        dt = at(!1),
                        ht = ct;

                    function pt(e, t) {
                        var n = e.type.contextTypes;
                        if (!n) return ct;
                        var r = e.stateNode;
                        if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext;
                        var i, o = {};
                        for (i in n) o[i] = t[i];
                        return r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = o), o
                    }

                    function ft(e) {
                        return null !== (e = e.childContextTypes) && void 0 !== e
                    }

                    function mt() {
                        st(dt), st(ut)
                    }

                    function gt(e, t, n) {
                        if (ut.current !== ct) throw Error(a(168));
                        lt(ut, t), lt(dt, n)
                    }

                    function vt(e, t, n) {
                        var r = e.stateNode;
                        if (t = t.childContextTypes, "function" !== typeof r.getChildContext) return n;
                        for (var i in r = r.getChildContext())
                            if (!(i in t)) throw Error(a(108, A(e) || "Unknown", i));
                        return o({}, n, r)
                    }

                    function yt(e) {
                        return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || ct, ht = ut.current, lt(ut, e), lt(dt, dt.current), !0
                    }

                    function bt(e, t, n) {
                        var r = e.stateNode;
                        if (!r) throw Error(a(169));
                        n ? (e = vt(e, t, ht), r.__reactInternalMemoizedMergedChildContext = e, st(dt), st(ut), lt(ut, e)) : st(dt), lt(dt, n)
                    }
                    var xt = Math.clz32 ? Math.clz32 : function(e) {
                            return 0 === (e >>>= 0) ? 32 : 31 - (_t(e) / Mt | 0) | 0
                        },
                        _t = Math.log,
                        Mt = Math.LN2;
                    var wt = 64,
                        At = 4194304;

                    function St(e) {
                        switch (e & -e) {
                            case 1:
                                return 1;
                            case 2:
                                return 2;
                            case 4:
                                return 4;
                            case 8:
                                return 8;
                            case 16:
                                return 16;
                            case 32:
                                return 32;
                            case 64:
                            case 128:
                            case 256:
                            case 512:
                            case 1024:
                            case 2048:
                            case 4096:
                            case 8192:
                            case 16384:
                            case 32768:
                            case 65536:
                            case 131072:
                            case 262144:
                            case 524288:
                            case 1048576:
                            case 2097152:
                                return 4194240 & e;
                            case 4194304:
                            case 8388608:
                            case 16777216:
                            case 33554432:
                            case 67108864:
                                return 130023424 & e;
                            case 134217728:
                                return 134217728;
                            case 268435456:
                                return 268435456;
                            case 536870912:
                                return 536870912;
                            case 1073741824:
                                return 1073741824;
                            default:
                                return e
                        }
                    }

                    function Et(e, t) {
                        var n = e.pendingLanes;
                        if (0 === n) return 0;
                        var r = 0,
                            i = e.suspendedLanes,
                            o = e.pingedLanes,
                            a = 268435455 & n;
                        if (0 !== a) {
                            var s = a & ~i;
                            0 !== s ? r = St(s) : 0 !== (o &= a) && (r = St(o))
                        } else 0 !== (a = n & ~i) ? r = St(a) : 0 !== o && (r = St(o));
                        if (0 === r) return 0;
                        if (0 !== t && t !== r && 0 === (t & i) && ((i = r & -r) >= (o = t & -t) || 16 === i && 0 !== (4194240 & o))) return t;
                        if (0 !== (4 & r) && (r |= 16 & n), 0 !== (t = e.entangledLanes))
                            for (e = e.entanglements, t &= r; 0 < t;) i = 1 << (n = 31 - xt(t)), r |= e[n], t &= ~i;
                        return r
                    }

                    function Ct(e, t) {
                        switch (e) {
                            case 1:
                            case 2:
                            case 4:
                                return t + 250;
                            case 8:
                            case 16:
                            case 32:
                            case 64:
                            case 128:
                            case 256:
                            case 512:
                            case 1024:
                            case 2048:
                            case 4096:
                            case 8192:
                            case 16384:
                            case 32768:
                            case 65536:
                            case 131072:
                            case 262144:
                            case 524288:
                            case 1048576:
                            case 2097152:
                                return t + 5e3;
                            default:
                                return -1
                        }
                    }

                    function Tt(e) {
                        return 0 !== (e = -1073741825 & e.pendingLanes) ? e : 1073741824 & e ? 1073741824 : 0
                    }

                    function Pt(e) {
                        for (var t = [], n = 0; 31 > n; n++) t.push(e);
                        return t
                    }

                    function Rt(e, t, n) {
                        e.pendingLanes |= t, 536870912 !== t && (e.suspendedLanes = 0, e.pingedLanes = 0), (e = e.eventTimes)[t = 31 - xt(t)] = n
                    }

                    function It(e, t) {
                        var n = e.entangledLanes |= t;
                        for (e = e.entanglements; n;) {
                            var r = 31 - xt(n),
                                i = 1 << r;
                            i & t | e[r] & t && (e[r] |= t), n &= ~i
                        }
                    }
                    var Ot = 0;

                    function Bt(e) {
                        return 1 < (e &= -e) ? 4 < e ? 0 !== (268435455 & e) ? 16 : 536870912 : 4 : 1
                    }
                    var Lt = i.unstable_scheduleCallback,
                        Dt = i.unstable_cancelCallback,
                        Nt = i.unstable_shouldYield,
                        kt = i.unstable_requestPaint,
                        Ft = i.unstable_now,
                        Ut = i.unstable_ImmediatePriority,
                        zt = i.unstable_UserBlockingPriority,
                        Ht = i.unstable_NormalPriority,
                        jt = i.unstable_IdlePriority,
                        Gt = null,
                        Vt = null;
                    var qt = "function" === typeof Object.is ? Object.is : function(e, t) {
                            return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t
                        },
                        Wt = null,
                        Xt = !1,
                        Kt = !1;

                    function Jt(e) {
                        null === Wt ? Wt = [e] : Wt.push(e)
                    }

                    function Yt() {
                        if (!Kt && null !== Wt) {
                            Kt = !0;
                            var e = 0,
                                t = Ot;
                            try {
                                var n = Wt;
                                for (Ot = 1; e < n.length; e++) {
                                    var r = n[e];
                                    do {
                                        r = r(!0)
                                    } while (null !== r)
                                }
                                Wt = null, Xt = !1
                            } catch (i) {
                                throw null !== Wt && (Wt = Wt.slice(e + 1)), Lt(Ut, Yt), i
                            } finally {
                                Ot = t, Kt = !1
                            }
                        }
                        return null
                    }
                    var Qt = s.ReactCurrentBatchConfig;

                    function Zt(e, t) {
                        if (qt(e, t)) return !0;
                        if ("object" !== typeof e || null === e || "object" !== typeof t || null === t) return !1;
                        var n = Object.keys(e),
                            r = Object.keys(t);
                        if (n.length !== r.length) return !1;
                        for (r = 0; r < n.length; r++) {
                            var i = n[r];
                            if (!rt.call(t, i) || !qt(e[i], t[i])) return !1
                        }
                        return !0
                    }

                    function $t(e) {
                        switch (e.tag) {
                            case 5:
                                return et(e.type);
                            case 16:
                                return et("Lazy");
                            case 13:
                                return et("Suspense");
                            case 19:
                                return et("SuspenseList");
                            case 0:
                            case 2:
                            case 15:
                                return e = nt(e.type, !1);
                            case 11:
                                return e = nt(e.type.render, !1);
                            case 1:
                                return e = nt(e.type, !0);
                            default:
                                return ""
                        }
                    }

                    function en(e, t) {
                        if (e && e.defaultProps) {
                            for (var n in t = o({}, t), e = e.defaultProps) void 0 === t[n] && (t[n] = e[n]);
                            return t
                        }
                        return t
                    }
                    var tn = at(null),
                        nn = null,
                        rn = null,
                        on = null;

                    function an() {
                        on = rn = nn = null
                    }

                    function sn(e, t, n) {
                        X ? (lt(tn, t._currentValue), t._currentValue = n) : (lt(tn, t._currentValue2), t._currentValue2 = n)
                    }

                    function ln(e) {
                        var t = tn.current;
                        st(tn), X ? e._currentValue = t : e._currentValue2 = t
                    }

                    function cn(e, t, n) {
                        for (; null !== e;) {
                            var r = e.alternate;
                            if ((e.childLanes & t) !== t ? (e.childLanes |= t, null !== r && (r.childLanes |= t)) : null !== r && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break;
                            e = e.return
                        }
                    }

                    function un(e, t) {
                        nn = e, on = rn = null, null !== (e = e.dependencies) && null !== e.firstContext && (0 !== (e.lanes & t) && (Ni = !0), e.firstContext = null)
                    }

                    function dn(e) {
                        var t = X ? e._currentValue : e._currentValue2;
                        if (on !== e)
                            if (e = {
                                    context: e,
                                    memoizedValue: t,
                                    next: null
                                }, null === rn) {
                                if (null === nn) throw Error(a(308));
                                rn = e, nn.dependencies = {
                                    lanes: 0,
                                    firstContext: e
                                }
                            } else rn = rn.next = e;
                        return t
                    }
                    var hn = null,
                        pn = !1;

                    function fn(e) {
                        e.updateQueue = {
                            baseState: e.memoizedState,
                            firstBaseUpdate: null,
                            lastBaseUpdate: null,
                            shared: {
                                pending: null,
                                interleaved: null,
                                lanes: 0
                            },
                            effects: null
                        }
                    }

                    function mn(e, t) {
                        e = e.updateQueue, t.updateQueue === e && (t.updateQueue = {
                            baseState: e.baseState,
                            firstBaseUpdate: e.firstBaseUpdate,
                            lastBaseUpdate: e.lastBaseUpdate,
                            shared: e.shared,
                            effects: e.effects
                        })
                    }

                    function gn(e, t) {
                        return {
                            eventTime: e,
                            lane: t,
                            tag: 0,
                            payload: null,
                            callback: null,
                            next: null
                        }
                    }

                    function vn(e, t) {
                        var n = e.updateQueue;
                        null !== n && (n = n.shared, null !== Jo && 0 !== (1 & e.mode) && 0 === (2 & Ko) ? (null === (e = n.interleaved) ? (t.next = t, null === hn ? hn = [n] : hn.push(n)) : (t.next = e.next, e.next = t), n.interleaved = t) : (null === (e = n.pending) ? t.next = t : (t.next = e.next, e.next = t), n.pending = t))
                    }

                    function yn(e, t, n) {
                        if (null !== (t = t.updateQueue) && (t = t.shared, 0 !== (4194240 & n))) {
                            var r = t.lanes;
                            n |= r &= e.pendingLanes, t.lanes = n, It(e, n)
                        }
                    }

                    function bn(e, t) {
                        var n = e.updateQueue,
                            r = e.alternate;
                        if (null !== r && n === (r = r.updateQueue)) {
                            var i = null,
                                o = null;
                            if (null !== (n = n.firstBaseUpdate)) {
                                do {
                                    var a = {
                                        eventTime: n.eventTime,
                                        lane: n.lane,
                                        tag: n.tag,
                                        payload: n.payload,
                                        callback: n.callback,
                                        next: null
                                    };
                                    null === o ? i = o = a : o = o.next = a, n = n.next
                                } while (null !== n);
                                null === o ? i = o = t : o = o.next = t
                            } else i = o = t;
                            return n = {
                                baseState: r.baseState,
                                firstBaseUpdate: i,
                                lastBaseUpdate: o,
                                shared: r.shared,
                                effects: r.effects
                            }, void(e.updateQueue = n)
                        }
                        null === (e = n.lastBaseUpdate) ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t
                    }

                    function xn(e, t, n, r) {
                        var i = e.updateQueue;
                        pn = !1;
                        var a = i.firstBaseUpdate,
                            s = i.lastBaseUpdate,
                            l = i.shared.pending;
                        if (null !== l) {
                            i.shared.pending = null;
                            var c = l,
                                u = c.next;
                            c.next = null, null === s ? a = u : s.next = u, s = c;
                            var d = e.alternate;
                            null !== d && ((l = (d = d.updateQueue).lastBaseUpdate) !== s && (null === l ? d.firstBaseUpdate = u : l.next = u, d.lastBaseUpdate = c))
                        }
                        if (null !== a) {
                            var h = i.baseState;
                            for (s = 0, d = u = c = null, l = a;;) {
                                var p = l.lane,
                                    f = l.eventTime;
                                if ((r & p) === p) {
                                    null !== d && (d = d.next = {
                                        eventTime: f,
                                        lane: 0,
                                        tag: l.tag,
                                        payload: l.payload,
                                        callback: l.callback,
                                        next: null
                                    });
                                    e: {
                                        var m = e,
                                            g = l;
                                        switch (p = t, f = n, g.tag) {
                                            case 1:
                                                if ("function" === typeof(m = g.payload)) {
                                                    h = m.call(f, h, p);
                                                    break e
                                                }
                                                h = m;
                                                break e;
                                            case 3:
                                                m.flags = -65537 & m.flags | 128;
                                            case 0:
                                                if (null === (p = "function" === typeof(m = g.payload) ? m.call(f, h, p) : m) || void 0 === p) break e;
                                                h = o({}, h, p);
                                                break e;
                                            case 2:
                                                pn = !0
                                        }
                                    }
                                    null !== l.callback && 0 !== l.lane && (e.flags |= 64, null === (p = i.effects) ? i.effects = [l] : p.push(l))
                                } else f = {
                                    eventTime: f,
                                    lane: p,
                                    tag: l.tag,
                                    payload: l.payload,
                                    callback: l.callback,
                                    next: null
                                }, null === d ? (u = d = f, c = h) : d = d.next = f, s |= p;
                                if (null === (l = l.next)) {
                                    if (null === (l = i.shared.pending)) break;
                                    l = (p = l).next, p.next = null, i.lastBaseUpdate = p, i.shared.pending = null
                                }
                            }
                            if (null === d && (c = h), i.baseState = c, i.firstBaseUpdate = u, i.lastBaseUpdate = d, null !== (t = i.shared.interleaved)) {
                                i = t;
                                do {
                                    s |= i.lane, i = i.next
                                } while (i !== t)
                            } else null === a && (i.shared.lanes = 0);
                            na |= s, e.lanes = s, e.memoizedState = h
                        }
                    }

                    function _n(e, t, n) {
                        if (e = t.effects, t.effects = null, null !== e)
                            for (t = 0; t < e.length; t++) {
                                var r = e[t],
                                    i = r.callback;
                                if (null !== i) {
                                    if (r.callback = null, r = n, "function" !== typeof i) throw Error(a(191, i));
                                    i.call(r)
                                }
                            }
                    }
                    var Mn = (new r.Component).refs;

                    function wn(e, t, n, r) {
                        n = null === (n = n(r, t = e.memoizedState)) || void 0 === n ? t : o({}, t, n), e.memoizedState = n, 0 === e.lanes && (e.updateQueue.baseState = n)
                    }
                    var An = {
                        isMounted: function(e) {
                            return !!(e = e._reactInternals) && S(e) === e
                        },
                        enqueueSetState: function(e, t, n) {
                            e = e._reactInternals;
                            var r = _a(),
                                i = Ma(e),
                                o = gn(r, i);
                            o.payload = t, void 0 !== n && null !== n && (o.callback = n), vn(e, o), null !== (t = wa(e, i, r)) && yn(t, e, i)
                        },
                        enqueueReplaceState: function(e, t, n) {
                            e = e._reactInternals;
                            var r = _a(),
                                i = Ma(e),
                                o = gn(r, i);
                            o.tag = 1, o.payload = t, void 0 !== n && null !== n && (o.callback = n), vn(e, o), null !== (t = wa(e, i, r)) && yn(t, e, i)
                        },
                        enqueueForceUpdate: function(e, t) {
                            e = e._reactInternals;
                            var n = _a(),
                                r = Ma(e),
                                i = gn(n, r);
                            i.tag = 2, void 0 !== t && null !== t && (i.callback = t), vn(e, i), null !== (t = wa(e, r, n)) && yn(t, e, r)
                        }
                    };

                    function Sn(e, t, n, r, i, o, a) {
                        return "function" === typeof(e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(r, o, a) : !t.prototype || !t.prototype.isPureReactComponent || (!Zt(n, r) || !Zt(i, o))
                    }

                    function En(e, t, n) {
                        var r = !1,
                            i = ct,
                            o = t.contextType;
                        return "object" === typeof o && null !== o ? o = dn(o) : (i = ft(t) ? ht : ut.current, o = (r = null !== (r = t.contextTypes) && void 0 !== r) ? pt(e, i) : ct), t = new t(n, o), e.memoizedState = null !== t.state && void 0 !== t.state ? t.state : null, t.updater = An, e.stateNode = t, t._reactInternals = e, r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = o), t
                    }

                    function Cn(e, t, n, r) {
                        e = t.state, "function" === typeof t.componentWillReceiveProps && t.componentWillReceiveProps(n, r), "function" === typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && An.enqueueReplaceState(t, t.state, null)
                    }

                    function Tn(e, t, n, r) {
                        var i = e.stateNode;
                        i.props = n, i.state = e.memoizedState, i.refs = Mn, fn(e);
                        var o = t.contextType;
                        "object" === typeof o && null !== o ? i.context = dn(o) : (o = ft(t) ? ht : ut.current, i.context = pt(e, o)), i.state = e.memoizedState, "function" === typeof(o = t.getDerivedStateFromProps) && (wn(e, t, o, n), i.state = e.memoizedState), "function" === typeof t.getDerivedStateFromProps || "function" === typeof i.getSnapshotBeforeUpdate || "function" !== typeof i.UNSAFE_componentWillMount && "function" !== typeof i.componentWillMount || (t = i.state, "function" === typeof i.componentWillMount && i.componentWillMount(), "function" === typeof i.UNSAFE_componentWillMount && i.UNSAFE_componentWillMount(), t !== i.state && An.enqueueReplaceState(i, i.state, null), xn(e, n, i, r), i.state = e.memoizedState), "function" === typeof i.componentDidMount && (e.flags |= 4194308)
                    }
                    var Pn = [],
                        Rn = 0,
                        In = null,
                        On = 0,
                        Bn = [],
                        Ln = 0,
                        Dn = null,
                        Nn = 1,
                        kn = "";

                    function Fn(e, t) {
                        Pn[Rn++] = On, Pn[Rn++] = In, In = e, On = t
                    }

                    function Un(e, t, n) {
                        Bn[Ln++] = Nn, Bn[Ln++] = kn, Bn[Ln++] = Dn, Dn = e;
                        var r = Nn;
                        e = kn;
                        var i = 32 - xt(r) - 1;
                        r &= ~(1 << i), n += 1;
                        var o = 32 - xt(t) + i;
                        if (30 < o) {
                            var a = i - i % 5;
                            o = (r & (1 << a) - 1).toString(32), r >>= a, i -= a, Nn = 1 << 32 - xt(t) + i | n << i | r, kn = o + e
                        } else Nn = 1 << o | n << i | r, kn = e
                    }

                    function zn(e) {
                        null !== e.return && (Fn(e, 1), Un(e, 1, 0))
                    }

                    function Hn(e) {
                        for (; e === In;) In = Pn[--Rn], Pn[Rn] = null, On = Pn[--Rn], Pn[Rn] = null;
                        for (; e === Dn;) Dn = Bn[--Ln], Bn[Ln] = null, kn = Bn[--Ln], Bn[Ln] = null, Nn = Bn[--Ln], Bn[Ln] = null
                    }
                    var jn = null,
                        Gn = null,
                        Vn = !1,
                        qn = !1,
                        Wn = null;

                    function Xn(e, t) {
                        var n = Za(5, null, null, 0);
                        n.elementType = "DELETED", n.stateNode = t, n.return = e, null === (t = e.deletions) ? (e.deletions = [n], e.flags |= 16) : t.push(n)
                    }

                    function Kn(e, t) {
                        switch (e.tag) {
                            case 5:
                                return null !== (t = Be(t, e.type, e.pendingProps)) && (e.stateNode = t, jn = e, Gn = ze(t), !0);
                            case 6:
                                return null !== (t = Le(t, e.pendingProps)) && (e.stateNode = t, jn = e, Gn = null, !0);
                            case 13:
                                if (null !== (t = De(t))) {
                                    var n = null !== Dn ? {
                                        id: Nn,
                                        overflow: kn
                                    } : null;
                                    return e.memoizedState = {
                                        dehydrated: t,
                                        treeContext: n,
                                        retryLane: 1073741824
                                    }, (n = Za(18, null, null, 0)).stateNode = t, n.return = e, e.child = n, jn = e, Gn = null, !0
                                }
                                return !1;
                            default:
                                return !1
                        }
                    }

                    function Jn(e) {
                        return 0 !== (1 & e.mode) && 0 === (128 & e.flags)
                    }

                    function Yn(e) {
                        if (Vn) {
                            var t = Gn;
                            if (t) {
                                var n = t;
                                if (!Kn(e, t)) {
                                    if (Jn(e)) throw Error(a(418));
                                    t = Ue(n);
                                    var r = jn;
                                    t && Kn(e, t) ? Xn(r, n) : (e.flags = -4097 & e.flags | 2, Vn = !1, jn = e)
                                }
                            } else {
                                if (Jn(e)) throw Error(a(418));
                                e.flags = -4097 & e.flags | 2, Vn = !1, jn = e
                            }
                        }
                    }

                    function Qn(e) {
                        for (e = e.return; null !== e && 5 !== e.tag && 3 !== e.tag && 13 !== e.tag;) e = e.return;
                        jn = e
                    }

                    function Zn(e) {
                        if (!Y || e !== jn) return !1;
                        if (!Vn) return Qn(e), Vn = !0, !1;
                        if (3 !== e.tag && (5 !== e.tag || Qe(e.type) && !j(e.type, e.memoizedProps))) {
                            var t = Gn;
                            if (t) {
                                if (Jn(e)) {
                                    for (e = Gn; e;) e = Ue(e);
                                    throw Error(a(418))
                                }
                                for (; t;) Xn(e, t), t = Ue(t)
                            }
                        }
                        if (Qn(e), 13 === e.tag) {
                            if (!Y) throw Error(a(316));
                            if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null)) throw Error(a(317));
                            Gn = We(e)
                        } else Gn = jn ? Ue(e.stateNode) : null;
                        return !0
                    }

                    function $n() {
                        Y && (Gn = jn = null, qn = Vn = !1)
                    }

                    function er(e) {
                        null === Wn ? Wn = [e] : Wn.push(e)
                    }

                    function tr(e, t, n) {
                        if (null !== (e = n.ref) && "function" !== typeof e && "object" !== typeof e) {
                            if (n._owner) {
                                if (n = n._owner) {
                                    if (1 !== n.tag) throw Error(a(309));
                                    var r = n.stateNode
                                }
                                if (!r) throw Error(a(147, e));
                                var i = r,
                                    o = "" + e;
                                return null !== t && null !== t.ref && "function" === typeof t.ref && t.ref._stringRef === o ? t.ref : (t = function(e) {
                                    var t = i.refs;
                                    t === Mn && (t = i.refs = {}), null === e ? delete t[o] : t[o] = e
                                }, t._stringRef = o, t)
                            }
                            if ("string" !== typeof e) throw Error(a(284));
                            if (!n._owner) throw Error(a(290, e))
                        }
                        return e
                    }

                    function nr(e, t) {
                        throw e = Object.prototype.toString.call(t), Error(a(31, "[object Object]" === e ? "object with keys {" + Object.keys(t).join(", ") + "}" : e))
                    }

                    function rr(e) {
                        return (0, e._init)(e._payload)
                    }

                    function ir(e) {
                        function t(t, n) {
                            if (e) {
                                var r = t.deletions;
                                null === r ? (t.deletions = [n], t.flags |= 16) : r.push(n)
                            }
                        }

                        function n(n, r) {
                            if (!e) return null;
                            for (; null !== r;) t(n, r), r = r.sibling;
                            return null
                        }

                        function r(e, t) {
                            for (e = new Map; null !== t;) null !== t.key ? e.set(t.key, t) : e.set(t.index, t), t = t.sibling;
                            return e
                        }

                        function i(e, t) {
                            return (e = es(e, t)).index = 0, e.sibling = null, e
                        }

                        function o(t, n, r) {
                            return t.index = r, e ? null !== (r = t.alternate) ? (r = r.index) < n ? (t.flags |= 2, n) : r : (t.flags |= 2, n) : (t.flags |= 1048576, n)
                        }

                        function s(t) {
                            return e && null === t.alternate && (t.flags |= 2), t
                        }

                        function d(e, t, n, r) {
                            return null === t || 6 !== t.tag ? ((t = is(n, e.mode, r)).return = e, t) : ((t = i(t, n)).return = e, t)
                        }

                        function h(e, t, n, r) {
                            var o = n.type;
                            return o === u ? f(e, t, n.props.children, r, n.key) : null !== t && (t.elementType === o || "object" === typeof o && null !== o && o.$$typeof === b && rr(o) === t.type) ? ((r = i(t, n.props)).ref = tr(e, t, n), r.return = e, r) : ((r = ts(n.type, n.key, n.props, null, e.mode, r)).ref = tr(e, t, n), r.return = e, r)
                        }

                        function p(e, t, n, r) {
                            return null === t || 4 !== t.tag || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? ((t = os(n, e.mode, r)).return = e, t) : ((t = i(t, n.children || [])).return = e, t)
                        }

                        function f(e, t, n, r, o) {
                            return null === t || 7 !== t.tag ? ((t = ns(n, e.mode, r, o)).return = e, t) : ((t = i(t, n)).return = e, t)
                        }

                        function m(e, t, n) {
                            if ("string" === typeof t && "" !== t || "number" === typeof t) return (t = is("" + t, e.mode, n)).return = e, t;
                            if ("object" === typeof t && null !== t) {
                                switch (t.$$typeof) {
                                    case l:
                                        return (n = ts(t.type, t.key, t.props, null, e.mode, n)).ref = tr(e, null, t), n.return = e, n;
                                    case c:
                                        return (t = os(t, e.mode, n)).return = e, t;
                                    case b:
                                        return m(e, (0, t._init)(t._payload), n)
                                }
                                if (O(t) || M(t)) return (t = ns(t, e.mode, n, null)).return = e, t;
                                nr(e, t)
                            }
                            return null
                        }

                        function g(e, t, n, r) {
                            var i = null !== t ? t.key : null;
                            if ("string" === typeof n && "" !== n || "number" === typeof n) return null !== i ? null : d(e, t, "" + n, r);
                            if ("object" === typeof n && null !== n) {
                                switch (n.$$typeof) {
                                    case l:
                                        return n.key === i ? h(e, t, n, r) : null;
                                    case c:
                                        return n.key === i ? p(e, t, n, r) : null;
                                    case b:
                                        return g(e, t, (i = n._init)(n._payload), r)
                                }
                                if (O(n) || M(n)) return null !== i ? null : f(e, t, n, r, null);
                                nr(e, n)
                            }
                            return null
                        }

                        function v(e, t, n, r, i) {
                            if ("string" === typeof r && "" !== r || "number" === typeof r) return d(t, e = e.get(n) || null, "" + r, i);
                            if ("object" === typeof r && null !== r) {
                                switch (r.$$typeof) {
                                    case l:
                                        return h(t, e = e.get(null === r.key ? n : r.key) || null, r, i);
                                    case c:
                                        return p(t, e = e.get(null === r.key ? n : r.key) || null, r, i);
                                    case b:
                                        return v(e, t, n, (0, r._init)(r._payload), i)
                                }
                                if (O(r) || M(r)) return f(t, e = e.get(n) || null, r, i, null);
                                nr(t, r)
                            }
                            return null
                        }

                        function y(i, a, s, l) {
                            for (var c = null, u = null, d = a, h = a = 0, p = null; null !== d && h < s.length; h++) {
                                d.index > h ? (p = d, d = null) : p = d.sibling;
                                var f = g(i, d, s[h], l);
                                if (null === f) {
                                    null === d && (d = p);
                                    break
                                }
                                e && d && null === f.alternate && t(i, d), a = o(f, a, h), null === u ? c = f : u.sibling = f, u = f, d = p
                            }
                            if (h === s.length) return n(i, d), Vn && Fn(i, h), c;
                            if (null === d) {
                                for (; h < s.length; h++) null !== (d = m(i, s[h], l)) && (a = o(d, a, h), null === u ? c = d : u.sibling = d, u = d);
                                return Vn && Fn(i, h), c
                            }
                            for (d = r(i, d); h < s.length; h++) null !== (p = v(d, i, h, s[h], l)) && (e && null !== p.alternate && d.delete(null === p.key ? h : p.key), a = o(p, a, h), null === u ? c = p : u.sibling = p, u = p);
                            return e && d.forEach((function(e) {
                                return t(i, e)
                            })), Vn && Fn(i, h), c
                        }

                        function x(i, s, l, c) {
                            var u = M(l);
                            if ("function" !== typeof u) throw Error(a(150));
                            if (null == (l = u.call(l))) throw Error(a(151));
                            for (var d = u = null, h = s, p = s = 0, f = null, y = l.next(); null !== h && !y.done; p++, y = l.next()) {
                                h.index > p ? (f = h, h = null) : f = h.sibling;
                                var b = g(i, h, y.value, c);
                                if (null === b) {
                                    null === h && (h = f);
                                    break
                                }
                                e && h && null === b.alternate && t(i, h), s = o(b, s, p), null === d ? u = b : d.sibling = b, d = b, h = f
                            }
                            if (y.done) return n(i, h), Vn && Fn(i, p), u;
                            if (null === h) {
                                for (; !y.done; p++, y = l.next()) null !== (y = m(i, y.value, c)) && (s = o(y, s, p), null === d ? u = y : d.sibling = y, d = y);
                                return Vn && Fn(i, p), u
                            }
                            for (h = r(i, h); !y.done; p++, y = l.next()) null !== (y = v(h, i, p, y.value, c)) && (e && null !== y.alternate && h.delete(null === y.key ? p : y.key), s = o(y, s, p), null === d ? u = y : d.sibling = y, d = y);
                            return e && h.forEach((function(e) {
                                return t(i, e)
                            })), Vn && Fn(i, p), u
                        }
                        return function e(r, o, a, d) {
                            if ("object" === typeof a && null !== a && a.type === u && null === a.key && (a = a.props.children), "object" === typeof a && null !== a) {
                                switch (a.$$typeof) {
                                    case l:
                                        e: {
                                            for (var h = a.key, p = o; null !== p;) {
                                                if (p.key === h) {
                                                    if ((h = a.type) === u) {
                                                        if (7 === p.tag) {
                                                            n(r, p.sibling), (o = i(p, a.props.children)).return = r, r = o;
                                                            break e
                                                        }
                                                    } else if (p.elementType === h || "object" === typeof h && null !== h && h.$$typeof === b && rr(h) === p.type) {
                                                        n(r, p.sibling), (o = i(p, a.props)).ref = tr(r, p, a), o.return = r, r = o;
                                                        break e
                                                    }
                                                    n(r, p);
                                                    break
                                                }
                                                t(r, p), p = p.sibling
                                            }
                                            a.type === u ? ((o = ns(a.props.children, r.mode, d, a.key)).return = r, r = o) : ((d = ts(a.type, a.key, a.props, null, r.mode, d)).ref = tr(r, o, a), d.return = r, r = d)
                                        }
                                        return s(r);
                                    case c:
                                        e: {
                                            for (p = a.key; null !== o;) {
                                                if (o.key === p) {
                                                    if (4 === o.tag && o.stateNode.containerInfo === a.containerInfo && o.stateNode.implementation === a.implementation) {
                                                        n(r, o.sibling), (o = i(o, a.children || [])).return = r, r = o;
                                                        break e
                                                    }
                                                    n(r, o);
                                                    break
                                                }
                                                t(r, o), o = o.sibling
                                            }(o = os(a, r.mode, d)).return = r,
                                            r = o
                                        }
                                        return s(r);
                                    case b:
                                        return e(r, o, (p = a._init)(a._payload), d)
                                }
                                if (O(a)) return y(r, o, a, d);
                                if (M(a)) return x(r, o, a, d);
                                nr(r, a)
                            }
                            return "string" === typeof a && "" !== a || "number" === typeof a ? (a = "" + a, null !== o && 6 === o.tag ? (n(r, o.sibling), (o = i(o, a)).return = r, r = o) : (n(r, o), (o = is(a, r.mode, d)).return = r, r = o), s(r)) : n(r, o)
                        }
                    }
                    var or = ir(!0),
                        ar = ir(!1),
                        sr = {},
                        lr = at(sr),
                        cr = at(sr),
                        ur = at(sr);

                    function dr(e) {
                        if (e === sr) throw Error(a(174));
                        return e
                    }

                    function hr(e, t) {
                        lt(ur, t), lt(cr, e), lt(lr, sr), e = L(t), st(lr), lt(lr, e)
                    }

                    function pr() {
                        st(lr), st(cr), st(ur)
                    }

                    function fr(e) {
                        var t = dr(ur.current),
                            n = dr(lr.current);
                        n !== (t = D(n, e.type, t)) && (lt(cr, e), lt(lr, t))
                    }

                    function mr(e) {
                        cr.current === e && (st(lr), st(cr))
                    }
                    var gr = at(0);

                    function vr(e) {
                        for (var t = e; null !== t;) {
                            if (13 === t.tag) {
                                var n = t.memoizedState;
                                if (null !== n && (null === (n = n.dehydrated) || Ne(n) || ke(n))) return t
                            } else if (19 === t.tag && void 0 !== t.memoizedProps.revealOrder) {
                                if (0 !== (128 & t.flags)) return t
                            } else if (null !== t.child) {
                                t.child.return = t, t = t.child;
                                continue
                            }
                            if (t === e) break;
                            for (; null === t.sibling;) {
                                if (null === t.return || t.return === e) return null;
                                t = t.return
                            }
                            t.sibling.return = t.return, t = t.sibling
                        }
                        return null
                    }
                    var yr = [];

                    function br() {
                        for (var e = 0; e < yr.length; e++) {
                            var t = yr[e];
                            X ? t._workInProgressVersionPrimary = null : t._workInProgressVersionSecondary = null
                        }
                        yr.length = 0
                    }
                    var xr = s.ReactCurrentDispatcher,
                        _r = s.ReactCurrentBatchConfig,
                        Mr = 0,
                        wr = null,
                        Ar = null,
                        Sr = null,
                        Er = !1,
                        Cr = !1,
                        Tr = 0,
                        Pr = 0;

                    function Rr() {
                        throw Error(a(321))
                    }

                    function Ir(e, t) {
                        if (null === t) return !1;
                        for (var n = 0; n < t.length && n < e.length; n++)
                            if (!qt(e[n], t[n])) return !1;
                        return !0
                    }

                    function Or(e, t, n, r, i, o) {
                        if (Mr = o, wr = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, xr.current = null === e || null === e.memoizedState ? fi : mi, e = n(r, i), Cr) {
                            o = 0;
                            do {
                                if (Cr = !1, Tr = 0, 25 <= o) throw Error(a(301));
                                o += 1, Sr = Ar = null, t.updateQueue = null, xr.current = gi, e = n(r, i)
                            } while (Cr)
                        }
                        if (xr.current = pi, t = null !== Ar && null !== Ar.next, Mr = 0, Sr = Ar = wr = null, Er = !1, t) throw Error(a(300));
                        return e
                    }

                    function Br() {
                        var e = 0 !== Tr;
                        return Tr = 0, e
                    }

                    function Lr() {
                        var e = {
                            memoizedState: null,
                            baseState: null,
                            baseQueue: null,
                            queue: null,
                            next: null
                        };
                        return null === Sr ? wr.memoizedState = Sr = e : Sr = Sr.next = e, Sr
                    }

                    function Dr() {
                        if (null === Ar) {
                            var e = wr.alternate;
                            e = null !== e ? e.memoizedState : null
                        } else e = Ar.next;
                        var t = null === Sr ? wr.memoizedState : Sr.next;
                        if (null !== t) Sr = t, Ar = e;
                        else {
                            if (null === e) throw Error(a(310));
                            e = {
                                memoizedState: (Ar = e).memoizedState,
                                baseState: Ar.baseState,
                                baseQueue: Ar.baseQueue,
                                queue: Ar.queue,
                                next: null
                            }, null === Sr ? wr.memoizedState = Sr = e : Sr = Sr.next = e
                        }
                        return Sr
                    }

                    function Nr(e, t) {
                        return "function" === typeof t ? t(e) : t
                    }

                    function kr(e) {
                        var t = Dr(),
                            n = t.queue;
                        if (null === n) throw Error(a(311));
                        n.lastRenderedReducer = e;
                        var r = Ar,
                            i = r.baseQueue,
                            o = n.pending;
                        if (null !== o) {
                            if (null !== i) {
                                var s = i.next;
                                i.next = o.next, o.next = s
                            }
                            r.baseQueue = i = o, n.pending = null
                        }
                        if (null !== i) {
                            o = i.next, r = r.baseState;
                            var l = s = null,
                                c = null,
                                u = o;
                            do {
                                var d = u.lane;
                                if ((Mr & d) === d) null !== c && (c = c.next = {
                                    lane: 0,
                                    action: u.action,
                                    hasEagerState: u.hasEagerState,
                                    eagerState: u.eagerState,
                                    next: null
                                }), r = u.hasEagerState ? u.eagerState : e(r, u.action);
                                else {
                                    var h = {
                                        lane: d,
                                        action: u.action,
                                        hasEagerState: u.hasEagerState,
                                        eagerState: u.eagerState,
                                        next: null
                                    };
                                    null === c ? (l = c = h, s = r) : c = c.next = h, wr.lanes |= d, na |= d
                                }
                                u = u.next
                            } while (null !== u && u !== o);
                            null === c ? s = r : c.next = l, qt(r, t.memoizedState) || (Ni = !0), t.memoizedState = r, t.baseState = s, t.baseQueue = c, n.lastRenderedState = r
                        }
                        if (null !== (e = n.interleaved)) {
                            i = e;
                            do {
                                o = i.lane, wr.lanes |= o, na |= o, i = i.next
                            } while (i !== e)
                        } else null === i && (n.lanes = 0);
                        return [t.memoizedState, n.dispatch]
                    }

                    function Fr(e) {
                        var t = Dr(),
                            n = t.queue;
                        if (null === n) throw Error(a(311));
                        n.lastRenderedReducer = e;
                        var r = n.dispatch,
                            i = n.pending,
                            o = t.memoizedState;
                        if (null !== i) {
                            n.pending = null;
                            var s = i = i.next;
                            do {
                                o = e(o, s.action), s = s.next
                            } while (s !== i);
                            qt(o, t.memoizedState) || (Ni = !0), t.memoizedState = o, null === t.baseQueue && (t.baseState = o), n.lastRenderedState = o
                        }
                        return [o, r]
                    }

                    function Ur() {}

                    function zr(e, t) {
                        var n = wr,
                            r = Dr(),
                            i = t(),
                            o = !qt(r.memoizedState, i);
                        if (o && (r.memoizedState = i, Ni = !0), r = r.queue, Qr(Gr.bind(null, n, r, e), [e]), r.getSnapshot !== t || o || null !== Sr && 1 & Sr.memoizedState.tag) {
                            if (n.flags |= 2048, Wr(9, jr.bind(null, n, r, i, t), void 0, null), null === Jo) throw Error(a(349));
                            0 !== (30 & Mr) || Hr(n, t, i)
                        }
                        return i
                    }

                    function Hr(e, t, n) {
                        e.flags |= 16384, e = {
                            getSnapshot: t,
                            value: n
                        }, null === (t = wr.updateQueue) ? (t = {
                            lastEffect: null,
                            stores: null
                        }, wr.updateQueue = t, t.stores = [e]) : null === (n = t.stores) ? t.stores = [e] : n.push(e)
                    }

                    function jr(e, t, n, r) {
                        t.value = n, t.getSnapshot = r, Vr(t) && wa(e, 1, -1)
                    }

                    function Gr(e, t, n) {
                        return n((function() {
                            Vr(t) && wa(e, 1, -1)
                        }))
                    }

                    function Vr(e) {
                        var t = e.getSnapshot;
                        e = e.value;
                        try {
                            var n = t();
                            return !qt(e, n)
                        } catch (r) {
                            return !0
                        }
                    }

                    function qr(e) {
                        var t = Lr();
                        return "function" === typeof e && (e = e()), t.memoizedState = t.baseState = e, e = {
                            pending: null,
                            interleaved: null,
                            lanes: 0,
                            dispatch: null,
                            lastRenderedReducer: Nr,
                            lastRenderedState: e
                        }, t.queue = e, e = e.dispatch = li.bind(null, wr, e), [t.memoizedState, e]
                    }

                    function Wr(e, t, n, r) {
                        return e = {
                            tag: e,
                            create: t,
                            destroy: n,
                            deps: r,
                            next: null
                        }, null === (t = wr.updateQueue) ? (t = {
                            lastEffect: null,
                            stores: null
                        }, wr.updateQueue = t, t.lastEffect = e.next = e) : null === (n = t.lastEffect) ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e), e
                    }

                    function Xr() {
                        return Dr().memoizedState
                    }

                    function Kr(e, t, n, r) {
                        var i = Lr();
                        wr.flags |= e, i.memoizedState = Wr(1 | t, n, void 0, void 0 === r ? null : r)
                    }

                    function Jr(e, t, n, r) {
                        var i = Dr();
                        r = void 0 === r ? null : r;
                        var o = void 0;
                        if (null !== Ar) {
                            var a = Ar.memoizedState;
                            if (o = a.destroy, null !== r && Ir(r, a.deps)) return void(i.memoizedState = Wr(t, n, o, r))
                        }
                        wr.flags |= e, i.memoizedState = Wr(1 | t, n, o, r)
                    }

                    function Yr(e, t) {
                        return Kr(8390656, 8, e, t)
                    }

                    function Qr(e, t) {
                        return Jr(2048, 8, e, t)
                    }

                    function Zr(e, t) {
                        return Jr(4, 2, e, t)
                    }

                    function $r(e, t) {
                        return Jr(4, 4, e, t)
                    }

                    function ei(e, t) {
                        return "function" === typeof t ? (e = e(), t(e), function() {
                            t(null)
                        }) : null !== t && void 0 !== t ? (e = e(), t.current = e, function() {
                            t.current = null
                        }) : void 0
                    }

                    function ti(e, t, n) {
                        return n = null !== n && void 0 !== n ? n.concat([e]) : null, Jr(4, 4, ei.bind(null, t, e), n)
                    }

                    function ni() {}

                    function ri(e, t) {
                        var n = Dr();
                        t = void 0 === t ? null : t;
                        var r = n.memoizedState;
                        return null !== r && null !== t && Ir(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e)
                    }

                    function ii(e, t) {
                        var n = Dr();
                        t = void 0 === t ? null : t;
                        var r = n.memoizedState;
                        return null !== r && null !== t && Ir(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e)
                    }

                    function oi(e, t) {
                        var n = Ot;
                        Ot = 0 !== n && 4 > n ? n : 4, e(!0);
                        var r = _r.transition;
                        _r.transition = {};
                        try {
                            e(!1), t()
                        } finally {
                            Ot = n, _r.transition = r
                        }
                    }

                    function ai() {
                        return Dr().memoizedState
                    }

                    function si(e, t, n) {
                        var r = Ma(e);
                        n = {
                            lane: r,
                            action: n,
                            hasEagerState: !1,
                            eagerState: null,
                            next: null
                        }, ci(e) ? ui(t, n) : (di(e, t, n), null !== (e = wa(e, r, n = _a())) && hi(e, t, r))
                    }

                    function li(e, t, n) {
                        var r = Ma(e),
                            i = {
                                lane: r,
                                action: n,
                                hasEagerState: !1,
                                eagerState: null,
                                next: null
                            };
                        if (ci(e)) ui(t, i);
                        else {
                            di(e, t, i);
                            var o = e.alternate;
                            if (0 === e.lanes && (null === o || 0 === o.lanes) && null !== (o = t.lastRenderedReducer)) try {
                                var a = t.lastRenderedState,
                                    s = o(a, n);
                                if (i.hasEagerState = !0, i.eagerState = s, qt(s, a)) return
                            } catch (l) {}
                            null !== (e = wa(e, r, n = _a())) && hi(e, t, r)
                        }
                    }

                    function ci(e) {
                        var t = e.alternate;
                        return e === wr || null !== t && t === wr
                    }

                    function ui(e, t) {
                        Cr = Er = !0;
                        var n = e.pending;
                        null === n ? t.next = t : (t.next = n.next, n.next = t), e.pending = t
                    }

                    function di(e, t, n) {
                        null !== Jo && 0 !== (1 & e.mode) && 0 === (2 & Ko) ? (null === (e = t.interleaved) ? (n.next = n, null === hn ? hn = [t] : hn.push(t)) : (n.next = e.next, e.next = n), t.interleaved = n) : (null === (e = t.pending) ? n.next = n : (n.next = e.next, e.next = n), t.pending = n)
                    }

                    function hi(e, t, n) {
                        if (0 !== (4194240 & n)) {
                            var r = t.lanes;
                            n |= r &= e.pendingLanes, t.lanes = n, It(e, n)
                        }
                    }
                    var pi = {
                            readContext: dn,
                            useCallback: Rr,
                            useContext: Rr,
                            useEffect: Rr,
                            useImperativeHandle: Rr,
                            useInsertionEffect: Rr,
                            useLayoutEffect: Rr,
                            useMemo: Rr,
                            useReducer: Rr,
                            useRef: Rr,
                            useState: Rr,
                            useDebugValue: Rr,
                            useDeferredValue: Rr,
                            useTransition: Rr,
                            useMutableSource: Rr,
                            useSyncExternalStore: Rr,
                            useId: Rr,
                            unstable_isNewReconciler: !1
                        },
                        fi = {
                            readContext: dn,
                            useCallback: function(e, t) {
                                return Lr().memoizedState = [e, void 0 === t ? null : t], e
                            },
                            useContext: dn,
                            useEffect: Yr,
                            useImperativeHandle: function(e, t, n) {
                                return n = null !== n && void 0 !== n ? n.concat([e]) : null, Kr(4194308, 4, ei.bind(null, t, e), n)
                            },
                            useLayoutEffect: function(e, t) {
                                return Kr(4194308, 4, e, t)
                            },
                            useInsertionEffect: function(e, t) {
                                return Kr(4, 2, e, t)
                            },
                            useMemo: function(e, t) {
                                var n = Lr();
                                return t = void 0 === t ? null : t, e = e(), n.memoizedState = [e, t], e
                            },
                            useReducer: function(e, t, n) {
                                var r = Lr();
                                return t = void 0 !== n ? n(t) : t, r.memoizedState = r.baseState = t, e = {
                                    pending: null,
                                    interleaved: null,
                                    lanes: 0,
                                    dispatch: null,
                                    lastRenderedReducer: e,
                                    lastRenderedState: t
                                }, r.queue = e, e = e.dispatch = si.bind(null, wr, e), [r.memoizedState, e]
                            },
                            useRef: function(e) {
                                return e = {
                                    current: e
                                }, Lr().memoizedState = e
                            },
                            useState: qr,
                            useDebugValue: ni,
                            useDeferredValue: function(e) {
                                var t = qr(e),
                                    n = t[0],
                                    r = t[1];
                                return Yr((function() {
                                    var t = _r.transition;
                                    _r.transition = {};
                                    try {
                                        r(e)
                                    } finally {
                                        _r.transition = t
                                    }
                                }), [e]), n
                            },
                            useTransition: function() {
                                var e = qr(!1),
                                    t = e[0];
                                return e = oi.bind(null, e[1]), Lr().memoizedState = e, [t, e]
                            },
                            useMutableSource: function() {},
                            useSyncExternalStore: function(e, t, n) {
                                var r = wr,
                                    i = Lr();
                                if (Vn) {
                                    if (void 0 === n) throw Error(a(407));
                                    n = n()
                                } else {
                                    if (n = t(), null === Jo) throw Error(a(349));
                                    0 !== (30 & Mr) || Hr(r, t, n)
                                }
                                i.memoizedState = n;
                                var o = {
                                    value: n,
                                    getSnapshot: t
                                };
                                return i.queue = o, Yr(Gr.bind(null, r, o, e), [e]), r.flags |= 2048, Wr(9, jr.bind(null, r, o, n, t), void 0, null), n
                            },
                            useId: function() {
                                var e = Lr(),
                                    t = Jo.identifierPrefix;
                                if (Vn) {
                                    var n = kn;
                                    t = ":" + t + "R" + (n = (Nn & ~(1 << 32 - xt(Nn) - 1)).toString(32) + n), 0 < (n = Tr++) && (t += "H" + n.toString(32)), t += ":"
                                } else t = ":" + t + "r" + (n = Pr++).toString(32) + ":";
                                return e.memoizedState = t
                            },
                            unstable_isNewReconciler: !1
                        },
                        mi = {
                            readContext: dn,
                            useCallback: ri,
                            useContext: dn,
                            useEffect: Qr,
                            useImperativeHandle: ti,
                            useInsertionEffect: Zr,
                            useLayoutEffect: $r,
                            useMemo: ii,
                            useReducer: kr,
                            useRef: Xr,
                            useState: function() {
                                return kr(Nr)
                            },
                            useDebugValue: ni,
                            useDeferredValue: function(e) {
                                var t = kr(Nr),
                                    n = t[0],
                                    r = t[1];
                                return Qr((function() {
                                    var t = _r.transition;
                                    _r.transition = {};
                                    try {
                                        r(e)
                                    } finally {
                                        _r.transition = t
                                    }
                                }), [e]), n
                            },
                            useTransition: function() {
                                return [kr(Nr)[0], Dr().memoizedState]
                            },
                            useMutableSource: Ur,
                            useSyncExternalStore: zr,
                            useId: ai,
                            unstable_isNewReconciler: !1
                        },
                        gi = {
                            readContext: dn,
                            useCallback: ri,
                            useContext: dn,
                            useEffect: Qr,
                            useImperativeHandle: ti,
                            useInsertionEffect: Zr,
                            useLayoutEffect: $r,
                            useMemo: ii,
                            useReducer: Fr,
                            useRef: Xr,
                            useState: function() {
                                return Fr(Nr)
                            },
                            useDebugValue: ni,
                            useDeferredValue: function(e) {
                                var t = Fr(Nr),
                                    n = t[0],
                                    r = t[1];
                                return Qr((function() {
                                    var t = _r.transition;
                                    _r.transition = {};
                                    try {
                                        r(e)
                                    } finally {
                                        _r.transition = t
                                    }
                                }), [e]), n
                            },
                            useTransition: function() {
                                return [Fr(Nr)[0], Dr().memoizedState]
                            },
                            useMutableSource: Ur,
                            useSyncExternalStore: zr,
                            useId: ai,
                            unstable_isNewReconciler: !1
                        };

                    function vi(e, t) {
                        try {
                            var n = "",
                                r = t;
                            do {
                                n += $t(r), r = r.return
                            } while (r);
                            var i = n
                        } catch (o) {
                            i = "\nError generating stack: " + o.message + "\n" + o.stack
                        }
                        return {
                            value: e,
                            source: t,
                            stack: i
                        }
                    }

                    function yi(e, t) {
                        try {
                            console.error(t.value)
                        } catch (n) {
                            setTimeout((function() {
                                throw n
                            }))
                        }
                    }
                    var bi, xi, _i, Mi, wi = "function" === typeof WeakMap ? WeakMap : Map;

                    function Ai(e, t, n) {
                        (n = gn(-1, n)).tag = 3, n.payload = {
                            element: null
                        };
                        var r = t.value;
                        return n.callback = function() {
                            da || (da = !0, ha = r), yi(0, t)
                        }, n
                    }

                    function Si(e, t, n) {
                        (n = gn(-1, n)).tag = 3;
                        var r = e.type.getDerivedStateFromError;
                        if ("function" === typeof r) {
                            var i = t.value;
                            n.payload = function() {
                                return r(i)
                            }, n.callback = function() {
                                yi(0, t)
                            }
                        }
                        var o = e.stateNode;
                        return null !== o && "function" === typeof o.componentDidCatch && (n.callback = function() {
                            yi(0, t), "function" !== typeof r && (null === pa ? pa = new Set([this]) : pa.add(this));
                            var e = t.stack;
                            this.componentDidCatch(t.value, {
                                componentStack: null !== e ? e : ""
                            })
                        }), n
                    }

                    function Ei(e, t, n) {
                        var r = e.pingCache;
                        if (null === r) {
                            r = e.pingCache = new wi;
                            var i = new Set;
                            r.set(t, i)
                        } else void 0 === (i = r.get(t)) && (i = new Set, r.set(t, i));
                        i.has(n) || (i.add(n), e = Wa.bind(null, e, t, n), t.then(e, e))
                    }

                    function Ci(e) {
                        do {
                            var t;
                            if ((t = 13 === e.tag) && (t = null === (t = e.memoizedState) || null !== t.dehydrated), t) return e;
                            e = e.return
                        } while (null !== e);
                        return null
                    }

                    function Ti(e, t, n, r, i) {
                        return 0 === (1 & e.mode) ? (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, 1 === n.tag && (null === n.alternate ? n.tag = 17 : ((t = gn(-1, 1)).tag = 2, vn(n, t))), n.lanes |= 1), e) : (e.flags |= 65536, e.lanes = i, e)
                    }

                    function Pi(e) {
                        e.flags |= 4
                    }

                    function Ri(e, t) {
                        if (null !== e && e.child === t.child) return !0;
                        if (0 !== (16 & t.flags)) return !1;
                        for (e = t.child; null !== e;) {
                            if (0 !== (12854 & e.flags) || 0 !== (12854 & e.subtreeFlags)) return !1;
                            e = e.sibling
                        }
                        return !0
                    }
                    if (K) bi = function(e, t) {
                        for (var n = t.child; null !== n;) {
                            if (5 === n.tag || 6 === n.tag) U(e, n.stateNode);
                            else if (4 !== n.tag && null !== n.child) {
                                n.child.return = n, n = n.child;
                                continue
                            }
                            if (n === t) break;
                            for (; null === n.sibling;) {
                                if (null === n.return || n.return === t) return;
                                n = n.return
                            }
                            n.sibling.return = n.return, n = n.sibling
                        }
                    }, xi = function() {}, _i = function(e, t, n, r, i) {
                        if ((e = e.memoizedProps) !== r) {
                            var o = t.stateNode,
                                a = dr(lr.current);
                            n = H(o, n, e, r, i, a), (t.updateQueue = n) && Pi(t)
                        }
                    }, Mi = function(e, t, n, r) {
                        n !== r && Pi(t)
                    };
                    else if (J) {
                        bi = function(e, t, n, r) {
                            for (var i = t.child; null !== i;) {
                                if (5 === i.tag) {
                                    var o = i.stateNode;
                                    n && r && (o = Ie(o, i.type, i.memoizedProps, i)), U(e, o)
                                } else if (6 === i.tag) o = i.stateNode, n && r && (o = Oe(o, i.memoizedProps, i)), U(e, o);
                                else if (4 !== i.tag)
                                    if (22 === i.tag && null !== i.memoizedState) null !== (o = i.child) && (o.return = i), bi(e, i, !0, !0);
                                    else if (null !== i.child) {
                                    i.child.return = i, i = i.child;
                                    continue
                                }
                                if (i === t) break;
                                for (; null === i.sibling;) {
                                    if (null === i.return || i.return === t) return;
                                    i = i.return
                                }
                                i.sibling.return = i.return, i = i.sibling
                            }
                        };
                        var Ii = function(e, t, n, r) {
                            for (var i = t.child; null !== i;) {
                                if (5 === i.tag) {
                                    var o = i.stateNode;
                                    n && r && (o = Ie(o, i.type, i.memoizedProps, i)), Te(e, o)
                                } else if (6 === i.tag) o = i.stateNode, n && r && (o = Oe(o, i.memoizedProps, i)), Te(e, o);
                                else if (4 !== i.tag)
                                    if (22 === i.tag && null !== i.memoizedState) null !== (o = i.child) && (o.return = i), Ii(e, i, !0, !0);
                                    else if (null !== i.child) {
                                    i.child.return = i, i = i.child;
                                    continue
                                }
                                if (i === t) break;
                                for (; null === i.sibling;) {
                                    if (null === i.return || i.return === t) return;
                                    i = i.return
                                }
                                i.sibling.return = i.return, i = i.sibling
                            }
                        };
                        xi = function(e, t) {
                            var n = t.stateNode;
                            if (!Ri(e, t)) {
                                e = n.containerInfo;
                                var r = Ce(e);
                                Ii(r, t, !1, !1), n.pendingChildren = r, Pi(t), Pe(e, r)
                            }
                        }, _i = function(e, t, n, r, i) {
                            var o = e.stateNode,
                                a = e.memoizedProps;
                            if ((e = Ri(e, t)) && a === r) t.stateNode = o;
                            else {
                                var s = t.stateNode,
                                    l = dr(lr.current),
                                    c = null;
                                a !== r && (c = H(s, n, a, r, i, l)), e && null === c ? t.stateNode = o : (o = Ee(o, c, n, a, r, t, e, s), z(o, n, r, i, l) && Pi(t), t.stateNode = o, e ? Pi(t) : bi(o, t, !1, !1))
                            }
                        }, Mi = function(e, t, n, r) {
                            n !== r ? (e = dr(ur.current), n = dr(lr.current), t.stateNode = G(r, e, n, t), Pi(t)) : t.stateNode = e.stateNode
                        }
                    } else xi = function() {}, _i = function() {}, Mi = function() {};

                    function Oi(e, t) {
                        if (!Vn) switch (e.tailMode) {
                            case "hidden":
                                t = e.tail;
                                for (var n = null; null !== t;) null !== t.alternate && (n = t), t = t.sibling;
                                null === n ? e.tail = null : n.sibling = null;
                                break;
                            case "collapsed":
                                n = e.tail;
                                for (var r = null; null !== n;) null !== n.alternate && (r = n), n = n.sibling;
                                null === r ? t || null === e.tail ? e.tail = null : e.tail.sibling = null : r.sibling = null
                        }
                    }

                    function Bi(e) {
                        var t = null !== e.alternate && e.alternate.child === e.child,
                            n = 0,
                            r = 0;
                        if (t)
                            for (var i = e.child; null !== i;) n |= i.lanes | i.childLanes, r |= 14680064 & i.subtreeFlags, r |= 14680064 & i.flags, i.return = e, i = i.sibling;
                        else
                            for (i = e.child; null !== i;) n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling;
                        return e.subtreeFlags |= r, e.childLanes = n, t
                    }

                    function Li(e, t, n) {
                        var r = t.pendingProps;
                        switch (Hn(t), t.tag) {
                            case 2:
                            case 16:
                            case 15:
                            case 0:
                            case 11:
                            case 7:
                            case 8:
                            case 12:
                            case 9:
                            case 14:
                                return Bi(t), null;
                            case 1:
                            case 17:
                                return ft(t.type) && mt(), Bi(t), null;
                            case 3:
                                return r = t.stateNode, pr(), st(dt), st(ut), br(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), null !== e && null !== e.child || (Zn(t) ? Pi(t) : null === e || e.memoizedState.isDehydrated && 0 === (256 & t.flags) || (t.flags |= 1024, null !== Wn && (Ta(Wn), Wn = null))), xi(e, t), Bi(t), null;
                            case 5:
                                mr(t), n = dr(ur.current);
                                var i = t.type;
                                if (null !== e && null != t.stateNode) _i(e, t, i, r, n), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152);
                                else {
                                    if (!r) {
                                        if (null === t.stateNode) throw Error(a(166));
                                        return Bi(t), null
                                    }
                                    if (e = dr(lr.current), Zn(t)) {
                                        if (!Y) throw Error(a(175));
                                        e = Ge(t.stateNode, t.type, t.memoizedProps, n, e, t, !qn), t.updateQueue = e, null !== e && Pi(t)
                                    } else {
                                        var o = F(i, r, n, e, t);
                                        bi(o, t, !1, !1), t.stateNode = o, z(o, i, r, n, e) && Pi(t)
                                    }
                                    null !== t.ref && (t.flags |= 512, t.flags |= 2097152)
                                }
                                return Bi(t), null;
                            case 6:
                                if (e && null != t.stateNode) Mi(e, t, e.memoizedProps, r);
                                else {
                                    if ("string" !== typeof r && null === t.stateNode) throw Error(a(166));
                                    if (e = dr(ur.current), n = dr(lr.current), Zn(t)) {
                                        if (!Y) throw Error(a(176));
                                        if (e = t.stateNode, r = t.memoizedProps, (n = Ve(e, r, t, !qn)) && null !== (i = jn)) switch (o = 0 !== (1 & i.mode), i.tag) {
                                            case 3:
                                                Ze(i.stateNode.containerInfo, e, r, o);
                                                break;
                                            case 5:
                                                $e(i.type, i.memoizedProps, i.stateNode, e, r, o)
                                        }
                                        n && Pi(t)
                                    } else t.stateNode = G(r, e, n, t)
                                }
                                return Bi(t), null;
                            case 13:
                                if (st(gr), r = t.memoizedState, Vn && null !== Gn && 0 !== (1 & t.mode) && 0 === (128 & t.flags)) {
                                    for (e = Gn; e;) e = Ue(e);
                                    return $n(), t.flags |= 98560, t
                                }
                                if (null !== r && null !== r.dehydrated) {
                                    if (r = Zn(t), null === e) {
                                        if (!r) throw Error(a(318));
                                        if (!Y) throw Error(a(344));
                                        if (!(e = null !== (e = t.memoizedState) ? e.dehydrated : null)) throw Error(a(317));
                                        qe(e, t)
                                    } else $n(), 0 === (128 & t.flags) && (t.memoizedState = null), t.flags |= 4;
                                    return Bi(t), null
                                }
                                return null !== Wn && (Ta(Wn), Wn = null), 0 !== (128 & t.flags) ? (t.lanes = n, t) : (r = null !== r, n = !1, null === e ? Zn(t) : n = null !== e.memoizedState, r && !n && (t.child.flags |= 8192, 0 !== (1 & t.mode) && (null === e || 0 !== (1 & gr.current) ? 0 === ea && (ea = 3) : Na())), null !== t.updateQueue && (t.flags |= 4), Bi(t), null);
                            case 4:
                                return pr(), xi(e, t), null === e && Z(t.stateNode.containerInfo), Bi(t), null;
                            case 10:
                                return ln(t.type._context), Bi(t), null;
                            case 19:
                                if (st(gr), null === (i = t.memoizedState)) return Bi(t), null;
                                if (r = 0 !== (128 & t.flags), null === (o = i.rendering))
                                    if (r) Oi(i, !1);
                                    else {
                                        if (0 !== ea || null !== e && 0 !== (128 & e.flags))
                                            for (e = t.child; null !== e;) {
                                                if (null !== (o = vr(e))) {
                                                    for (t.flags |= 128, Oi(i, !1), null !== (e = o.updateQueue) && (t.updateQueue = e, t.flags |= 4), t.subtreeFlags = 0, e = n, r = t.child; null !== r;) i = e, (n = r).flags &= 14680066, null === (o = n.alternate) ? (n.childLanes = 0, n.lanes = i, n.child = null, n.subtreeFlags = 0, n.memoizedProps = null, n.memoizedState = null, n.updateQueue = null, n.dependencies = null, n.stateNode = null) : (n.childLanes = o.childLanes, n.lanes = o.lanes, n.child = o.child, n.subtreeFlags = 0, n.deletions = null, n.memoizedProps = o.memoizedProps, n.memoizedState = o.memoizedState, n.updateQueue = o.updateQueue, n.type = o.type, i = o.dependencies, n.dependencies = null === i ? null : {
                                                        lanes: i.lanes,
                                                        firstContext: i.firstContext
                                                    }), r = r.sibling;
                                                    return lt(gr, 1 & gr.current | 2), t.child
                                                }
                                                e = e.sibling
                                            }
                                        null !== i.tail && Ft() > la && (t.flags |= 128, r = !0, Oi(i, !1), t.lanes = 4194304)
                                    }
                                else {
                                    if (!r)
                                        if (null !== (e = vr(o))) {
                                            if (t.flags |= 128, r = !0, null !== (e = e.updateQueue) && (t.updateQueue = e, t.flags |= 4), Oi(i, !0), null === i.tail && "hidden" === i.tailMode && !o.alternate && !Vn) return Bi(t), null
                                        } else 2 * Ft() - i.renderingStartTime > la && 1073741824 !== n && (t.flags |= 128, r = !0, Oi(i, !1), t.lanes = 4194304);
                                    i.isBackwards ? (o.sibling = t.child, t.child = o) : (null !== (e = i.last) ? e.sibling = o : t.child = o, i.last = o)
                                }
                                return null !== i.tail ? (t = i.tail, i.rendering = t, i.tail = t.sibling, i.renderingStartTime = Ft(), t.sibling = null, e = gr.current, lt(gr, r ? 1 & e | 2 : 1 & e), t) : (Bi(t), null);
                            case 22:
                            case 23:
                                return Oa(), r = null !== t.memoizedState, null !== e && null !== e.memoizedState !== r && (t.flags |= 8192), r && 0 !== (1 & t.mode) ? 0 !== (1073741824 & Zo) && (Bi(t), K && 6 & t.subtreeFlags && (t.flags |= 8192)) : Bi(t), null;
                            case 24:
                            case 25:
                                return null
                        }
                        throw Error(a(156, t.tag))
                    }
                    var Di = s.ReactCurrentOwner,
                        Ni = !1;

                    function ki(e, t, n, r) {
                        t.child = null === e ? ar(t, null, n, r) : or(t, e.child, n, r)
                    }

                    function Fi(e, t, n, r, i) {
                        n = n.render;
                        var o = t.ref;
                        return un(t, i), r = Or(e, t, n, r, o, i), n = Br(), null === e || Ni ? (Vn && n && zn(t), t.flags |= 1, ki(e, t, r, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, io(e, t, i))
                    }

                    function Ui(e, t, n, r, i) {
                        if (null === e) {
                            var o = n.type;
                            return "function" !== typeof o || $a(o) || void 0 !== o.defaultProps || null !== n.compare || void 0 !== n.defaultProps ? ((e = ts(n.type, null, r, t, t.mode, i)).ref = t.ref, e.return = t, t.child = e) : (t.tag = 15, t.type = o, zi(e, t, o, r, i))
                        }
                        if (o = e.child, 0 === (e.lanes & i)) {
                            var a = o.memoizedProps;
                            if ((n = null !== (n = n.compare) ? n : Zt)(a, r) && e.ref === t.ref) return io(e, t, i)
                        }
                        return t.flags |= 1, (e = es(o, r)).ref = t.ref, e.return = t, t.child = e
                    }

                    function zi(e, t, n, r, i) {
                        if (null !== e && Zt(e.memoizedProps, r) && e.ref === t.ref) {
                            if (Ni = !1, 0 === (e.lanes & i)) return t.lanes = e.lanes, io(e, t, i);
                            0 !== (131072 & e.flags) && (Ni = !0)
                        }
                        return Gi(e, t, n, r, i)
                    }

                    function Hi(e, t, n) {
                        var r = t.pendingProps,
                            i = r.children,
                            o = null !== e ? e.memoizedState : null;
                        if ("hidden" === r.mode)
                            if (0 === (1 & t.mode)) t.memoizedState = {
                                baseLanes: 0,
                                cachePool: null
                            }, lt($o, Zo), Zo |= n;
                            else {
                                if (0 === (1073741824 & n)) return e = null !== o ? o.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = {
                                    baseLanes: e,
                                    cachePool: null
                                }, t.updateQueue = null, lt($o, Zo), Zo |= e, null;
                                t.memoizedState = {
                                    baseLanes: 0,
                                    cachePool: null
                                }, r = null !== o ? o.baseLanes : n, lt($o, Zo), Zo |= r
                            }
                        else null !== o ? (r = o.baseLanes | n, t.memoizedState = null) : r = n, lt($o, Zo), Zo |= r;
                        return ki(e, t, i, n), t.child
                    }

                    function ji(e, t) {
                        var n = t.ref;
                        (null === e && null !== n || null !== e && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152)
                    }

                    function Gi(e, t, n, r, i) {
                        var o = ft(n) ? ht : ut.current;
                        return o = pt(t, o), un(t, i), n = Or(e, t, n, r, o, i), r = Br(), null === e || Ni ? (Vn && r && zn(t), t.flags |= 1, ki(e, t, n, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, io(e, t, i))
                    }

                    function Vi(e, t, n, r, i) {
                        if (ft(n)) {
                            var o = !0;
                            yt(t)
                        } else o = !1;
                        if (un(t, i), null === t.stateNode) null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2), En(t, n, r), Tn(t, n, r, i), r = !0;
                        else if (null === e) {
                            var a = t.stateNode,
                                s = t.memoizedProps;
                            a.props = s;
                            var l = a.context,
                                c = n.contextType;
                            "object" === typeof c && null !== c ? c = dn(c) : c = pt(t, c = ft(n) ? ht : ut.current);
                            var u = n.getDerivedStateFromProps,
                                d = "function" === typeof u || "function" === typeof a.getSnapshotBeforeUpdate;
                            d || "function" !== typeof a.UNSAFE_componentWillReceiveProps && "function" !== typeof a.componentWillReceiveProps || (s !== r || l !== c) && Cn(t, a, r, c), pn = !1;
                            var h = t.memoizedState;
                            a.state = h, xn(t, r, a, i), l = t.memoizedState, s !== r || h !== l || dt.current || pn ? ("function" === typeof u && (wn(t, n, u, r), l = t.memoizedState), (s = pn || Sn(t, n, s, r, h, l, c)) ? (d || "function" !== typeof a.UNSAFE_componentWillMount && "function" !== typeof a.componentWillMount || ("function" === typeof a.componentWillMount && a.componentWillMount(), "function" === typeof a.UNSAFE_componentWillMount && a.UNSAFE_componentWillMount()), "function" === typeof a.componentDidMount && (t.flags |= 4194308)) : ("function" === typeof a.componentDidMount && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = l), a.props = r, a.state = l, a.context = c, r = s) : ("function" === typeof a.componentDidMount && (t.flags |= 4194308), r = !1)
                        } else {
                            a = t.stateNode, mn(e, t), s = t.memoizedProps, c = t.type === t.elementType ? s : en(t.type, s), a.props = c, d = t.pendingProps, h = a.context, "object" === typeof(l = n.contextType) && null !== l ? l = dn(l) : l = pt(t, l = ft(n) ? ht : ut.current);
                            var p = n.getDerivedStateFromProps;
                            (u = "function" === typeof p || "function" === typeof a.getSnapshotBeforeUpdate) || "function" !== typeof a.UNSAFE_componentWillReceiveProps && "function" !== typeof a.componentWillReceiveProps || (s !== d || h !== l) && Cn(t, a, r, l), pn = !1, h = t.memoizedState, a.state = h, xn(t, r, a, i);
                            var f = t.memoizedState;
                            s !== d || h !== f || dt.current || pn ? ("function" === typeof p && (wn(t, n, p, r), f = t.memoizedState), (c = pn || Sn(t, n, c, r, h, f, l) || !1) ? (u || "function" !== typeof a.UNSAFE_componentWillUpdate && "function" !== typeof a.componentWillUpdate || ("function" === typeof a.componentWillUpdate && a.componentWillUpdate(r, f, l), "function" === typeof a.UNSAFE_componentWillUpdate && a.UNSAFE_componentWillUpdate(r, f, l)), "function" === typeof a.componentDidUpdate && (t.flags |= 4), "function" === typeof a.getSnapshotBeforeUpdate && (t.flags |= 1024)) : ("function" !== typeof a.componentDidUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), "function" !== typeof a.getSnapshotBeforeUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = f), a.props = r, a.state = f, a.context = l, r = c) : ("function" !== typeof a.componentDidUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), "function" !== typeof a.getSnapshotBeforeUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), r = !1)
                        }
                        return qi(e, t, n, r, o, i)
                    }

                    function qi(e, t, n, r, i, o) {
                        ji(e, t);
                        var a = 0 !== (128 & t.flags);
                        if (!r && !a) return i && bt(t, n, !1), io(e, t, o);
                        r = t.stateNode, Di.current = t;
                        var s = a && "function" !== typeof n.getDerivedStateFromError ? null : r.render();
                        return t.flags |= 1, null !== e && a ? (t.child = or(t, e.child, null, o), t.child = or(t, null, s, o)) : ki(e, t, s, o), t.memoizedState = r.state, i && bt(t, n, !0), t.child
                    }

                    function Wi(e) {
                        var t = e.stateNode;
                        t.pendingContext ? gt(0, t.pendingContext, t.pendingContext !== t.context) : t.context && gt(0, t.context, !1), hr(e, t.containerInfo)
                    }

                    function Xi(e, t, n, r, i) {
                        return $n(), er(i), t.flags |= 256, ki(e, t, n, r), t.child
                    }
                    var Ki = {
                        dehydrated: null,
                        treeContext: null,
                        retryLane: 0
                    };

                    function Ji(e) {
                        return {
                            baseLanes: e,
                            cachePool: null
                        }
                    }

                    function Yi(e, t, n) {
                        var r, i = t.pendingProps,
                            o = gr.current,
                            s = !1,
                            l = 0 !== (128 & t.flags);
                        if ((r = l) || (r = (null === e || null !== e.memoizedState) && 0 !== (2 & o)), r ? (s = !0, t.flags &= -129) : null !== e && null === e.memoizedState || (o |= 1), lt(gr, 1 & o), null === e) return Yn(t), null !== (e = t.memoizedState) && null !== (e = e.dehydrated) ? (0 === (1 & t.mode) ? t.lanes = 1 : ke(e) ? t.lanes = 8 : t.lanes = 1073741824, null) : (o = i.children, e = i.fallback, s ? (i = t.mode, s = t.child, o = {
                            mode: "hidden",
                            children: o
                        }, 0 === (1 & i) && null !== s ? (s.childLanes = 0, s.pendingProps = o) : s = rs(o, i, 0, null), e = ns(e, i, n, null), s.return = t, e.return = t, s.sibling = e, t.child = s, t.child.memoizedState = Ji(n), t.memoizedState = Ki, e) : Qi(t, o));
                        if (null !== (o = e.memoizedState)) {
                            if (null !== (r = o.dehydrated)) {
                                if (l) return 256 & t.flags ? (t.flags &= -257, eo(e, t, n, Error(a(422)))) : null !== t.memoizedState ? (t.child = e.child, t.flags |= 128, null) : (s = i.fallback, o = t.mode, i = rs({
                                    mode: "visible",
                                    children: i.children
                                }, o, 0, null), (s = ns(s, o, n, null)).flags |= 2, i.return = t, s.return = t, i.sibling = s, t.child = i, 0 !== (1 & t.mode) && or(t, e.child, null, n), t.child.memoizedState = Ji(n), t.memoizedState = Ki, s);
                                if (0 === (1 & t.mode)) t = eo(e, t, n, null);
                                else if (ke(r)) t = eo(e, t, n, Error(a(419)));
                                else if (i = 0 !== (n & e.childLanes), Ni || i) {
                                    if (null !== (i = Jo)) {
                                        switch (n & -n) {
                                            case 4:
                                                s = 2;
                                                break;
                                            case 16:
                                                s = 8;
                                                break;
                                            case 64:
                                            case 128:
                                            case 256:
                                            case 512:
                                            case 1024:
                                            case 2048:
                                            case 4096:
                                            case 8192:
                                            case 16384:
                                            case 32768:
                                            case 65536:
                                            case 131072:
                                            case 262144:
                                            case 524288:
                                            case 1048576:
                                            case 2097152:
                                            case 4194304:
                                            case 8388608:
                                            case 16777216:
                                            case 33554432:
                                            case 67108864:
                                                s = 32;
                                                break;
                                            case 536870912:
                                                s = 268435456;
                                                break;
                                            default:
                                                s = 0
                                        }
                                        0 !== (i = 0 !== (s & (i.suspendedLanes | n)) ? 0 : s) && i !== o.retryLane && (o.retryLane = i, wa(e, i, -1))
                                    }
                                    Na(), t = eo(e, t, n, Error(a(421)))
                                } else Ne(r) ? (t.flags |= 128, t.child = e.child, t = Ka.bind(null, e), Fe(r, t), t = null) : (n = o.treeContext, Y && (Gn = je(r), jn = t, Vn = !0, Wn = null, qn = !1, null !== n && (Bn[Ln++] = Nn, Bn[Ln++] = kn, Bn[Ln++] = Dn, Nn = n.id, kn = n.overflow, Dn = t)), (t = Qi(t, t.pendingProps.children)).flags |= 4096);
                                return t
                            }
                            return s ? (i = $i(e, t, i.children, i.fallback, n), s = t.child, o = e.child.memoizedState, s.memoizedState = null === o ? Ji(n) : {
                                baseLanes: o.baseLanes | n,
                                cachePool: null
                            }, s.childLanes = e.childLanes & ~n, t.memoizedState = Ki, i) : (n = Zi(e, t, i.children, n), t.memoizedState = null, n)
                        }
                        return s ? (i = $i(e, t, i.children, i.fallback, n), s = t.child, o = e.child.memoizedState, s.memoizedState = null === o ? Ji(n) : {
                            baseLanes: o.baseLanes | n,
                            cachePool: null
                        }, s.childLanes = e.childLanes & ~n, t.memoizedState = Ki, i) : (n = Zi(e, t, i.children, n), t.memoizedState = null, n)
                    }

                    function Qi(e, t) {
                        return (t = rs({
                            mode: "visible",
                            children: t
                        }, e.mode, 0, null)).return = e, e.child = t
                    }

                    function Zi(e, t, n, r) {
                        var i = e.child;
                        return e = i.sibling, n = es(i, {
                            mode: "visible",
                            children: n
                        }), 0 === (1 & t.mode) && (n.lanes = r), n.return = t, n.sibling = null, null !== e && (null === (r = t.deletions) ? (t.deletions = [e], t.flags |= 16) : r.push(e)), t.child = n
                    }

                    function $i(e, t, n, r, i) {
                        var o = t.mode,
                            a = (e = e.child).sibling,
                            s = {
                                mode: "hidden",
                                children: n
                            };
                        return 0 === (1 & o) && t.child !== e ? ((n = t.child).childLanes = 0, n.pendingProps = s, t.deletions = null) : (n = es(e, s)).subtreeFlags = 14680064 & e.subtreeFlags, null !== a ? r = es(a, r) : (r = ns(r, o, i, null)).flags |= 2, r.return = t, n.return = t, n.sibling = r, t.child = n, r
                    }

                    function eo(e, t, n, r) {
                        return null !== r && er(r), or(t, e.child, null, n), (e = Qi(t, t.pendingProps.children)).flags |= 2, t.memoizedState = null, e
                    }

                    function to(e, t, n) {
                        e.lanes |= t;
                        var r = e.alternate;
                        null !== r && (r.lanes |= t), cn(e.return, t, n)
                    }

                    function no(e, t, n, r, i) {
                        var o = e.memoizedState;
                        null === o ? e.memoizedState = {
                            isBackwards: t,
                            rendering: null,
                            renderingStartTime: 0,
                            last: r,
                            tail: n,
                            tailMode: i
                        } : (o.isBackwards = t, o.rendering = null, o.renderingStartTime = 0, o.last = r, o.tail = n, o.tailMode = i)
                    }

                    function ro(e, t, n) {
                        var r = t.pendingProps,
                            i = r.revealOrder,
                            o = r.tail;
                        if (ki(e, t, r.children, n), 0 !== (2 & (r = gr.current))) r = 1 & r | 2, t.flags |= 128;
                        else {
                            if (null !== e && 0 !== (128 & e.flags)) e: for (e = t.child; null !== e;) {
                                if (13 === e.tag) null !== e.memoizedState && to(e, n, t);
                                else if (19 === e.tag) to(e, n, t);
                                else if (null !== e.child) {
                                    e.child.return = e, e = e.child;
                                    continue
                                }
                                if (e === t) break e;
                                for (; null === e.sibling;) {
                                    if (null === e.return || e.return === t) break e;
                                    e = e.return
                                }
                                e.sibling.return = e.return, e = e.sibling
                            }
                            r &= 1
                        }
                        if (lt(gr, r), 0 === (1 & t.mode)) t.memoizedState = null;
                        else switch (i) {
                            case "forwards":
                                for (n = t.child, i = null; null !== n;) null !== (e = n.alternate) && null === vr(e) && (i = n), n = n.sibling;
                                null === (n = i) ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), no(t, !1, i, n, o);
                                break;
                            case "backwards":
                                for (n = null, i = t.child, t.child = null; null !== i;) {
                                    if (null !== (e = i.alternate) && null === vr(e)) {
                                        t.child = i;
                                        break
                                    }
                                    e = i.sibling, i.sibling = n, n = i, i = e
                                }
                                no(t, !0, n, null, o);
                                break;
                            case "together":
                                no(t, !1, null, null, void 0);
                                break;
                            default:
                                t.memoizedState = null
                        }
                        return t.child
                    }

                    function io(e, t, n) {
                        if (null !== e && (t.dependencies = e.dependencies), na |= t.lanes, 0 === (n & t.childLanes)) return null;
                        if (null !== e && t.child !== e.child) throw Error(a(153));
                        if (null !== t.child) {
                            for (n = es(e = t.child, e.pendingProps), t.child = n, n.return = t; null !== e.sibling;) e = e.sibling, (n = n.sibling = es(e, e.pendingProps)).return = t;
                            n.sibling = null
                        }
                        return t.child
                    }

                    function oo(e, t) {
                        switch (Hn(t), t.tag) {
                            case 1:
                                return ft(t.type) && mt(), 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null;
                            case 3:
                                return pr(), st(dt), st(ut), br(), 0 !== (65536 & (e = t.flags)) && 0 === (128 & e) ? (t.flags = -65537 & e | 128, t) : null;
                            case 5:
                                return mr(t), null;
                            case 13:
                                if (st(gr), null !== (e = t.memoizedState) && null !== e.dehydrated) {
                                    if (null === t.alternate) throw Error(a(340));
                                    $n()
                                }
                                return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null;
                            case 19:
                                return st(gr), null;
                            case 4:
                                return pr(), null;
                            case 10:
                                return ln(t.type._context), null;
                            case 22:
                            case 23:
                                return Oa(), null;
                            default:
                                return null
                        }
                    }
                    var ao = !1,
                        so = !1,
                        lo = "function" === typeof WeakSet ? WeakSet : Set,
                        co = null;

                    function uo(e, t) {
                        var n = e.ref;
                        if (null !== n)
                            if ("function" === typeof n) try {
                                n(null)
                            } catch (r) {
                                qa(e, t, r)
                            } else n.current = null
                    }

                    function ho(e, t, n) {
                        try {
                            n()
                        } catch (r) {
                            qa(e, t, r)
                        }
                    }
                    var po = !1;

                    function fo(e, t, n) {
                        var r = t.updateQueue;
                        if (null !== (r = null !== r ? r.lastEffect : null)) {
                            var i = r = r.next;
                            do {
                                if ((i.tag & e) === e) {
                                    var o = i.destroy;
                                    i.destroy = void 0, void 0 !== o && ho(t, n, o)
                                }
                                i = i.next
                            } while (i !== r)
                        }
                    }

                    function mo(e, t) {
                        if (null !== (t = null !== (t = t.updateQueue) ? t.lastEffect : null)) {
                            var n = t = t.next;
                            do {
                                if ((n.tag & e) === e) {
                                    var r = n.create;
                                    n.destroy = r()
                                }
                                n = n.next
                            } while (n !== t)
                        }
                    }

                    function go(e) {
                        var t = e.ref;
                        if (null !== t) {
                            var n = e.stateNode;
                            if (5 === e.tag) e = B(n);
                            else e = n;
                            "function" === typeof t ? t(e) : t.current = e
                        }
                    }

                    function vo(e, t, n) {
                        if (Vt && "function" === typeof Vt.onCommitFiberUnmount) try {
                            Vt.onCommitFiberUnmount(Gt, t)
                        } catch (a) {}
                        switch (t.tag) {
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                                if (null !== (e = t.updateQueue) && null !== (e = e.lastEffect)) {
                                    var r = e = e.next;
                                    do {
                                        var i = r,
                                            o = i.destroy;
                                        i = i.tag, void 0 !== o && (0 !== (2 & i) || 0 !== (4 & i)) && ho(t, n, o), r = r.next
                                    } while (r !== e)
                                }
                                break;
                            case 1:
                                if (uo(t, n), "function" === typeof(e = t.stateNode).componentWillUnmount) try {
                                    e.props = t.memoizedProps, e.state = t.memoizedState, e.componentWillUnmount()
                                } catch (a) {
                                    qa(t, n, a)
                                }
                                break;
                            case 5:
                                uo(t, n);
                                break;
                            case 4:
                                K ? So(e, t, n) : J && J && (t = t.stateNode.containerInfo, n = Ce(t), Re(t, n))
                        }
                    }

                    function yo(e, t, n) {
                        for (var r = t;;)
                            if (vo(e, r, n), null === r.child || K && 4 === r.tag) {
                                if (r === t) break;
                                for (; null === r.sibling;) {
                                    if (null === r.return || r.return === t) return;
                                    r = r.return
                                }
                                r.sibling.return = r.return, r = r.sibling
                            } else r.child.return = r, r = r.child
                    }

                    function bo(e) {
                        var t = e.alternate;
                        null !== t && (e.alternate = null, bo(t)), e.child = null, e.deletions = null, e.sibling = null, 5 === e.tag && (null !== (t = e.stateNode) && ee(t)), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null
                    }

                    function xo(e) {
                        return 5 === e.tag || 3 === e.tag || 4 === e.tag
                    }

                    function _o(e) {
                        e: for (;;) {
                            for (; null === e.sibling;) {
                                if (null === e.return || xo(e.return)) return null;
                                e = e.return
                            }
                            for (e.sibling.return = e.return, e = e.sibling; 5 !== e.tag && 6 !== e.tag && 18 !== e.tag;) {
                                if (2 & e.flags) continue e;
                                if (null === e.child || 4 === e.tag) continue e;
                                e.child.return = e, e = e.child
                            }
                            if (!(2 & e.flags)) return e.stateNode
                        }
                    }

                    function Mo(e) {
                        if (K) {
                            e: {
                                for (var t = e.return; null !== t;) {
                                    if (xo(t)) break e;
                                    t = t.return
                                }
                                throw Error(a(160))
                            }
                            var n = t;
                            switch (n.tag) {
                                case 5:
                                    t = n.stateNode, 32 & n.flags && (xe(t), n.flags &= -33), Ao(e, n = _o(e), t);
                                    break;
                                case 3:
                                case 4:
                                    t = n.stateNode.containerInfo, wo(e, n = _o(e), t);
                                    break;
                                default:
                                    throw Error(a(161))
                            }
                        }
                    }

                    function wo(e, t, n) {
                        var r = e.tag;
                        if (5 === r || 6 === r) e = e.stateNode, t ? ve(n, e, t) : he(n, e);
                        else if (4 !== r && null !== (e = e.child))
                            for (wo(e, t, n), e = e.sibling; null !== e;) wo(e, t, n), e = e.sibling
                    }

                    function Ao(e, t, n) {
                        var r = e.tag;
                        if (5 === r || 6 === r) e = e.stateNode, t ? ge(n, e, t) : de(n, e);
                        else if (4 !== r && null !== (e = e.child))
                            for (Ao(e, t, n), e = e.sibling; null !== e;) Ao(e, t, n), e = e.sibling
                    }

                    function So(e, t, n) {
                        for (var r, i, o = t, s = !1;;) {
                            if (!s) {
                                s = o.return;
                                e: for (;;) {
                                    if (null === s) throw Error(a(160));
                                    switch (r = s.stateNode, s.tag) {
                                        case 5:
                                            i = !1;
                                            break e;
                                        case 3:
                                        case 4:
                                            r = r.containerInfo, i = !0;
                                            break e
                                    }
                                    s = s.return
                                }
                                s = !0
                            }
                            if (5 === o.tag || 6 === o.tag) yo(e, o, n), i ? be(r, o.stateNode) : ye(r, o.stateNode);
                            else if (18 === o.tag) i ? Ye(r, o.stateNode) : Je(r, o.stateNode);
                            else if (4 === o.tag) {
                                if (null !== o.child) {
                                    r = o.stateNode.containerInfo, i = !0, o.child.return = o, o = o.child;
                                    continue
                                }
                            } else if (vo(e, o, n), null !== o.child) {
                                o.child.return = o, o = o.child;
                                continue
                            }
                            if (o === t) break;
                            for (; null === o.sibling;) {
                                if (null === o.return || o.return === t) return;
                                4 === (o = o.return).tag && (s = !1)
                            }
                            o.sibling.return = o.return, o = o.sibling
                        }
                    }

                    function Eo(e, t) {
                        if (K) {
                            switch (t.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                    return fo(3, t, t.return), mo(3, t), void fo(5, t, t.return);
                                case 1:
                                case 12:
                                case 17:
                                    return;
                                case 5:
                                    var n = t.stateNode;
                                    if (null != n) {
                                        var r = t.memoizedProps;
                                        e = null !== e ? e.memoizedProps : r;
                                        var i = t.type,
                                            o = t.updateQueue;
                                        t.updateQueue = null, null !== o && me(n, o, i, e, r, t)
                                    }
                                    return;
                                case 6:
                                    if (null === t.stateNode) throw Error(a(162));
                                    return n = t.memoizedProps, void pe(t.stateNode, null !== e ? e.memoizedProps : n, n);
                                case 3:
                                    return void(Y && null !== e && e.memoizedState.isDehydrated && Xe(t.stateNode.containerInfo));
                                case 13:
                                case 19:
                                    return void Co(t)
                            }
                            throw Error(a(163))
                        }
                        switch (t.tag) {
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                                return fo(3, t, t.return), mo(3, t), void fo(5, t, t.return);
                            case 12:
                            case 22:
                            case 23:
                                return;
                            case 13:
                            case 19:
                                return void Co(t);
                            case 3:
                                Y && null !== e && e.memoizedState.isDehydrated && Xe(t.stateNode.containerInfo)
                        }
                        e: if (J) {
                            switch (t.tag) {
                                case 1:
                                case 5:
                                case 6:
                                    break e;
                                case 3:
                                case 4:
                                    t = t.stateNode, Re(t.containerInfo, t.pendingChildren);
                                    break e
                            }
                            throw Error(a(163))
                        }
                    }

                    function Co(e) {
                        var t = e.updateQueue;
                        if (null !== t) {
                            e.updateQueue = null;
                            var n = e.stateNode;
                            null === n && (n = e.stateNode = new lo), t.forEach((function(t) {
                                var r = Ja.bind(null, e, t);
                                n.has(t) || (n.add(t), t.then(r, r))
                            }))
                        }
                    }

                    function To(e, t, n) {
                        co = e, Po(e, t, n)
                    }

                    function Po(e, t, n) {
                        for (var r = 0 !== (1 & e.mode); null !== co;) {
                            var i = co,
                                o = i.child;
                            if (22 === i.tag && r) {
                                var a = null !== i.memoizedState || ao;
                                if (!a) {
                                    var s = i.alternate,
                                        l = null !== s && null !== s.memoizedState || so;
                                    s = ao;
                                    var c = so;
                                    if (ao = a, (so = l) && !c)
                                        for (co = i; null !== co;) l = (a = co).child, 22 === a.tag && null !== a.memoizedState ? Oo(i) : null !== l ? (l.return = a, co = l) : Oo(i);
                                    for (; null !== o;) co = o, Po(o, t, n), o = o.sibling;
                                    co = i, ao = s, so = c
                                }
                                Ro(e)
                            } else 0 !== (8772 & i.subtreeFlags) && null !== o ? (o.return = i, co = o) : Ro(e)
                        }
                    }

                    function Ro(e) {
                        for (; null !== co;) {
                            var t = co;
                            if (0 !== (8772 & t.flags)) {
                                var n = t.alternate;
                                try {
                                    if (0 !== (8772 & t.flags)) switch (t.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            so || mo(5, t);
                                            break;
                                        case 1:
                                            var r = t.stateNode;
                                            if (4 & t.flags && !so)
                                                if (null === n) r.componentDidMount();
                                                else {
                                                    var i = t.elementType === t.type ? n.memoizedProps : en(t.type, n.memoizedProps);
                                                    r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                                                }
                                            var o = t.updateQueue;
                                            null !== o && _n(t, o, r);
                                            break;
                                        case 3:
                                            var s = t.updateQueue;
                                            if (null !== s) {
                                                if (n = null, null !== t.child) switch (t.child.tag) {
                                                    case 5:
                                                        n = B(t.child.stateNode);
                                                        break;
                                                    case 1:
                                                        n = t.child.stateNode
                                                }
                                                _n(t, s, n)
                                            }
                                            break;
                                        case 5:
                                            var l = t.stateNode;
                                            null === n && 4 & t.flags && fe(l, t.type, t.memoizedProps, t);
                                            break;
                                        case 6:
                                        case 4:
                                        case 12:
                                        case 19:
                                        case 17:
                                        case 21:
                                        case 22:
                                        case 23:
                                            break;
                                        case 13:
                                            if (Y && null === t.memoizedState) {
                                                var c = t.alternate;
                                                if (null !== c) {
                                                    var u = c.memoizedState;
                                                    if (null !== u) {
                                                        var d = u.dehydrated;
                                                        null !== d && Ke(d)
                                                    }
                                                }
                                            }
                                            break;
                                        default:
                                            throw Error(a(163))
                                    }
                                    so || 512 & t.flags && go(t)
                                } catch (h) {
                                    qa(t, t.return, h)
                                }
                            }
                            if (t === e) {
                                co = null;
                                break
                            }
                            if (null !== (n = t.sibling)) {
                                n.return = t.return, co = n;
                                break
                            }
                            co = t.return
                        }
                    }

                    function Io(e) {
                        for (; null !== co;) {
                            var t = co;
                            if (t === e) {
                                co = null;
                                break
                            }
                            var n = t.sibling;
                            if (null !== n) {
                                n.return = t.return, co = n;
                                break
                            }
                            co = t.return
                        }
                    }

                    function Oo(e) {
                        for (; null !== co;) {
                            var t = co;
                            try {
                                switch (t.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        var n = t.return;
                                        try {
                                            mo(4, t)
                                        } catch (l) {
                                            qa(t, n, l)
                                        }
                                        break;
                                    case 1:
                                        var r = t.stateNode;
                                        if ("function" === typeof r.componentDidMount) {
                                            var i = t.return;
                                            try {
                                                r.componentDidMount()
                                            } catch (l) {
                                                qa(t, i, l)
                                            }
                                        }
                                        var o = t.return;
                                        try {
                                            go(t)
                                        } catch (l) {
                                            qa(t, o, l)
                                        }
                                        break;
                                    case 5:
                                        var a = t.return;
                                        try {
                                            go(t)
                                        } catch (l) {
                                            qa(t, a, l)
                                        }
                                }
                            } catch (l) {
                                qa(t, t.return, l)
                            }
                            if (t === e) {
                                co = null;
                                break
                            }
                            var s = t.sibling;
                            if (null !== s) {
                                s.return = t.return, co = s;
                                break
                            }
                            co = t.return
                        }
                    }
                    var Bo = 0,
                        Lo = 1,
                        Do = 2,
                        No = 3,
                        ko = 4;
                    if ("function" === typeof Symbol && Symbol.for) {
                        var Fo = Symbol.for;
                        Bo = Fo("selector.component"), Lo = Fo("selector.has_pseudo_class"), Do = Fo("selector.role"), No = Fo("selector.test_id"), ko = Fo("selector.text")
                    }

                    function Uo(e) {
                        var t = Q(e);
                        if (null != t) {
                            if ("string" !== typeof t.memoizedProps["data-testname"]) throw Error(a(364));
                            return t
                        }
                        if (null === (e = ie(e))) throw Error(a(362));
                        return e.stateNode.current
                    }

                    function zo(e, t) {
                        switch (t.$$typeof) {
                            case Bo:
                                if (e.type === t.value) return !0;
                                break;
                            case Lo:
                                e: {
                                    t = t.value,
                                    e = [e, 0];
                                    for (var n = 0; n < e.length;) {
                                        var r = e[n++],
                                            i = e[n++],
                                            o = t[i];
                                        if (5 !== r.tag || !se(r)) {
                                            for (; null != o && zo(r, o);) o = t[++i];
                                            if (i === t.length) {
                                                t = !0;
                                                break e
                                            }
                                            for (r = r.child; null !== r;) e.push(r, i), r = r.sibling
                                        }
                                    }
                                    t = !1
                                }
                                return t;
                            case Do:
                                if (5 === e.tag && le(e.stateNode, t.value)) return !0;
                                break;
                            case ko:
                                if ((5 === e.tag || 6 === e.tag) && (null !== (e = ae(e)) && 0 <= e.indexOf(t.value))) return !0;
                                break;
                            case No:
                                if (5 === e.tag && ("string" === typeof(e = e.memoizedProps["data-testname"]) && e.toLowerCase() === t.value.toLowerCase())) return !0;
                                break;
                            default:
                                throw Error(a(365))
                        }
                        return !1
                    }

                    function Ho(e) {
                        switch (e.$$typeof) {
                            case Bo:
                                return "<" + (w(e.value) || "Unknown") + ">";
                            case Lo:
                                return ":has(" + (Ho(e) || "") + ")";
                            case Do:
                                return '[role="' + e.value + '"]';
                            case ko:
                                return '"' + e.value + '"';
                            case No:
                                return '[data-testname="' + e.value + '"]';
                            default:
                                throw Error(a(365))
                        }
                    }

                    function jo(e, t) {
                        var n = [];
                        e = [e, 0];
                        for (var r = 0; r < e.length;) {
                            var i = e[r++],
                                o = e[r++],
                                a = t[o];
                            if (5 !== i.tag || !se(i)) {
                                for (; null != a && zo(i, a);) a = t[++o];
                                if (o === t.length) n.push(i);
                                else
                                    for (i = i.child; null !== i;) e.push(i, o), i = i.sibling
                            }
                        }
                        return n
                    }

                    function Go(e, t) {
                        if (!re) throw Error(a(363));
                        e = jo(e = Uo(e), t), t = [], e = Array.from(e);
                        for (var n = 0; n < e.length;) {
                            var r = e[n++];
                            if (5 === r.tag) se(r) || t.push(r.stateNode);
                            else
                                for (r = r.child; null !== r;) e.push(r), r = r.sibling
                        }
                        return t
                    }
                    var Vo = Math.ceil,
                        qo = s.ReactCurrentDispatcher,
                        Wo = s.ReactCurrentOwner,
                        Xo = s.ReactCurrentBatchConfig,
                        Ko = 0,
                        Jo = null,
                        Yo = null,
                        Qo = 0,
                        Zo = 0,
                        $o = at(0),
                        ea = 0,
                        ta = null,
                        na = 0,
                        ra = 0,
                        ia = 0,
                        oa = null,
                        aa = null,
                        sa = 0,
                        la = 1 / 0;

                    function ca() {
                        la = Ft() + 500
                    }
                    var ua, da = !1,
                        ha = null,
                        pa = null,
                        fa = !1,
                        ma = null,
                        ga = 0,
                        va = 0,
                        ya = null,
                        ba = -1,
                        xa = 0;

                    function _a() {
                        return 0 !== (6 & Ko) ? Ft() : -1 !== ba ? ba : ba = Ft()
                    }

                    function Ma(e) {
                        return 0 === (1 & e.mode) ? 1 : 0 !== (2 & Ko) && 0 !== Qo ? Qo & -Qo : null !== Qt.transition ? (0 === xa && (e = wt, 0 === (4194240 & (wt <<= 1)) && (wt = 64), xa = e), xa) : 0 !== (e = Ot) ? e : $()
                    }

                    function wa(e, t, n) {
                        if (50 < va) throw va = 0, ya = null, Error(a(185));
                        var r = Aa(e, t);
                        return null === r ? null : (Rt(r, t, n), 0 !== (2 & Ko) && r === Jo || (r === Jo && (0 === (2 & Ko) && (ra |= t), 4 === ea && Pa(r, Qo)), Sa(r, n), 1 === t && 0 === Ko && 0 === (1 & e.mode) && (ca(), Xt && Yt())), r)
                    }

                    function Aa(e, t) {
                        e.lanes |= t;
                        var n = e.alternate;
                        for (null !== n && (n.lanes |= t), n = e, e = e.return; null !== e;) e.childLanes |= t, null !== (n = e.alternate) && (n.childLanes |= t), n = e, e = e.return;
                        return 3 === n.tag ? n.stateNode : null
                    }

                    function Sa(e, t) {
                        var n = e.callbackNode;
                        ! function(e, t) {
                            for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, o = e.pendingLanes; 0 < o;) {
                                var a = 31 - xt(o),
                                    s = 1 << a,
                                    l = i[a]; - 1 === l ? 0 !== (s & n) && 0 === (s & r) || (i[a] = Ct(s, t)) : l <= t && (e.expiredLanes |= s), o &= ~s
                            }
                        }(e, t);
                        var r = Et(e, e === Jo ? Qo : 0);
                        if (0 === r) null !== n && Dt(n), e.callbackNode = null, e.callbackPriority = 0;
                        else if (t = r & -r, e.callbackPriority !== t) {
                            if (null != n && Dt(n), 1 === t) 0 === e.tag ? function(e) {
                                Xt = !0, Jt(e)
                            }(Ra.bind(null, e)) : Jt(Ra.bind(null, e)), te ? ne((function() {
                                0 === Ko && Yt()
                            })) : Lt(Ut, Yt), n = null;
                            else {
                                switch (Bt(r)) {
                                    case 1:
                                        n = Ut;
                                        break;
                                    case 4:
                                        n = zt;
                                        break;
                                    case 16:
                                    default:
                                        n = Ht;
                                        break;
                                    case 536870912:
                                        n = jt
                                }
                                n = Ya(n, Ea.bind(null, e))
                            }
                            e.callbackPriority = t, e.callbackNode = n
                        }
                    }

                    function Ea(e, t) {
                        if (ba = -1, xa = 0, 0 !== (6 & Ko)) throw Error(a(327));
                        var n = e.callbackNode;
                        if (Ga() && e.callbackNode !== n) return null;
                        var r = Et(e, e === Jo ? Qo : 0);
                        if (0 === r) return null;
                        if (0 !== (30 & r) || 0 !== (r & e.expiredLanes) || t) t = ka(e, r);
                        else {
                            t = r;
                            var i = Ko;
                            Ko |= 2;
                            var o = Da();
                            for (Jo === e && Qo === t || (ca(), Ba(e, t));;) try {
                                Ua();
                                break
                            } catch (l) {
                                La(e, l)
                            }
                            an(), qo.current = o, Ko = i, null !== Yo ? t = 0 : (Jo = null, Qo = 0, t = ea)
                        }
                        if (0 !== t) {
                            if (2 === t && (0 !== (i = Tt(e)) && (r = i, t = Ca(e, i))), 1 === t) throw n = ta, Ba(e, 0), Pa(e, r), Sa(e, Ft()), n;
                            if (6 === t) Pa(e, r);
                            else {
                                if (i = e.current.alternate, 0 === (30 & r) && ! function(e) {
                                        for (var t = e;;) {
                                            if (16384 & t.flags) {
                                                var n = t.updateQueue;
                                                if (null !== n && null !== (n = n.stores))
                                                    for (var r = 0; r < n.length; r++) {
                                                        var i = n[r],
                                                            o = i.getSnapshot;
                                                        i = i.value;
                                                        try {
                                                            if (!qt(o(), i)) return !1
                                                        } catch (s) {
                                                            return !1
                                                        }
                                                    }
                                            }
                                            if (n = t.child, 16384 & t.subtreeFlags && null !== n) n.return = t, t = n;
                                            else {
                                                if (t === e) break;
                                                for (; null === t.sibling;) {
                                                    if (null === t.return || t.return === e) return !0;
                                                    t = t.return
                                                }
                                                t.sibling.return = t.return, t = t.sibling
                                            }
                                        }
                                        return !0
                                    }(i) && (2 === (t = ka(e, r)) && (0 !== (o = Tt(e)) && (r = o, t = Ca(e, o))), 1 === t)) throw n = ta, Ba(e, 0), Pa(e, r), Sa(e, Ft()), n;
                                switch (e.finishedWork = i, e.finishedLanes = r, t) {
                                    case 0:
                                    case 1:
                                        throw Error(a(345));
                                    case 2:
                                    case 5:
                                        ja(e, aa);
                                        break;
                                    case 3:
                                        if (Pa(e, r), (130023424 & r) === r && 10 < (t = sa + 500 - Ft())) {
                                            if (0 !== Et(e, 0)) break;
                                            if (((i = e.suspendedLanes) & r) !== r) {
                                                _a(), e.pingedLanes |= e.suspendedLanes & i;
                                                break
                                            }
                                            e.timeoutHandle = V(ja.bind(null, e, aa), t);
                                            break
                                        }
                                        ja(e, aa);
                                        break;
                                    case 4:
                                        if (Pa(e, r), (4194240 & r) === r) break;
                                        for (t = e.eventTimes, i = -1; 0 < r;) {
                                            var s = 31 - xt(r);
                                            o = 1 << s, (s = t[s]) > i && (i = s), r &= ~o
                                        }
                                        if (r = i, 10 < (r = (120 > (r = Ft() - r) ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * Vo(r / 1960)) - r)) {
                                            e.timeoutHandle = V(ja.bind(null, e, aa), r);
                                            break
                                        }
                                        ja(e, aa);
                                        break;
                                    default:
                                        throw Error(a(329))
                                }
                            }
                        }
                        return Sa(e, Ft()), e.callbackNode === n ? Ea.bind(null, e) : null
                    }

                    function Ca(e, t) {
                        var n = oa;
                        return e.current.memoizedState.isDehydrated && (Ba(e, t).flags |= 256), 2 !== (e = ka(e, t)) && (t = aa, aa = n, null !== t && Ta(t)), e
                    }

                    function Ta(e) {
                        null === aa ? aa = e : aa.push.apply(aa, e)
                    }

                    function Pa(e, t) {
                        for (t &= ~ia, t &= ~ra, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) {
                            var n = 31 - xt(t),
                                r = 1 << n;
                            e[n] = -1, t &= ~r
                        }
                    }

                    function Ra(e) {
                        if (0 !== (6 & Ko)) throw Error(a(327));
                        Ga();
                        var t = Et(e, 0);
                        if (0 === (1 & t)) return Sa(e, Ft()), null;
                        var n = ka(e, t);
                        if (0 !== e.tag && 2 === n) {
                            var r = Tt(e);
                            0 !== r && (t = r, n = Ca(e, r))
                        }
                        if (1 === n) throw n = ta, Ba(e, 0), Pa(e, t), Sa(e, Ft()), n;
                        if (6 === n) throw Error(a(345));
                        return e.finishedWork = e.current.alternate, e.finishedLanes = t, ja(e, aa), Sa(e, Ft()), null
                    }

                    function Ia(e) {
                        null !== ma && 0 === ma.tag && 0 === (6 & Ko) && Ga();
                        var t = Ko;
                        Ko |= 1;
                        var n = Xo.transition,
                            r = Ot;
                        try {
                            if (Xo.transition = null, Ot = 1, e) return e()
                        } finally {
                            Ot = r, Xo.transition = n, 0 === (6 & (Ko = t)) && Yt()
                        }
                    }

                    function Oa() {
                        Zo = $o.current, st($o)
                    }

                    function Ba(e, t) {
                        e.finishedWork = null, e.finishedLanes = 0;
                        var n = e.timeoutHandle;
                        if (n !== W && (e.timeoutHandle = W, q(n)), null !== Yo)
                            for (n = Yo.return; null !== n;) {
                                var r = n;
                                switch (Hn(r), r.tag) {
                                    case 1:
                                        null !== (r = r.type.childContextTypes) && void 0 !== r && mt();
                                        break;
                                    case 3:
                                        pr(), st(dt), st(ut), br();
                                        break;
                                    case 5:
                                        mr(r);
                                        break;
                                    case 4:
                                        pr();
                                        break;
                                    case 13:
                                    case 19:
                                        st(gr);
                                        break;
                                    case 10:
                                        ln(r.type._context);
                                        break;
                                    case 22:
                                    case 23:
                                        Oa()
                                }
                                n = n.return
                            }
                        if (Jo = e, Yo = e = es(e.current, null), Qo = Zo = t, ea = 0, ta = null, ia = ra = na = 0, aa = oa = null, null !== hn) {
                            for (t = 0; t < hn.length; t++)
                                if (null !== (r = (n = hn[t]).interleaved)) {
                                    n.interleaved = null;
                                    var i = r.next,
                                        o = n.pending;
                                    if (null !== o) {
                                        var a = o.next;
                                        o.next = i, r.next = a
                                    }
                                    n.pending = r
                                }
                            hn = null
                        }
                        return e
                    }

                    function La(e, t) {
                        for (;;) {
                            var n = Yo;
                            try {
                                if (an(), xr.current = pi, Er) {
                                    for (var r = wr.memoizedState; null !== r;) {
                                        var i = r.queue;
                                        null !== i && (i.pending = null), r = r.next
                                    }
                                    Er = !1
                                }
                                if (Mr = 0, Sr = Ar = wr = null, Cr = !1, Tr = 0, Wo.current = null, null === n || null === n.return) {
                                    ea = 1, ta = t, Yo = null;
                                    break
                                }
                                e: {
                                    var o = e,
                                        s = n.return,
                                        l = n,
                                        c = t;
                                    if (t = Qo, l.flags |= 32768, null !== c && "object" === typeof c && "function" === typeof c.then) {
                                        var u = c,
                                            d = l,
                                            h = d.tag;
                                        if (0 === (1 & d.mode) && (0 === h || 11 === h || 15 === h)) {
                                            var p = d.alternate;
                                            p ? (d.updateQueue = p.updateQueue, d.memoizedState = p.memoizedState, d.lanes = p.lanes) : (d.updateQueue = null, d.memoizedState = null)
                                        }
                                        var f = Ci(s);
                                        if (null !== f) {
                                            f.flags &= -257, Ti(f, s, l, 0, t), 1 & f.mode && Ei(o, u, t), c = u;
                                            var m = (t = f).updateQueue;
                                            if (null === m) {
                                                var g = new Set;
                                                g.add(c), t.updateQueue = g
                                            } else m.add(c);
                                            break e
                                        }
                                        if (0 === (1 & t)) {
                                            Ei(o, u, t), Na();
                                            break e
                                        }
                                        c = Error(a(426))
                                    } else if (Vn && 1 & l.mode) {
                                        var v = Ci(s);
                                        if (null !== v) {
                                            0 === (65536 & v.flags) && (v.flags |= 256), Ti(v, s, l, 0, t), er(c);
                                            break e
                                        }
                                    }
                                    o = c,
                                    4 !== ea && (ea = 2),
                                    null === oa ? oa = [o] : oa.push(o),
                                    c = vi(c, l),
                                    l = s;do {
                                        switch (l.tag) {
                                            case 3:
                                                l.flags |= 65536, t &= -t, l.lanes |= t, bn(l, Ai(0, c, t));
                                                break e;
                                            case 1:
                                                o = c;
                                                var y = l.type,
                                                    b = l.stateNode;
                                                if (0 === (128 & l.flags) && ("function" === typeof y.getDerivedStateFromError || null !== b && "function" === typeof b.componentDidCatch && (null === pa || !pa.has(b)))) {
                                                    l.flags |= 65536, t &= -t, l.lanes |= t, bn(l, Si(l, o, t));
                                                    break e
                                                }
                                        }
                                        l = l.return
                                    } while (null !== l)
                                }
                                Ha(n)
                            } catch (x) {
                                t = x, Yo === n && null !== n && (Yo = n = n.return);
                                continue
                            }
                            break
                        }
                    }

                    function Da() {
                        var e = qo.current;
                        return qo.current = pi, null === e ? pi : e
                    }

                    function Na() {
                        0 !== ea && 3 !== ea && 2 !== ea || (ea = 4), null === Jo || 0 === (268435455 & na) && 0 === (268435455 & ra) || Pa(Jo, Qo)
                    }

                    function ka(e, t) {
                        var n = Ko;
                        Ko |= 2;
                        var r = Da();
                        for (Jo === e && Qo === t || Ba(e, t);;) try {
                            Fa();
                            break
                        } catch (i) {
                            La(e, i)
                        }
                        if (an(), Ko = n, qo.current = r, null !== Yo) throw Error(a(261));
                        return Jo = null, Qo = 0, ea
                    }

                    function Fa() {
                        for (; null !== Yo;) za(Yo)
                    }

                    function Ua() {
                        for (; null !== Yo && !Nt();) za(Yo)
                    }

                    function za(e) {
                        var t = ua(e.alternate, e, Zo);
                        e.memoizedProps = e.pendingProps, null === t ? Ha(e) : Yo = t, Wo.current = null
                    }

                    function Ha(e) {
                        var t = e;
                        do {
                            var n = t.alternate;
                            if (e = t.return, 0 === (32768 & t.flags)) {
                                if (null !== (n = Li(n, t, Zo))) return void(Yo = n)
                            } else {
                                if (null !== (n = oo(n, t))) return n.flags &= 32767, void(Yo = n);
                                if (null === e) return ea = 6, void(Yo = null);
                                e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null
                            }
                            if (null !== (t = t.sibling)) return void(Yo = t);
                            Yo = t = e
                        } while (null !== t);
                        0 === ea && (ea = 5)
                    }

                    function ja(e, t) {
                        var n = Ot,
                            r = Xo.transition;
                        try {
                            Xo.transition = null, Ot = 1,
                                function(e, t, n) {
                                    do {
                                        Ga()
                                    } while (null !== ma);
                                    if (0 !== (6 & Ko)) throw Error(a(327));
                                    var r = e.finishedWork,
                                        i = e.finishedLanes;
                                    if (null === r) return null;
                                    if (e.finishedWork = null, e.finishedLanes = 0, r === e.current) throw Error(a(177));
                                    e.callbackNode = null, e.callbackPriority = 0;
                                    var o = r.lanes | r.childLanes;
                                    if (function(e, t) {
                                            var n = e.pendingLanes & ~t;
                                            e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements;
                                            var r = e.eventTimes;
                                            for (e = e.expirationTimes; 0 < n;) {
                                                var i = 31 - xt(n),
                                                    o = 1 << i;
                                                t[i] = 0, r[i] = -1, e[i] = -1, n &= ~o
                                            }
                                        }(e, o), e === Jo && (Yo = Jo = null, Qo = 0), 0 === (2064 & r.subtreeFlags) && 0 === (2064 & r.flags) || fa || (fa = !0, Ya(Ht, (function() {
                                            return Ga(), null
                                        }))), o = 0 !== (15990 & r.flags), 0 !== (15990 & r.subtreeFlags) || o) {
                                        o = Xo.transition, Xo.transition = null;
                                        var s = Ot;
                                        Ot = 1;
                                        var l = Ko;
                                        Ko |= 4, Wo.current = null,
                                            function(e, t) {
                                                for (N(e.containerInfo), co = t; null !== co;)
                                                    if (t = (e = co).child, 0 !== (1028 & e.subtreeFlags) && null !== t) t.return = e, co = t;
                                                    else
                                                        for (; null !== co;) {
                                                            e = co;
                                                            try {
                                                                var n = e.alternate;
                                                                if (0 !== (1024 & e.flags)) switch (e.tag) {
                                                                    case 0:
                                                                    case 11:
                                                                    case 15:
                                                                    case 5:
                                                                    case 6:
                                                                    case 4:
                                                                    case 17:
                                                                        break;
                                                                    case 1:
                                                                        if (null !== n) {
                                                                            var r = n.memoizedProps,
                                                                                i = n.memoizedState,
                                                                                o = e.stateNode,
                                                                                s = o.getSnapshotBeforeUpdate(e.elementType === e.type ? r : en(e.type, r), i);
                                                                            o.__reactInternalSnapshotBeforeUpdate = s
                                                                        }
                                                                        break;
                                                                    case 3:
                                                                        K && Se(e.stateNode.containerInfo);
                                                                        break;
                                                                    default:
                                                                        throw Error(a(163))
                                                                }
                                                            } catch (l) {
                                                                qa(e, e.return, l)
                                                            }
                                                            if (null !== (t = e.sibling)) {
                                                                t.return = e.return, co = t;
                                                                break
                                                            }
                                                            co = e.return
                                                        }
                                                n = po, po = !1
                                            }(e, r),
                                            function(e, t) {
                                                for (co = t; null !== co;) {
                                                    var n = (t = co).deletions;
                                                    if (null !== n)
                                                        for (var r = 0; r < n.length; r++) {
                                                            var i = n[r];
                                                            try {
                                                                var o = e;
                                                                K ? So(o, i, t) : yo(o, i, t);
                                                                var a = i.alternate;
                                                                null !== a && (a.return = null), i.return = null
                                                            } catch (_) {
                                                                qa(i, t, _)
                                                            }
                                                        }
                                                    if (n = t.child, 0 !== (12854 & t.subtreeFlags) && null !== n) n.return = t, co = n;
                                                    else
                                                        for (; null !== co;) {
                                                            t = co;
                                                            try {
                                                                var s = t.flags;
                                                                if (32 & s && K && xe(t.stateNode), 512 & s) {
                                                                    var l = t.alternate;
                                                                    if (null !== l) {
                                                                        var c = l.ref;
                                                                        null !== c && ("function" === typeof c ? c(null) : c.current = null)
                                                                    }
                                                                }
                                                                if (8192 & s) switch (t.tag) {
                                                                    case 13:
                                                                        if (null !== t.memoizedState) {
                                                                            var u = t.alternate;
                                                                            null !== u && null !== u.memoizedState || (sa = Ft())
                                                                        }
                                                                        break;
                                                                    case 22:
                                                                        var d = null !== t.memoizedState,
                                                                            h = t.alternate,
                                                                            p = null !== h && null !== h.memoizedState;
                                                                        if (n = t, K) e: if (r = n, i = d, o = null, K)
                                                                            for (var f = r;;) {
                                                                                if (5 === f.tag) {
                                                                                    if (null === o) {
                                                                                        o = f;
                                                                                        var m = f.stateNode;
                                                                                        i ? _e(m) : we(f.stateNode, f.memoizedProps)
                                                                                    }
                                                                                } else if (6 === f.tag) {
                                                                                    if (null === o) {
                                                                                        var g = f.stateNode;
                                                                                        i ? Me(g) : Ae(g, f.memoizedProps)
                                                                                    }
                                                                                } else if ((22 !== f.tag && 23 !== f.tag || null === f.memoizedState || f === r) && null !== f.child) {
                                                                                    f.child.return = f, f = f.child;
                                                                                    continue
                                                                                }
                                                                                if (f === r) break;
                                                                                for (; null === f.sibling;) {
                                                                                    if (null === f.return || f.return === r) break e;
                                                                                    o === f && (o = null), f = f.return
                                                                                }
                                                                                o === f && (o = null), f.sibling.return = f.return, f = f.sibling
                                                                            }
                                                                        if (d && !p && 0 !== (1 & n.mode)) {
                                                                            co = n;
                                                                            for (var v = n.child; null !== v;) {
                                                                                for (n = co = v; null !== co;) {
                                                                                    var y = (r = co).child;
                                                                                    switch (r.tag) {
                                                                                        case 0:
                                                                                        case 11:
                                                                                        case 14:
                                                                                        case 15:
                                                                                            fo(4, r, r.return);
                                                                                            break;
                                                                                        case 1:
                                                                                            uo(r, r.return);
                                                                                            var b = r.stateNode;
                                                                                            if ("function" === typeof b.componentWillUnmount) {
                                                                                                var x = r.return;
                                                                                                try {
                                                                                                    b.props = r.memoizedProps, b.state = r.memoizedState, b.componentWillUnmount()
                                                                                                } catch (_) {
                                                                                                    qa(r, x, _)
                                                                                                }
                                                                                            }
                                                                                            break;
                                                                                        case 5:
                                                                                            uo(r, r.return);
                                                                                            break;
                                                                                        case 22:
                                                                                            if (null !== r.memoizedState) {
                                                                                                Io(n);
                                                                                                continue
                                                                                            }
                                                                                    }
                                                                                    null !== y ? (y.return = r, co = y) : Io(n)
                                                                                }
                                                                                v = v.sibling
                                                                            }
                                                                        }
                                                                }
                                                                switch (4102 & s) {
                                                                    case 2:
                                                                        Mo(t), t.flags &= -3;
                                                                        break;
                                                                    case 6:
                                                                        Mo(t), t.flags &= -3, Eo(t.alternate, t);
                                                                        break;
                                                                    case 4096:
                                                                        t.flags &= -4097;
                                                                        break;
                                                                    case 4100:
                                                                        t.flags &= -4097, Eo(t.alternate, t);
                                                                        break;
                                                                    case 4:
                                                                        Eo(t.alternate, t)
                                                                }
                                                            } catch (_) {
                                                                qa(t, t.return, _)
                                                            }
                                                            if (null !== (n = t.sibling)) {
                                                                n.return = t.return, co = n;
                                                                break
                                                            }
                                                            co = t.return
                                                        }
                                                }
                                            }(e, r), k(e.containerInfo), e.current = r, To(r, e, i), kt(), Ko = l, Ot = s, Xo.transition = o
                                    } else e.current = r;
                                    if (fa && (fa = !1, ma = e, ga = i), o = e.pendingLanes, 0 === o && (pa = null), function(e) {
                                            if (Vt && "function" === typeof Vt.onCommitFiberRoot) try {
                                                Vt.onCommitFiberRoot(Gt, e, void 0, 128 === (128 & e.current.flags))
                                            } catch (t) {}
                                        }(r.stateNode), Sa(e, Ft()), null !== t)
                                        for (n = e.onRecoverableError, r = 0; r < t.length; r++) n(t[r]);
                                    if (da) throw da = !1, e = ha, ha = null, e;
                                    0 !== (1 & ga) && 0 !== e.tag && Ga(), o = e.pendingLanes, 0 !== (1 & o) ? e === ya ? va++ : (va = 0, ya = e) : va = 0, Yt()
                                }(e, t, n)
                        } finally {
                            Xo.transition = r, Ot = n
                        }
                        return null
                    }

                    function Ga() {
                        if (null !== ma) {
                            var e = Bt(ga),
                                t = Xo.transition,
                                n = Ot;
                            try {
                                if (Xo.transition = null, Ot = 16 > e ? 16 : e, null === ma) var r = !1;
                                else {
                                    if (e = ma, ma = null, ga = 0, 0 !== (6 & Ko)) throw Error(a(331));
                                    var i = Ko;
                                    for (Ko |= 4, co = e.current; null !== co;) {
                                        var o = co,
                                            s = o.child;
                                        if (0 !== (16 & co.flags)) {
                                            var l = o.deletions;
                                            if (null !== l) {
                                                for (var c = 0; c < l.length; c++) {
                                                    var u = l[c];
                                                    for (co = u; null !== co;) {
                                                        var d = co;
                                                        switch (d.tag) {
                                                            case 0:
                                                            case 11:
                                                            case 15:
                                                                fo(8, d, o)
                                                        }
                                                        var h = d.child;
                                                        if (null !== h) h.return = d, co = h;
                                                        else
                                                            for (; null !== co;) {
                                                                var p = (d = co).sibling,
                                                                    f = d.return;
                                                                if (bo(d), d === u) {
                                                                    co = null;
                                                                    break
                                                                }
                                                                if (null !== p) {
                                                                    p.return = f, co = p;
                                                                    break
                                                                }
                                                                co = f
                                                            }
                                                    }
                                                }
                                                var m = o.alternate;
                                                if (null !== m) {
                                                    var g = m.child;
                                                    if (null !== g) {
                                                        m.child = null;
                                                        do {
                                                            var v = g.sibling;
                                                            g.sibling = null, g = v
                                                        } while (null !== g)
                                                    }
                                                }
                                                co = o
                                            }
                                        }
                                        if (0 !== (2064 & o.subtreeFlags) && null !== s) s.return = o, co = s;
                                        else e: for (; null !== co;) {
                                            if (0 !== (2048 & (o = co).flags)) switch (o.tag) {
                                                case 0:
                                                case 11:
                                                case 15:
                                                    fo(9, o, o.return)
                                            }
                                            var y = o.sibling;
                                            if (null !== y) {
                                                y.return = o.return, co = y;
                                                break e
                                            }
                                            co = o.return
                                        }
                                    }
                                    var b = e.current;
                                    for (co = b; null !== co;) {
                                        var x = (s = co).child;
                                        if (0 !== (2064 & s.subtreeFlags) && null !== x) x.return = s, co = x;
                                        else e: for (s = b; null !== co;) {
                                            if (0 !== (2048 & (l = co).flags)) try {
                                                switch (l.tag) {
                                                    case 0:
                                                    case 11:
                                                    case 15:
                                                        mo(9, l)
                                                }
                                            } catch (M) {
                                                qa(l, l.return, M)
                                            }
                                            if (l === s) {
                                                co = null;
                                                break e
                                            }
                                            var _ = l.sibling;
                                            if (null !== _) {
                                                _.return = l.return, co = _;
                                                break e
                                            }
                                            co = l.return
                                        }
                                    }
                                    if (Ko = i, Yt(), Vt && "function" === typeof Vt.onPostCommitFiberRoot) try {
                                        Vt.onPostCommitFiberRoot(Gt, e)
                                    } catch (M) {}
                                    r = !0
                                }
                                return r
                            } finally {
                                Ot = n, Xo.transition = t
                            }
                        }
                        return !1
                    }

                    function Va(e, t, n) {
                        vn(e, t = Ai(0, t = vi(n, t), 1)), t = _a(), null !== (e = Aa(e, 1)) && (Rt(e, 1, t), Sa(e, t))
                    }

                    function qa(e, t, n) {
                        if (3 === e.tag) Va(e, e, n);
                        else
                            for (; null !== t;) {
                                if (3 === t.tag) {
                                    Va(t, e, n);
                                    break
                                }
                                if (1 === t.tag) {
                                    var r = t.stateNode;
                                    if ("function" === typeof t.type.getDerivedStateFromError || "function" === typeof r.componentDidCatch && (null === pa || !pa.has(r))) {
                                        vn(t, e = Si(t, e = vi(n, e), 1)), e = _a(), null !== (t = Aa(t, 1)) && (Rt(t, 1, e), Sa(t, e));
                                        break
                                    }
                                }
                                t = t.return
                            }
                    }

                    function Wa(e, t, n) {
                        var r = e.pingCache;
                        null !== r && r.delete(t), t = _a(), e.pingedLanes |= e.suspendedLanes & n, Jo === e && (Qo & n) === n && (4 === ea || 3 === ea && (130023424 & Qo) === Qo && 500 > Ft() - sa ? Ba(e, 0) : ia |= n), Sa(e, t)
                    }

                    function Xa(e, t) {
                        0 === t && (0 === (1 & e.mode) ? t = 1 : (t = At, 0 === (130023424 & (At <<= 1)) && (At = 4194304)));
                        var n = _a();
                        null !== (e = Aa(e, t)) && (Rt(e, t, n), Sa(e, n))
                    }

                    function Ka(e) {
                        var t = e.memoizedState,
                            n = 0;
                        null !== t && (n = t.retryLane), Xa(e, n)
                    }

                    function Ja(e, t) {
                        var n = 0;
                        switch (e.tag) {
                            case 13:
                                var r = e.stateNode,
                                    i = e.memoizedState;
                                null !== i && (n = i.retryLane);
                                break;
                            case 19:
                                r = e.stateNode;
                                break;
                            default:
                                throw Error(a(314))
                        }
                        null !== r && r.delete(t), Xa(e, n)
                    }

                    function Ya(e, t) {
                        return Lt(e, t)
                    }

                    function Qa(e, t, n, r) {
                        this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
                    }

                    function Za(e, t, n, r) {
                        return new Qa(e, t, n, r)
                    }

                    function $a(e) {
                        return !(!(e = e.prototype) || !e.isReactComponent)
                    }

                    function es(e, t) {
                        var n = e.alternate;
                        return null === n ? ((n = Za(e.tag, t, e.key, e.mode)).elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = 14680064 & e.flags, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = null === t ? null : {
                            lanes: t.lanes,
                            firstContext: t.firstContext
                        }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n
                    }

                    function ts(e, t, n, r, i, o) {
                        var s = 2;
                        if (r = e, "function" === typeof e) $a(e) && (s = 1);
                        else if ("string" === typeof e) s = 5;
                        else e: switch (e) {
                            case u:
                                return ns(n.children, i, o, t);
                            case d:
                                s = 8, i |= 8;
                                break;
                            case h:
                                return (e = Za(12, n, t, 2 | i)).elementType = h, e.lanes = o, e;
                            case g:
                                return (e = Za(13, n, t, i)).elementType = g, e.lanes = o, e;
                            case v:
                                return (e = Za(19, n, t, i)).elementType = v, e.lanes = o, e;
                            case x:
                                return rs(n, i, o, t);
                            default:
                                if ("object" === typeof e && null !== e) switch (e.$$typeof) {
                                    case p:
                                        s = 10;
                                        break e;
                                    case f:
                                        s = 9;
                                        break e;
                                    case m:
                                        s = 11;
                                        break e;
                                    case y:
                                        s = 14;
                                        break e;
                                    case b:
                                        s = 16, r = null;
                                        break e
                                }
                                throw Error(a(130, null == e ? e : typeof e, ""))
                        }
                        return (t = Za(s, n, t, i)).elementType = e, t.type = r, t.lanes = o, t
                    }

                    function ns(e, t, n, r) {
                        return (e = Za(7, e, r, t)).lanes = n, e
                    }

                    function rs(e, t, n, r) {
                        return (e = Za(22, e, r, t)).elementType = x, e.lanes = n, e.stateNode = {}, e
                    }

                    function is(e, t, n) {
                        return (e = Za(6, e, null, t)).lanes = n, e
                    }

                    function os(e, t, n) {
                        return (t = Za(4, null !== e.children ? e.children : [], e.key, t)).lanes = n, t.stateNode = {
                            containerInfo: e.containerInfo,
                            pendingChildren: null,
                            implementation: e.implementation
                        }, t
                    }

                    function as(e, t, n, r, i) {
                        this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = W, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Pt(0), this.expirationTimes = Pt(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Pt(0), this.identifierPrefix = r, this.onRecoverableError = i, Y && (this.mutableSourceEagerHydrationData = null)
                    }

                    function ss(e, t, n, r, i, o, a, s, l) {
                        return e = new as(e, t, n, s, l), 1 === t ? (t = 1, !0 === o && (t |= 8)) : t = 0, o = Za(3, null, null, t), e.current = o, o.stateNode = e, o.memoizedState = {
                            element: r,
                            isDehydrated: n,
                            cache: null,
                            transitions: null
                        }, fn(o), e
                    }

                    function ls(e) {
                        if (!e) return ct;
                        e: {
                            if (S(e = e._reactInternals) !== e || 1 !== e.tag) throw Error(a(170));
                            var t = e;do {
                                switch (t.tag) {
                                    case 3:
                                        t = t.stateNode.context;
                                        break e;
                                    case 1:
                                        if (ft(t.type)) {
                                            t = t.stateNode.__reactInternalMemoizedMergedChildContext;
                                            break e
                                        }
                                }
                                t = t.return
                            } while (null !== t);
                            throw Error(a(171))
                        }
                        if (1 === e.tag) {
                            var n = e.type;
                            if (ft(n)) return vt(e, n, t)
                        }
                        return t
                    }

                    function cs(e) {
                        var t = e._reactInternals;
                        if (void 0 === t) {
                            if ("function" === typeof e.render) throw Error(a(188));
                            throw e = Object.keys(e).join(","), Error(a(268, e))
                        }
                        return null === (e = T(t)) ? null : e.stateNode
                    }

                    function us(e, t) {
                        if (null !== (e = e.memoizedState) && null !== e.dehydrated) {
                            var n = e.retryLane;
                            e.retryLane = 0 !== n && n < t ? n : t
                        }
                    }

                    function ds(e, t) {
                        us(e, t), (e = e.alternate) && us(e, t)
                    }

                    function hs(e) {
                        return null === (e = T(e)) ? null : e.stateNode
                    }

                    function ps() {
                        return null
                    }
                    return ua = function(e, t, n) {
                        if (null !== e)
                            if (e.memoizedProps !== t.pendingProps || dt.current) Ni = !0;
                            else {
                                if (0 === (e.lanes & n) && 0 === (128 & t.flags)) return Ni = !1,
                                    function(e, t, n) {
                                        switch (t.tag) {
                                            case 3:
                                                Wi(t), $n();
                                                break;
                                            case 5:
                                                fr(t);
                                                break;
                                            case 1:
                                                ft(t.type) && yt(t);
                                                break;
                                            case 4:
                                                hr(t, t.stateNode.containerInfo);
                                                break;
                                            case 10:
                                                sn(0, t.type._context, t.memoizedProps.value);
                                                break;
                                            case 13:
                                                var r = t.memoizedState;
                                                if (null !== r) return null !== r.dehydrated ? (lt(gr, 1 & gr.current), t.flags |= 128, null) : 0 !== (n & t.child.childLanes) ? Yi(e, t, n) : (lt(gr, 1 & gr.current), null !== (e = io(e, t, n)) ? e.sibling : null);
                                                lt(gr, 1 & gr.current);
                                                break;
                                            case 19:
                                                if (r = 0 !== (n & t.childLanes), 0 !== (128 & e.flags)) {
                                                    if (r) return ro(e, t, n);
                                                    t.flags |= 128
                                                }
                                                var i = t.memoizedState;
                                                if (null !== i && (i.rendering = null, i.tail = null, i.lastEffect = null), lt(gr, gr.current), r) break;
                                                return null;
                                            case 22:
                                            case 23:
                                                return t.lanes = 0, Hi(e, t, n)
                                        }
                                        return io(e, t, n)
                                    }(e, t, n);
                                Ni = 0 !== (131072 & e.flags)
                            }
                        else Ni = !1, Vn && 0 !== (1048576 & t.flags) && Un(t, On, t.index);
                        switch (t.lanes = 0, t.tag) {
                            case 2:
                                var r = t.type;
                                null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2), e = t.pendingProps;
                                var i = pt(t, ut.current);
                                un(t, n), i = Or(null, t, r, e, i, n);
                                var o = Br();
                                return t.flags |= 1, "object" === typeof i && null !== i && "function" === typeof i.render && void 0 === i.$$typeof ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, ft(r) ? (o = !0, yt(t)) : o = !1, t.memoizedState = null !== i.state && void 0 !== i.state ? i.state : null, fn(t), i.updater = An, t.stateNode = i, i._reactInternals = t, Tn(t, r, e, n), t = qi(null, t, r, !0, o, n)) : (t.tag = 0, Vn && o && zn(t), ki(null, t, i, n), t = t.child), t;
                            case 16:
                                r = t.elementType;
                                e: {
                                    switch (null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2), e = t.pendingProps, r = (i = r._init)(r._payload), t.type = r, i = t.tag = function(e) {
                                        if ("function" === typeof e) return $a(e) ? 1 : 0;
                                        if (void 0 !== e && null !== e) {
                                            if ((e = e.$$typeof) === m) return 11;
                                            if (e === y) return 14
                                        }
                                        return 2
                                    }(r), e = en(r, e), i) {
                                        case 0:
                                            t = Gi(null, t, r, e, n);
                                            break e;
                                        case 1:
                                            t = Vi(null, t, r, e, n);
                                            break e;
                                        case 11:
                                            t = Fi(null, t, r, e, n);
                                            break e;
                                        case 14:
                                            t = Ui(null, t, r, en(r.type, e), n);
                                            break e
                                    }
                                    throw Error(a(306, r, ""))
                                }
                                return t;
                            case 0:
                                return r = t.type, i = t.pendingProps, Gi(e, t, r, i = t.elementType === r ? i : en(r, i), n);
                            case 1:
                                return r = t.type, i = t.pendingProps, Vi(e, t, r, i = t.elementType === r ? i : en(r, i), n);
                            case 3:
                                e: {
                                    if (Wi(t), null === e) throw Error(a(387));r = t.pendingProps,
                                    i = (o = t.memoizedState).element,
                                    mn(e, t),
                                    xn(t, r, null, n);
                                    var s = t.memoizedState;
                                    if (r = s.element, Y && o.isDehydrated) {
                                        if (o = {
                                                element: r,
                                                isDehydrated: !1,
                                                cache: s.cache,
                                                transitions: s.transitions
                                            }, t.updateQueue.baseState = o, t.memoizedState = o, 256 & t.flags) {
                                            t = Xi(e, t, r, n, i = Error(a(423)));
                                            break e
                                        }
                                        if (r !== i) {
                                            t = Xi(e, t, r, n, i = Error(a(424)));
                                            break e
                                        }
                                        for (Y && (Gn = He(t.stateNode.containerInfo), jn = t, Vn = !0, Wn = null, qn = !1), n = ar(t, null, r, n), t.child = n; n;) n.flags = -3 & n.flags | 4096, n = n.sibling
                                    } else {
                                        if ($n(), r === i) {
                                            t = io(e, t, n);
                                            break e
                                        }
                                        ki(e, t, r, n)
                                    }
                                    t = t.child
                                }
                                return t;
                            case 5:
                                return fr(t), null === e && Yn(t), r = t.type, i = t.pendingProps, o = null !== e ? e.memoizedProps : null, s = i.children, j(r, i) ? s = null : null !== o && j(r, o) && (t.flags |= 32), ji(e, t), ki(e, t, s, n), t.child;
                            case 6:
                                return null === e && Yn(t), null;
                            case 13:
                                return Yi(e, t, n);
                            case 4:
                                return hr(t, t.stateNode.containerInfo), r = t.pendingProps, null === e ? t.child = or(t, null, r, n) : ki(e, t, r, n), t.child;
                            case 11:
                                return r = t.type, i = t.pendingProps, Fi(e, t, r, i = t.elementType === r ? i : en(r, i), n);
                            case 7:
                                return ki(e, t, t.pendingProps, n), t.child;
                            case 8:
                            case 12:
                                return ki(e, t, t.pendingProps.children, n), t.child;
                            case 10:
                                e: {
                                    if (r = t.type._context, i = t.pendingProps, o = t.memoizedProps, sn(0, r, s = i.value), null !== o)
                                        if (qt(o.value, s)) {
                                            if (o.children === i.children && !dt.current) {
                                                t = io(e, t, n);
                                                break e
                                            }
                                        } else
                                            for (null !== (o = t.child) && (o.return = t); null !== o;) {
                                                var l = o.dependencies;
                                                if (null !== l) {
                                                    s = o.child;
                                                    for (var c = l.firstContext; null !== c;) {
                                                        if (c.context === r) {
                                                            if (1 === o.tag) {
                                                                (c = gn(-1, n & -n)).tag = 2;
                                                                var u = o.updateQueue;
                                                                if (null !== u) {
                                                                    var d = (u = u.shared).pending;
                                                                    null === d ? c.next = c : (c.next = d.next, d.next = c), u.pending = c
                                                                }
                                                            }
                                                            o.lanes |= n, null !== (c = o.alternate) && (c.lanes |= n), cn(o.return, n, t), l.lanes |= n;
                                                            break
                                                        }
                                                        c = c.next
                                                    }
                                                } else if (10 === o.tag) s = o.type === t.type ? null : o.child;
                                                else if (18 === o.tag) {
                                                    if (null === (s = o.return)) throw Error(a(341));
                                                    s.lanes |= n, null !== (l = s.alternate) && (l.lanes |= n), cn(s, n, t), s = o.sibling
                                                } else s = o.child;
                                                if (null !== s) s.return = o;
                                                else
                                                    for (s = o; null !== s;) {
                                                        if (s === t) {
                                                            s = null;
                                                            break
                                                        }
                                                        if (null !== (o = s.sibling)) {
                                                            o.return = s.return, s = o;
                                                            break
                                                        }
                                                        s = s.return
                                                    }
                                                o = s
                                            }
                                    ki(e, t, i.children, n),
                                    t = t.child
                                }
                                return t;
                            case 9:
                                return i = t.type, r = t.pendingProps.children, un(t, n), r = r(i = dn(i)), t.flags |= 1, ki(e, t, r, n), t.child;
                            case 14:
                                return i = en(r = t.type, t.pendingProps), Ui(e, t, r, i = en(r.type, i), n);
                            case 15:
                                return zi(e, t, t.type, t.pendingProps, n);
                            case 17:
                                return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : en(r, i), null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2), t.tag = 1, ft(r) ? (e = !0, yt(t)) : e = !1, un(t, n), En(t, r, i), Tn(t, r, i, n), qi(null, t, r, !0, e, n);
                            case 19:
                                return ro(e, t, n);
                            case 22:
                                return Hi(e, t, n)
                        }
                        throw Error(a(156, t.tag))
                    }, t.attemptContinuousHydration = function(e) {
                        13 === e.tag && (wa(e, 134217728, _a()), ds(e, 134217728))
                    }, t.attemptHydrationAtCurrentPriority = function(e) {
                        if (13 === e.tag) {
                            var t = _a(),
                                n = Ma(e);
                            wa(e, n, t), ds(e, n)
                        }
                    }, t.attemptSynchronousHydration = function(e) {
                        switch (e.tag) {
                            case 3:
                                var t = e.stateNode;
                                if (t.current.memoizedState.isDehydrated) {
                                    var n = St(t.pendingLanes);
                                    0 !== n && (It(t, 1 | n), Sa(t, Ft()), 0 === (6 & Ko) && (ca(), Yt()))
                                }
                                break;
                            case 13:
                                var r = _a();
                                Ia((function() {
                                    return wa(e, 1, r)
                                })), ds(e, 1)
                        }
                    }, t.batchedUpdates = function(e, t) {
                        var n = Ko;
                        Ko |= 1;
                        try {
                            return e(t)
                        } finally {
                            0 === (Ko = n) && (ca(), Xt && Yt())
                        }
                    }, t.createComponentSelector = function(e) {
                        return {
                            $$typeof: Bo,
                            value: e
                        }
                    }, t.createContainer = function(e, t, n, r, i, o, a) {
                        return ss(e, t, !1, null, 0, r, 0, o, a)
                    }, t.createHasPseudoClassSelector = function(e) {
                        return {
                            $$typeof: Lo,
                            value: e
                        }
                    }, t.createHydrationContainer = function(e, t, n, r, i, o, a, s, l) {
                        return (e = ss(n, r, !0, e, 0, o, 0, s, l)).context = ls(null), n = e.current, (o = gn(r = _a(), i = Ma(n))).callback = void 0 !== t && null !== t ? t : null, vn(n, o), e.current.lanes = i, Rt(e, i, r), Sa(e, r), e
                    }, t.createPortal = function(e, t, n) {
                        var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
                        return {
                            $$typeof: c,
                            key: null == r ? null : "" + r,
                            children: e,
                            containerInfo: t,
                            implementation: n
                        }
                    }, t.createRoleSelector = function(e) {
                        return {
                            $$typeof: Do,
                            value: e
                        }
                    }, t.createTestNameSelector = function(e) {
                        return {
                            $$typeof: No,
                            value: e
                        }
                    }, t.createTextSelector = function(e) {
                        return {
                            $$typeof: ko,
                            value: e
                        }
                    }, t.deferredUpdates = function(e) {
                        var t = Ot,
                            n = Xo.transition;
                        try {
                            return Xo.transition = null, Ot = 16, e()
                        } finally {
                            Ot = t, Xo.transition = n
                        }
                    }, t.discreteUpdates = function(e, t, n, r, i) {
                        var o = Ot,
                            a = Xo.transition;
                        try {
                            return Xo.transition = null, Ot = 1, e(t, n, r, i)
                        } finally {
                            Ot = o, Xo.transition = a, 0 === Ko && ca()
                        }
                    }, t.findAllNodes = Go, t.findBoundingRects = function(e, t) {
                        if (!re) throw Error(a(363));
                        t = Go(e, t), e = [];
                        for (var n = 0; n < t.length; n++) e.push(oe(t[n]));
                        for (t = e.length - 1; 0 < t; t--)
                            for (var r = (n = e[t]).x, i = r + n.width, o = n.y, s = o + n.height, l = t - 1; 0 <= l; l--)
                                if (t !== l) {
                                    var c = e[l],
                                        u = c.x,
                                        d = u + c.width,
                                        h = c.y,
                                        p = h + c.height;
                                    if (r >= u && o >= h && i <= d && s <= p) {
                                        e.splice(t, 1);
                                        break
                                    }
                                    if (!(r !== u || n.width !== c.width || p < o || h > s)) {
                                        h > o && (c.height += h - o, c.y = o), p < s && (c.height = s - h), e.splice(t, 1);
                                        break
                                    }
                                    if (!(o !== h || n.height !== c.height || d < r || u > i)) {
                                        u > r && (c.width += u - r, c.x = r), d < i && (c.width = i - u), e.splice(t, 1);
                                        break
                                    }
                                }
                        return e
                    }, t.findHostInstance = cs, t.findHostInstanceWithNoPortals = function(e) {
                        return null === (e = null !== (e = C(e)) ? R(e) : null) ? null : e.stateNode
                    }, t.findHostInstanceWithWarning = function(e) {
                        return cs(e)
                    }, t.flushControlled = function(e) {
                        var t = Ko;
                        Ko |= 1;
                        var n = Xo.transition,
                            r = Ot;
                        try {
                            Xo.transition = null, Ot = 1, e()
                        } finally {
                            Ot = r, Xo.transition = n, 0 === (Ko = t) && (ca(), Yt())
                        }
                    }, t.flushPassiveEffects = Ga, t.flushSync = Ia, t.focusWithin = function(e, t) {
                        if (!re) throw Error(a(363));
                        for (t = jo(e = Uo(e), t), t = Array.from(t), e = 0; e < t.length;) {
                            var n = t[e++];
                            if (!se(n)) {
                                if (5 === n.tag && ce(n.stateNode)) return !0;
                                for (n = n.child; null !== n;) t.push(n), n = n.sibling
                            }
                        }
                        return !1
                    }, t.getCurrentUpdatePriority = function() {
                        return Ot
                    }, t.getFindAllNodesFailureDescription = function(e, t) {
                        if (!re) throw Error(a(363));
                        var n = 0,
                            r = [];
                        e = [Uo(e), 0];
                        for (var i = 0; i < e.length;) {
                            var o = e[i++],
                                s = e[i++],
                                l = t[s];
                            if ((5 !== o.tag || !se(o)) && (zo(o, l) && (r.push(Ho(l)), ++s > n && (n = s)), s < t.length))
                                for (o = o.child; null !== o;) e.push(o, s), o = o.sibling
                        }
                        if (n < t.length) {
                            for (e = []; n < t.length; n++) e.push(Ho(t[n]));
                            return "findAllNodes was able to match part of the selector:\n  " + r.join(" > ") + "\n\nNo matching component was found for:\n  " + e.join(" > ")
                        }
                        return null
                    }, t.getPublicRootInstance = function(e) {
                        return (e = e.current).child ? 5 === e.child.tag ? B(e.child.stateNode) : e.child.stateNode : null
                    }, t.injectIntoDevTools = function(e) {
                        if (e = {
                                bundleType: e.bundleType,
                                version: e.version,
                                rendererPackageName: e.rendererPackageName,
                                rendererConfig: e.rendererConfig,
                                overrideHookState: null,
                                overrideHookStateDeletePath: null,
                                overrideHookStateRenamePath: null,
                                overrideProps: null,
                                overridePropsDeletePath: null,
                                overridePropsRenamePath: null,
                                setErrorHandler: null,
                                setSuspenseHandler: null,
                                scheduleUpdate: null,
                                currentDispatcherRef: s.ReactCurrentDispatcher,
                                findHostInstanceByFiber: hs,
                                findFiberByHostInstance: e.findFiberByHostInstance || ps,
                                findHostInstancesForRefresh: null,
                                scheduleRefresh: null,
                                scheduleRoot: null,
                                setRefreshHandler: null,
                                getCurrentFiber: null,
                                reconcilerVersion: "18.0.0-fc46dba67-20220329"
                            }, "undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) e = !1;
                        else {
                            var t = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                            if (t.isDisabled || !t.supportsFiber) e = !0;
                            else {
                                try {
                                    Gt = t.inject(e), Vt = t
                                } catch (n) {}
                                e = !!t.checkDCE
                            }
                        }
                        return e
                    }, t.isAlreadyRendering = function() {
                        return !1
                    }, t.observeVisibleRects = function(e, t, n, r) {
                        if (!re) throw Error(a(363));
                        e = Go(e, t);
                        var i = ue(e, n, r).disconnect;
                        return {
                            disconnect: function() {
                                i()
                            }
                        }
                    }, t.registerMutableSourceForHydration = function(e, t) {
                        var n = t._getVersion;
                        n = n(t._source), null == e.mutableSourceEagerHydrationData ? e.mutableSourceEagerHydrationData = [t, n] : e.mutableSourceEagerHydrationData.push(t, n)
                    }, t.runWithPriority = function(e, t) {
                        var n = Ot;
                        try {
                            return Ot = e, t()
                        } finally {
                            Ot = n
                        }
                    }, t.shouldError = function() {
                        return null
                    }, t.shouldSuspend = function() {
                        return !1
                    }, t.updateContainer = function(e, t, n, r) {
                        var i = t.current,
                            o = _a(),
                            a = Ma(i);
                        return n = ls(n), null === t.context ? t.context = n : t.pendingContext = n, (t = gn(o, a)).payload = {
                            element: e
                        }, null !== (r = void 0 === r ? null : r) && (t.callback = r), vn(i, t), null !== (e = wa(i, a, o)) && yn(e, i, a), a
                    }, t
                }
            },
            1920: (e, t, n) => {
                "use strict";
                e.exports = n(2280)
            },
            4384: (e, t, n) => {
                "use strict";
                e.exports = n(3744)
            },
            724: (e, t) => {
                "use strict";

                function n(e, t) {
                    var n = e.length;
                    e.push(t);
                    e: for (; 0 < n;) {
                        var r = n - 1 >>> 1,
                            i = e[r];
                        if (!(0 < o(i, t))) break e;
                        e[r] = t, e[n] = i, n = r
                    }
                }

                function r(e) {
                    return 0 === e.length ? null : e[0]
                }

                function i(e) {
                    if (0 === e.length) return null;
                    var t = e[0],
                        n = e.pop();
                    if (n !== t) {
                        e[0] = n;
                        e: for (var r = 0, i = e.length, a = i >>> 1; r < a;) {
                            var s = 2 * (r + 1) - 1,
                                l = e[s],
                                c = s + 1,
                                u = e[c];
                            if (0 > o(l, n)) c < i && 0 > o(u, l) ? (e[r] = u, e[c] = n, r = c) : (e[r] = l, e[s] = n, r = s);
                            else {
                                if (!(c < i && 0 > o(u, n))) break e;
                                e[r] = u, e[c] = n, r = c
                            }
                        }
                    }
                    return t
                }

                function o(e, t) {
                    var n = e.sortIndex - t.sortIndex;
                    return 0 !== n ? n : e.id - t.id
                }
                if ("object" === typeof performance && "function" === typeof performance.now) {
                    var a = performance;
                    t.unstable_now = function() {
                        return a.now()
                    }
                } else {
                    var s = Date,
                        l = s.now();
                    t.unstable_now = function() {
                        return s.now() - l
                    }
                }
                var c = [],
                    u = [],
                    d = 1,
                    h = null,
                    p = 3,
                    f = !1,
                    m = !1,
                    g = !1,
                    v = "function" === typeof setTimeout ? setTimeout : null,
                    y = "function" === typeof clearTimeout ? clearTimeout : null,
                    b = "undefined" !== typeof setImmediate ? setImmediate : null;

                function x(e) {
                    for (var t = r(u); null !== t;) {
                        if (null === t.callback) i(u);
                        else {
                            if (!(t.startTime <= e)) break;
                            i(u), t.sortIndex = t.expirationTime, n(c, t)
                        }
                        t = r(u)
                    }
                }

                function _(e) {
                    if (g = !1, x(e), !m)
                        if (null !== r(c)) m = !0, B(M);
                        else {
                            var t = r(u);
                            null !== t && L(_, t.startTime - e)
                        }
                }

                function M(e, n) {
                    m = !1, g && (g = !1, y(E), E = -1), f = !0;
                    var o = p;
                    try {
                        for (x(n), h = r(c); null !== h && (!(h.expirationTime > n) || e && !P());) {
                            var a = h.callback;
                            if ("function" === typeof a) {
                                h.callback = null, p = h.priorityLevel;
                                var s = a(h.expirationTime <= n);
                                n = t.unstable_now(), "function" === typeof s ? h.callback = s : h === r(c) && i(c), x(n)
                            } else i(c);
                            h = r(c)
                        }
                        if (null !== h) var l = !0;
                        else {
                            var d = r(u);
                            null !== d && L(_, d.startTime - n), l = !1
                        }
                        return l
                    } finally {
                        h = null, p = o, f = !1
                    }
                }
                "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
                var w, A = !1,
                    S = null,
                    E = -1,
                    C = 5,
                    T = -1;

                function P() {
                    return !(t.unstable_now() - T < C)
                }

                function R() {
                    if (null !== S) {
                        var e = t.unstable_now();
                        T = e;
                        var n = !0;
                        try {
                            n = S(!0, e)
                        } finally {
                            n ? w() : (A = !1, S = null)
                        }
                    } else A = !1
                }
                if ("function" === typeof b) w = function() {
                    b(R)
                };
                else if ("undefined" !== typeof MessageChannel) {
                    var I = new MessageChannel,
                        O = I.port2;
                    I.port1.onmessage = R, w = function() {
                        O.postMessage(null)
                    }
                } else w = function() {
                    v(R, 0)
                };

                function B(e) {
                    S = e, A || (A = !0, w())
                }

                function L(e, n) {
                    E = v((function() {
                        e(t.unstable_now())
                    }), n)
                }
                t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(e) {
                    e.callback = null
                }, t.unstable_continueExecution = function() {
                    m || f || (m = !0, B(M))
                }, t.unstable_forceFrameRate = function(e) {
                    0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : C = 0 < e ? Math.floor(1e3 / e) : 5
                }, t.unstable_getCurrentPriorityLevel = function() {
                    return p
                }, t.unstable_getFirstCallbackNode = function() {
                    return r(c)
                }, t.unstable_next = function(e) {
                    switch (p) {
                        case 1:
                        case 2:
                        case 3:
                            var t = 3;
                            break;
                        default:
                            t = p
                    }
                    var n = p;
                    p = t;
                    try {
                        return e()
                    } finally {
                        p = n
                    }
                }, t.unstable_pauseExecution = function() {}, t.unstable_requestPaint = function() {}, t.unstable_runWithPriority = function(e, t) {
                    switch (e) {
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        default:
                            e = 3
                    }
                    var n = p;
                    p = e;
                    try {
                        return t()
                    } finally {
                        p = n
                    }
                }, t.unstable_scheduleCallback = function(e, i, o) {
                    var a = t.unstable_now();
                    switch ("object" === typeof o && null !== o ? o = "number" === typeof(o = o.delay) && 0 < o ? a + o : a : o = a, e) {
                        case 1:
                            var s = -1;
                            break;
                        case 2:
                            s = 250;
                            break;
                        case 5:
                            s = 1073741823;
                            break;
                        case 4:
                            s = 1e4;
                            break;
                        default:
                            s = 5e3
                    }
                    return e = {
                        id: d++,
                        callback: i,
                        priorityLevel: e,
                        startTime: o,
                        expirationTime: s = o + s,
                        sortIndex: -1
                    }, o > a ? (e.sortIndex = o, n(u, e), null === r(c) && e === r(u) && (g ? (y(E), E = -1) : g = !0, L(_, o - a))) : (e.sortIndex = s, n(c, e), m || f || (m = !0, B(M))), e
                }, t.unstable_shouldYield = P, t.unstable_wrapCallback = function(e) {
                    var t = p;
                    return function() {
                        var n = p;
                        p = t;
                        try {
                            return e.apply(this, arguments)
                        } finally {
                            p = n
                        }
                    }
                }
            },
            752: (e, t, n) => {
                "use strict";
                e.exports = n(724)
            },
            1808: (e, t, n) => {
                "use strict";
                var r = n(9584),
                    i = Symbol.for("react.element"),
                    o = Symbol.for("react.fragment"),
                    a = Object.prototype.hasOwnProperty,
                    s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
                    l = {
                        key: !0,
                        ref: !0,
                        __self: !0,
                        __source: !0
                    };

                function c(e, t, n) {
                    var r, o = {},
                        c = null,
                        u = null;
                    for (r in void 0 !== n && (c = "" + n), void 0 !== t.key && (c = "" + t.key), void 0 !== t.ref && (u = t.ref), t) a.call(t, r) && !l.hasOwnProperty(r) && (o[r] = t[r]);
                    if (e && e.defaultProps)
                        for (r in t = e.defaultProps) void 0 === o[r] && (o[r] = t[r]);
                    return {
                        $$typeof: i,
                        type: e,
                        key: c,
                        ref: u,
                        props: o,
                        _owner: s.current
                    }
                }
                t.Fragment = o, t.jsx = c, t.jsxs = c
            },
            2052: (e, t) => {
                "use strict";
                var n = Symbol.for("react.element"),
                    r = Symbol.for("react.portal"),
                    i = Symbol.for("react.fragment"),
                    o = Symbol.for("react.strict_mode"),
                    a = Symbol.for("react.profiler"),
                    s = Symbol.for("react.provider"),
                    l = Symbol.for("react.context"),
                    c = Symbol.for("react.forward_ref"),
                    u = Symbol.for("react.suspense"),
                    d = Symbol.for("react.memo"),
                    h = Symbol.for("react.lazy"),
                    p = Symbol.iterator;
                var f = {
                        isMounted: function() {
                            return !1
                        },
                        enqueueForceUpdate: function() {},
                        enqueueReplaceState: function() {},
                        enqueueSetState: function() {}
                    },
                    m = Object.assign,
                    g = {};

                function v(e, t, n) {
                    this.props = e, this.context = t, this.refs = g, this.updater = n || f
                }

                function y() {}

                function b(e, t, n) {
                    this.props = e, this.context = t, this.refs = g, this.updater = n || f
                }
                v.prototype.isReactComponent = {}, v.prototype.setState = function(e, t) {
                    if ("object" !== typeof e && "function" !== typeof e && null != e) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
                    this.updater.enqueueSetState(this, e, t, "setState")
                }, v.prototype.forceUpdate = function(e) {
                    this.updater.enqueueForceUpdate(this, e, "forceUpdate")
                }, y.prototype = v.prototype;
                var x = b.prototype = new y;
                x.constructor = b, m(x, v.prototype), x.isPureReactComponent = !0;
                var _ = Array.isArray,
                    M = Object.prototype.hasOwnProperty,
                    w = {
                        current: null
                    },
                    A = {
                        key: !0,
                        ref: !0,
                        __self: !0,
                        __source: !0
                    };

                function S(e, t, r) {
                    var i, o = {},
                        a = null,
                        s = null;
                    if (null != t)
                        for (i in void 0 !== t.ref && (s = t.ref), void 0 !== t.key && (a = "" + t.key), t) M.call(t, i) && !A.hasOwnProperty(i) && (o[i] = t[i]);
                    var l = arguments.length - 2;
                    if (1 === l) o.children = r;
                    else if (1 < l) {
                        for (var c = Array(l), u = 0; u < l; u++) c[u] = arguments[u + 2];
                        o.children = c
                    }
                    if (e && e.defaultProps)
                        for (i in l = e.defaultProps) void 0 === o[i] && (o[i] = l[i]);
                    return {
                        $$typeof: n,
                        type: e,
                        key: a,
                        ref: s,
                        props: o,
                        _owner: w.current
                    }
                }

                function E(e) {
                    return "object" === typeof e && null !== e && e.$$typeof === n
                }
                var C = /\/+/g;

                function T(e, t) {
                    return "object" === typeof e && null !== e && null != e.key ? function(e) {
                        var t = {
                            "=": "=0",
                            ":": "=2"
                        };
                        return "$" + e.replace(/[=:]/g, (function(e) {
                            return t[e]
                        }))
                    }("" + e.key) : t.toString(36)
                }

                function P(e, t, i, o, a) {
                    var s = typeof e;
                    "undefined" !== s && "boolean" !== s || (e = null);
                    var l = !1;
                    if (null === e) l = !0;
                    else switch (s) {
                        case "string":
                        case "number":
                            l = !0;
                            break;
                        case "object":
                            switch (e.$$typeof) {
                                case n:
                                case r:
                                    l = !0
                            }
                    }
                    if (l) return a = a(l = e), e = "" === o ? "." + T(l, 0) : o, _(a) ? (i = "", null != e && (i = e.replace(C, "$&/") + "/"), P(a, t, i, "", (function(e) {
                        return e
                    }))) : null != a && (E(a) && (a = function(e, t) {
                        return {
                            $$typeof: n,
                            type: e.type,
                            key: t,
                            ref: e.ref,
                            props: e.props,
                            _owner: e._owner
                        }
                    }(a, i + (!a.key || l && l.key === a.key ? "" : ("" + a.key).replace(C, "$&/") + "/") + e)), t.push(a)), 1;
                    if (l = 0, o = "" === o ? "." : o + ":", _(e))
                        for (var c = 0; c < e.length; c++) {
                            var u = o + T(s = e[c], c);
                            l += P(s, t, i, u, a)
                        } else if (u = function(e) {
                                return null === e || "object" !== typeof e ? null : "function" === typeof(e = p && e[p] || e["@@iterator"]) ? e : null
                            }(e), "function" === typeof u)
                            for (e = u.call(e), c = 0; !(s = e.next()).done;) l += P(s = s.value, t, i, u = o + T(s, c++), a);
                        else if ("object" === s) throw t = String(e), Error("Objects are not valid as a React child (found: " + ("[object Object]" === t ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
                    return l
                }

                function R(e, t, n) {
                    if (null == e) return e;
                    var r = [],
                        i = 0;
                    return P(e, r, "", "", (function(e) {
                        return t.call(n, e, i++)
                    })), r
                }

                function I(e) {
                    if (-1 === e._status) {
                        var t = e._result;
                        (t = t()).then((function(t) {
                            0 !== e._status && -1 !== e._status || (e._status = 1, e._result = t)
                        }), (function(t) {
                            0 !== e._status && -1 !== e._status || (e._status = 2, e._result = t)
                        })), -1 === e._status && (e._status = 0, e._result = t)
                    }
                    if (1 === e._status) return e._result.default;
                    throw e._result
                }
                var O = {
                        current: null
                    },
                    B = {
                        transition: null
                    },
                    L = {
                        ReactCurrentDispatcher: O,
                        ReactCurrentBatchConfig: B,
                        ReactCurrentOwner: w
                    };
                t.Children = {
                    map: R,
                    forEach: function(e, t, n) {
                        R(e, (function() {
                            t.apply(this, arguments)
                        }), n)
                    },
                    count: function(e) {
                        var t = 0;
                        return R(e, (function() {
                            t++
                        })), t
                    },
                    toArray: function(e) {
                        return R(e, (function(e) {
                            return e
                        })) || []
                    },
                    only: function(e) {
                        if (!E(e)) throw Error("React.Children.only expected to receive a single React element child.");
                        return e
                    }
                }, t.Component = v, t.Fragment = i, t.Profiler = a, t.PureComponent = b, t.StrictMode = o, t.Suspense = u, t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = L, t.cloneElement = function(e, t, r) {
                    if (null === e || void 0 === e) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
                    var i = m({}, e.props),
                        o = e.key,
                        a = e.ref,
                        s = e._owner;
                    if (null != t) {
                        if (void 0 !== t.ref && (a = t.ref, s = w.current), void 0 !== t.key && (o = "" + t.key), e.type && e.type.defaultProps) var l = e.type.defaultProps;
                        for (c in t) M.call(t, c) && !A.hasOwnProperty(c) && (i[c] = void 0 === t[c] && void 0 !== l ? l[c] : t[c])
                    }
                    var c = arguments.length - 2;
                    if (1 === c) i.children = r;
                    else if (1 < c) {
                        l = Array(c);
                        for (var u = 0; u < c; u++) l[u] = arguments[u + 2];
                        i.children = l
                    }
                    return {
                        $$typeof: n,
                        type: e.type,
                        key: o,
                        ref: a,
                        props: i,
                        _owner: s
                    }
                }, t.createContext = function(e) {
                    return (e = {
                        $$typeof: l,
                        _currentValue: e,
                        _currentValue2: e,
                        _threadCount: 0,
                        Provider: null,
                        Consumer: null,
                        _defaultValue: null,
                        _globalName: null
                    }).Provider = {
                        $$typeof: s,
                        _context: e
                    }, e.Consumer = e
                }, t.createElement = S, t.createFactory = function(e) {
                    var t = S.bind(null, e);
                    return t.type = e, t
                }, t.createRef = function() {
                    return {
                        current: null
                    }
                }, t.forwardRef = function(e) {
                    return {
                        $$typeof: c,
                        render: e
                    }
                }, t.isValidElement = E, t.lazy = function(e) {
                    return {
                        $$typeof: h,
                        _payload: {
                            _status: -1,
                            _result: e
                        },
                        _init: I
                    }
                }, t.memo = function(e, t) {
                    return {
                        $$typeof: d,
                        type: e,
                        compare: void 0 === t ? null : t
                    }
                }, t.startTransition = function(e) {
                    var t = B.transition;
                    B.transition = {};
                    try {
                        e()
                    } finally {
                        B.transition = t
                    }
                }, t.unstable_act = function() {
                    throw Error("act(...) is not supported in production builds of React.")
                }, t.useCallback = function(e, t) {
                    return O.current.useCallback(e, t)
                }, t.useContext = function(e) {
                    return O.current.useContext(e)
                }, t.useDebugValue = function() {}, t.useDeferredValue = function(e) {
                    return O.current.useDeferredValue(e)
                }, t.useEffect = function(e, t) {
                    return O.current.useEffect(e, t)
                }, t.useId = function() {
                    return O.current.useId()
                }, t.useImperativeHandle = function(e, t, n) {
                    return O.current.useImperativeHandle(e, t, n)
                }, t.useInsertionEffect = function(e, t) {
                    return O.current.useInsertionEffect(e, t)
                }, t.useLayoutEffect = function(e, t) {
                    return O.current.useLayoutEffect(e, t)
                }, t.useMemo = function(e, t) {
                    return O.current.useMemo(e, t)
                }, t.useReducer = function(e, t, n) {
                    return O.current.useReducer(e, t, n)
                }, t.useRef = function(e) {
                    return O.current.useRef(e)
                }, t.useState = function(e) {
                    return O.current.useState(e)
                }, t.useSyncExternalStore = function(e, t, n) {
                    return O.current.useSyncExternalStore(e, t, n)
                }, t.useTransition = function() {
                    return O.current.useTransition()
                }, t.version = "18.2.0"
            },
            9584: (e, t, n) => {
                "use strict";
                e.exports = n(2052)
            },
            7884: (e, t, n) => {
                "use strict";
                e.exports = n(1808)
            },
            3728: (e, t, n) => {
                "use strict";
                var r = n(4588),
                    i = n(7896),
                    o = Object;
                e.exports = r((function() {
                    if (null == this || this !== o(this)) throw new i("RegExp.prototype.flags getter called on non-object");
                    var e = "";
                    return this.hasIndices && (e += "d"), this.global && (e += "g"), this.ignoreCase && (e += "i"), this.multiline && (e += "m"), this.dotAll && (e += "s"), this.unicode && (e += "u"), this.unicodeSets && (e += "v"), this.sticky && (e += "y"), e
                }), "get flags", !0)
            },
            8912: (e, t, n) => {
                "use strict";
                var r = n(108),
                    i = n(5520),
                    o = n(3728),
                    a = n(4700),
                    s = n(6672),
                    l = i(a());
                r(l, {
                    getPolyfill: a,
                    implementation: o,
                    shim: s
                }), e.exports = l
            },
            4700: (e, t, n) => {
                "use strict";
                var r = n(3728),
                    i = n(108).supportsDescriptors,
                    o = Object.getOwnPropertyDescriptor;
                e.exports = function() {
                    if (i && "gim" === /a/gim.flags) {
                        var e = o(RegExp.prototype, "flags");
                        if (e && "function" === typeof e.get && "boolean" === typeof RegExp.prototype.dotAll && "boolean" === typeof RegExp.prototype.hasIndices) {
                            var t = "",
                                n = {};
                            if (Object.defineProperty(n, "hasIndices", {
                                    get: function() {
                                        t += "d"
                                    }
                                }), Object.defineProperty(n, "sticky", {
                                    get: function() {
                                        t += "y"
                                    }
                                }), "dy" === t) return e.get
                        }
                    }
                    return r
                }
            },
            6672: (e, t, n) => {
                "use strict";
                var r = n(108).supportsDescriptors,
                    i = n(4700),
                    o = Object.getOwnPropertyDescriptor,
                    a = Object.defineProperty,
                    s = TypeError,
                    l = Object.getPrototypeOf,
                    c = /a/;
                e.exports = function() {
                    if (!r || !l) throw new s("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
                    var e = i(),
                        t = l(c),
                        n = o(t, "flags");
                    return n && n.get === e || a(t, "flags", {
                        configurable: !0,
                        enumerable: !1,
                        get: e
                    }), e
                }
            },
            9952: (e, t) => {
                "use strict";

                function n(e, t) {
                    var n = e.length;
                    e.push(t);
                    e: for (; 0 < n;) {
                        var r = n - 1 >>> 1,
                            i = e[r];
                        if (!(0 < o(i, t))) break e;
                        e[r] = t, e[n] = i, n = r
                    }
                }

                function r(e) {
                    return 0 === e.length ? null : e[0]
                }

                function i(e) {
                    if (0 === e.length) return null;
                    var t = e[0],
                        n = e.pop();
                    if (n !== t) {
                        e[0] = n;
                        e: for (var r = 0, i = e.length, a = i >>> 1; r < a;) {
                            var s = 2 * (r + 1) - 1,
                                l = e[s],
                                c = s + 1,
                                u = e[c];
                            if (0 > o(l, n)) c < i && 0 > o(u, l) ? (e[r] = u, e[c] = n, r = c) : (e[r] = l, e[s] = n, r = s);
                            else {
                                if (!(c < i && 0 > o(u, n))) break e;
                                e[r] = u, e[c] = n, r = c
                            }
                        }
                    }
                    return t
                }

                function o(e, t) {
                    var n = e.sortIndex - t.sortIndex;
                    return 0 !== n ? n : e.id - t.id
                }
                if ("object" === typeof performance && "function" === typeof performance.now) {
                    var a = performance;
                    t.unstable_now = function() {
                        return a.now()
                    }
                } else {
                    var s = Date,
                        l = s.now();
                    t.unstable_now = function() {
                        return s.now() - l
                    }
                }
                var c = [],
                    u = [],
                    d = 1,
                    h = null,
                    p = 3,
                    f = !1,
                    m = !1,
                    g = !1,
                    v = "function" === typeof setTimeout ? setTimeout : null,
                    y = "function" === typeof clearTimeout ? clearTimeout : null,
                    b = "undefined" !== typeof setImmediate ? setImmediate : null;

                function x(e) {
                    for (var t = r(u); null !== t;) {
                        if (null === t.callback) i(u);
                        else {
                            if (!(t.startTime <= e)) break;
                            i(u), t.sortIndex = t.expirationTime, n(c, t)
                        }
                        t = r(u)
                    }
                }

                function _(e) {
                    if (g = !1, x(e), !m)
                        if (null !== r(c)) m = !0, B(M);
                        else {
                            var t = r(u);
                            null !== t && L(_, t.startTime - e)
                        }
                }

                function M(e, n) {
                    m = !1, g && (g = !1, y(E), E = -1), f = !0;
                    var o = p;
                    try {
                        for (x(n), h = r(c); null !== h && (!(h.expirationTime > n) || e && !P());) {
                            var a = h.callback;
                            if ("function" === typeof a) {
                                h.callback = null, p = h.priorityLevel;
                                var s = a(h.expirationTime <= n);
                                n = t.unstable_now(), "function" === typeof s ? h.callback = s : h === r(c) && i(c), x(n)
                            } else i(c);
                            h = r(c)
                        }
                        if (null !== h) var l = !0;
                        else {
                            var d = r(u);
                            null !== d && L(_, d.startTime - n), l = !1
                        }
                        return l
                    } finally {
                        h = null, p = o, f = !1
                    }
                }
                "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
                var w, A = !1,
                    S = null,
                    E = -1,
                    C = 5,
                    T = -1;

                function P() {
                    return !(t.unstable_now() - T < C)
                }

                function R() {
                    if (null !== S) {
                        var e = t.unstable_now();
                        T = e;
                        var n = !0;
                        try {
                            n = S(!0, e)
                        } finally {
                            n ? w() : (A = !1, S = null)
                        }
                    } else A = !1
                }
                if ("function" === typeof b) w = function() {
                    b(R)
                };
                else if ("undefined" !== typeof MessageChannel) {
                    var I = new MessageChannel,
                        O = I.port2;
                    I.port1.onmessage = R, w = function() {
                        O.postMessage(null)
                    }
                } else w = function() {
                    v(R, 0)
                };

                function B(e) {
                    S = e, A || (A = !0, w())
                }

                function L(e, n) {
                    E = v((function() {
                        e(t.unstable_now())
                    }), n)
                }
                t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(e) {
                    e.callback = null
                }, t.unstable_continueExecution = function() {
                    m || f || (m = !0, B(M))
                }, t.unstable_forceFrameRate = function(e) {
                    0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : C = 0 < e ? Math.floor(1e3 / e) : 5
                }, t.unstable_getCurrentPriorityLevel = function() {
                    return p
                }, t.unstable_getFirstCallbackNode = function() {
                    return r(c)
                }, t.unstable_next = function(e) {
                    switch (p) {
                        case 1:
                        case 2:
                        case 3:
                            var t = 3;
                            break;
                        default:
                            t = p
                    }
                    var n = p;
                    p = t;
                    try {
                        return e()
                    } finally {
                        p = n
                    }
                }, t.unstable_pauseExecution = function() {}, t.unstable_requestPaint = function() {}, t.unstable_runWithPriority = function(e, t) {
                    switch (e) {
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        default:
                            e = 3
                    }
                    var n = p;
                    p = e;
                    try {
                        return t()
                    } finally {
                        p = n
                    }
                }, t.unstable_scheduleCallback = function(e, i, o) {
                    var a = t.unstable_now();
                    switch ("object" === typeof o && null !== o ? o = "number" === typeof(o = o.delay) && 0 < o ? a + o : a : o = a, e) {
                        case 1:
                            var s = -1;
                            break;
                        case 2:
                            s = 250;
                            break;
                        case 5:
                            s = 1073741823;
                            break;
                        case 4:
                            s = 1e4;
                            break;
                        default:
                            s = 5e3
                    }
                    return e = {
                        id: d++,
                        callback: i,
                        priorityLevel: e,
                        startTime: o,
                        expirationTime: s = o + s,
                        sortIndex: -1
                    }, o > a ? (e.sortIndex = o, n(u, e), null === r(c) && e === r(u) && (g ? (y(E), E = -1) : g = !0, L(_, o - a))) : (e.sortIndex = s, n(c, e), m || f || (m = !0, B(M))), e
                }, t.unstable_shouldYield = P, t.unstable_wrapCallback = function(e) {
                    var t = p;
                    return function() {
                        var n = p;
                        p = t;
                        try {
                            return e.apply(this, arguments)
                        } finally {
                            p = n
                        }
                    }
                }
            },
            8024: (e, t, n) => {
                "use strict";
                e.exports = n(9952)
            },
            804: (e, t, n) => {
                "use strict";
                var r = n(6344),
                    i = n(4152),
                    o = n(1040)(),
                    a = n(6948),
                    s = n(7896),
                    l = r("%Math.floor%");
                e.exports = function(e, t) {
                    if ("function" !== typeof e) throw new s("`fn` is not a function");
                    if ("number" !== typeof t || t < 0 || t > 4294967295 || l(t) !== t) throw new s("`length` must be a positive 32-bit integer");
                    var n = arguments.length > 2 && !!arguments[2],
                        r = !0,
                        c = !0;
                    if ("length" in e && a) {
                        var u = a(e, "length");
                        u && !u.configurable && (r = !1), u && !u.writable && (c = !1)
                    }
                    return (r || c || !n) && (o ? i(e, "length", t, !0, !0) : i(e, "length", t)), e
                }
            },
            4588: (e, t, n) => {
                "use strict";
                var r = n(4152),
                    i = n(1040)(),
                    o = n(3672).functionsHaveConfigurableNames(),
                    a = TypeError;
                e.exports = function(e, t) {
                    if ("function" !== typeof e) throw new a("`fn` is not a function");
                    return arguments.length > 2 && !!arguments[2] && !o || (i ? r(e, "name", t, !0, !0) : r(e, "name", t)), e
                }
            },
            5208: (e, t, n) => {
                "use strict";
                var r = n(6344),
                    i = n(6396),
                    o = n(3136),
                    a = n(7896),
                    s = r("%WeakMap%", !0),
                    l = r("%Map%", !0),
                    c = i("WeakMap.prototype.get", !0),
                    u = i("WeakMap.prototype.set", !0),
                    d = i("WeakMap.prototype.has", !0),
                    h = i("Map.prototype.get", !0),
                    p = i("Map.prototype.set", !0),
                    f = i("Map.prototype.has", !0),
                    m = function(e, t) {
                        for (var n, r = e; null !== (n = r.next); r = n)
                            if (n.key === t) return r.next = n.next, n.next = e.next, e.next = n, n
                    };
                e.exports = function() {
                    var e, t, n, r = {
                        assert: function(e) {
                            if (!r.has(e)) throw new a("Side channel does not contain " + o(e))
                        },
                        get: function(r) {
                            if (s && r && ("object" === typeof r || "function" === typeof r)) {
                                if (e) return c(e, r)
                            } else if (l) {
                                if (t) return h(t, r)
                            } else if (n) return function(e, t) {
                                var n = m(e, t);
                                return n && n.value
                            }(n, r)
                        },
                        has: function(r) {
                            if (s && r && ("object" === typeof r || "function" === typeof r)) {
                                if (e) return d(e, r)
                            } else if (l) {
                                if (t) return f(t, r)
                            } else if (n) return function(e, t) {
                                return !!m(e, t)
                            }(n, r);
                            return !1
                        },
                        set: function(r, i) {
                            s && r && ("object" === typeof r || "function" === typeof r) ? (e || (e = new s), u(e, r, i)) : l ? (t || (t = new l), p(t, r, i)) : (n || (n = {
                                key: {},
                                next: null
                            }), function(e, t, n) {
                                var r = m(e, t);
                                r ? r.value = n : e.next = {
                                    key: t,
                                    next: e.next,
                                    value: n
                                }
                            }(n, r, i))
                        }
                    };
                    return r
                }
            },
            100: (e, t, n) => {
                "use strict";
                var r = n(6484),
                    i = SyntaxError,
                    o = "object" === typeof StopIteration ? StopIteration : null;
                e.exports = function(e) {
                    if (!o) throw new i("this environment lacks StopIteration");
                    r.set(e, "[[Done]]", !1);
                    var t = {
                        next: function() {
                            var e = r.get(this, "[[Iterator]]"),
                                t = r.get(e, "[[Done]]");
                            try {
                                return {
                                    done: t,
                                    value: t ? void 0 : e.next()
                                }
                            } catch (n) {
                                if (r.set(e, "[[Done]]", !0), n !== o) throw n;
                                return {
                                    done: !0,
                                    value: void 0
                                }
                            }
                        }
                    };
                    return r.set(t, "[[Iterator]]", e), t
                }
            },
            1552: (e, t, n) => {
                "use strict";
                var r = n(9584);
                var i = "function" === typeof Object.is ? Object.is : function(e, t) {
                        return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t
                    },
                    o = r.useState,
                    a = r.useEffect,
                    s = r.useLayoutEffect,
                    l = r.useDebugValue;

                function c(e) {
                    var t = e.getSnapshot;
                    e = e.value;
                    try {
                        var n = t();
                        return !i(e, n)
                    } catch (r) {
                        return !0
                    }
                }
                var u = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? function(e, t) {
                    return t()
                } : function(e, t) {
                    var n = t(),
                        r = o({
                            inst: {
                                value: n,
                                getSnapshot: t
                            }
                        }),
                        i = r[0].inst,
                        u = r[1];
                    return s((function() {
                        i.value = n, i.getSnapshot = t, c(i) && u({
                            inst: i
                        })
                    }), [e, n, t]), a((function() {
                        return c(i) && u({
                            inst: i
                        }), e((function() {
                            c(i) && u({
                                inst: i
                            })
                        }))
                    }), [e]), l(n), n
                };
                t.useSyncExternalStore = void 0 !== r.useSyncExternalStore ? r.useSyncExternalStore : u
            },
            6800: (e, t, n) => {
                "use strict";
                var r = n(9584),
                    i = n(3887);
                var o = "function" === typeof Object.is ? Object.is : function(e, t) {
                        return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t
                    },
                    a = i.useSyncExternalStore,
                    s = r.useRef,
                    l = r.useEffect,
                    c = r.useMemo,
                    u = r.useDebugValue;
                t.useSyncExternalStoreWithSelector = function(e, t, n, r, i) {
                    var d = s(null);
                    if (null === d.current) {
                        var h = {
                            hasValue: !1,
                            value: null
                        };
                        d.current = h
                    } else h = d.current;
                    d = c((function() {
                        function e(e) {
                            if (!l) {
                                if (l = !0, a = e, e = r(e), void 0 !== i && h.hasValue) {
                                    var t = h.value;
                                    if (i(t, e)) return s = t
                                }
                                return s = e
                            }
                            if (t = s, o(a, e)) return t;
                            var n = r(e);
                            return void 0 !== i && i(t, n) ? t : (a = e, s = n)
                        }
                        var a, s, l = !1,
                            c = void 0 === n ? null : n;
                        return [function() {
                            return e(t())
                        }, null === c ? void 0 : function() {
                            return e(c())
                        }]
                    }), [t, n, r, i]);
                    var p = a(e, d[0], d[1]);
                    return l((function() {
                        h.hasValue = !0, h.value = p
                    }), [p]), u(p), p
                }
            },
            3887: (e, t, n) => {
                "use strict";
                e.exports = n(1552)
            },
            5968: (e, t, n) => {
                "use strict";
                e.exports = n(6800)
            },
            9756: (e, t, n) => {
                "use strict";
                var r = n(5224),
                    i = n(9212),
                    o = n(9120),
                    a = n(3960),
                    s = n(9168);
                e.exports = function(e) {
                    return null == e || "object" !== typeof e && "function" !== typeof e ? null : r(e) ? "String" : i(e) ? "Number" : o(e) ? "Boolean" : a(e) ? "Symbol" : s(e) ? "BigInt" : void 0
                }
            },
            4244: (e, t, n) => {
                "use strict";
                var r = n(6964),
                    i = n(8748),
                    o = n(5520),
                    a = n(6396),
                    s = n(6948),
                    l = a("Object.prototype.toString"),
                    c = n(2728)(),
                    u = "undefined" === typeof globalThis ? n.g : globalThis,
                    d = i(),
                    h = a("String.prototype.slice"),
                    p = Object.getPrototypeOf,
                    f = a("Array.prototype.indexOf", !0) || function(e, t) {
                        for (var n = 0; n < e.length; n += 1)
                            if (e[n] === t) return n;
                        return -1
                    },
                    m = {
                        __proto__: null
                    };
                r(d, c && s && p ? function(e) {
                    var t = new u[e];
                    if (Symbol.toStringTag in t) {
                        var n = p(t),
                            r = s(n, Symbol.toStringTag);
                        if (!r) {
                            var i = p(n);
                            r = s(i, Symbol.toStringTag)
                        }
                        m["$" + e] = o(r.get)
                    }
                } : function(e) {
                    var t = new u[e],
                        n = t.slice || t.set;
                    n && (m["$" + e] = o(n))
                });
                e.exports = function(e) {
                    if (!e || "object" !== typeof e) return !1;
                    if (!c) {
                        var t = h(l(e), 8, -1);
                        return f(d, t) > -1 ? t : "Object" === t && function(e) {
                            var t = !1;
                            return r(m, (function(n, r) {
                                if (!t) try {
                                    n(e), t = h(r, 1)
                                } catch (i) {}
                            })), t
                        }(e)
                    }
                    return s ? function(e) {
                        var t = !1;
                        return r(m, (function(n, r) {
                            if (!t) try {
                                "$" + n(e) === r && (t = h(r, 1))
                            } catch (i) {}
                        })), t
                    }(e) : null
                }
            },
            6204: () => {},
            8748: (e, t, n) => {
                "use strict";
                var r = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"],
                    i = "undefined" === typeof globalThis ? n.g : globalThis;
                e.exports = function() {
                    for (var e = [], t = 0; t < r.length; t++) "function" === typeof i[r[t]] && (e[e.length] = r[t]);
                    return e
                }
            },
            7500: (e, t, n) => {
                "use strict";
                var r = n(8512),
                    i = n(100);
                if (n(7740)() || n(472)()) {
                    var o = Symbol.iterator;
                    e.exports = function(e) {
                        return null != e && "undefined" !== typeof e[o] ? e[o]() : r(e) ? Array.prototype[o].call(e) : void 0
                    }
                } else {
                    var a = n(5399),
                        s = n(5224),
                        l = n(6344),
                        c = l("%Map%", !0),
                        u = l("%Set%", !0),
                        d = n(6396),
                        h = d("Array.prototype.push"),
                        p = d("String.prototype.charCodeAt"),
                        f = d("String.prototype.slice"),
                        m = function(e) {
                            var t = 0;
                            return {
                                next: function() {
                                    var n, r = t >= e.length;
                                    return r || (n = e[t], t += 1), {
                                        done: r,
                                        value: n
                                    }
                                }
                            }
                        },
                        g = function(e, t) {
                            if (a(e) || r(e)) return m(e);
                            if (s(e)) {
                                var n = 0;
                                return {
                                    next: function() {
                                        var t = function(e, t) {
                                                if (t + 1 >= e.length) return t + 1;
                                                var n = p(e, t);
                                                if (n < 55296 || n > 56319) return t + 1;
                                                var r = p(e, t + 1);
                                                return r < 56320 || r > 57343 ? t + 1 : t + 2
                                            }(e, n),
                                            r = f(e, n, t);
                                        return n = t, {
                                            done: t > e.length,
                                            value: r
                                        }
                                    }
                                }
                            }
                            return t && "undefined" !== typeof e["_es6-shim iterator_"] ? e["_es6-shim iterator_"]() : void 0
                        };
                    if (c || u) {
                        var v = n(3612),
                            y = n(32),
                            b = d("Map.prototype.forEach", !0),
                            x = d("Set.prototype.forEach", !0);
                        if ("undefined" === typeof process || !process.versions || !process.versions.node) var _ = d("Map.prototype.iterator", !0),
                            M = d("Set.prototype.iterator", !0);
                        var w = d("Map.prototype.@@iterator", !0) || d("Map.prototype._es6-shim iterator_", !0),
                            A = d("Set.prototype.@@iterator", !0) || d("Set.prototype._es6-shim iterator_", !0);
                        e.exports = function(e) {
                            return function(e) {
                                if (v(e)) {
                                    if (_) return i(_(e));
                                    if (w) return w(e);
                                    if (b) {
                                        var t = [];
                                        return b(e, (function(e, n) {
                                            h(t, [n, e])
                                        })), m(t)
                                    }
                                }
                                if (y(e)) {
                                    if (M) return i(M(e));
                                    if (A) return A(e);
                                    if (x) {
                                        var n = [];
                                        return x(e, (function(e) {
                                            h(n, e)
                                        })), m(n)
                                    }
                                }
                            }(e) || g(e)
                        }
                    } else e.exports = function(e) {
                        if (null != e) return g(e, !0)
                    }
                }
            },
            676: (e, t, n) => {
                "use strict";
                var r = n(3612),
                    i = n(32),
                    o = n(6968),
                    a = n(8332);
                e.exports = function(e) {
                    if (e && "object" === typeof e) {
                        if (r(e)) return "Map";
                        if (i(e)) return "Set";
                        if (o(e)) return "WeakMap";
                        if (a(e)) return "WeakSet"
                    }
                    return !1
                }
            },
            5072: (e, t, n) => {
                "use strict";

                function r() {
                    return r = Object.assign ? Object.assign.bind() : function(e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var n = arguments[t];
                            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                        }
                        return e
                    }, r.apply(this, arguments)
                }
                n.d(t, {
                    c: () => r
                })
            },
            568: (e, t, n) => {
                "use strict";

                function r(e, t) {
                    return r = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                        return e.__proto__ = t, e
                    }, r(e, t)
                }

                function i(e, t) {
                    e.prototype = Object.create(t.prototype), e.prototype.constructor = e, r(e, t)
                }
                n.d(t, {
                    c: () => i
                })
            }
        },
        t = {};

    function n(r) {
        var i = t[r];
        if (void 0 !== i) return i.exports;
        var o = t[r] = {
            id: r,
            loaded: !1,
            exports: {}
        };
        return e[r](o, o.exports, n), o.loaded = !0, o.exports
    }
    n.n = e => {
        var t = e && e.__esModule ? () => e.default : () => e;
        return n.d(t, {
            a: t
        }), t
    }, n.d = (e, t) => {
        for (var r in t) n.o(t, r) && !n.o(e, r) && Object.defineProperty(e, r, {
            enumerable: !0,
            get: t[r]
        })
    }, n.g = function() {
        if ("object" === typeof globalThis) return globalThis;
        try {
            return this || new Function("return this")()
        } catch (e) {
            if ("object" === typeof window) return window
        }
    }(), n.hmd = e => ((e = Object.create(e)).children || (e.children = []), Object.defineProperty(e, "exports", {
        enumerable: !0,
        set: () => {
            throw new Error("ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: " + e.id)
        }
    }), e), n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), n.r = e => {
        "undefined" !== typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }, n.nmd = e => (e.paths = [], e.children || (e.children = []), e), n.p = "/", (() => {
        "use strict";
        var e = {};
        n.r(e), n.d(e, {
            hasBrowserEnv: () => vt,
            hasStandardBrowserEnv: () => yt,
            hasStandardBrowserWebWorkerEnv: () => xt
        });
        var t = {};
        n.r(t), n.d(t, {
            ACESFilmicToneMapping: () => $a,
            AddEquation: () => ya,
            AddOperation: () => Ka,
            AdditiveAnimationBlendMode: () => Bl,
            AdditiveBlending: () => fa,
            AgXToneMapping: () => ts,
            AlphaFormat: () => Ls,
            AlwaysCompare: () => _c,
            AlwaysDepth: () => Ua,
            AlwaysStencilFunc: () => pc,
            AmbientLight: () => ox,
            AnimationAction: () => Kx,
            AnimationClip: () => Pb,
            AnimationLoader: () => Fb,
            AnimationMixer: () => Yx,
            AnimationObjectGroup: () => Xx,
            AnimationUtils: () => gb,
            ArcCurve: () => Lv,
            ArrayCamera: () => zm,
            ArrowHelper: () => H_,
            AttachedBindMode: () => ns,
            Audio: () => Ox,
            AudioAnalyser: () => Fx,
            AudioContext: () => bx,
            AudioListener: () => Ix,
            AudioLoader: () => xx,
            AxesHelper: () => j_,
            BackSide: () => ua,
            BasicDepthPacking: () => Ul,
            BasicShadowMap: () => oa,
            BatchedMesh: () => sv,
            Bone: () => Ig,
            BooleanKeyframeTrack: () => Mb,
            Box2: () => l_,
            Box3: () => Ou,
            Box3Helper: () => N_,
            BoxGeometry: () => jh,
            BoxHelper: () => D_,
            BufferAttribute: () => ih,
            BufferGeometry: () => Mh,
            BufferGeometryLoader: () => hx,
            ByteType: () => As,
            Cache: () => Ib,
            Camera: () => Kh,
            CameraHelper: () => O_,
            CanvasTexture: () => Iv,
            CapsuleGeometry: () => ty,
            CatmullRomCurve3: () => zv,
            CineonToneMapping: () => Za,
            CircleGeometry: () => ny,
            ClampToEdgeWrapping: () => ds,
            Clock: () => Sx,
            Color: () => Wd,
            ColorKeyframeTrack: () => wb,
            ColorManagement: () => uu,
            CompressedArrayTexture: () => Pv,
            CompressedCubeTexture: () => Rv,
            CompressedTexture: () => Tv,
            CompressedTextureLoader: () => Ub,
            ConeGeometry: () => iy,
            ConstantAlphaFactor: () => Na,
            ConstantColorFactor: () => La,
            CubeCamera: () => ep,
            CubeReflectionMapping: () => os,
            CubeRefractionMapping: () => as,
            CubeTexture: () => tp,
            CubeTextureLoader: () => Hb,
            CubeUVReflectionMapping: () => cs,
            CubicBezierCurve: () => Vv,
            CubicBezierCurve3: () => qv,
            CubicInterpolant: () => yb,
            CullFaceBack: () => na,
            CullFaceFront: () => ra,
            CullFaceFrontBack: () => ia,
            CullFaceNone: () => ta,
            Curve: () => Ov,
            CurvePath: () => Zv,
            CustomBlending: () => va,
            CustomToneMapping: () => es,
            CylinderGeometry: () => ry,
            Cylindrical: () => a_,
            Data3DTexture: () => Su,
            DataArrayTexture: () => wu,
            DataTexture: () => Og,
            DataTextureLoader: () => jb,
            DataUtils: () => th,
            DecrementStencilOp: () => nc,
            DecrementWrapStencilOp: () => ic,
            DefaultLoadingManager: () => Bb,
            DepthFormat: () => Fs,
            DepthStencilFormat: () => Us,
            DepthTexture: () => Kp,
            DetachedBindMode: () => rs,
            DirectionalLight: () => ix,
            DirectionalLightHelper: () => P_,
            DiscreteInterpolant: () => xb,
            DisplayP3ColorSpace: () => Wl,
            DodecahedronGeometry: () => ay,
            DoubleSide: () => da,
            DstAlphaFactor: () => Pa,
            DstColorFactor: () => Ia,
            DynamicCopyUsage: () => Pc,
            DynamicDrawUsage: () => wc,
            DynamicReadUsage: () => Ec,
            EdgesGeometry: () => dy,
            EllipseCurve: () => Bv,
            EqualCompare: () => gc,
            EqualDepth: () => ja,
            EqualStencilFunc: () => lc,
            EquirectangularReflectionMapping: () => ss,
            EquirectangularRefractionMapping: () => ls,
            Euler: () => md,
            EventDispatcher: () => Nc,
            ExtrudeGeometry: () => Hy,
            FileLoader: () => kb,
            Float16BufferAttribute: () => hh,
            Float32BufferAttribute: () => ph,
            Float64BufferAttribute: () => fh,
            FloatType: () => Ps,
            Fog: () => Qm,
            FogExp2: () => Ym,
            FramebufferTexture: () => Cv,
            FrontSide: () => ca,
            Frustum: () => cp,
            GLBufferAttribute: () => t_,
            GLSL1: () => Ic,
            GLSL3: () => Oc,
            GreaterCompare: () => yc,
            GreaterDepth: () => Va,
            GreaterEqualCompare: () => xc,
            GreaterEqualDepth: () => Ga,
            GreaterEqualStencilFunc: () => hc,
            GreaterStencilFunc: () => uc,
            GridHelper: () => A_,
            Group: () => Hm,
            HalfFloatType: () => Rs,
            HemisphereLight: () => qb,
            HemisphereLightHelper: () => w_,
            IcosahedronGeometry: () => Gy,
            ImageBitmapLoader: () => vx,
            ImageLoader: () => zb,
            ImageUtils: () => fu,
            IncrementStencilOp: () => tc,
            IncrementWrapStencilOp: () => rc,
            InstancedBufferAttribute: () => Ng,
            InstancedBufferGeometry: () => dx,
            InstancedInterleavedBuffer: () => e_,
            InstancedMesh: () => Vg,
            Int16BufferAttribute: () => lh,
            Int32BufferAttribute: () => uh,
            Int8BufferAttribute: () => oh,
            IntType: () => Cs,
            InterleavedBuffer: () => $m,
            InterleavedBufferAttribute: () => tg,
            Interpolant: () => vb,
            InterpolateDiscrete: () => El,
            InterpolateLinear: () => Cl,
            InterpolateSmooth: () => Tl,
            InvertStencilOp: () => oc,
            KeepStencilOp: () => $l,
            KeyframeTrack: () => _b,
            LOD: () => xg,
            LatheGeometry: () => ey,
            Layers: () => gd,
            LessCompare: () => mc,
            LessDepth: () => za,
            LessEqualCompare: () => vc,
            LessEqualDepth: () => Ha,
            LessEqualStencilFunc: () => cc,
            LessStencilFunc: () => sc,
            Light: () => Vb,
            LightProbe: () => lx,
            Line: () => fv,
            Line3: () => d_,
            LineBasicMaterial: () => lv,
            LineCurve: () => Wv,
            LineCurve3: () => Xv,
            LineDashedMaterial: () => ub,
            LineLoop: () => yv,
            LineSegments: () => vv,
            LinearDisplayP3ColorSpace: () => Xl,
            LinearEncoding: () => kl,
            LinearFilter: () => ys,
            LinearInterpolant: () => bb,
            LinearMipMapLinearFilter: () => Ms,
            LinearMipMapNearestFilter: () => xs,
            LinearMipmapLinearFilter: () => _s,
            LinearMipmapNearestFilter: () => bs,
            LinearSRGBColorSpace: () => ql,
            LinearToneMapping: () => Ya,
            LinearTransfer: () => Kl,
            Loader: () => Lb,
            LoaderUtils: () => ux,
            LoadingManager: () => Ob,
            LoopOnce: () => wl,
            LoopPingPong: () => Sl,
            LoopRepeat: () => Al,
            LuminanceAlphaFormat: () => ks,
            LuminanceFormat: () => Ns,
            MOUSE: () => $o,
            Material: () => Jd,
            MaterialLoader: () => cx,
            MathUtils: () => Jc,
            Matrix3: () => Qc,
            Matrix4: () => od,
            MaxEquation: () => Ma,
            Mesh: () => zh,
            MeshBasicMaterial: () => Yd,
            MeshDepthMaterial: () => Lm,
            MeshDistanceMaterial: () => Dm,
            MeshLambertMaterial: () => lb,
            MeshMatcapMaterial: () => cb,
            MeshNormalMaterial: () => sb,
            MeshPhongMaterial: () => ob,
            MeshPhysicalMaterial: () => ib,
            MeshStandardMaterial: () => rb,
            MeshToonMaterial: () => ab,
            MinEquation: () => _a,
            MirroredRepeatWrapping: () => hs,
            MixOperation: () => Xa,
            MultiplyBlending: () => ga,
            MultiplyOperation: () => Wa,
            NearestFilter: () => ps,
            NearestMipMapLinearFilter: () => vs,
            NearestMipMapNearestFilter: () => ms,
            NearestMipmapLinearFilter: () => gs,
            NearestMipmapNearestFilter: () => fs,
            NeverCompare: () => fc,
            NeverDepth: () => Fa,
            NeverStencilFunc: () => ac,
            NoBlending: () => ha,
            NoColorSpace: () => Gl,
            NoToneMapping: () => Ja,
            NormalAnimationBlendMode: () => Ol,
            NormalBlending: () => pa,
            NotEqualCompare: () => bc,
            NotEqualDepth: () => qa,
            NotEqualStencilFunc: () => dc,
            NumberKeyframeTrack: () => Ab,
            Object3D: () => Rd,
            ObjectLoader: () => px,
            ObjectSpaceNormalMap: () => jl,
            OctahedronGeometry: () => Vy,
            OneFactor: () => Aa,
            OneMinusConstantAlphaFactor: () => ka,
            OneMinusConstantColorFactor: () => Da,
            OneMinusDstAlphaFactor: () => Ra,
            OneMinusDstColorFactor: () => Oa,
            OneMinusSrcAlphaFactor: () => Ta,
            OneMinusSrcColorFactor: () => Ea,
            OrthographicCamera: () => wp,
            P3Primaries: () => Ql,
            PCFShadowMap: () => aa,
            PCFSoftShadowMap: () => sa,
            PMREMGenerator: () => Lp,
            Path: () => $v,
            PerspectiveCamera: () => Zh,
            Plane: () => ap,
            PlaneGeometry: () => hp,
            PlaneHelper: () => k_,
            PointLight: () => nx,
            PointLightHelper: () => b_,
            Points: () => Av,
            PointsMaterial: () => bv,
            PolarGridHelper: () => S_,
            PolyhedronGeometry: () => oy,
            PositionalAudio: () => kx,
            PropertyBinding: () => Wx,
            PropertyMixer: () => Ux,
            QuadraticBezierCurve: () => Kv,
            QuadraticBezierCurve3: () => Jv,
            Quaternion: () => Tu,
            QuaternionKeyframeTrack: () => Eb,
            QuaternionLinearInterpolant: () => Sb,
            RED_GREEN_RGTC2_Format: () => _l,
            RED_RGTC1_Format: () => bl,
            REVISION: () => Zo,
            RGBADepthPacking: () => zl,
            RGBAFormat: () => Ds,
            RGBAIntegerFormat: () => Vs,
            RGBA_ASTC_10x10_Format: () => pl,
            RGBA_ASTC_10x5_Format: () => ul,
            RGBA_ASTC_10x6_Format: () => dl,
            RGBA_ASTC_10x8_Format: () => hl,
            RGBA_ASTC_12x10_Format: () => fl,
            RGBA_ASTC_12x12_Format: () => ml,
            RGBA_ASTC_4x4_Format: () => nl,
            RGBA_ASTC_5x4_Format: () => rl,
            RGBA_ASTC_5x5_Format: () => il,
            RGBA_ASTC_6x5_Format: () => ol,
            RGBA_ASTC_6x6_Format: () => al,
            RGBA_ASTC_8x5_Format: () => sl,
            RGBA_ASTC_8x6_Format: () => ll,
            RGBA_ASTC_8x8_Format: () => cl,
            RGBA_BPTC_Format: () => gl,
            RGBA_ETC2_EAC_Format: () => tl,
            RGBA_PVRTC_2BPPV1_Format: () => Zs,
            RGBA_PVRTC_4BPPV1_Format: () => Qs,
            RGBA_S3TC_DXT1_Format: () => Ws,
            RGBA_S3TC_DXT3_Format: () => Xs,
            RGBA_S3TC_DXT5_Format: () => Ks,
            RGB_BPTC_SIGNED_Format: () => vl,
            RGB_BPTC_UNSIGNED_Format: () => yl,
            RGB_ETC1_Format: () => $s,
            RGB_ETC2_Format: () => el,
            RGB_PVRTC_2BPPV1_Format: () => Ys,
            RGB_PVRTC_4BPPV1_Format: () => Js,
            RGB_S3TC_DXT1_Format: () => qs,
            RGFormat: () => js,
            RGIntegerFormat: () => Gs,
            RawShaderMaterial: () => nb,
            Ray: () => id,
            Raycaster: () => n_,
            Rec709Primaries: () => Yl,
            RectAreaLight: () => ax,
            RedFormat: () => zs,
            RedIntegerFormat: () => Hs,
            ReinhardToneMapping: () => Qa,
            RenderTarget: () => _u,
            RepeatWrapping: () => us,
            ReplaceStencilOp: () => ec,
            ReverseSubtractEquation: () => xa,
            RingGeometry: () => qy,
            SIGNED_RED_GREEN_RGTC2_Format: () => Ml,
            SIGNED_RED_RGTC1_Format: () => xl,
            SRGBColorSpace: () => Vl,
            SRGBTransfer: () => Jl,
            Scene: () => Zm,
            ShaderChunk: () => pp,
            ShaderLib: () => mp,
            ShaderMaterial: () => Xh,
            ShadowMaterial: () => tb,
            Shape: () => hy,
            ShapeGeometry: () => Wy,
            ShapePath: () => G_,
            ShapeUtils: () => Fy,
            ShortType: () => Ss,
            Skeleton: () => Dg,
            SkeletonHelper: () => v_,
            SkinnedMesh: () => Rg,
            Source: () => gu,
            Sphere: () => Yu,
            SphereGeometry: () => Xy,
            Spherical: () => o_,
            SphericalHarmonics3: () => sx,
            SplineCurve: () => Yv,
            SpotLight: () => Qb,
            SpotLightHelper: () => p_,
            Sprite: () => gg,
            SpriteMaterial: () => ng,
            SrcAlphaFactor: () => Ca,
            SrcAlphaSaturateFactor: () => Ba,
            SrcColorFactor: () => Sa,
            StaticCopyUsage: () => Tc,
            StaticDrawUsage: () => Mc,
            StaticReadUsage: () => Sc,
            StereoCamera: () => Ax,
            StreamCopyUsage: () => Rc,
            StreamDrawUsage: () => Ac,
            StreamReadUsage: () => Cc,
            StringKeyframeTrack: () => Cb,
            SubtractEquation: () => ba,
            SubtractiveBlending: () => ma,
            TOUCH: () => ea,
            TangentSpaceNormalMap: () => Hl,
            TetrahedronGeometry: () => Ky,
            Texture: () => bu,
            TextureLoader: () => Gb,
            TorusGeometry: () => Jy,
            TorusKnotGeometry: () => Yy,
            Triangle: () => Hd,
            TriangleFanDrawMode: () => Nl,
            TriangleStripDrawMode: () => Dl,
            TrianglesDrawMode: () => Ll,
            TubeGeometry: () => Qy,
            UVMapping: () => is,
            Uint16BufferAttribute: () => ch,
            Uint32BufferAttribute: () => dh,
            Uint8BufferAttribute: () => ah,
            Uint8ClampedBufferAttribute: () => sh,
            Uniform: () => Qx,
            UniformsGroup: () => $x,
            UniformsLib: () => fp,
            UniformsUtils: () => Wh,
            UnsignedByteType: () => ws,
            UnsignedInt248Type: () => Bs,
            UnsignedIntType: () => Ts,
            UnsignedShort4444Type: () => Is,
            UnsignedShort5551Type: () => Os,
            UnsignedShortType: () => Es,
            VSMShadowMap: () => la,
            Vector2: () => Yc,
            Vector3: () => Pu,
            Vector4: () => xu,
            VectorKeyframeTrack: () => Tb,
            VideoTexture: () => Ev,
            WebGL1Renderer: () => Jm,
            WebGL3DRenderTarget: () => Eu,
            WebGLArrayRenderTarget: () => Au,
            WebGLCoordinateSystem: () => Lc,
            WebGLCubeRenderTarget: () => np,
            WebGLMultipleRenderTargets: () => Cu,
            WebGLRenderTarget: () => Mu,
            WebGLRenderer: () => Km,
            WebGLUtils: () => Um,
            WebGPUCoordinateSystem: () => Dc,
            WireframeGeometry: () => Zy,
            WrapAroundEnding: () => Il,
            ZeroCurvatureEnding: () => Pl,
            ZeroFactor: () => wa,
            ZeroSlopeEnding: () => Rl,
            ZeroStencilOp: () => Zl,
            _SRGBAFormat: () => Bc,
            createCanvasElement: () => ru,
            sRGBEncoding: () => Fl
        });
        var r = n(9584),
            i = n(7504),
            o = n(4752);
        const a = e => {
                let t;
                const n = new Set,
                    r = (e, r) => {
                        const i = "function" === typeof e ? e(t) : e;
                        if (!Object.is(i, t)) {
                            const e = t;
                            t = (null != r ? r : "object" !== typeof i || null === i) ? i : Object.assign({}, t, i), n.forEach((n => n(t, e)))
                        }
                    },
                    i = () => t,
                    o = {
                        setState: r,
                        getState: i,
                        getInitialState: () => a,
                        subscribe: e => (n.add(e), () => n.delete(e)),
                        destroy: () => {
                            console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."), n.clear()
                        }
                    },
                    a = t = e(r, i, o);
                return o
            },
            s = e => e ? a(e) : a;
        var l = n(5968);
        const {
            useDebugValue: c
        } = r, {
            useSyncExternalStoreWithSelector: u
        } = l;
        let d = !1;
        const h = e => e;
        const p = e => {
                "function" !== typeof e && console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");
                const t = "function" === typeof e ? s(e) : e,
                    n = (e, n) => function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : h,
                            n = arguments.length > 2 ? arguments[2] : void 0;
                        n && !d && (console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"), d = !0);
                        const r = u(e.subscribe, e.getState, e.getServerState || e.getInitialState, t, n);
                        return c(r), r
                    }(t, e, n);
                return Object.assign(n, t), n
            },
            f = e => e ? p(e) : p;
        const m = {
                center: 1,
                left: 0,
                right: 2,
                side: 2
            },
            g = {
                Cushion: {
                    square: {
                        length: 5.59,
                        width: 5.59,
                        depth: 3.919,
                        pavHeight: 2.62,
                        girdleThickness: .241,
                        crownHeight: 1.058
                    },
                    elongated: {
                        length: 6.4,
                        width: 5.329,
                        depth: 3.569,
                        pavHeight: 2.63,
                        girdleThickness: .23,
                        crownHeight: .71
                    }
                },
                Radiant: {
                    square: {
                        length: 5.4,
                        width: 5.4,
                        depth: 3.631,
                        pavHeight: 2.782,
                        girdleThickness: .227,
                        crownHeight: .622
                    },
                    elongated: {
                        length: 6.4,
                        width: 5.06,
                        depth: 3.479,
                        pavHeight: 2.683,
                        girdleThickness: .151,
                        crownHeight: .645
                    }
                }
            },
            v = (e, t) => {
                const n = e.heads;
                if (!(1 === n.filter(Boolean).length)) return null;
                const r = { ...n[1],
                    stone: { ...n[1].stone
                    }
                };
                r.stone.caratWeight = null !== t && void 0 !== t ? t : 1;
                const i = yn.getState().availableStones;
                if (!i.length) return {
                    headOptions: r
                };
                const {
                    caratWeightMultiplier: o,
                    dimensions: a
                } = y(r.stone.name, i), s = b(a, r.stone.caratWeight, o);
                return r.stone.dimensions = s, r
            },
            y = (e, t) => {
                const {
                    caratWeightMultiplier: n,
                    dimensions: r
                } = t.find((t => t.name === e));
                return {
                    caratWeightMultiplier: n,
                    dimensions: r
                }
            },
            b = (e, t, n) => ({
                length: e.length * Math.pow(t, n.L),
                width: e.width * Math.pow(t, n.W),
                depth: e.depth * Math.pow(t, n.D),
                pavHeight: e.pavHeight * Math.pow(t, n.D),
                girdleThickness: e.girdleThickness * Math.pow(t, n.D),
                crownHeight: e.crownHeight * Math.pow(t, n.D)
            }),
            x = e => parseFloat(e.toFixed(4)),
            _ = e => {
                const [t] = e.split(".glb");
                return t + "Elongated.glb"
            },
            M = e => e.replace("Elongated", ""),
            w = e => {
                const {
                    stone: t
                } = Mn.getState().heads[m[e]], {
                    dimensions: n
                } = t;
                return A(n.length, n.width)
            },
            A = (e, t) => Math.max(e, t) / Math.min(e, t) < 1.1,
            S = {
                one: {
                    center: {
                        stone: {
                            diamondShape: "Round",
                            caratWeight: 1
                        },
                        orientation: "Classic",
                        prongCount: "4 Classic"
                    },
                    stoneElevation: "Tiered",
                    diamondtype: "Natural",
                    prongMetalColor: "18K Yellow",
                    prongArm: "Straight",
                    prongTip: "Claw",
                    prongPave: !1,
                    basketHalo: "None",
                    engravingFont: "Block",
                    engravingText: "",
                    surpriseStones: !1,
                    availableStones: []
                },
                two: {
                    right: {
                        stone: {
                            diamondShape: "Round",
                            caratWeight: 1
                        },
                        orientation: "Classic",
                        prongCount: "4 Classic"
                    },
                    left: {
                        stone: {
                            diamondShape: "Round",
                            caratWeight: 1
                        },
                        orientation: "Classic",
                        prongCount: "4 Classic"
                    },
                    stoneElevation: "Tiered",
                    diamondtype: "Natural",
                    prongMetalColor: "18K Yellow",
                    prongArm: "Straight",
                    prongTip: "Claw",
                    prongPave: !1,
                    basketHalo: "None",
                    engravingFont: "Block",
                    engravingText: "",
                    surpriseStones: !1,
                    availableStones: []
                },
                three: {
                    side: {
                        stone: {
                            diamondShape: "Round",
                            caratWeight: .5
                        },
                        orientation: "Classic",
                        prongCount: "4 Classic"
                    },
                    center: {
                        stone: {
                            diamondShape: "Round",
                            caratWeight: 1
                        },
                        orientation: "Classic",
                        prongCount: "4 Classic"
                    },
                    stoneElevation: "Tiered",
                    diamondtype: "Natural",
                    prongMetalColor: "18K White",
                    prongArm: "Straight",
                    prongTip: "Claw",
                    prongPave: !1,
                    basketHalo: "None",
                    engravingFont: "Block",
                    engravingText: "",
                    surpriseStones: !1,
                    availableStones: []
                }
            },
            E = {
                stone: {
                    diamondShape: "https://stonealgo-configurator.s3.amazonaws.com/glb/RoundDiamond.glb",
                    caratWeight: 1,
                    name: "Round",
                    caratWeightMultiplier: {
                        L: .3407,
                        W: .3407,
                        D: .3291
                    },
                    dimensions: {
                        length: 6.4,
                        width: 6.4,
                        depth: 3.935,
                        pavHeight: 2.751,
                        girdleThickness: .192,
                        crownHeight: .992
                    },
                    meshes: [{
                        name: "RoundDiamond",
                        type: "Mesh",
                        _id: "65c0ee00496b694e546f46e8"
                    }]
                },
                basketHalo: null,
                orientation: "Classic",
                prongCount: {
                    type: "4 Classic",
                    value: "4"
                },
                prongMetalColor: "#FFCB7D",
                prongArm: {
                    meshes: [{
                        name: "StraightArm",
                        type: "Mesh",
                        _id: "65c0ed6b496b694e546f46c0"
                    }],
                    glb: "https://stonealgo-configurator.s3.amazonaws.com/glb/StraightRoundArm.glb",
                    name: "Straight"
                },
                prongTip: {
                    meshes: [{
                        name: "ClawTip",
                        type: "Mesh",
                        _id: "65c0ed6c496b694e546f46c9"
                    }],
                    glb: "https://stonealgo-configurator.s3.amazonaws.com/glb/ClawTip.glb",
                    name: "Claw"
                },
                prongPave: !1,
                surpriseStones: !1
            },
            C = (e, t) => {
                if (e) return e;
                if (!t) return E;
                const n = b(E.stone.dimensions, t, E.stone.caratWeightMultiplier),
                    r = structuredClone(E);
                return r.stone.caratWeight = t, r.stone.dimensions = n, r
            },
            T = {
                heads: [null, C(), null],
                band: {
                    bandMetalColor: "#FFCB7D",
                    bandStyle: "Round",
                    bandCathedral: "None",
                    bandPaveStyle: "None",
                    bandPaveLength: "Half",
                    bandWidth: 1.7,
                    ringSize: 6,
                    bandFit: "Comfort Fit",
                    bridge: !1,
                    accentStones: [null, null, null]
                },
                engravingFont: "Block",
                engravingText: "",
                stoneElevation: "Tiered",
                diamondtype: "Natural"
            };
        var P = Symbol.for("immer-nothing"),
            R = Symbol.for("immer-draftable"),
            I = Symbol.for("immer-state");

        function O(e) {
            throw new Error("[Immer] minified error nr: ".concat(e, ". Full error at: https://bit.ly/3cXEKWf"))
        }
        var B = Object.getPrototypeOf;

        function L(e) {
            return !!e && !!e[I]
        }

        function D(e) {
            var t;
            return !!e && (k(e) || Array.isArray(e) || !!e[R] || !(null === (t = e.constructor) || void 0 === t || !t[R]) || j(e) || G(e))
        }
        var N = Object.prototype.constructor.toString();

        function k(e) {
            if (!e || "object" !== typeof e) return !1;
            const t = B(e);
            if (null === t) return !0;
            const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
            return n === Object || "function" == typeof n && Function.toString.call(n) === N
        }

        function F(e, t) {
            0 === U(e) ? Reflect.ownKeys(e).forEach((n => {
                t(n, e[n], e)
            })) : e.forEach(((n, r) => t(r, n, e)))
        }

        function U(e) {
            const t = e[I];
            return t ? t.type_ : Array.isArray(e) ? 1 : j(e) ? 2 : G(e) ? 3 : 0
        }

        function z(e, t) {
            return 2 === U(e) ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t)
        }

        function H(e, t, n) {
            const r = U(e);
            2 === r ? e.set(t, n) : 3 === r ? e.add(n) : e[t] = n
        }

        function j(e) {
            return e instanceof Map
        }

        function G(e) {
            return e instanceof Set
        }

        function V(e) {
            return e.copy_ || e.base_
        }

        function q(e, t) {
            if (j(e)) return new Map(e);
            if (G(e)) return new Set(e);
            if (Array.isArray(e)) return Array.prototype.slice.call(e);
            if (!t && k(e)) {
                if (!B(e)) {
                    const t = Object.create(null);
                    return Object.assign(t, e)
                }
                return { ...e
                }
            }
            const n = Object.getOwnPropertyDescriptors(e);
            delete n[I];
            let r = Reflect.ownKeys(n);
            for (let i = 0; i < r.length; i++) {
                const t = r[i],
                    o = n[t];
                !1 === o.writable && (o.writable = !0, o.configurable = !0), (o.get || o.set) && (n[t] = {
                    configurable: !0,
                    writable: !0,
                    enumerable: o.enumerable,
                    value: e[t]
                })
            }
            return Object.create(B(e), n)
        }

        function W(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            return K(e) || L(e) || !D(e) || (U(e) > 1 && (e.set = e.add = e.clear = e.delete = X), Object.freeze(e), t && Object.entries(e).forEach((e => {
                let [t, n] = e;
                return W(n, !0)
            }))), e
        }

        function X() {
            O(2)
        }

        function K(e) {
            return Object.isFrozen(e)
        }
        var J, Y = {};

        function Q(e) {
            const t = Y[e];
            return t || O(0), t
        }

        function Z() {
            return J
        }

        function $(e, t) {
            t && (Q("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t)
        }

        function ee(e) {
            te(e), e.drafts_.forEach(re), e.drafts_ = null
        }

        function te(e) {
            e === J && (J = e.parent_)
        }

        function ne(e) {
            return J = {
                drafts_: [],
                parent_: J,
                immer_: e,
                canAutoFreeze_: !0,
                unfinalizedDrafts_: 0
            }
        }

        function re(e) {
            const t = e[I];
            0 === t.type_ || 1 === t.type_ ? t.revoke_() : t.revoked_ = !0
        }

        function ie(e, t) {
            t.unfinalizedDrafts_ = t.drafts_.length;
            const n = t.drafts_[0];
            return void 0 !== e && e !== n ? (n[I].modified_ && (ee(t), O(4)), D(e) && (e = oe(t, e), t.parent_ || se(t, e)), t.patches_ && Q("Patches").generateReplacementPatches_(n[I].base_, e, t.patches_, t.inversePatches_)) : e = oe(t, n, []), ee(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== P ? e : void 0
        }

        function oe(e, t, n) {
            if (K(t)) return t;
            const r = t[I];
            if (!r) return F(t, ((i, o) => ae(e, r, t, i, o, n))), t;
            if (r.scope_ !== e) return t;
            if (!r.modified_) return se(e, r.base_, !0), r.base_;
            if (!r.finalized_) {
                r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
                const t = r.copy_;
                let i = t,
                    o = !1;
                3 === r.type_ && (i = new Set(t), t.clear(), o = !0), F(i, ((i, a) => ae(e, r, t, i, a, n, o))), se(e, t, !1), n && e.patches_ && Q("Patches").generatePatches_(r, n, e.patches_, e.inversePatches_)
            }
            return r.copy_
        }

        function ae(e, t, n, r, i, o, a) {
            if (L(i)) {
                const a = oe(e, i, o && t && 3 !== t.type_ && !z(t.assigned_, r) ? o.concat(r) : void 0);
                if (H(n, r, a), !L(a)) return;
                e.canAutoFreeze_ = !1
            } else a && n.add(i);
            if (D(i) && !K(i)) {
                if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1) return;
                oe(e, i), t && t.scope_.parent_ || "symbol" === typeof r || !Object.prototype.propertyIsEnumerable.call(n, r) || se(e, i)
            }
        }

        function se(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && W(t, n)
        }
        var le = {
                get(e, t) {
                    if (t === I) return e;
                    const n = V(e);
                    if (!z(n, t)) return function(e, t, n) {
                        var r;
                        const i = de(t, n);
                        return i ? "value" in i ? i.value : null === (r = i.get) || void 0 === r ? void 0 : r.call(e.draft_) : void 0
                    }(e, n, t);
                    const r = n[t];
                    return e.finalized_ || !D(r) ? r : r === ue(e.base_, t) ? (pe(e), e.copy_[t] = fe(r, e)) : r
                },
                has: (e, t) => t in V(e),
                ownKeys: e => Reflect.ownKeys(V(e)),
                set(e, t, n) {
                    const r = de(V(e), t);
                    if (null !== r && void 0 !== r && r.set) return r.set.call(e.draft_, n), !0;
                    if (!e.modified_) {
                        const r = ue(V(e), t),
                            i = null === r || void 0 === r ? void 0 : r[I];
                        if (i && i.base_ === n) return e.copy_[t] = n, e.assigned_[t] = !1, !0;
                        if (function(e, t) {
                                return e === t ? 0 !== e || 1 / e === 1 / t : e !== e && t !== t
                            }(n, r) && (void 0 !== n || z(e.base_, t))) return !0;
                        pe(e), he(e)
                    }
                    return e.copy_[t] === n && (void 0 !== n || t in e.copy_) || Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0
                },
                deleteProperty: (e, t) => (void 0 !== ue(e.base_, t) || t in e.base_ ? (e.assigned_[t] = !1, pe(e), he(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0),
                getOwnPropertyDescriptor(e, t) {
                    const n = V(e),
                        r = Reflect.getOwnPropertyDescriptor(n, t);
                    return r ? {
                        writable: !0,
                        configurable: 1 !== e.type_ || "length" !== t,
                        enumerable: r.enumerable,
                        value: n[t]
                    } : r
                },
                defineProperty() {
                    O(11)
                },
                getPrototypeOf: e => B(e.base_),
                setPrototypeOf() {
                    O(12)
                }
            },
            ce = {};

        function ue(e, t) {
            const n = e[I];
            return (n ? V(n) : e)[t]
        }

        function de(e, t) {
            if (!(t in e)) return;
            let n = B(e);
            for (; n;) {
                const e = Object.getOwnPropertyDescriptor(n, t);
                if (e) return e;
                n = B(n)
            }
        }

        function he(e) {
            e.modified_ || (e.modified_ = !0, e.parent_ && he(e.parent_))
        }

        function pe(e) {
            e.copy_ || (e.copy_ = q(e.base_, e.scope_.immer_.useStrictShallowCopy_))
        }
        F(le, ((e, t) => {
            ce[e] = function() {
                return arguments[0] = arguments[0][0], t.apply(this, arguments)
            }
        })), ce.deleteProperty = function(e, t) {
            return ce.set.call(this, e, t, void 0)
        }, ce.set = function(e, t, n) {
            return le.set.call(this, e[0], t, n, e[0])
        };

        function fe(e, t) {
            const n = j(e) ? Q("MapSet").proxyMap_(e, t) : G(e) ? Q("MapSet").proxySet_(e, t) : function(e, t) {
                const n = Array.isArray(e),
                    r = {
                        type_: n ? 1 : 0,
                        scope_: t ? t.scope_ : Z(),
                        modified_: !1,
                        finalized_: !1,
                        assigned_: {},
                        parent_: t,
                        base_: e,
                        draft_: null,
                        copy_: null,
                        revoke_: null,
                        isManual_: !1
                    };
                let i = r,
                    o = le;
                n && (i = [r], o = ce);
                const {
                    revoke: a,
                    proxy: s
                } = Proxy.revocable(i, o);
                return r.draft_ = s, r.revoke_ = a, s
            }(e, t);
            return (t ? t.scope_ : Z()).drafts_.push(n), n
        }

        function me(e) {
            if (!D(e) || K(e)) return e;
            const t = e[I];
            let n;
            if (t) {
                if (!t.modified_) return t.base_;
                t.finalized_ = !0, n = q(e, t.scope_.immer_.useStrictShallowCopy_)
            } else n = q(e, !0);
            return F(n, ((e, t) => {
                H(n, e, me(t))
            })), t && (t.finalized_ = !1), n
        }
        var ge = new class {
                constructor(e) {
                    var t = this;
                    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (e, t, n) => {
                        if ("function" === typeof e && "function" !== typeof t) {
                            const n = t;
                            t = e;
                            const r = this;
                            return function() {
                                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : n;
                                for (var i = arguments.length, o = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++) o[a - 1] = arguments[a];
                                return r.produce(e, (e => t.call(this, e, ...o)))
                            }
                        }
                        let r;
                        if ("function" !== typeof t && O(6), void 0 !== n && "function" !== typeof n && O(7), D(e)) {
                            const i = ne(this),
                                o = fe(e, void 0);
                            let a = !0;
                            try {
                                r = t(o), a = !1
                            } finally {
                                a ? ee(i) : te(i)
                            }
                            return $(i, n), ie(r, i)
                        }
                        if (!e || "object" !== typeof e) {
                            if (r = t(e), void 0 === r && (r = e), r === P && (r = void 0), this.autoFreeze_ && W(r, !0), n) {
                                const t = [],
                                    i = [];
                                Q("Patches").generateReplacementPatches_(e, r, t, i), n(t, i)
                            }
                            return r
                        }
                        O(1)
                    }, this.produceWithPatches = (e, n) => {
                        if ("function" === typeof e) return function(n) {
                            for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++) i[o - 1] = arguments[o];
                            return t.produceWithPatches(n, (t => e(t, ...i)))
                        };
                        let r, i;
                        return [this.produce(e, n, ((e, t) => {
                            r = e, i = t
                        })), r, i]
                    }, "boolean" === typeof(null === e || void 0 === e ? void 0 : e.autoFreeze) && this.setAutoFreeze(e.autoFreeze), "boolean" === typeof(null === e || void 0 === e ? void 0 : e.useStrictShallowCopy) && this.setUseStrictShallowCopy(e.useStrictShallowCopy)
                }
                createDraft(e) {
                    D(e) || O(8), L(e) && (e = function(e) {
                        L(e) || O(10);
                        return me(e)
                    }(e));
                    const t = ne(this),
                        n = fe(e, void 0);
                    return n[I].isManual_ = !0, te(t), n
                }
                finishDraft(e, t) {
                    const n = e && e[I];
                    n && n.isManual_ || O(9);
                    const {
                        scope_: r
                    } = n;
                    return $(r, t), ie(void 0, r)
                }
                setAutoFreeze(e) {
                    this.autoFreeze_ = e
                }
                setUseStrictShallowCopy(e) {
                    this.useStrictShallowCopy_ = e
                }
                applyPatches(e, t) {
                    let n;
                    for (n = t.length - 1; n >= 0; n--) {
                        const r = t[n];
                        if (0 === r.path.length && "replace" === r.op) {
                            e = r.value;
                            break
                        }
                    }
                    n > -1 && (t = t.slice(n + 1));
                    const r = Q("Patches").applyPatches_;
                    return L(e) ? r(e, t) : this.produce(e, (e => r(e, t)))
                }
            },
            ve = ge.produce;
        ge.produceWithPatches.bind(ge), ge.setAutoFreeze.bind(ge), ge.setUseStrictShallowCopy.bind(ge), ge.applyPatches.bind(ge), ge.createDraft.bind(ge), ge.finishDraft.bind(ge);

        function ye(e, t) {
            return function() {
                return e.apply(t, arguments)
            }
        }
        const {
            toString: be
        } = Object.prototype, {
            getPrototypeOf: xe
        } = Object, _e = (Me = Object.create(null), e => {
            const t = be.call(e);
            return Me[t] || (Me[t] = t.slice(8, -1).toLowerCase())
        });
        var Me;
        const we = e => (e = e.toLowerCase(), t => _e(t) === e),
            Ae = e => t => typeof t === e,
            {
                isArray: Se
            } = Array,
            Ee = Ae("undefined");
        const Ce = we("ArrayBuffer");
        const Te = Ae("string"),
            Pe = Ae("function"),
            Re = Ae("number"),
            Ie = e => null !== e && "object" === typeof e,
            Oe = e => {
                if ("object" !== _e(e)) return !1;
                const t = xe(e);
                return (null === t || t === Object.prototype || null === Object.getPrototypeOf(t)) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e)
            },
            Be = we("Date"),
            Le = we("File"),
            De = we("Blob"),
            Ne = we("FileList"),
            ke = we("URLSearchParams");

        function Fe(e, t) {
            let n, r, {
                allOwnKeys: i = !1
            } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            if (null !== e && "undefined" !== typeof e)
                if ("object" !== typeof e && (e = [e]), Se(e))
                    for (n = 0, r = e.length; n < r; n++) t.call(null, e[n], n, e);
                else {
                    const r = i ? Object.getOwnPropertyNames(e) : Object.keys(e),
                        o = r.length;
                    let a;
                    for (n = 0; n < o; n++) a = r[n], t.call(null, e[a], a, e)
                }
        }

        function Ue(e, t) {
            t = t.toLowerCase();
            const n = Object.keys(e);
            let r, i = n.length;
            for (; i-- > 0;)
                if (r = n[i], t === r.toLowerCase()) return r;
            return null
        }
        const ze = "undefined" !== typeof globalThis ? globalThis : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : global,
            He = e => !Ee(e) && e !== ze;
        const je = (Ge = "undefined" !== typeof Uint8Array && xe(Uint8Array), e => Ge && e instanceof Ge);
        var Ge;
        const Ve = we("HTMLFormElement"),
            qe = (e => {
                let {
                    hasOwnProperty: t
                } = e;
                return (e, n) => t.call(e, n)
            })(Object.prototype),
            We = we("RegExp"),
            Xe = (e, t) => {
                const n = Object.getOwnPropertyDescriptors(e),
                    r = {};
                Fe(n, ((n, i) => {
                    let o;
                    !1 !== (o = t(n, i, e)) && (r[i] = o || n)
                })), Object.defineProperties(e, r)
            },
            Ke = "abcdefghijklmnopqrstuvwxyz",
            Je = "0123456789",
            Ye = {
                DIGIT: Je,
                ALPHA: Ke,
                ALPHA_DIGIT: Ke + Ke.toUpperCase() + Je
            };
        const Qe = we("AsyncFunction"),
            Ze = {
                isArray: Se,
                isArrayBuffer: Ce,
                isBuffer: function(e) {
                    return null !== e && !Ee(e) && null !== e.constructor && !Ee(e.constructor) && Pe(e.constructor.isBuffer) && e.constructor.isBuffer(e)
                },
                isFormData: e => {
                    let t;
                    return e && ("function" === typeof FormData && e instanceof FormData || Pe(e.append) && ("formdata" === (t = _e(e)) || "object" === t && Pe(e.toString) && "[object FormData]" === e.toString()))
                },
                isArrayBufferView: function(e) {
                    let t;
                    return t = "undefined" !== typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && Ce(e.buffer), t
                },
                isString: Te,
                isNumber: Re,
                isBoolean: e => !0 === e || !1 === e,
                isObject: Ie,
                isPlainObject: Oe,
                isUndefined: Ee,
                isDate: Be,
                isFile: Le,
                isBlob: De,
                isRegExp: We,
                isFunction: Pe,
                isStream: e => Ie(e) && Pe(e.pipe),
                isURLSearchParams: ke,
                isTypedArray: je,
                isFileList: Ne,
                forEach: Fe,
                merge: function e() {
                    const {
                        caseless: t
                    } = He(this) && this || {}, n = {}, r = (r, i) => {
                        const o = t && Ue(n, i) || i;
                        Oe(n[o]) && Oe(r) ? n[o] = e(n[o], r) : Oe(r) ? n[o] = e({}, r) : Se(r) ? n[o] = r.slice() : n[o] = r
                    };
                    for (let i = 0, o = arguments.length; i < o; i++) arguments[i] && Fe(arguments[i], r);
                    return n
                },
                extend: function(e, t, n) {
                    let {
                        allOwnKeys: r
                    } = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                    return Fe(t, ((t, r) => {
                        n && Pe(t) ? e[r] = ye(t, n) : e[r] = t
                    }), {
                        allOwnKeys: r
                    }), e
                },
                trim: e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""),
                stripBOM: e => (65279 === e.charCodeAt(0) && (e = e.slice(1)), e),
                inherits: (e, t, n, r) => {
                    e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
                        value: t.prototype
                    }), n && Object.assign(e.prototype, n)
                },
                toFlatObject: (e, t, n, r) => {
                    let i, o, a;
                    const s = {};
                    if (t = t || {}, null == e) return t;
                    do {
                        for (i = Object.getOwnPropertyNames(e), o = i.length; o-- > 0;) a = i[o], r && !r(a, e, t) || s[a] || (t[a] = e[a], s[a] = !0);
                        e = !1 !== n && xe(e)
                    } while (e && (!n || n(e, t)) && e !== Object.prototype);
                    return t
                },
                kindOf: _e,
                kindOfTest: we,
                endsWith: (e, t, n) => {
                    e = String(e), (void 0 === n || n > e.length) && (n = e.length), n -= t.length;
                    const r = e.indexOf(t, n);
                    return -1 !== r && r === n
                },
                toArray: e => {
                    if (!e) return null;
                    if (Se(e)) return e;
                    let t = e.length;
                    if (!Re(t)) return null;
                    const n = new Array(t);
                    for (; t-- > 0;) n[t] = e[t];
                    return n
                },
                forEachEntry: (e, t) => {
                    const n = (e && e[Symbol.iterator]).call(e);
                    let r;
                    for (;
                        (r = n.next()) && !r.done;) {
                        const n = r.value;
                        t.call(e, n[0], n[1])
                    }
                },
                matchAll: (e, t) => {
                    let n;
                    const r = [];
                    for (; null !== (n = e.exec(t));) r.push(n);
                    return r
                },
                isHTMLForm: Ve,
                hasOwnProperty: qe,
                hasOwnProp: qe,
                reduceDescriptors: Xe,
                freezeMethods: e => {
                    Xe(e, ((t, n) => {
                        if (Pe(e) && -1 !== ["arguments", "caller", "callee"].indexOf(n)) return !1;
                        const r = e[n];
                        Pe(r) && (t.enumerable = !1, "writable" in t ? t.writable = !1 : t.set || (t.set = () => {
                            throw Error("Can not rewrite read-only method '" + n + "'")
                        }))
                    }))
                },
                toObjectSet: (e, t) => {
                    const n = {},
                        r = e => {
                            e.forEach((e => {
                                n[e] = !0
                            }))
                        };
                    return Se(e) ? r(e) : r(String(e).split(t)), n
                },
                toCamelCase: e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, (function(e, t, n) {
                    return t.toUpperCase() + n
                })),
                noop: () => {},
                toFiniteNumber: (e, t) => (e = +e, Number.isFinite(e) ? e : t),
                findKey: Ue,
                global: ze,
                isContextDefined: He,
                ALPHABET: Ye,
                generateString: function() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 16,
                        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Ye.ALPHA_DIGIT,
                        n = "";
                    const {
                        length: r
                    } = t;
                    for (; e--;) n += t[Math.random() * r | 0];
                    return n
                },
                isSpecCompliantForm: function(e) {
                    return !!(e && Pe(e.append) && "FormData" === e[Symbol.toStringTag] && e[Symbol.iterator])
                },
                toJSONObject: e => {
                    const t = new Array(10),
                        n = (e, r) => {
                            if (Ie(e)) {
                                if (t.indexOf(e) >= 0) return;
                                if (!("toJSON" in e)) {
                                    t[r] = e;
                                    const i = Se(e) ? [] : {};
                                    return Fe(e, ((e, t) => {
                                        const o = n(e, r + 1);
                                        !Ee(o) && (i[t] = o)
                                    })), t[r] = void 0, i
                                }
                            }
                            return e
                        };
                    return n(e, 0)
                },
                isAsyncFn: Qe,
                isThenable: e => e && (Ie(e) || Pe(e)) && Pe(e.then) && Pe(e.catch)
            };

        function $e(e, t, n, r, i) {
            Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), i && (this.response = i)
        }
        Ze.inherits($e, Error, {
            toJSON: function() {
                return {
                    message: this.message,
                    name: this.name,
                    description: this.description,
                    number: this.number,
                    fileName: this.fileName,
                    lineNumber: this.lineNumber,
                    columnNumber: this.columnNumber,
                    stack: this.stack,
                    config: Ze.toJSONObject(this.config),
                    code: this.code,
                    status: this.response && this.response.status ? this.response.status : null
                }
            }
        });
        const et = $e.prototype,
            tt = {};
        ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((e => {
            tt[e] = {
                value: e
            }
        })), Object.defineProperties($e, tt), Object.defineProperty(et, "isAxiosError", {
            value: !0
        }), $e.from = (e, t, n, r, i, o) => {
            const a = Object.create(et);
            return Ze.toFlatObject(e, a, (function(e) {
                return e !== Error.prototype
            }), (e => "isAxiosError" !== e)), $e.call(a, e.message, t, n, r, i), a.cause = e, a.name = e.name, o && Object.assign(a, o), a
        };
        const nt = $e;

        function rt(e) {
            return Ze.isPlainObject(e) || Ze.isArray(e)
        }

        function it(e) {
            return Ze.endsWith(e, "[]") ? e.slice(0, -2) : e
        }

        function ot(e, t, n) {
            return e ? e.concat(t).map((function(e, t) {
                return e = it(e), !n && t ? "[" + e + "]" : e
            })).join(n ? "." : "") : t
        }
        const at = Ze.toFlatObject(Ze, {}, null, (function(e) {
            return /^is[A-Z]/.test(e)
        }));
        const st = function(e, t, n) {
            if (!Ze.isObject(e)) throw new TypeError("target must be an object");
            t = t || new FormData;
            const r = (n = Ze.toFlatObject(n, {
                    metaTokens: !0,
                    dots: !1,
                    indexes: !1
                }, !1, (function(e, t) {
                    return !Ze.isUndefined(t[e])
                }))).metaTokens,
                i = n.visitor || c,
                o = n.dots,
                a = n.indexes,
                s = (n.Blob || "undefined" !== typeof Blob && Blob) && Ze.isSpecCompliantForm(t);
            if (!Ze.isFunction(i)) throw new TypeError("visitor must be a function");

            function l(e) {
                if (null === e) return "";
                if (Ze.isDate(e)) return e.toISOString();
                if (!s && Ze.isBlob(e)) throw new nt("Blob is not supported. Use a Buffer instead.");
                return Ze.isArrayBuffer(e) || Ze.isTypedArray(e) ? s && "function" === typeof Blob ? new Blob([e]) : Buffer.from(e) : e
            }

            function c(e, n, i) {
                let s = e;
                if (e && !i && "object" === typeof e)
                    if (Ze.endsWith(n, "{}")) n = r ? n : n.slice(0, -2), e = JSON.stringify(e);
                    else if (Ze.isArray(e) && function(e) {
                        return Ze.isArray(e) && !e.some(rt)
                    }(e) || (Ze.isFileList(e) || Ze.endsWith(n, "[]")) && (s = Ze.toArray(e))) return n = it(n), s.forEach((function(e, r) {
                    !Ze.isUndefined(e) && null !== e && t.append(!0 === a ? ot([n], r, o) : null === a ? n : n + "[]", l(e))
                })), !1;
                return !!rt(e) || (t.append(ot(i, n, o), l(e)), !1)
            }
            const u = [],
                d = Object.assign(at, {
                    defaultVisitor: c,
                    convertValue: l,
                    isVisitable: rt
                });
            if (!Ze.isObject(e)) throw new TypeError("data must be an object");
            return function e(n, r) {
                if (!Ze.isUndefined(n)) {
                    if (-1 !== u.indexOf(n)) throw Error("Circular reference detected in " + r.join("."));
                    u.push(n), Ze.forEach(n, (function(n, o) {
                        !0 === (!(Ze.isUndefined(n) || null === n) && i.call(t, n, Ze.isString(o) ? o.trim() : o, r, d)) && e(n, r ? r.concat(o) : [o])
                    })), u.pop()
                }
            }(e), t
        };

        function lt(e) {
            const t = {
                "!": "%21",
                "'": "%27",
                "(": "%28",
                ")": "%29",
                "~": "%7E",
                "%20": "+",
                "%00": "\0"
            };
            return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, (function(e) {
                return t[e]
            }))
        }

        function ct(e, t) {
            this._pairs = [], e && st(e, this, t)
        }
        const ut = ct.prototype;
        ut.append = function(e, t) {
            this._pairs.push([e, t])
        }, ut.toString = function(e) {
            const t = e ? function(t) {
                return e.call(this, t, lt)
            } : lt;
            return this._pairs.map((function(e) {
                return t(e[0]) + "=" + t(e[1])
            }), "").join("&")
        };
        const dt = ct;

        function ht(e) {
            return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
        }

        function pt(e, t, n) {
            if (!t) return e;
            const r = n && n.encode || ht,
                i = n && n.serialize;
            let o;
            if (o = i ? i(t, n) : Ze.isURLSearchParams(t) ? t.toString() : new dt(t, n).toString(r), o) {
                const t = e.indexOf("#"); - 1 !== t && (e = e.slice(0, t)), e += (-1 === e.indexOf("?") ? "?" : "&") + o
            }
            return e
        }
        const ft = class {
                constructor() {
                    this.handlers = []
                }
                use(e, t, n) {
                    return this.handlers.push({
                        fulfilled: e,
                        rejected: t,
                        synchronous: !!n && n.synchronous,
                        runWhen: n ? n.runWhen : null
                    }), this.handlers.length - 1
                }
                eject(e) {
                    this.handlers[e] && (this.handlers[e] = null)
                }
                clear() {
                    this.handlers && (this.handlers = [])
                }
                forEach(e) {
                    Ze.forEach(this.handlers, (function(t) {
                        null !== t && e(t)
                    }))
                }
            },
            mt = {
                silentJSONParsing: !0,
                forcedJSONParsing: !0,
                clarifyTimeoutError: !1
            },
            gt = {
                isBrowser: !0,
                classes: {
                    URLSearchParams: "undefined" !== typeof URLSearchParams ? URLSearchParams : dt,
                    FormData: "undefined" !== typeof FormData ? FormData : null,
                    Blob: "undefined" !== typeof Blob ? Blob : null
                },
                protocols: ["http", "https", "file", "blob", "url", "data"]
            },
            vt = "undefined" !== typeof window && "undefined" !== typeof document,
            yt = (bt = "undefined" !== typeof navigator && navigator.product, vt && ["ReactNative", "NativeScript", "NS"].indexOf(bt) < 0);
        var bt;
        const xt = "undefined" !== typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" === typeof self.importScripts,
            _t = { ...e,
                ...gt
            };
        const Mt = function(e) {
            function t(e, n, r, i) {
                let o = e[i++];
                if ("__proto__" === o) return !0;
                const a = Number.isFinite(+o),
                    s = i >= e.length;
                if (o = !o && Ze.isArray(r) ? r.length : o, s) return Ze.hasOwnProp(r, o) ? r[o] = [r[o], n] : r[o] = n, !a;
                r[o] && Ze.isObject(r[o]) || (r[o] = []);
                return t(e, n, r[o], i) && Ze.isArray(r[o]) && (r[o] = function(e) {
                    const t = {},
                        n = Object.keys(e);
                    let r;
                    const i = n.length;
                    let o;
                    for (r = 0; r < i; r++) o = n[r], t[o] = e[o];
                    return t
                }(r[o])), !a
            }
            if (Ze.isFormData(e) && Ze.isFunction(e.entries)) {
                const n = {};
                return Ze.forEachEntry(e, ((e, r) => {
                    t(function(e) {
                        return Ze.matchAll(/\w+|\[(\w*)]/g, e).map((e => "[]" === e[0] ? "" : e[1] || e[0]))
                    }(e), r, n, 0)
                })), n
            }
            return null
        };
        const wt = {
            transitional: mt,
            adapter: ["xhr", "http"],
            transformRequest: [function(e, t) {
                const n = t.getContentType() || "",
                    r = n.indexOf("application/json") > -1,
                    i = Ze.isObject(e);
                i && Ze.isHTMLForm(e) && (e = new FormData(e));
                if (Ze.isFormData(e)) return r ? JSON.stringify(Mt(e)) : e;
                if (Ze.isArrayBuffer(e) || Ze.isBuffer(e) || Ze.isStream(e) || Ze.isFile(e) || Ze.isBlob(e)) return e;
                if (Ze.isArrayBufferView(e)) return e.buffer;
                if (Ze.isURLSearchParams(e)) return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
                let o;
                if (i) {
                    if (n.indexOf("application/x-www-form-urlencoded") > -1) return function(e, t) {
                        return st(e, new _t.classes.URLSearchParams, Object.assign({
                            visitor: function(e, t, n, r) {
                                return _t.isNode && Ze.isBuffer(e) ? (this.append(t, e.toString("base64")), !1) : r.defaultVisitor.apply(this, arguments)
                            }
                        }, t))
                    }(e, this.formSerializer).toString();
                    if ((o = Ze.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
                        const t = this.env && this.env.FormData;
                        return st(o ? {
                            "files[]": e
                        } : e, t && new t, this.formSerializer)
                    }
                }
                return i || r ? (t.setContentType("application/json", !1), function(e, t, n) {
                    if (Ze.isString(e)) try {
                        return (t || JSON.parse)(e), Ze.trim(e)
                    } catch (r) {
                        if ("SyntaxError" !== r.name) throw r
                    }
                    return (n || JSON.stringify)(e)
                }(e)) : e
            }],
            transformResponse: [function(e) {
                const t = this.transitional || wt.transitional,
                    n = t && t.forcedJSONParsing,
                    r = "json" === this.responseType;
                if (e && Ze.isString(e) && (n && !this.responseType || r)) {
                    const n = !(t && t.silentJSONParsing) && r;
                    try {
                        return JSON.parse(e)
                    } catch (i) {
                        if (n) {
                            if ("SyntaxError" === i.name) throw nt.from(i, nt.ERR_BAD_RESPONSE, this, null, this.response);
                            throw i
                        }
                    }
                }
                return e
            }],
            timeout: 0,
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN",
            maxContentLength: -1,
            maxBodyLength: -1,
            env: {
                FormData: _t.classes.FormData,
                Blob: _t.classes.Blob
            },
            validateStatus: function(e) {
                return e >= 200 && e < 300
            },
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*",
                    "Content-Type": void 0
                }
            }
        };
        Ze.forEach(["delete", "get", "head", "post", "put", "patch"], (e => {
            wt.headers[e] = {}
        }));
        const At = wt,
            St = Ze.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]),
            Et = Symbol("internals");

        function Ct(e) {
            return e && String(e).trim().toLowerCase()
        }

        function Tt(e) {
            return !1 === e || null == e ? e : Ze.isArray(e) ? e.map(Tt) : String(e)
        }

        function Pt(e, t, n, r, i) {
            return Ze.isFunction(r) ? r.call(this, t, n) : (i && (t = n), Ze.isString(t) ? Ze.isString(r) ? -1 !== t.indexOf(r) : Ze.isRegExp(r) ? r.test(t) : void 0 : void 0)
        }
        class Rt {
            constructor(e) {
                e && this.set(e)
            }
            set(e, t, n) {
                const r = this;

                function i(e, t, n) {
                    const i = Ct(t);
                    if (!i) throw new Error("header name must be a non-empty string");
                    const o = Ze.findKey(r, i);
                    (!o || void 0 === r[o] || !0 === n || void 0 === n && !1 !== r[o]) && (r[o || t] = Tt(e))
                }
                const o = (e, t) => Ze.forEach(e, ((e, n) => i(e, n, t)));
                return Ze.isPlainObject(e) || e instanceof this.constructor ? o(e, t) : Ze.isString(e) && (e = e.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim()) ? o((e => {
                    const t = {};
                    let n, r, i;
                    return e && e.split("\n").forEach((function(e) {
                        i = e.indexOf(":"), n = e.substring(0, i).trim().toLowerCase(), r = e.substring(i + 1).trim(), !n || t[n] && St[n] || ("set-cookie" === n ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r)
                    })), t
                })(e), t) : null != e && i(t, e, n), this
            }
            get(e, t) {
                if (e = Ct(e)) {
                    const n = Ze.findKey(this, e);
                    if (n) {
                        const e = this[n];
                        if (!t) return e;
                        if (!0 === t) return function(e) {
                            const t = Object.create(null),
                                n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                            let r;
                            for (; r = n.exec(e);) t[r[1]] = r[2];
                            return t
                        }(e);
                        if (Ze.isFunction(t)) return t.call(this, e, n);
                        if (Ze.isRegExp(t)) return t.exec(e);
                        throw new TypeError("parser must be boolean|regexp|function")
                    }
                }
            }
            has(e, t) {
                if (e = Ct(e)) {
                    const n = Ze.findKey(this, e);
                    return !(!n || void 0 === this[n] || t && !Pt(0, this[n], n, t))
                }
                return !1
            }
            delete(e, t) {
                const n = this;
                let r = !1;

                function i(e) {
                    if (e = Ct(e)) {
                        const i = Ze.findKey(n, e);
                        !i || t && !Pt(0, n[i], i, t) || (delete n[i], r = !0)
                    }
                }
                return Ze.isArray(e) ? e.forEach(i) : i(e), r
            }
            clear(e) {
                const t = Object.keys(this);
                let n = t.length,
                    r = !1;
                for (; n--;) {
                    const i = t[n];
                    e && !Pt(0, this[i], i, e, !0) || (delete this[i], r = !0)
                }
                return r
            }
            normalize(e) {
                const t = this,
                    n = {};
                return Ze.forEach(this, ((r, i) => {
                    const o = Ze.findKey(n, i);
                    if (o) return t[o] = Tt(r), void delete t[i];
                    const a = e ? function(e) {
                        return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, ((e, t, n) => t.toUpperCase() + n))
                    }(i) : String(i).trim();
                    a !== i && delete t[i], t[a] = Tt(r), n[a] = !0
                })), this
            }
            concat() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                return this.constructor.concat(this, ...t)
            }
            toJSON(e) {
                const t = Object.create(null);
                return Ze.forEach(this, ((n, r) => {
                    null != n && !1 !== n && (t[r] = e && Ze.isArray(n) ? n.join(", ") : n)
                })), t
            }[Symbol.iterator]() {
                return Object.entries(this.toJSON())[Symbol.iterator]()
            }
            toString() {
                return Object.entries(this.toJSON()).map((e => {
                    let [t, n] = e;
                    return t + ": " + n
                })).join("\n")
            }
            get[Symbol.toStringTag]() {
                return "AxiosHeaders"
            }
            static from(e) {
                return e instanceof this ? e : new this(e)
            }
            static concat(e) {
                const t = new this(e);
                for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) r[i - 1] = arguments[i];
                return r.forEach((e => t.set(e))), t
            }
            static accessor(e) {
                const t = (this[Et] = this[Et] = {
                        accessors: {}
                    }).accessors,
                    n = this.prototype;

                function r(e) {
                    const r = Ct(e);
                    t[r] || (! function(e, t) {
                        const n = Ze.toCamelCase(" " + t);
                        ["get", "set", "has"].forEach((r => {
                            Object.defineProperty(e, r + n, {
                                value: function(e, n, i) {
                                    return this[r].call(this, t, e, n, i)
                                },
                                configurable: !0
                            })
                        }))
                    }(n, e), t[r] = !0)
                }
                return Ze.isArray(e) ? e.forEach(r) : r(e), this
            }
        }
        Rt.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), Ze.reduceDescriptors(Rt.prototype, ((e, t) => {
            let {
                value: n
            } = e, r = t[0].toUpperCase() + t.slice(1);
            return {
                get: () => n,
                set(e) {
                    this[r] = e
                }
            }
        })), Ze.freezeMethods(Rt);
        const It = Rt;

        function Ot(e, t) {
            const n = this || At,
                r = t || n,
                i = It.from(r.headers);
            let o = r.data;
            return Ze.forEach(e, (function(e) {
                o = e.call(n, o, i.normalize(), t ? t.status : void 0)
            })), i.normalize(), o
        }

        function Bt(e) {
            return !(!e || !e.__CANCEL__)
        }

        function Lt(e, t, n) {
            nt.call(this, null == e ? "canceled" : e, nt.ERR_CANCELED, t, n), this.name = "CanceledError"
        }
        Ze.inherits(Lt, nt, {
            __CANCEL__: !0
        });
        const Dt = Lt;
        const Nt = _t.hasStandardBrowserEnv ? {
            write(e, t, n, r, i, o) {
                const a = [e + "=" + encodeURIComponent(t)];
                Ze.isNumber(n) && a.push("expires=" + new Date(n).toGMTString()), Ze.isString(r) && a.push("path=" + r), Ze.isString(i) && a.push("domain=" + i), !0 === o && a.push("secure"), document.cookie = a.join("; ")
            },
            read(e) {
                const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
                return t ? decodeURIComponent(t[3]) : null
            },
            remove(e) {
                this.write(e, "", Date.now() - 864e5)
            }
        } : {
            write() {},
            read: () => null,
            remove() {}
        };

        function kt(e, t) {
            return e && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t) ? function(e, t) {
                return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e
            }(e, t) : t
        }
        const Ft = _t.hasStandardBrowserEnv ? function() {
            const e = /(msie|trident)/i.test(navigator.userAgent),
                t = document.createElement("a");
            let n;

            function r(n) {
                let r = n;
                return e && (t.setAttribute("href", r), r = t.href), t.setAttribute("href", r), {
                    href: t.href,
                    protocol: t.protocol ? t.protocol.replace(/:$/, "") : "",
                    host: t.host,
                    search: t.search ? t.search.replace(/^\?/, "") : "",
                    hash: t.hash ? t.hash.replace(/^#/, "") : "",
                    hostname: t.hostname,
                    port: t.port,
                    pathname: "/" === t.pathname.charAt(0) ? t.pathname : "/" + t.pathname
                }
            }
            return n = r(window.location.href),
                function(e) {
                    const t = Ze.isString(e) ? r(e) : e;
                    return t.protocol === n.protocol && t.host === n.host
                }
        }() : function() {
            return !0
        };
        const Ut = function(e, t) {
            e = e || 10;
            const n = new Array(e),
                r = new Array(e);
            let i, o = 0,
                a = 0;
            return t = void 0 !== t ? t : 1e3,
                function(s) {
                    const l = Date.now(),
                        c = r[a];
                    i || (i = l), n[o] = s, r[o] = l;
                    let u = a,
                        d = 0;
                    for (; u !== o;) d += n[u++], u %= e;
                    if (o = (o + 1) % e, o === a && (a = (a + 1) % e), l - i < t) return;
                    const h = c && l - c;
                    return h ? Math.round(1e3 * d / h) : void 0
                }
        };

        function zt(e, t) {
            let n = 0;
            const r = Ut(50, 250);
            return i => {
                const o = i.loaded,
                    a = i.lengthComputable ? i.total : void 0,
                    s = o - n,
                    l = r(s);
                n = o;
                const c = {
                    loaded: o,
                    total: a,
                    progress: a ? o / a : void 0,
                    bytes: s,
                    rate: l || void 0,
                    estimated: l && a && o <= a ? (a - o) / l : void 0,
                    event: i
                };
                c[t ? "download" : "upload"] = !0, e(c)
            }
        }
        const Ht = "undefined" !== typeof XMLHttpRequest && function(e) {
                return new Promise((function(t, n) {
                    let r = e.data;
                    const i = It.from(e.headers).normalize();
                    let o, a, {
                        responseType: s,
                        withXSRFToken: l
                    } = e;

                    function c() {
                        e.cancelToken && e.cancelToken.unsubscribe(o), e.signal && e.signal.removeEventListener("abort", o)
                    }
                    if (Ze.isFormData(r))
                        if (_t.hasStandardBrowserEnv || _t.hasStandardBrowserWebWorkerEnv) i.setContentType(!1);
                        else if (!1 !== (a = i.getContentType())) {
                        const [e, ...t] = a ? a.split(";").map((e => e.trim())).filter(Boolean) : [];
                        i.setContentType([e || "multipart/form-data", ...t].join("; "))
                    }
                    let u = new XMLHttpRequest;
                    if (e.auth) {
                        const t = e.auth.username || "",
                            n = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
                        i.set("Authorization", "Basic " + btoa(t + ":" + n))
                    }
                    const d = kt(e.baseURL, e.url);

                    function h() {
                        if (!u) return;
                        const r = It.from("getAllResponseHeaders" in u && u.getAllResponseHeaders());
                        ! function(e, t, n) {
                            const r = n.config.validateStatus;
                            n.status && r && !r(n.status) ? t(new nt("Request failed with status code " + n.status, [nt.ERR_BAD_REQUEST, nt.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n)) : e(n)
                        }((function(e) {
                            t(e), c()
                        }), (function(e) {
                            n(e), c()
                        }), {
                            data: s && "text" !== s && "json" !== s ? u.response : u.responseText,
                            status: u.status,
                            statusText: u.statusText,
                            headers: r,
                            config: e,
                            request: u
                        }), u = null
                    }
                    if (u.open(e.method.toUpperCase(), pt(d, e.params, e.paramsSerializer), !0), u.timeout = e.timeout, "onloadend" in u ? u.onloadend = h : u.onreadystatechange = function() {
                            u && 4 === u.readyState && (0 !== u.status || u.responseURL && 0 === u.responseURL.indexOf("file:")) && setTimeout(h)
                        }, u.onabort = function() {
                            u && (n(new nt("Request aborted", nt.ECONNABORTED, e, u)), u = null)
                        }, u.onerror = function() {
                            n(new nt("Network Error", nt.ERR_NETWORK, e, u)), u = null
                        }, u.ontimeout = function() {
                            let t = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded";
                            const r = e.transitional || mt;
                            e.timeoutErrorMessage && (t = e.timeoutErrorMessage), n(new nt(t, r.clarifyTimeoutError ? nt.ETIMEDOUT : nt.ECONNABORTED, e, u)), u = null
                        }, _t.hasStandardBrowserEnv && (l && Ze.isFunction(l) && (l = l(e)), l || !1 !== l && Ft(d))) {
                        const t = e.xsrfHeaderName && e.xsrfCookieName && Nt.read(e.xsrfCookieName);
                        t && i.set(e.xsrfHeaderName, t)
                    }
                    void 0 === r && i.setContentType(null), "setRequestHeader" in u && Ze.forEach(i.toJSON(), (function(e, t) {
                        u.setRequestHeader(t, e)
                    })), Ze.isUndefined(e.withCredentials) || (u.withCredentials = !!e.withCredentials), s && "json" !== s && (u.responseType = e.responseType), "function" === typeof e.onDownloadProgress && u.addEventListener("progress", zt(e.onDownloadProgress, !0)), "function" === typeof e.onUploadProgress && u.upload && u.upload.addEventListener("progress", zt(e.onUploadProgress)), (e.cancelToken || e.signal) && (o = t => {
                        u && (n(!t || t.type ? new Dt(null, e, u) : t), u.abort(), u = null)
                    }, e.cancelToken && e.cancelToken.subscribe(o), e.signal && (e.signal.aborted ? o() : e.signal.addEventListener("abort", o)));
                    const p = function(e) {
                        const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
                        return t && t[1] || ""
                    }(d);
                    p && -1 === _t.protocols.indexOf(p) ? n(new nt("Unsupported protocol " + p + ":", nt.ERR_BAD_REQUEST, e)) : u.send(r || null)
                }))
            },
            jt = {
                http: null,
                xhr: Ht
            };
        Ze.forEach(jt, ((e, t) => {
            if (e) {
                try {
                    Object.defineProperty(e, "name", {
                        value: t
                    })
                } catch (n) {}
                Object.defineProperty(e, "adapterName", {
                    value: t
                })
            }
        }));
        const Gt = e => "- ".concat(e),
            Vt = e => Ze.isFunction(e) || null === e || !1 === e,
            qt = e => {
                e = Ze.isArray(e) ? e : [e];
                const {
                    length: t
                } = e;
                let n, r;
                const i = {};
                for (let o = 0; o < t; o++) {
                    let t;
                    if (n = e[o], r = n, !Vt(n) && (r = jt[(t = String(n)).toLowerCase()], void 0 === r)) throw new nt("Unknown adapter '".concat(t, "'"));
                    if (r) break;
                    i[t || "#" + o] = r
                }
                if (!r) {
                    const e = Object.entries(i).map((e => {
                        let [t, n] = e;
                        return "adapter ".concat(t, " ") + (!1 === n ? "is not supported by the environment" : "is not available in the build")
                    }));
                    let n = t ? e.length > 1 ? "since :\n" + e.map(Gt).join("\n") : " " + Gt(e[0]) : "as no adapter specified";
                    throw new nt("There is no suitable adapter to dispatch the request " + n, "ERR_NOT_SUPPORT")
                }
                return r
            };

        function Wt(e) {
            if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new Dt(null, e)
        }

        function Xt(e) {
            Wt(e), e.headers = It.from(e.headers), e.data = Ot.call(e, e.transformRequest), -1 !== ["post", "put", "patch"].indexOf(e.method) && e.headers.setContentType("application/x-www-form-urlencoded", !1);
            return qt(e.adapter || At.adapter)(e).then((function(t) {
                return Wt(e), t.data = Ot.call(e, e.transformResponse, t), t.headers = It.from(t.headers), t
            }), (function(t) {
                return Bt(t) || (Wt(e), t && t.response && (t.response.data = Ot.call(e, e.transformResponse, t.response), t.response.headers = It.from(t.response.headers))), Promise.reject(t)
            }))
        }
        const Kt = e => e instanceof It ? { ...e
        } : e;

        function Jt(e, t) {
            t = t || {};
            const n = {};

            function r(e, t, n) {
                return Ze.isPlainObject(e) && Ze.isPlainObject(t) ? Ze.merge.call({
                    caseless: n
                }, e, t) : Ze.isPlainObject(t) ? Ze.merge({}, t) : Ze.isArray(t) ? t.slice() : t
            }

            function i(e, t, n) {
                return Ze.isUndefined(t) ? Ze.isUndefined(e) ? void 0 : r(void 0, e, n) : r(e, t, n)
            }

            function o(e, t) {
                if (!Ze.isUndefined(t)) return r(void 0, t)
            }

            function a(e, t) {
                return Ze.isUndefined(t) ? Ze.isUndefined(e) ? void 0 : r(void 0, e) : r(void 0, t)
            }

            function s(n, i, o) {
                return o in t ? r(n, i) : o in e ? r(void 0, n) : void 0
            }
            const l = {
                url: o,
                method: o,
                data: o,
                baseURL: a,
                transformRequest: a,
                transformResponse: a,
                paramsSerializer: a,
                timeout: a,
                timeoutMessage: a,
                withCredentials: a,
                withXSRFToken: a,
                adapter: a,
                responseType: a,
                xsrfCookieName: a,
                xsrfHeaderName: a,
                onUploadProgress: a,
                onDownloadProgress: a,
                decompress: a,
                maxContentLength: a,
                maxBodyLength: a,
                beforeRedirect: a,
                transport: a,
                httpAgent: a,
                httpsAgent: a,
                cancelToken: a,
                socketPath: a,
                responseEncoding: a,
                validateStatus: s,
                headers: (e, t) => i(Kt(e), Kt(t), !0)
            };
            return Ze.forEach(Object.keys(Object.assign({}, e, t)), (function(r) {
                const o = l[r] || i,
                    a = o(e[r], t[r], r);
                Ze.isUndefined(a) && o !== s || (n[r] = a)
            })), n
        }
        const Yt = "1.6.8",
            Qt = {};
        ["object", "boolean", "number", "function", "string", "symbol"].forEach(((e, t) => {
            Qt[e] = function(n) {
                return typeof n === e || "a" + (t < 1 ? "n " : " ") + e
            }
        }));
        const Zt = {};
        Qt.transitional = function(e, t, n) {
            function r(e, t) {
                return "[Axios v1.6.8] Transitional option '" + e + "'" + t + (n ? ". " + n : "")
            }
            return (n, i, o) => {
                if (!1 === e) throw new nt(r(i, " has been removed" + (t ? " in " + t : "")), nt.ERR_DEPRECATED);
                return t && !Zt[i] && (Zt[i] = !0, console.warn(r(i, " has been deprecated since v" + t + " and will be removed in the near future"))), !e || e(n, i, o)
            }
        };
        const $t = {
                assertOptions: function(e, t, n) {
                    if ("object" !== typeof e) throw new nt("options must be an object", nt.ERR_BAD_OPTION_VALUE);
                    const r = Object.keys(e);
                    let i = r.length;
                    for (; i-- > 0;) {
                        const o = r[i],
                            a = t[o];
                        if (a) {
                            const t = e[o],
                                n = void 0 === t || a(t, o, e);
                            if (!0 !== n) throw new nt("option " + o + " must be " + n, nt.ERR_BAD_OPTION_VALUE)
                        } else if (!0 !== n) throw new nt("Unknown option " + o, nt.ERR_BAD_OPTION)
                    }
                },
                validators: Qt
            },
            en = $t.validators;
        class tn {
            constructor(e) {
                this.defaults = e, this.interceptors = {
                    request: new ft,
                    response: new ft
                }
            }
            async request(e, t) {
                try {
                    return await this._request(e, t)
                } catch (n) {
                    if (n instanceof Error) {
                        let e;
                        Error.captureStackTrace ? Error.captureStackTrace(e = {}) : e = new Error;
                        const t = e.stack ? e.stack.replace(/^.+\n/, "") : "";
                        n.stack ? t && !String(n.stack).endsWith(t.replace(/^.+\n.+\n/, "")) && (n.stack += "\n" + t) : n.stack = t
                    }
                    throw n
                }
            }
            _request(e, t) {
                "string" === typeof e ? (t = t || {}).url = e : t = e || {}, t = Jt(this.defaults, t);
                const {
                    transitional: n,
                    paramsSerializer: r,
                    headers: i
                } = t;
                void 0 !== n && $t.assertOptions(n, {
                    silentJSONParsing: en.transitional(en.boolean),
                    forcedJSONParsing: en.transitional(en.boolean),
                    clarifyTimeoutError: en.transitional(en.boolean)
                }, !1), null != r && (Ze.isFunction(r) ? t.paramsSerializer = {
                    serialize: r
                } : $t.assertOptions(r, {
                    encode: en.function,
                    serialize: en.function
                }, !0)), t.method = (t.method || this.defaults.method || "get").toLowerCase();
                let o = i && Ze.merge(i.common, i[t.method]);
                i && Ze.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (e => {
                    delete i[e]
                })), t.headers = It.concat(o, i);
                const a = [];
                let s = !0;
                this.interceptors.request.forEach((function(e) {
                    "function" === typeof e.runWhen && !1 === e.runWhen(t) || (s = s && e.synchronous, a.unshift(e.fulfilled, e.rejected))
                }));
                const l = [];
                let c;
                this.interceptors.response.forEach((function(e) {
                    l.push(e.fulfilled, e.rejected)
                }));
                let u, d = 0;
                if (!s) {
                    const e = [Xt.bind(this), void 0];
                    for (e.unshift.apply(e, a), e.push.apply(e, l), u = e.length, c = Promise.resolve(t); d < u;) c = c.then(e[d++], e[d++]);
                    return c
                }
                u = a.length;
                let h = t;
                for (d = 0; d < u;) {
                    const e = a[d++],
                        t = a[d++];
                    try {
                        h = e(h)
                    } catch (p) {
                        t.call(this, p);
                        break
                    }
                }
                try {
                    c = Xt.call(this, h)
                } catch (p) {
                    return Promise.reject(p)
                }
                for (d = 0, u = l.length; d < u;) c = c.then(l[d++], l[d++]);
                return c
            }
            getUri(e) {
                return pt(kt((e = Jt(this.defaults, e)).baseURL, e.url), e.params, e.paramsSerializer)
            }
        }
        Ze.forEach(["delete", "get", "head", "options"], (function(e) {
            tn.prototype[e] = function(t, n) {
                return this.request(Jt(n || {}, {
                    method: e,
                    url: t,
                    data: (n || {}).data
                }))
            }
        })), Ze.forEach(["post", "put", "patch"], (function(e) {
            function t(t) {
                return function(n, r, i) {
                    return this.request(Jt(i || {}, {
                        method: e,
                        headers: t ? {
                            "Content-Type": "multipart/form-data"
                        } : {},
                        url: n,
                        data: r
                    }))
                }
            }
            tn.prototype[e] = t(), tn.prototype[e + "Form"] = t(!0)
        }));
        const nn = tn;
        class rn {
            constructor(e) {
                if ("function" !== typeof e) throw new TypeError("executor must be a function.");
                let t;
                this.promise = new Promise((function(e) {
                    t = e
                }));
                const n = this;
                this.promise.then((e => {
                    if (!n._listeners) return;
                    let t = n._listeners.length;
                    for (; t-- > 0;) n._listeners[t](e);
                    n._listeners = null
                })), this.promise.then = e => {
                    let t;
                    const r = new Promise((e => {
                        n.subscribe(e), t = e
                    })).then(e);
                    return r.cancel = function() {
                        n.unsubscribe(t)
                    }, r
                }, e((function(e, r, i) {
                    n.reason || (n.reason = new Dt(e, r, i), t(n.reason))
                }))
            }
            throwIfRequested() {
                if (this.reason) throw this.reason
            }
            subscribe(e) {
                this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : this._listeners = [e]
            }
            unsubscribe(e) {
                if (!this._listeners) return;
                const t = this._listeners.indexOf(e); - 1 !== t && this._listeners.splice(t, 1)
            }
            static source() {
                let e;
                return {
                    token: new rn((function(t) {
                        e = t
                    })),
                    cancel: e
                }
            }
        }
        const on = rn;
        const an = {
            Continue: 100,
            SwitchingProtocols: 101,
            Processing: 102,
            EarlyHints: 103,
            Ok: 200,
            Created: 201,
            Accepted: 202,
            NonAuthoritativeInformation: 203,
            NoContent: 204,
            ResetContent: 205,
            PartialContent: 206,
            MultiStatus: 207,
            AlreadyReported: 208,
            ImUsed: 226,
            MultipleChoices: 300,
            MovedPermanently: 301,
            Found: 302,
            SeeOther: 303,
            NotModified: 304,
            UseProxy: 305,
            Unused: 306,
            TemporaryRedirect: 307,
            PermanentRedirect: 308,
            BadRequest: 400,
            Unauthorized: 401,
            PaymentRequired: 402,
            Forbidden: 403,
            NotFound: 404,
            MethodNotAllowed: 405,
            NotAcceptable: 406,
            ProxyAuthenticationRequired: 407,
            RequestTimeout: 408,
            Conflict: 409,
            Gone: 410,
            LengthRequired: 411,
            PreconditionFailed: 412,
            PayloadTooLarge: 413,
            UriTooLong: 414,
            UnsupportedMediaType: 415,
            RangeNotSatisfiable: 416,
            ExpectationFailed: 417,
            ImATeapot: 418,
            MisdirectedRequest: 421,
            UnprocessableEntity: 422,
            Locked: 423,
            FailedDependency: 424,
            TooEarly: 425,
            UpgradeRequired: 426,
            PreconditionRequired: 428,
            TooManyRequests: 429,
            RequestHeaderFieldsTooLarge: 431,
            UnavailableForLegalReasons: 451,
            InternalServerError: 500,
            NotImplemented: 501,
            BadGateway: 502,
            ServiceUnavailable: 503,
            GatewayTimeout: 504,
            HttpVersionNotSupported: 505,
            VariantAlsoNegotiates: 506,
            InsufficientStorage: 507,
            LoopDetected: 508,
            NotExtended: 510,
            NetworkAuthenticationRequired: 511
        };
        Object.entries(an).forEach((e => {
            let [t, n] = e;
            an[n] = t
        }));
        const sn = an;
        const ln = function e(t) {
            const n = new nn(t),
                r = ye(nn.prototype.request, n);
            return Ze.extend(r, nn.prototype, n, {
                allOwnKeys: !0
            }), Ze.extend(r, n, null, {
                allOwnKeys: !0
            }), r.create = function(n) {
                return e(Jt(t, n))
            }, r
        }(At);
        ln.Axios = nn, ln.CanceledError = Dt, ln.CancelToken = on, ln.isCancel = Bt, ln.VERSION = Yt, ln.toFormData = st, ln.AxiosError = nt, ln.Cancel = ln.CanceledError, ln.all = function(e) {
            return Promise.all(e)
        }, ln.spread = function(e) {
            return function(t) {
                return e.apply(null, t)
            }
        }, ln.isAxiosError = function(e) {
            return Ze.isObject(e) && !0 === e.isAxiosError
        }, ln.mergeConfig = Jt, ln.AxiosHeaders = It, ln.formToJSON = e => Mt(Ze.isHTMLForm(e) ? new FormData(e) : e), ln.getAdapter = qt, ln.HttpStatusCode = sn, ln.default = ln;
        const cn = ln.create({
            baseURL: "https://api.modularcx.link/stone-algo-backend/",
            timeout: 1e4
        });
        async function un(e) {
            let t;
            return await fetch("https://diamonds5.azurewebsites.net/stone-api/get-ring-price/", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    Authorization: "Token 8f365b2027ef6a62b0a4027a5171238a09838305"
                },
                body: JSON.stringify(e)
            }).then((e => e.json())).then((e => {
                t = e
            })).catch((e => {
                console.error("Error:", e)
            })), t
        }
        const dn = function() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                let r = "";
                return t.forEach(((e, n) => {
                    let i = n === t.length;
                    e && (r += e, i || (r += " "))
                })), r
            },
            hn = e => {
                var t;
                return null !== (t = null === e || void 0 === e ? void 0 : e.split(/[,.]/)) && void 0 !== t ? t : []
            },
            pn = (e, t) => {
                if (Array.isArray(e)) return e.map((e => hn(e).reduce(((e, t) => e[t]), t)));
                return hn(e).reduce(((e, t) => e[t]), t)
            },
            fn = () => null,
            mn = (e, t) => ({
                modalTitle: e,
                modalUI: [{
                    title: "Diamond Shape",
                    api: {
                        queryKeys: ["allStones"],
                        queryFn: Rn,
                        queryOptions: {
                            refetchOnWindowFocus: !1,
                            refetchOnMount: !1,
                            staleTime: 1 / 0
                        },
                        queryInvalidationName: {
                            querKey: ["prongCount", "orientation"]
                        },
                        onQuerySuccess: e => ({
                            label: e.name,
                            value: e.name,
                            description: e.name + " Diamond",
                            value3D: {
                                name: e.name,
                                meshes: e.meshes,
                                caratWeightMultiplier: e.caratWeightMultiplier,
                                dimensions: e.dimensions,
                                diamondShape: e.glbUrl
                            }
                        })
                    },
                    onClick: async (e, n) => {
                        const r = ["Cushion", "Radiant"],
                            i = yn.getState(),
                            o = i.numOfStones,
                            a = i.sideStonesChanged,
                            s = i[t].stone.caratWeight;
                        "side" === t && bn();
                        const l = "three" === o && "center" === t && !a;
                        xn("".concat(t, ".orientation"))("Classic"), wn(t, "orientation", "Classic"), xn("".concat(t, ".stone.diamondShape"))(e), l && xn("side.stone.diamondShape")(e);
                        try {
                            const i = await (async e => {
                                    try {
                                        const {
                                            data: t
                                        } = await cn.get("stoneprong/get-prong-counts/".concat(e));
                                        return t[0]
                                    } catch (t) {
                                        throw new Error(t)
                                    }
                                })(e),
                                {
                                    uiValue: o,
                                    value: a
                                } = null !== i && void 0 !== i ? i : {},
                                c = {
                                    type: o,
                                    value: a
                                },
                                u = b(n.dimensions, s, n.caratWeightMultiplier);
                            if (!A(n.dimensions.length, n.dimensions.width) && r.includes(e) && (n.diamondShape.includes("Elongated") || (n.diamondShape = _(n.diamondShape))), wn(t, "stone", { ...n,
                                    dimensions: u
                                }), xn("".concat(t, ".prongCount"))(o), wn(t, "prongCount", c), l) {
                                const e = s / 2;
                                let t;
                                if (e >= .25 && e <= 1.5) t = e;
                                else {
                                    const n = Math.abs(e - .25);
                                    t = n < Math.abs(e - 1.5) ? .25 : 1.5
                                }
                                const r = b(n.dimensions, t, n.caratWeightMultiplier);
                                wn("side", "stone", { ...n,
                                    dimensions: r
                                }), xn("side.prongCount")(o), wn("side", "prongCount", c)
                            }
                        } catch (c) {
                            console.log({
                                error: c
                            })
                        }
                    },
                    storeKey: "".concat(t, ".stone.diamondShape"),
                    componentType: "Basic"
                }, {
                    toggleItem: {
                        title: "Diamond Dimensions",
                        textinfo: "More info",
                        head: t,
                        description: e => e,
                        buttons: [{
                            label: "Elongated",
                            value: "Elongated"
                        }, {
                            label: "Square",
                            value: "Square"
                        }],
                        onClick: e => {
                            const n = yn.getState(),
                                r = n.numOfStones,
                                i = n.sideStonesChanged,
                                {
                                    stone: {
                                        caratWeight: o,
                                        diamondShape: a
                                    }
                                } = n[t],
                                {
                                    stone: s
                                } = Mn.getState().heads[m[t]],
                                l = g[a]["Square" === e ? "square" : "elongated"],
                                c = b(l, o, s.caratWeightMultiplier);
                            if (Object.keys(c).forEach((e => {
                                    const n = c[e];
                                    wn(t, "stone.dimensions.".concat(e), n)
                                })), wn(t, "stone.diamondShape", "Elongated" === e ? _(s.diamondShape) : M(s.diamondShape)), "side" === t && bn(), "three" === r && "center" === t && !i) {
                                const {
                                    stone: {
                                        caratWeight: t
                                    }
                                } = yn.getState().side, {
                                    stone: n
                                } = Mn.getState().heads[m.side], r = b(l, t, n.caratWeightMultiplier);
                                Object.keys(r).forEach((e => {
                                    const t = r[e];
                                    wn("side", "stone.dimensions.".concat(e), t)
                                })), wn("side", "stone.diamondShape", "Elongated" === e ? _(n.diamondShape) : M(n.diamondShape))
                            }
                        }
                    },
                    toggleKeys: "".concat(t, ".stone.diamondShape"),
                    checkValues: e => ["Cushion", "Radiant"].includes(e),
                    componentType: "Toggle"
                }, {
                    title: "Carat Weight",
                    description: () => {
                        const {
                            caratWeight: e
                        } = yn.getState()[t].stone;
                        return "".concat(e, " carat diamond")
                    },
                    isInput: {
                        placeholder: "Carat Weight",
                        onChange: (e, n) => {
                            const r = yn.getState(),
                                i = r.availableStones,
                                o = r.numOfStones,
                                a = r.sideStonesChanged,
                                s = r[t].stone.diamondShape;
                            if ("Cushion" === s || "Radiant" === s) {
                                const n = w(t),
                                    o = g[s][n ? "square" : "elongated"],
                                    {
                                        caratWeightMultiplier: a
                                    } = y(r[t].stone.diamondShape, i),
                                    l = b(o, e, a);
                                Object.keys(l).forEach((e => {
                                    const n = l[e];
                                    wn(t, "stone.dimensions.".concat(e), n)
                                }))
                            } else {
                                const {
                                    caratWeightMultiplier: n,
                                    dimensions: o
                                } = y(r[t].stone.diamondShape, i), a = b(o, e, n);
                                Object.keys(a).forEach((e => {
                                    const n = a[e];
                                    wn(t, "stone.dimensions.".concat(e), n)
                                }))
                            }
                            "side" === t && bn();
                            const l = "three" === o && "center" === t && !a;
                            if (xn("".concat(t, ".stone.caratWeight"))(e), wn(t, "stone.caratWeight", e), !l) return;
                            const {
                                allLimits: c
                            } = n, u = [c.threeStones.left.min, c.threeStones.left.max], d = e / 2;
                            let h;
                            if (d >= u[0] && d <= u[1]) h = d;
                            else {
                                h = Math.abs(d - u[0]) < Math.abs(d - u[1]) ? u[0] : u[1]
                            }
                            xn("side.stone.caratWeight")(h), wn("side", "stone.caratWeight", h);
                            const p = r.side.stone.diamondShape;
                            if ("Cushion" === p || "Radiant" === p) {
                                const e = w(t),
                                    n = g[p][e ? "square" : "elongated"],
                                    {
                                        caratWeightMultiplier: r
                                    } = y(p, i),
                                    o = b(n, h, r);
                                Object.keys(o).forEach((e => {
                                    const t = o[e];
                                    wn("side", "stone.dimensions.".concat(e), t)
                                }))
                            } else {
                                const {
                                    caratWeightMultiplier: e,
                                    dimensions: t
                                } = y(p, i), n = b(t, h, e);
                                Object.keys(n).forEach((e => {
                                    const t = n[e];
                                    wn("side", "stone.dimensions.".concat(e), t)
                                }))
                            }
                        },
                        stepValue: .01
                    },
                    Slider: !0,
                    api: {
                        queryKeys: ["caratWeight", "side" === t ? "left" : t],
                        queryFn: On,
                        queryOptions: {
                            refetchOnWindowFocus: !1,
                            refetchOnMount: !0
                        }
                    },
                    storeKey: "".concat(t, ".stone.caratWeight"),
                    componentType: "Input"
                }, {
                    title: "Orientation - Clockwise Rotation",
                    api: {
                        queryKeys: () => {
                            const e = yn.getState();
                            return ["orientation", t, e.numOfStones, e[t].stone.diamondShape]
                        },
                        queryFn: In,
                        queryOptions: {
                            refetchOnWindowFocus: !1,
                            refetchOnMount: !1,
                            staleTime: 1 / 0
                        },
                        onQuerySuccess: e => ({
                            label: e,
                            value: e,
                            description: e
                        })
                    },
                    onClick: e => {
                        const n = yn.getState().numOfStones,
                            r = yn.getState().sideStonesChanged;
                        "side" === t && bn();
                        const i = "three" === n && "center" === t && !r;
                        xn("".concat(t, ".orientation"))(e), wn(t, "orientation", e), i && (xn("side.orientation")(e), wn("side", "orientation", e))
                    },
                    dependantKey: "".concat(t, ".stone.diamondShape"),
                    storeKey: "".concat(t, ".orientation"),
                    componentType: "Basic"
                }]
            }),
            gn = e => {
                let t = "";
                return e.forEach(((n, r) => {
                    let {
                        size: i,
                        quantity: o
                    } = n;
                    const a = (.0047 * Math.pow(i.toFixed(1), 2.731) * o).toFixed(2),
                        s = r === e.length - 1;
                    t += "Pave Size ".concat(i.toFixed(1), "mm; CTW ").concat(a, " ") + (s ? "" : "| ")
                })), t
            },
            vn = (e, t) => new Promise(((n, r) => {
                setTimeout((() => {
                    e(n)
                }), null !== t && void 0 !== t ? t : 100)
            })),
            yn = f((e => ({ ...S.one,
                numOfStones: "one",
                sideStonesChanged: !1,
                band: {
                    bandMetalColor: "18K Yellow",
                    bandStyle: "Round",
                    bandCathedral: "None",
                    bandPaveStyle: "None",
                    bandPaveLength: "Half",
                    bandWidth: 1.7,
                    ringSize: 6,
                    bandFit: "Comfort Fit"
                },
                alterState: (t, n) => {
                    e(ve((e => {
                        let r = e;
                        const i = hn(t);
                        for (let t = 0; t < i.length - 1; t++) r = r[i[t]];
                        r[i[i.length - 1]] = n
                    })))
                },
                changeNumOfStones: t => {
                    e((e => {
                        const n = ((e, t) => {
                            const n = structuredClone(S[t]);
                            if (n.diamondtype = e.diamondtype, "one" !== e.numOfStones) return n;
                            const {
                                stone: r
                            } = e.center, i = r.diamondShape, o = ["center", "right", "left", "side"];
                            return Object.keys(n).forEach((t => {
                                if (!o.includes(t)) return;
                                const r = n[t];
                                n.basketHalo = e.basketHalo, n.prongPave = e.prongPave, n.prongTip = e.prongTip, n.surpriseStones = e.surpriseStones, r.stone.diamondShape = i
                            })), n
                        })(e, t);
                        return { ...n,
                            numOfStones: t,
                            availableStones: e.availableStones,
                            prongMetalColor: e.prongMetalColor,
                            band: e.band,
                            changeNumOfStones: e.changeNumOfStones,
                            alterState: e.alterState
                        }
                    }), !0)
                },
                initiateDefaultRing: t => e((e => ({ ...t,
                    engravingFont:  "Block",
                    // t.engravingFont ? t.engravingFont :
                    changeNumOfStones: e.changeNumOfStones,
                    alterState: e.alterState
                })), !0)
            }))),
            bn = () => {
                yn.setState({
                    sideStonesChanged: !0
                })
            },
            xn = e => t => {
                yn.getState().alterState(e, t)
            },
            _n = new Map([
                ["left", 0],
                ["center", 1],
                ["side", [0, 2]],
                ["right", 2],
                ["one", 1],
                ["two", 2],
                ["three", 3]
            ]),
            Mn = f((e => ({ ...T,
                changeNumberOfHeads: t => {
                    const n = _n.get(t);
                    1 === n ? e(ve((e => {
                        var t, n, r, i, o, a;
                        const s = e,
                            l = s.heads,
                            c = null !== (t = null !== (n = null !== (r = null === (i = l[0]) || void 0 === i ? void 0 : i.prongMetalColor) && void 0 !== r ? r : null === (o = l[1]) || void 0 === o ? void 0 : o.prongMetalColor) && void 0 !== n ? n : null === (a = l[2]) || void 0 === a ? void 0 : a.prongMetalColor) && void 0 !== t ? t : "#FFCB7D";
                        s.heads = [null, { ...C(),
                            prongMetalColor: c
                        }, null]
                    }))) : 2 === n ? e(ve((e => {
                        var t, n, r, i, o, a;
                        const s = e,
                            l = s.heads,
                            c = null !== (t = null !== (n = null !== (r = null === (i = l[0]) || void 0 === i ? void 0 : i.prongMetalColor) && void 0 !== r ? r : null === (o = l[1]) || void 0 === o ? void 0 : o.prongMetalColor) && void 0 !== n ? n : null === (a = l[2]) || void 0 === a ? void 0 : a.prongMetalColor) && void 0 !== t ? t : "#FFCB7D",
                            u = v(s);
                        s.heads = [{ ...C(u),
                            prongMetalColor: c
                        }, null, { ...C(u),
                            prongMetalColor: c
                        }]
                    }))) : 3 === n && e(ve((e => {
                        var t, n, r, i, o, a;
                        const s = e,
                            l = s.heads,
                            c = null !== (t = null !== (n = null !== (r = null === (i = l[0]) || void 0 === i ? void 0 : i.prongMetalColor) && void 0 !== r ? r : null === (o = l[1]) || void 0 === o ? void 0 : o.prongMetalColor) && void 0 !== n ? n : null === (a = l[2]) || void 0 === a ? void 0 : a.prongMetalColor) && void 0 !== t ? t : "#FFCB7D",
                            u = v(s, .5),
                            d = v(s);
                        s.heads = [{ ...C(u, .5),
                            prongMetalColor: c
                        }, { ...C(d),
                            prongMetalColor: c
                        }, { ...C(u, .5),
                            prongMetalColor: c
                        }]
                    })))
                },
                alterHeads: (t, n, r) => {
                    e(ve((e => {
                        const i = e;
                        let o = t;
                        if ("all" === o)
                            for (let t of i.heads) {
                                if (!t) continue;
                                const e = hn(n);
                                for (let n = 0; n < e.length - 1; n++) t = t[e[n]];
                                t[e[e.length - 1]] = "object" === typeof r && null !== r ? { ...t[e[e.length - 1]],
                                    ...r
                                } : r
                            } else {
                                const e = "number" === typeof o ? o : _n.get(o);
                                if (e instanceof Array)
                                    for (let t of e) {
                                        let e = i.heads[t];
                                        const o = hn(n);
                                        for (let t = 0; t < o.length - 1; t++) e = e[o[t]];
                                        e[o[o.length - 1]] = "object" === typeof r && null !== r ? { ...e[o[o.length - 1]],
                                            ...r
                                        } : r
                                    } else {
                                        let t = i.heads[e];
                                        const o = hn(n);
                                        for (let e = 0; e < o.length - 1; e++) t = t[o[e]];
                                        t[o[o.length - 1]] = "object" === typeof r && null !== r ? { ...t[o[o.length - 1]],
                                            ...r
                                        } : r
                                    }
                            }
                    })))
                },
                alterStoneElevation: t => {
                    e(ve((e => {
                        e.stoneElevation = t
                    })))
                },
                alterDiamondType: t => {
                    e(ve((e => {
                        e.diamondtype = t
                    })))
                },
                alterEngravings: (t, n) => {
                    e(ve((e => {
                        e[t] = n
                    })))
                },
                alterBand: (t, n) => {
                    e(ve((e => {
                        e.band[t] = n
                    })))
                },
                initiateRing: t => e(t)
            }))),
            wn = (e, t, n) => {
                Mn.getState().alterHeads(e, t, n)
            },
            An = (e, t) => {
                Mn.getState().alterBand(e, t)
            },
            Sn = e => {
                Mn.getState().alterStoneElevation(e)
            },
            En = (e, t) => {
                Mn.getState().alterEngravings(e, t)
            },
            Cn = () => {
                const e = Mn.getState(),
                    t = yn.getState(),
                    n = {
                        HeadMetalColor: null,
                        BandMetalColor: null,
                        HeadLeft: {
                            Shape: null,
                            CaratWeight: null,
                            Orientation: null,
                            Width: null,
                            Length: null,
                            Depth: null,
                            PavilionDepth: null,
                            GirdleThickness: null,
                            CrownHeight: null
                        },
                        HeadCenter: {
                            Shape: null,
                            CaratWeight: null,
                            Orientation: null,
                            Width: null,
                            Length: null,
                            Depth: null,
                            PavilionDepth: null,
                            GirdleThickness: null,
                            CrownHeight: null
                        },
                        HeadRight: {
                            Shape: null,
                            CaratWeight: null,
                            Orientation: null,
                            Width: null,
                            Length: null,
                            Depth: null,
                            PavilionDepth: null,
                            GirdleThickness: null,
                            CrownHeight: null
                        },
                        StoneElevation: null,
                        DiamondType: null,
                        ProngCount: null,
                        ProngTips: null,
                        ProngArms: null,
                        ProngPave: null,
                        BasketHalo: null,
                        EngravingText: null,
                        EngravingFont: null,
                        SurpriseStones: null,
                        BandStyle: null,
                        Cathedral: null,
                        BandPaveStyle: null,
                        BandPaveLength: null,
                        BandWidth: null,
                        BandSize: null,
                        BandFit: null
                    };
                if (n.BandStyle = t.band.bandStyle, n.Cathedral = t.band.bandCathedral, n.BandPaveStyle = t.band.bandPaveStyle, n.BandPaveLength = t.band.bandPaveLength, n.BandWidth = t.band.bandWidth, n.BandSize = t.band.ringSize, n.BandFit = t.band.bandFit, n.BandMetalColor = t.band.bandMetalColor, n.HeadMetalColor = t.prongMetalColor, n.StoneElevation = t.stoneElevation, n.DiamondType = t.diamondtype, n.EngravingText = t.engravingText, n.EngravingFont = t.engravingText ? t.engravingFont : "", "one" === t.numOfStones ? n.ProngCount = t.center.prongCount : n.ProngCount = "Auto", n.ProngTips = t.prongTip, n.ProngArms = t.prongArm, n.ProngPave = t.prongPave ? "Pave" : "", n.BasketHalo = t.basketHalo, n.SurpriseStones = t.surpriseStones ? "Add Stones" : "", "one" === t.numOfStones) {
                    n.HeadCenter.Shape = t.center.stone.diamondShape, n.HeadCenter.CaratWeight = t.center.stone.caratWeight, n.HeadCenter.Orientation = t.center.orientation;
                    const r = e.heads[1].stone.dimensions;
                    n.HeadCenter.Width = x(r.width), n.HeadCenter.Length = x(r.length), n.HeadCenter.Depth = x(r.depth), n.HeadCenter.PavilionDepth = x(r.pavHeight), n.HeadCenter.GirdleThickness = x(r.girdleThickness), n.HeadCenter.CrownHeight = x(r.crownHeight)
                } else if ("two" === t.numOfStones) {
                    n.HeadLeft.Shape = t.left.stone.diamondShape, n.HeadLeft.CaratWeight = t.left.stone.caratWeight, n.HeadLeft.Orientation = t.left.orientation;
                    const r = e.heads[0].stone.dimensions;
                    n.HeadLeft.Width = x(r.width), n.HeadLeft.Length = x(r.length), n.HeadLeft.Depth = x(r.depth), n.HeadLeft.PavilionDepth = x(r.pavHeight), n.HeadLeft.GirdleThickness = x(r.girdleThickness), n.HeadLeft.CrownHeight = x(r.crownHeight), n.HeadRight.Shape = t.right.stone.diamondShape, n.HeadRight.CaratWeight = t.right.stone.caratWeight, n.HeadRight.Orientation = t.right.orientation;
                    const i = e.heads[2].stone.dimensions;
                    n.HeadRight.Width = x(i.width), n.HeadRight.Length = x(i.length), n.HeadRight.Depth = x(i.depth), n.HeadRight.PavilionDepth = x(i.pavHeight), n.HeadRight.GirdleThickness = x(i.girdleThickness), n.HeadRight.CrownHeight = x(i.crownHeight)
                } else {
                    n.HeadCenter.Shape = t.center.stone.diamondShape, n.HeadCenter.CaratWeight = t.center.stone.caratWeight, n.HeadCenter.Orientation = t.center.orientation;
                    const r = e.heads[1].stone.dimensions;
                    n.HeadCenter.Width = x(r.width), n.HeadCenter.Length = x(r.length), n.HeadCenter.Depth = x(r.depth), n.HeadCenter.PavilionDepth = x(r.pavHeight), n.HeadCenter.GirdleThickness = x(r.girdleThickness), n.HeadCenter.CrownHeight = x(r.crownHeight), n.HeadLeft.Shape = t.side.stone.diamondShape, n.HeadLeft.CaratWeight = t.side.stone.caratWeight, n.HeadLeft.Orientation = t.side.orientation;
                    const i = e.heads[0].stone.dimensions;
                    n.HeadLeft.Width = x(i.width), n.HeadLeft.Length = x(i.length), n.HeadLeft.Depth = x(i.depth), n.HeadLeft.PavilionDepth = x(i.pavHeight), n.HeadLeft.GirdleThickness = x(i.girdleThickness), n.HeadLeft.CrownHeight = x(i.crownHeight), n.HeadRight.Shape = t.side.stone.diamondShape, n.HeadRight.CaratWeight = t.side.stone.caratWeight, n.HeadRight.Orientation = t.side.orientation;
                    const o = e.heads[2].stone.dimensions;
                    n.HeadRight.Width = x(o.width), n.HeadRight.Length = x(o.length), n.HeadRight.Depth = x(o.depth), n.HeadRight.PavilionDepth = x(o.pavHeight), n.HeadRight.GirdleThickness = x(o.girdleThickness), n.HeadRight.CrownHeight = x(o.crownHeight)
                }
                return n
            },
            Tn = async () => {
                try {
                    const e = new URL(window.location.href).searchParams.get("ring"),
                        {
                            data: t
                        } = await cn.get("ring/get-by-key-for-config/".concat(e));
                    return t
                } catch (e) {
                    throw e
                }
            },
            Pn = async e => {
                try {
                    const {
                        data: t
                    } = await cn.post("ring/create-ring", e);
                    return t
                } catch (t) {
                    throw t
                }
            },
            Rn = async () => {
                try {
                    const {
                        data: e
                    } = await cn.get("stone/get-all"), t = ["Heart"];
                    return e.filter((e => !t.includes(e.name)))
                } catch (e) {
                    throw new Error(e)
                }
            },
            In = async e => {
                try {
                    const {
                        queryKey: t
                    } = e, [, n, r, i] = t, {
                        data: o
                    } = await cn.get("stone/get-orientation-by-stone/".concat(i)), a = o[{
                        one: "solitaire",
                        two: "twoStones",
                        three: "threeStones"
                    }[r]];
                    if ("one" === r) return a;
                    if ("two" === r) return a[n];
                    if ("three" === r) return "center" === n ? [] : a
                } catch (t) {
                    throw new Error(t)
                }
            },
            On = async e => {
                try {
                    const {
                        queryKey: t
                    } = e, {
                        data: n
                    } = await cn.get("caratweight/get-all"), r = ((e, t) => {
                        const n = yn.getState().numOfStones,
                            r = {
                                one: "solitaire",
                                two: "twoStones",
                                three: "threeStones",
                                center: "center",
                                left: "left",
                                right: "right"
                            },
                            i = r[t];
                        return e[r[n]][i]
                    })(n, t[1]);
                    return {
                        ownLimits: r,
                        allLimits: n
                    }
                } catch (t) {
                    throw new Error(t)
                }
            },
            Bn = async e => {
                try {
                    const {
                        data: e
                    } = await cn.get("colorcustomisation/get-by-type/Prong");
                    return e
                } catch (t) {
                    throw new Error(t)
                }
            },
            Ln = async e => {
                const {
                    queryKey: t
                } = e, n = t[1];
                if (!("None" === yn.getState().band.bandPaveStyle) && "width" === n) return {
                    ownLimits: {
                        min: 1.5,
                        max: 3
                    }
                };
                try {
                    const {
                        data: e
                    } = await cn.get("band/get-all?key=".concat(n));
                    switch (n) {
                        case "pave.style":
                            const t = ["Channel Set", "Flush Set", "Triple Row"];
                            return e.pave.style.filter((e => !t.includes(e)));
                        case "pave.length":
                            return e.pave.length;
                        case "width":
                        case "ringSize":
                            return {
                                ownLimits: e[n]
                            };
                        default:
                            const r = ["Split Shank", "Twist", "Knife Edge"];
                            return e[n].filter((e => !r.includes(e)))
                    }
                } catch (r) {
                    throw r
                }
            },
            Dn = () => {
                const [e, t] = (0, r.useState)({
                    isVisible: !1,
                    data: null
                });
                return {
                    modal: e,
                    showModal: (0, r.useCallback)((e => {
                        t({
                            isVisible: !0,
                            data: e
                        })
                    }), []),
                    hideModal: (0, r.useCallback)((() => {
                        t({
                            isVisible: !1,
                            data: null
                        })
                    }), [])
                }
            };
        var Nn = n(7884);
        const kn = e => {
                let {
                    hide: t,
                    DisplayRecycle: n
                } = e;
                const [i, o] = (0, r.useState)(window.innerWidth <= 600);
                return (0, r.useEffect)((() => {
                    const e = () => {
                        o(window.innerWidth <= 600)
                    };
                    return window.addEventListener("resize", e), () => window.removeEventListener("resize", e)
                }), []), (0, Nn.jsx)("div", {
                    className: "CPfooter popup",
                    children: (0, Nn.jsxs)("div", {
                        className: "Fcontent popup",
                        children: [(0, Nn.jsx)("button", {
                            onClick: t,
                            className: n ? "Savebtn" : "PMSavebtn",
                            children: "Apply & Return"
                        }), n ? (0, Nn.jsx)("button", {
                            className: "PMstyledbtn",
                            children: (0, Nn.jsx)("img", {
                                src: i ? "trashwhite.svg" : "trash.svg",
                                alt: ""
                            })
                        }) : null]
                    })
                })
            },
            Fn = e => {
                let {
                    hide: t,
                    modalTitle: n,
                    children: r
                } = e;
                return (0, Nn.jsxs)("div", {
                    className: "PopUpModalContainer",
                    children: [(0, Nn.jsxs)("div", {
                        className: "PopUpheader",
                        children: [(0, Nn.jsx)("div", {
                            className: "poparrowcon",
                            children: (0, Nn.jsx)("button", {
                                onClick: t,
                                children: (0, Nn.jsx)("img", {
                                    src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAACnSURBVHgB5ZRBDcJAEEV/UYAEJOAECYwFHOAACR0UAAoqAQmtA+qg/CY02SxzoOyHS1/ymm42eYfJZoDPMPqgJwgxOiTWEGBZdPSOQiyIjuPYogALoi3doABbZrRKovkz6umBdphPN0UHsU31+lHTrfg5Q08/zdjpPr+kV3zHLT043md1hAgP4jVE+L/jF7qGAEe8Mn8WbyDCIV70UbxF4aaL2GHGfJ8EyW0Jk28mvAAAAABJRU5ErkJggg==",
                                    alt: ""
                                })
                            })
                        }), (0, Nn.jsx)("div", {
                            className: "PopUpModalTitle",
                            children: n
                        })]
                    }), (0, Nn.jsxs)("div", {
                        className: "PMContent",
                        id: "styleSB",
                        children: [(0, Nn.jsx)("div", {
                            className: "ChildrenContainer",
                            children: r
                        }), (0, Nn.jsx)(kn, {
                            hide: t,
                            DisplayRecycle: !1
                        })]
                    })]
                })
            },
            Un = e => {
                const t = yn((t => pn(e, t)));
                if (Array.isArray(t)) {
                    const [e, n] = t;
                    return e === n ? e : "@different"
                }
                return t
            },
            zn = "styles_container__5iBAb",
            Hn = "styles_overlay__-jYI8",
            jn = "styles_loader__B1whZ",
            Gn = "styles_loader_text__Z7++G",
            Vn = e => {
                let {
                    text: t
                } = e;
                return (0, Nn.jsx)("div", {
                    className: zn,
                    children: (0, Nn.jsxs)("div", {
                        className: Hn,
                        children: [(0, Nn.jsx)("div", {
                            className: jn
                        }), (0, Nn.jsx)("span", {
                            className: Gn,
                            children: t
                        })]
                    })
                })
            };

        function qn(e) {
            if (null == e) return window;
            if ("[object Window]" !== e.toString()) {
                var t = e.ownerDocument;
                return t && t.defaultView || window
            }
            return e
        }

        function Wn(e) {
            return e instanceof qn(e).Element || e instanceof Element
        }

        function Xn(e) {
            return e instanceof qn(e).HTMLElement || e instanceof HTMLElement
        }

        function Kn(e) {
            return "undefined" !== typeof ShadowRoot && (e instanceof qn(e).ShadowRoot || e instanceof ShadowRoot)
        }
        var Jn = Math.max,
            Yn = Math.min,
            Qn = Math.round;

        function Zn() {
            var e = navigator.userAgentData;
            return null != e && e.brands && Array.isArray(e.brands) ? e.brands.map((function(e) {
                return e.brand + "/" + e.version
            })).join(" ") : navigator.userAgent
        }

        function $n() {
            return !/^((?!chrome|android).)*safari/i.test(Zn())
        }

        function er(e, t, n) {
            void 0 === t && (t = !1), void 0 === n && (n = !1);
            var r = e.getBoundingClientRect(),
                i = 1,
                o = 1;
            t && Xn(e) && (i = e.offsetWidth > 0 && Qn(r.width) / e.offsetWidth || 1, o = e.offsetHeight > 0 && Qn(r.height) / e.offsetHeight || 1);
            var a = (Wn(e) ? qn(e) : window).visualViewport,
                s = !$n() && n,
                l = (r.left + (s && a ? a.offsetLeft : 0)) / i,
                c = (r.top + (s && a ? a.offsetTop : 0)) / o,
                u = r.width / i,
                d = r.height / o;
            return {
                width: u,
                height: d,
                top: c,
                right: l + u,
                bottom: c + d,
                left: l,
                x: l,
                y: c
            }
        }

        function tr(e) {
            var t = qn(e);
            return {
                scrollLeft: t.pageXOffset,
                scrollTop: t.pageYOffset
            }
        }

        function nr(e) {
            return e ? (e.nodeName || "").toLowerCase() : null
        }

        function rr(e) {
            return ((Wn(e) ? e.ownerDocument : e.document) || window.document).documentElement
        }

        function ir(e) {
            return er(rr(e)).left + tr(e).scrollLeft
        }

        function or(e) {
            return qn(e).getComputedStyle(e)
        }

        function ar(e) {
            var t = or(e),
                n = t.overflow,
                r = t.overflowX,
                i = t.overflowY;
            return /auto|scroll|overlay|hidden/.test(n + i + r)
        }

        function sr(e, t, n) {
            void 0 === n && (n = !1);
            var r = Xn(t),
                i = Xn(t) && function(e) {
                    var t = e.getBoundingClientRect(),
                        n = Qn(t.width) / e.offsetWidth || 1,
                        r = Qn(t.height) / e.offsetHeight || 1;
                    return 1 !== n || 1 !== r
                }(t),
                o = rr(t),
                a = er(e, i, n),
                s = {
                    scrollLeft: 0,
                    scrollTop: 0
                },
                l = {
                    x: 0,
                    y: 0
                };
            return (r || !r && !n) && (("body" !== nr(t) || ar(o)) && (s = function(e) {
                return e !== qn(e) && Xn(e) ? {
                    scrollLeft: (t = e).scrollLeft,
                    scrollTop: t.scrollTop
                } : tr(e);
                var t
            }(t)), Xn(t) ? ((l = er(t, !0)).x += t.clientLeft, l.y += t.clientTop) : o && (l.x = ir(o))), {
                x: a.left + s.scrollLeft - l.x,
                y: a.top + s.scrollTop - l.y,
                width: a.width,
                height: a.height
            }
        }

        function lr(e) {
            var t = er(e),
                n = e.offsetWidth,
                r = e.offsetHeight;
            return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), {
                x: e.offsetLeft,
                y: e.offsetTop,
                width: n,
                height: r
            }
        }

        function cr(e) {
            return "html" === nr(e) ? e : e.assignedSlot || e.parentNode || (Kn(e) ? e.host : null) || rr(e)
        }

        function ur(e) {
            return ["html", "body", "#document"].indexOf(nr(e)) >= 0 ? e.ownerDocument.body : Xn(e) && ar(e) ? e : ur(cr(e))
        }

        function dr(e, t) {
            var n;
            void 0 === t && (t = []);
            var r = ur(e),
                i = r === (null == (n = e.ownerDocument) ? void 0 : n.body),
                o = qn(r),
                a = i ? [o].concat(o.visualViewport || [], ar(r) ? r : []) : r,
                s = t.concat(a);
            return i ? s : s.concat(dr(cr(a)))
        }

        function hr(e) {
            return ["table", "td", "th"].indexOf(nr(e)) >= 0
        }

        function pr(e) {
            return Xn(e) && "fixed" !== or(e).position ? e.offsetParent : null
        }

        function fr(e) {
            for (var t = qn(e), n = pr(e); n && hr(n) && "static" === or(n).position;) n = pr(n);
            return n && ("html" === nr(n) || "body" === nr(n) && "static" === or(n).position) ? t : n || function(e) {
                var t = /firefox/i.test(Zn());
                if (/Trident/i.test(Zn()) && Xn(e) && "fixed" === or(e).position) return null;
                var n = cr(e);
                for (Kn(n) && (n = n.host); Xn(n) && ["html", "body"].indexOf(nr(n)) < 0;) {
                    var r = or(n);
                    if ("none" !== r.transform || "none" !== r.perspective || "paint" === r.contain || -1 !== ["transform", "perspective"].indexOf(r.willChange) || t && "filter" === r.willChange || t && r.filter && "none" !== r.filter) return n;
                    n = n.parentNode
                }
                return null
            }(e) || t
        }
        var mr = "top",
            gr = "bottom",
            vr = "right",
            yr = "left",
            br = "auto",
            xr = [mr, gr, vr, yr],
            _r = "start",
            Mr = "end",
            wr = "clippingParents",
            Ar = "viewport",
            Sr = "popper",
            Er = "reference",
            Cr = xr.reduce((function(e, t) {
                return e.concat([t + "-" + _r, t + "-" + Mr])
            }), []),
            Tr = [].concat(xr, [br]).reduce((function(e, t) {
                return e.concat([t, t + "-" + _r, t + "-" + Mr])
            }), []),
            Pr = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"];

        function Rr(e) {
            var t = new Map,
                n = new Set,
                r = [];

            function i(e) {
                n.add(e.name), [].concat(e.requires || [], e.requiresIfExists || []).forEach((function(e) {
                    if (!n.has(e)) {
                        var r = t.get(e);
                        r && i(r)
                    }
                })), r.push(e)
            }
            return e.forEach((function(e) {
                t.set(e.name, e)
            })), e.forEach((function(e) {
                n.has(e.name) || i(e)
            })), r
        }

        function Ir(e) {
            var t;
            return function() {
                return t || (t = new Promise((function(n) {
                    Promise.resolve().then((function() {
                        t = void 0, n(e())
                    }))
                }))), t
            }
        }
        var Or = {
            placement: "bottom",
            modifiers: [],
            strategy: "absolute"
        };

        function Br() {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
            return !t.some((function(e) {
                return !(e && "function" === typeof e.getBoundingClientRect)
            }))
        }

        function Lr(e) {
            void 0 === e && (e = {});
            var t = e,
                n = t.defaultModifiers,
                r = void 0 === n ? [] : n,
                i = t.defaultOptions,
                o = void 0 === i ? Or : i;
            return function(e, t, n) {
                void 0 === n && (n = o);
                var i = {
                        placement: "bottom",
                        orderedModifiers: [],
                        options: Object.assign({}, Or, o),
                        modifiersData: {},
                        elements: {
                            reference: e,
                            popper: t
                        },
                        attributes: {},
                        styles: {}
                    },
                    a = [],
                    s = !1,
                    l = {
                        state: i,
                        setOptions: function(n) {
                            var s = "function" === typeof n ? n(i.options) : n;
                            c(), i.options = Object.assign({}, o, i.options, s), i.scrollParents = {
                                reference: Wn(e) ? dr(e) : e.contextElement ? dr(e.contextElement) : [],
                                popper: dr(t)
                            };
                            var u = function(e) {
                                var t = Rr(e);
                                return Pr.reduce((function(e, n) {
                                    return e.concat(t.filter((function(e) {
                                        return e.phase === n
                                    })))
                                }), [])
                            }(function(e) {
                                var t = e.reduce((function(e, t) {
                                    var n = e[t.name];
                                    return e[t.name] = n ? Object.assign({}, n, t, {
                                        options: Object.assign({}, n.options, t.options),
                                        data: Object.assign({}, n.data, t.data)
                                    }) : t, e
                                }), {});
                                return Object.keys(t).map((function(e) {
                                    return t[e]
                                }))
                            }([].concat(r, i.options.modifiers)));
                            return i.orderedModifiers = u.filter((function(e) {
                                return e.enabled
                            })), i.orderedModifiers.forEach((function(e) {
                                var t = e.name,
                                    n = e.options,
                                    r = void 0 === n ? {} : n,
                                    o = e.effect;
                                if ("function" === typeof o) {
                                    var s = o({
                                            state: i,
                                            name: t,
                                            instance: l,
                                            options: r
                                        }),
                                        c = function() {};
                                    a.push(s || c)
                                }
                            })), l.update()
                        },
                        forceUpdate: function() {
                            if (!s) {
                                var e = i.elements,
                                    t = e.reference,
                                    n = e.popper;
                                if (Br(t, n)) {
                                    i.rects = {
                                        reference: sr(t, fr(n), "fixed" === i.options.strategy),
                                        popper: lr(n)
                                    }, i.reset = !1, i.placement = i.options.placement, i.orderedModifiers.forEach((function(e) {
                                        return i.modifiersData[e.name] = Object.assign({}, e.data)
                                    }));
                                    for (var r = 0; r < i.orderedModifiers.length; r++)
                                        if (!0 !== i.reset) {
                                            var o = i.orderedModifiers[r],
                                                a = o.fn,
                                                c = o.options,
                                                u = void 0 === c ? {} : c,
                                                d = o.name;
                                            "function" === typeof a && (i = a({
                                                state: i,
                                                options: u,
                                                name: d,
                                                instance: l
                                            }) || i)
                                        } else i.reset = !1, r = -1
                                }
                            }
                        },
                        update: Ir((function() {
                            return new Promise((function(e) {
                                l.forceUpdate(), e(i)
                            }))
                        })),
                        destroy: function() {
                            c(), s = !0
                        }
                    };
                if (!Br(e, t)) return l;

                function c() {
                    a.forEach((function(e) {
                        return e()
                    })), a = []
                }
                return l.setOptions(n).then((function(e) {
                    !s && n.onFirstUpdate && n.onFirstUpdate(e)
                })), l
            }
        }
        var Dr = {
            passive: !0
        };

        function Nr(e) {
            return e.split("-")[0]
        }

        function kr(e) {
            return e.split("-")[1]
        }

        function Fr(e) {
            return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y"
        }

        function Ur(e) {
            var t, n = e.reference,
                r = e.element,
                i = e.placement,
                o = i ? Nr(i) : null,
                a = i ? kr(i) : null,
                s = n.x + n.width / 2 - r.width / 2,
                l = n.y + n.height / 2 - r.height / 2;
            switch (o) {
                case mr:
                    t = {
                        x: s,
                        y: n.y - r.height
                    };
                    break;
                case gr:
                    t = {
                        x: s,
                        y: n.y + n.height
                    };
                    break;
                case vr:
                    t = {
                        x: n.x + n.width,
                        y: l
                    };
                    break;
                case yr:
                    t = {
                        x: n.x - r.width,
                        y: l
                    };
                    break;
                default:
                    t = {
                        x: n.x,
                        y: n.y
                    }
            }
            var c = o ? Fr(o) : null;
            if (null != c) {
                var u = "y" === c ? "height" : "width";
                switch (a) {
                    case _r:
                        t[c] = t[c] - (n[u] / 2 - r[u] / 2);
                        break;
                    case Mr:
                        t[c] = t[c] + (n[u] / 2 - r[u] / 2)
                }
            }
            return t
        }
        var zr = {
            top: "auto",
            right: "auto",
            bottom: "auto",
            left: "auto"
        };

        function Hr(e) {
            var t, n = e.popper,
                r = e.popperRect,
                i = e.placement,
                o = e.variation,
                a = e.offsets,
                s = e.position,
                l = e.gpuAcceleration,
                c = e.adaptive,
                u = e.roundOffsets,
                d = e.isFixed,
                h = a.x,
                p = void 0 === h ? 0 : h,
                f = a.y,
                m = void 0 === f ? 0 : f,
                g = "function" === typeof u ? u({
                    x: p,
                    y: m
                }) : {
                    x: p,
                    y: m
                };
            p = g.x, m = g.y;
            var v = a.hasOwnProperty("x"),
                y = a.hasOwnProperty("y"),
                b = yr,
                x = mr,
                _ = window;
            if (c) {
                var M = fr(n),
                    w = "clientHeight",
                    A = "clientWidth";
                if (M === qn(n) && "static" !== or(M = rr(n)).position && "absolute" === s && (w = "scrollHeight", A = "scrollWidth"), i === mr || (i === yr || i === vr) && o === Mr) x = gr, m -= (d && M === _ && _.visualViewport ? _.visualViewport.height : M[w]) - r.height, m *= l ? 1 : -1;
                if (i === yr || (i === mr || i === gr) && o === Mr) b = vr, p -= (d && M === _ && _.visualViewport ? _.visualViewport.width : M[A]) - r.width, p *= l ? 1 : -1
            }
            var S, E = Object.assign({
                    position: s
                }, c && zr),
                C = !0 === u ? function(e, t) {
                    var n = e.x,
                        r = e.y,
                        i = t.devicePixelRatio || 1;
                    return {
                        x: Qn(n * i) / i || 0,
                        y: Qn(r * i) / i || 0
                    }
                }({
                    x: p,
                    y: m
                }, qn(n)) : {
                    x: p,
                    y: m
                };
            return p = C.x, m = C.y, l ? Object.assign({}, E, ((S = {})[x] = y ? "0" : "", S[b] = v ? "0" : "", S.transform = (_.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + m + "px)" : "translate3d(" + p + "px, " + m + "px, 0)", S)) : Object.assign({}, E, ((t = {})[x] = y ? m + "px" : "", t[b] = v ? p + "px" : "", t.transform = "", t))
        }
        const jr = {
            name: "applyStyles",
            enabled: !0,
            phase: "write",
            fn: function(e) {
                var t = e.state;
                Object.keys(t.elements).forEach((function(e) {
                    var n = t.styles[e] || {},
                        r = t.attributes[e] || {},
                        i = t.elements[e];
                    Xn(i) && nr(i) && (Object.assign(i.style, n), Object.keys(r).forEach((function(e) {
                        var t = r[e];
                        !1 === t ? i.removeAttribute(e) : i.setAttribute(e, !0 === t ? "" : t)
                    })))
                }))
            },
            effect: function(e) {
                var t = e.state,
                    n = {
                        popper: {
                            position: t.options.strategy,
                            left: "0",
                            top: "0",
                            margin: "0"
                        },
                        arrow: {
                            position: "absolute"
                        },
                        reference: {}
                    };
                return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow),
                    function() {
                        Object.keys(t.elements).forEach((function(e) {
                            var r = t.elements[e],
                                i = t.attributes[e] || {},
                                o = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : n[e]).reduce((function(e, t) {
                                    return e[t] = "", e
                                }), {});
                            Xn(r) && nr(r) && (Object.assign(r.style, o), Object.keys(i).forEach((function(e) {
                                r.removeAttribute(e)
                            })))
                        }))
                    }
            },
            requires: ["computeStyles"]
        };
        const Gr = {
            name: "offset",
            enabled: !0,
            phase: "main",
            requires: ["popperOffsets"],
            fn: function(e) {
                var t = e.state,
                    n = e.options,
                    r = e.name,
                    i = n.offset,
                    o = void 0 === i ? [0, 0] : i,
                    a = Tr.reduce((function(e, n) {
                        return e[n] = function(e, t, n) {
                            var r = Nr(e),
                                i = [yr, mr].indexOf(r) >= 0 ? -1 : 1,
                                o = "function" === typeof n ? n(Object.assign({}, t, {
                                    placement: e
                                })) : n,
                                a = o[0],
                                s = o[1];
                            return a = a || 0, s = (s || 0) * i, [yr, vr].indexOf(r) >= 0 ? {
                                x: s,
                                y: a
                            } : {
                                x: a,
                                y: s
                            }
                        }(n, t.rects, o), e
                    }), {}),
                    s = a[t.placement],
                    l = s.x,
                    c = s.y;
                null != t.modifiersData.popperOffsets && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c), t.modifiersData[r] = a
            }
        };
        var Vr = {
            left: "right",
            right: "left",
            bottom: "top",
            top: "bottom"
        };

        function qr(e) {
            return e.replace(/left|right|bottom|top/g, (function(e) {
                return Vr[e]
            }))
        }
        var Wr = {
            start: "end",
            end: "start"
        };

        function Xr(e) {
            return e.replace(/start|end/g, (function(e) {
                return Wr[e]
            }))
        }

        function Kr(e, t) {
            var n = t.getRootNode && t.getRootNode();
            if (e.contains(t)) return !0;
            if (n && Kn(n)) {
                var r = t;
                do {
                    if (r && e.isSameNode(r)) return !0;
                    r = r.parentNode || r.host
                } while (r)
            }
            return !1
        }

        function Jr(e) {
            return Object.assign({}, e, {
                left: e.x,
                top: e.y,
                right: e.x + e.width,
                bottom: e.y + e.height
            })
        }

        function Yr(e, t, n) {
            return t === Ar ? Jr(function(e, t) {
                var n = qn(e),
                    r = rr(e),
                    i = n.visualViewport,
                    o = r.clientWidth,
                    a = r.clientHeight,
                    s = 0,
                    l = 0;
                if (i) {
                    o = i.width, a = i.height;
                    var c = $n();
                    (c || !c && "fixed" === t) && (s = i.offsetLeft, l = i.offsetTop)
                }
                return {
                    width: o,
                    height: a,
                    x: s + ir(e),
                    y: l
                }
            }(e, n)) : Wn(t) ? function(e, t) {
                var n = er(e, !1, "fixed" === t);
                return n.top = n.top + e.clientTop, n.left = n.left + e.clientLeft, n.bottom = n.top + e.clientHeight, n.right = n.left + e.clientWidth, n.width = e.clientWidth, n.height = e.clientHeight, n.x = n.left, n.y = n.top, n
            }(t, n) : Jr(function(e) {
                var t, n = rr(e),
                    r = tr(e),
                    i = null == (t = e.ownerDocument) ? void 0 : t.body,
                    o = Jn(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0),
                    a = Jn(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0),
                    s = -r.scrollLeft + ir(e),
                    l = -r.scrollTop;
                return "rtl" === or(i || n).direction && (s += Jn(n.clientWidth, i ? i.clientWidth : 0) - o), {
                    width: o,
                    height: a,
                    x: s,
                    y: l
                }
            }(rr(e)))
        }

        function Qr(e, t, n, r) {
            var i = "clippingParents" === t ? function(e) {
                    var t = dr(cr(e)),
                        n = ["absolute", "fixed"].indexOf(or(e).position) >= 0 && Xn(e) ? fr(e) : e;
                    return Wn(n) ? t.filter((function(e) {
                        return Wn(e) && Kr(e, n) && "body" !== nr(e)
                    })) : []
                }(e) : [].concat(t),
                o = [].concat(i, [n]),
                a = o[0],
                s = o.reduce((function(t, n) {
                    var i = Yr(e, n, r);
                    return t.top = Jn(i.top, t.top), t.right = Yn(i.right, t.right), t.bottom = Yn(i.bottom, t.bottom), t.left = Jn(i.left, t.left), t
                }), Yr(e, a, r));
            return s.width = s.right - s.left, s.height = s.bottom - s.top, s.x = s.left, s.y = s.top, s
        }

        function Zr(e) {
            return Object.assign({}, {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
            }, e)
        }

        function $r(e, t) {
            return t.reduce((function(t, n) {
                return t[n] = e, t
            }), {})
        }

        function ei(e, t) {
            void 0 === t && (t = {});
            var n = t,
                r = n.placement,
                i = void 0 === r ? e.placement : r,
                o = n.strategy,
                a = void 0 === o ? e.strategy : o,
                s = n.boundary,
                l = void 0 === s ? wr : s,
                c = n.rootBoundary,
                u = void 0 === c ? Ar : c,
                d = n.elementContext,
                h = void 0 === d ? Sr : d,
                p = n.altBoundary,
                f = void 0 !== p && p,
                m = n.padding,
                g = void 0 === m ? 0 : m,
                v = Zr("number" !== typeof g ? g : $r(g, xr)),
                y = h === Sr ? Er : Sr,
                b = e.rects.popper,
                x = e.elements[f ? y : h],
                _ = Qr(Wn(x) ? x : x.contextElement || rr(e.elements.popper), l, u, a),
                M = er(e.elements.reference),
                w = Ur({
                    reference: M,
                    element: b,
                    strategy: "absolute",
                    placement: i
                }),
                A = Jr(Object.assign({}, b, w)),
                S = h === Sr ? A : M,
                E = {
                    top: _.top - S.top + v.top,
                    bottom: S.bottom - _.bottom + v.bottom,
                    left: _.left - S.left + v.left,
                    right: S.right - _.right + v.right
                },
                C = e.modifiersData.offset;
            if (h === Sr && C) {
                var T = C[i];
                Object.keys(E).forEach((function(e) {
                    var t = [vr, gr].indexOf(e) >= 0 ? 1 : -1,
                        n = [mr, gr].indexOf(e) >= 0 ? "y" : "x";
                    E[e] += T[n] * t
                }))
            }
            return E
        }
        const ti = {
            name: "flip",
            enabled: !0,
            phase: "main",
            fn: function(e) {
                var t = e.state,
                    n = e.options,
                    r = e.name;
                if (!t.modifiersData[r]._skip) {
                    for (var i = n.mainAxis, o = void 0 === i || i, a = n.altAxis, s = void 0 === a || a, l = n.fallbackPlacements, c = n.padding, u = n.boundary, d = n.rootBoundary, h = n.altBoundary, p = n.flipVariations, f = void 0 === p || p, m = n.allowedAutoPlacements, g = t.options.placement, v = Nr(g), y = l || (v === g || !f ? [qr(g)] : function(e) {
                            if (Nr(e) === br) return [];
                            var t = qr(e);
                            return [Xr(e), t, Xr(t)]
                        }(g)), b = [g].concat(y).reduce((function(e, n) {
                            return e.concat(Nr(n) === br ? function(e, t) {
                                void 0 === t && (t = {});
                                var n = t,
                                    r = n.placement,
                                    i = n.boundary,
                                    o = n.rootBoundary,
                                    a = n.padding,
                                    s = n.flipVariations,
                                    l = n.allowedAutoPlacements,
                                    c = void 0 === l ? Tr : l,
                                    u = kr(r),
                                    d = u ? s ? Cr : Cr.filter((function(e) {
                                        return kr(e) === u
                                    })) : xr,
                                    h = d.filter((function(e) {
                                        return c.indexOf(e) >= 0
                                    }));
                                0 === h.length && (h = d);
                                var p = h.reduce((function(t, n) {
                                    return t[n] = ei(e, {
                                        placement: n,
                                        boundary: i,
                                        rootBoundary: o,
                                        padding: a
                                    })[Nr(n)], t
                                }), {});
                                return Object.keys(p).sort((function(e, t) {
                                    return p[e] - p[t]
                                }))
                            }(t, {
                                placement: n,
                                boundary: u,
                                rootBoundary: d,
                                padding: c,
                                flipVariations: f,
                                allowedAutoPlacements: m
                            }) : n)
                        }), []), x = t.rects.reference, _ = t.rects.popper, M = new Map, w = !0, A = b[0], S = 0; S < b.length; S++) {
                        var E = b[S],
                            C = Nr(E),
                            T = kr(E) === _r,
                            P = [mr, gr].indexOf(C) >= 0,
                            R = P ? "width" : "height",
                            I = ei(t, {
                                placement: E,
                                boundary: u,
                                rootBoundary: d,
                                altBoundary: h,
                                padding: c
                            }),
                            O = P ? T ? vr : yr : T ? gr : mr;
                        x[R] > _[R] && (O = qr(O));
                        var B = qr(O),
                            L = [];
                        if (o && L.push(I[C] <= 0), s && L.push(I[O] <= 0, I[B] <= 0), L.every((function(e) {
                                return e
                            }))) {
                            A = E, w = !1;
                            break
                        }
                        M.set(E, L)
                    }
                    if (w)
                        for (var D = function(e) {
                                var t = b.find((function(t) {
                                    var n = M.get(t);
                                    if (n) return n.slice(0, e).every((function(e) {
                                        return e
                                    }))
                                }));
                                if (t) return A = t, "break"
                            }, N = f ? 3 : 1; N > 0; N--) {
                            if ("break" === D(N)) break
                        }
                    t.placement !== A && (t.modifiersData[r]._skip = !0, t.placement = A, t.reset = !0)
                }
            },
            requiresIfExists: ["offset"],
            data: {
                _skip: !1
            }
        };

        function ni(e, t, n) {
            return Jn(e, Yn(t, n))
        }
        const ri = {
            name: "preventOverflow",
            enabled: !0,
            phase: "main",
            fn: function(e) {
                var t = e.state,
                    n = e.options,
                    r = e.name,
                    i = n.mainAxis,
                    o = void 0 === i || i,
                    a = n.altAxis,
                    s = void 0 !== a && a,
                    l = n.boundary,
                    c = n.rootBoundary,
                    u = n.altBoundary,
                    d = n.padding,
                    h = n.tether,
                    p = void 0 === h || h,
                    f = n.tetherOffset,
                    m = void 0 === f ? 0 : f,
                    g = ei(t, {
                        boundary: l,
                        rootBoundary: c,
                        padding: d,
                        altBoundary: u
                    }),
                    v = Nr(t.placement),
                    y = kr(t.placement),
                    b = !y,
                    x = Fr(v),
                    _ = "x" === x ? "y" : "x",
                    M = t.modifiersData.popperOffsets,
                    w = t.rects.reference,
                    A = t.rects.popper,
                    S = "function" === typeof m ? m(Object.assign({}, t.rects, {
                        placement: t.placement
                    })) : m,
                    E = "number" === typeof S ? {
                        mainAxis: S,
                        altAxis: S
                    } : Object.assign({
                        mainAxis: 0,
                        altAxis: 0
                    }, S),
                    C = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null,
                    T = {
                        x: 0,
                        y: 0
                    };
                if (M) {
                    if (o) {
                        var P, R = "y" === x ? mr : yr,
                            I = "y" === x ? gr : vr,
                            O = "y" === x ? "height" : "width",
                            B = M[x],
                            L = B + g[R],
                            D = B - g[I],
                            N = p ? -A[O] / 2 : 0,
                            k = y === _r ? w[O] : A[O],
                            F = y === _r ? -A[O] : -w[O],
                            U = t.elements.arrow,
                            z = p && U ? lr(U) : {
                                width: 0,
                                height: 0
                            },
                            H = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : {
                                top: 0,
                                right: 0,
                                bottom: 0,
                                left: 0
                            },
                            j = H[R],
                            G = H[I],
                            V = ni(0, w[O], z[O]),
                            q = b ? w[O] / 2 - N - V - j - E.mainAxis : k - V - j - E.mainAxis,
                            W = b ? -w[O] / 2 + N + V + G + E.mainAxis : F + V + G + E.mainAxis,
                            X = t.elements.arrow && fr(t.elements.arrow),
                            K = X ? "y" === x ? X.clientTop || 0 : X.clientLeft || 0 : 0,
                            J = null != (P = null == C ? void 0 : C[x]) ? P : 0,
                            Y = B + W - J,
                            Q = ni(p ? Yn(L, B + q - J - K) : L, B, p ? Jn(D, Y) : D);
                        M[x] = Q, T[x] = Q - B
                    }
                    if (s) {
                        var Z, $ = "x" === x ? mr : yr,
                            ee = "x" === x ? gr : vr,
                            te = M[_],
                            ne = "y" === _ ? "height" : "width",
                            re = te + g[$],
                            ie = te - g[ee],
                            oe = -1 !== [mr, yr].indexOf(v),
                            ae = null != (Z = null == C ? void 0 : C[_]) ? Z : 0,
                            se = oe ? re : te - w[ne] - A[ne] - ae + E.altAxis,
                            le = oe ? te + w[ne] + A[ne] - ae - E.altAxis : ie,
                            ce = p && oe ? function(e, t, n) {
                                var r = ni(e, t, n);
                                return r > n ? n : r
                            }(se, te, le) : ni(p ? se : re, te, p ? le : ie);
                        M[_] = ce, T[_] = ce - te
                    }
                    t.modifiersData[r] = T
                }
            },
            requiresIfExists: ["offset"]
        };
        const ii = {
            name: "arrow",
            enabled: !0,
            phase: "main",
            fn: function(e) {
                var t, n = e.state,
                    r = e.name,
                    i = e.options,
                    o = n.elements.arrow,
                    a = n.modifiersData.popperOffsets,
                    s = Nr(n.placement),
                    l = Fr(s),
                    c = [yr, vr].indexOf(s) >= 0 ? "height" : "width";
                if (o && a) {
                    var u = function(e, t) {
                            return Zr("number" !== typeof(e = "function" === typeof e ? e(Object.assign({}, t.rects, {
                                placement: t.placement
                            })) : e) ? e : $r(e, xr))
                        }(i.padding, n),
                        d = lr(o),
                        h = "y" === l ? mr : yr,
                        p = "y" === l ? gr : vr,
                        f = n.rects.reference[c] + n.rects.reference[l] - a[l] - n.rects.popper[c],
                        m = a[l] - n.rects.reference[l],
                        g = fr(o),
                        v = g ? "y" === l ? g.clientHeight || 0 : g.clientWidth || 0 : 0,
                        y = f / 2 - m / 2,
                        b = u[h],
                        x = v - d[c] - u[p],
                        _ = v / 2 - d[c] / 2 + y,
                        M = ni(b, _, x),
                        w = l;
                    n.modifiersData[r] = ((t = {})[w] = M, t.centerOffset = M - _, t)
                }
            },
            effect: function(e) {
                var t = e.state,
                    n = e.options.element,
                    r = void 0 === n ? "[data-popper-arrow]" : n;
                null != r && ("string" !== typeof r || (r = t.elements.popper.querySelector(r))) && Kr(t.elements.popper, r) && (t.elements.arrow = r)
            },
            requires: ["popperOffsets"],
            requiresIfExists: ["preventOverflow"]
        };

        function oi(e, t, n) {
            return void 0 === n && (n = {
                x: 0,
                y: 0
            }), {
                top: e.top - t.height - n.y,
                right: e.right - t.width + n.x,
                bottom: e.bottom - t.height + n.y,
                left: e.left - t.width - n.x
            }
        }

        function ai(e) {
            return [mr, vr, gr, yr].some((function(t) {
                return e[t] >= 0
            }))
        }
        var si = Lr({
                defaultModifiers: [{
                    name: "eventListeners",
                    enabled: !0,
                    phase: "write",
                    fn: function() {},
                    effect: function(e) {
                        var t = e.state,
                            n = e.instance,
                            r = e.options,
                            i = r.scroll,
                            o = void 0 === i || i,
                            a = r.resize,
                            s = void 0 === a || a,
                            l = qn(t.elements.popper),
                            c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
                        return o && c.forEach((function(e) {
                                e.addEventListener("scroll", n.update, Dr)
                            })), s && l.addEventListener("resize", n.update, Dr),
                            function() {
                                o && c.forEach((function(e) {
                                    e.removeEventListener("scroll", n.update, Dr)
                                })), s && l.removeEventListener("resize", n.update, Dr)
                            }
                    },
                    data: {}
                }, {
                    name: "popperOffsets",
                    enabled: !0,
                    phase: "read",
                    fn: function(e) {
                        var t = e.state,
                            n = e.name;
                        t.modifiersData[n] = Ur({
                            reference: t.rects.reference,
                            element: t.rects.popper,
                            strategy: "absolute",
                            placement: t.placement
                        })
                    },
                    data: {}
                }, {
                    name: "computeStyles",
                    enabled: !0,
                    phase: "beforeWrite",
                    fn: function(e) {
                        var t = e.state,
                            n = e.options,
                            r = n.gpuAcceleration,
                            i = void 0 === r || r,
                            o = n.adaptive,
                            a = void 0 === o || o,
                            s = n.roundOffsets,
                            l = void 0 === s || s,
                            c = {
                                placement: Nr(t.placement),
                                variation: kr(t.placement),
                                popper: t.elements.popper,
                                popperRect: t.rects.popper,
                                gpuAcceleration: i,
                                isFixed: "fixed" === t.options.strategy
                            };
                        null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign({}, t.styles.popper, Hr(Object.assign({}, c, {
                            offsets: t.modifiersData.popperOffsets,
                            position: t.options.strategy,
                            adaptive: a,
                            roundOffsets: l
                        })))), null != t.modifiersData.arrow && (t.styles.arrow = Object.assign({}, t.styles.arrow, Hr(Object.assign({}, c, {
                            offsets: t.modifiersData.arrow,
                            position: "absolute",
                            adaptive: !1,
                            roundOffsets: l
                        })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
                            "data-popper-placement": t.placement
                        })
                    },
                    data: {}
                }, jr, Gr, ti, ri, ii, {
                    name: "hide",
                    enabled: !0,
                    phase: "main",
                    requiresIfExists: ["preventOverflow"],
                    fn: function(e) {
                        var t = e.state,
                            n = e.name,
                            r = t.rects.reference,
                            i = t.rects.popper,
                            o = t.modifiersData.preventOverflow,
                            a = ei(t, {
                                elementContext: "reference"
                            }),
                            s = ei(t, {
                                altBoundary: !0
                            }),
                            l = oi(a, r),
                            c = oi(s, i, o),
                            u = ai(l),
                            d = ai(c);
                        t.modifiersData[n] = {
                            referenceClippingOffsets: l,
                            popperEscapeOffsets: c,
                            isReferenceHidden: u,
                            hasPopperEscaped: d
                        }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
                            "data-popper-reference-hidden": u,
                            "data-popper-escaped": d
                        })
                    }
                }]
            }),
            li = "tippy-content",
            ci = "tippy-backdrop",
            ui = "tippy-arrow",
            di = "tippy-svg-arrow",
            hi = {
                passive: !0,
                capture: !0
            },
            pi = function() {
                return document.body
            };

        function fi(e, t, n) {
            if (Array.isArray(e)) {
                var r = e[t];
                return null == r ? Array.isArray(n) ? n[t] : n : r
            }
            return e
        }

        function mi(e, t) {
            var n = {}.toString.call(e);
            return 0 === n.indexOf("[object") && n.indexOf(t + "]") > -1
        }

        function gi(e, t) {
            return "function" === typeof e ? e.apply(void 0, t) : e
        }

        function vi(e, t) {
            return 0 === t ? e : function(r) {
                clearTimeout(n), n = setTimeout((function() {
                    e(r)
                }), t)
            };
            var n
        }

        function yi(e) {
            return [].concat(e)
        }

        function bi(e, t) {
            -1 === e.indexOf(t) && e.push(t)
        }

        function xi(e) {
            return e.split("-")[0]
        }

        function _i(e) {
            return [].slice.call(e)
        }

        function Mi(e) {
            return Object.keys(e).reduce((function(t, n) {
                return void 0 !== e[n] && (t[n] = e[n]), t
            }), {})
        }

        function wi() {
            return document.createElement("div")
        }

        function Ai(e) {
            return ["Element", "Fragment"].some((function(t) {
                return mi(e, t)
            }))
        }

        function Si(e) {
            return mi(e, "MouseEvent")
        }

        function Ei(e) {
            return !(!e || !e._tippy || e._tippy.reference !== e)
        }

        function Ci(e) {
            return Ai(e) ? [e] : function(e) {
                return mi(e, "NodeList")
            }(e) ? _i(e) : Array.isArray(e) ? e : _i(document.querySelectorAll(e))
        }

        function Ti(e, t) {
            e.forEach((function(e) {
                e && (e.style.transitionDuration = t + "ms")
            }))
        }

        function Pi(e, t) {
            e.forEach((function(e) {
                e && e.setAttribute("data-state", t)
            }))
        }

        function Ri(e) {
            var t, n = yi(e)[0];
            return null != n && null != (t = n.ownerDocument) && t.body ? n.ownerDocument : document
        }

        function Ii(e, t, n) {
            var r = t + "EventListener";
            ["transitionend", "webkitTransitionEnd"].forEach((function(t) {
                e[r](t, n)
            }))
        }

        function Oi(e, t) {
            for (var n = t; n;) {
                var r;
                if (e.contains(n)) return !0;
                n = null == n.getRootNode || null == (r = n.getRootNode()) ? void 0 : r.host
            }
            return !1
        }
        var Bi = {
                isTouch: !1
            },
            Li = 0;

        function Di() {
            Bi.isTouch || (Bi.isTouch = !0, window.performance && document.addEventListener("mousemove", Ni))
        }

        function Ni() {
            var e = performance.now();
            e - Li < 20 && (Bi.isTouch = !1, document.removeEventListener("mousemove", Ni)), Li = e
        }

        function ki() {
            var e = document.activeElement;
            if (Ei(e)) {
                var t = e._tippy;
                e.blur && !t.state.isVisible && e.blur()
            }
        }
        var Fi = !!("undefined" !== typeof window && "undefined" !== typeof document) && !!window.msCrypto;
        var Ui = {
                animateFill: !1,
                followCursor: !1,
                inlinePositioning: !1,
                sticky: !1
            },
            zi = Object.assign({
                appendTo: pi,
                aria: {
                    content: "auto",
                    expanded: "auto"
                },
                delay: 0,
                duration: [300, 250],
                getReferenceClientRect: null,
                hideOnClick: !0,
                ignoreAttributes: !1,
                interactive: !1,
                interactiveBorder: 2,
                interactiveDebounce: 0,
                moveTransition: "",
                offset: [0, 10],
                onAfterUpdate: function() {},
                onBeforeUpdate: function() {},
                onCreate: function() {},
                onDestroy: function() {},
                onHidden: function() {},
                onHide: function() {},
                onMount: function() {},
                onShow: function() {},
                onShown: function() {},
                onTrigger: function() {},
                onUntrigger: function() {},
                onClickOutside: function() {},
                placement: "top",
                plugins: [],
                popperOptions: {},
                render: null,
                showOnCreate: !1,
                touch: !0,
                trigger: "mouseenter focus",
                triggerTarget: null
            }, Ui, {
                allowHTML: !1,
                animation: "fade",
                arrow: !0,
                content: "",
                inertia: !1,
                maxWidth: 350,
                role: "tooltip",
                theme: "",
                zIndex: 9999
            }),
            Hi = Object.keys(zi);

        function ji(e) {
            var t = (e.plugins || []).reduce((function(t, n) {
                var r, i = n.name,
                    o = n.defaultValue;
                i && (t[i] = void 0 !== e[i] ? e[i] : null != (r = zi[i]) ? r : o);
                return t
            }), {});
            return Object.assign({}, e, t)
        }

        function Gi(e, t) {
            var n = Object.assign({}, t, {
                content: gi(t.content, [e])
            }, t.ignoreAttributes ? {} : function(e, t) {
                return (t ? Object.keys(ji(Object.assign({}, zi, {
                    plugins: t
                }))) : Hi).reduce((function(t, n) {
                    var r = (e.getAttribute("data-tippy-" + n) || "").trim();
                    if (!r) return t;
                    if ("content" === n) t[n] = r;
                    else try {
                        t[n] = JSON.parse(r)
                    } catch (i) {
                        t[n] = r
                    }
                    return t
                }), {})
            }(e, t.plugins));
            return n.aria = Object.assign({}, zi.aria, n.aria), n.aria = {
                expanded: "auto" === n.aria.expanded ? t.interactive : n.aria.expanded,
                content: "auto" === n.aria.content ? t.interactive ? null : "describedby" : n.aria.content
            }, n
        }
        var Vi = function() {
            return "innerHTML"
        };

        function qi(e, t) {
            e[Vi()] = t
        }

        function Wi(e) {
            var t = wi();
            return !0 === e ? t.className = ui : (t.className = di, Ai(e) ? t.appendChild(e) : qi(t, e)), t
        }

        function Xi(e, t) {
            Ai(t.content) ? (qi(e, ""), e.appendChild(t.content)) : "function" !== typeof t.content && (t.allowHTML ? qi(e, t.content) : e.textContent = t.content)
        }

        function Ki(e) {
            var t = e.firstElementChild,
                n = _i(t.children);
            return {
                box: t,
                content: n.find((function(e) {
                    return e.classList.contains(li)
                })),
                arrow: n.find((function(e) {
                    return e.classList.contains(ui) || e.classList.contains(di)
                })),
                backdrop: n.find((function(e) {
                    return e.classList.contains(ci)
                }))
            }
        }

        function Ji(e) {
            var t = wi(),
                n = wi();
            n.className = "tippy-box", n.setAttribute("data-state", "hidden"), n.setAttribute("tabindex", "-1");
            var r = wi();

            function i(n, r) {
                var i = Ki(t),
                    o = i.box,
                    a = i.content,
                    s = i.arrow;
                r.theme ? o.setAttribute("data-theme", r.theme) : o.removeAttribute("data-theme"), "string" === typeof r.animation ? o.setAttribute("data-animation", r.animation) : o.removeAttribute("data-animation"), r.inertia ? o.setAttribute("data-inertia", "") : o.removeAttribute("data-inertia"), o.style.maxWidth = "number" === typeof r.maxWidth ? r.maxWidth + "px" : r.maxWidth, r.role ? o.setAttribute("role", r.role) : o.removeAttribute("role"), n.content === r.content && n.allowHTML === r.allowHTML || Xi(a, e.props), r.arrow ? s ? n.arrow !== r.arrow && (o.removeChild(s), o.appendChild(Wi(r.arrow))) : o.appendChild(Wi(r.arrow)) : s && o.removeChild(s)
            }
            return r.className = li, r.setAttribute("data-state", "hidden"), Xi(r, e.props), t.appendChild(n), n.appendChild(r), i(e.props, e.props), {
                popper: t,
                onUpdate: i
            }
        }
        Ji.$$tippy = !0;
        var Yi = 1,
            Qi = [],
            Zi = [];

        function $i(e, t) {
            var n, r, i, o, a, s, l, c, u = Gi(e, Object.assign({}, zi, ji(Mi(t)))),
                d = !1,
                h = !1,
                p = !1,
                f = !1,
                m = [],
                g = vi(X, u.interactiveDebounce),
                v = Yi++,
                y = (c = u.plugins).filter((function(e, t) {
                    return c.indexOf(e) === t
                })),
                b = {
                    id: v,
                    reference: e,
                    popper: wi(),
                    popperInstance: null,
                    props: u,
                    state: {
                        isEnabled: !0,
                        isVisible: !1,
                        isDestroyed: !1,
                        isMounted: !1,
                        isShown: !1
                    },
                    plugins: y,
                    clearDelayTimeouts: function() {
                        clearTimeout(n), clearTimeout(r), cancelAnimationFrame(i)
                    },
                    setProps: function(t) {
                        0;
                        if (b.state.isDestroyed) return;
                        B("onBeforeUpdate", [b, t]), q();
                        var n = b.props,
                            r = Gi(e, Object.assign({}, n, Mi(t), {
                                ignoreAttributes: !0
                            }));
                        b.props = r, V(), n.interactiveDebounce !== r.interactiveDebounce && (N(), g = vi(X, r.interactiveDebounce));
                        n.triggerTarget && !r.triggerTarget ? yi(n.triggerTarget).forEach((function(e) {
                            e.removeAttribute("aria-expanded")
                        })) : r.triggerTarget && e.removeAttribute("aria-expanded");
                        D(), O(), M && M(n, r);
                        b.popperInstance && (Q(), $().forEach((function(e) {
                            requestAnimationFrame(e._tippy.popperInstance.forceUpdate)
                        })));
                        B("onAfterUpdate", [b, t])
                    },
                    setContent: function(e) {
                        b.setProps({
                            content: e
                        })
                    },
                    show: function() {
                        0;
                        var e = b.state.isVisible,
                            t = b.state.isDestroyed,
                            n = !b.state.isEnabled,
                            r = Bi.isTouch && !b.props.touch,
                            i = fi(b.props.duration, 0, zi.duration);
                        if (e || t || n || r) return;
                        if (T().hasAttribute("disabled")) return;
                        if (B("onShow", [b], !1), !1 === b.props.onShow(b)) return;
                        b.state.isVisible = !0, C() && (_.style.visibility = "visible");
                        O(), z(), b.state.isMounted || (_.style.transition = "none");
                        if (C()) {
                            var o = R();
                            Ti([o.box, o.content], 0)
                        }
                        s = function() {
                                var e;
                                if (b.state.isVisible && !f) {
                                    if (f = !0, _.offsetHeight, _.style.transition = b.props.moveTransition, C() && b.props.animation) {
                                        var t = R(),
                                            n = t.box,
                                            r = t.content;
                                        Ti([n, r], i), Pi([n, r], "visible")
                                    }
                                    L(), D(), bi(Zi, b), null == (e = b.popperInstance) || e.forceUpdate(), B("onMount", [b]), b.props.animation && C() && function(e, t) {
                                        j(e, t)
                                    }(i, (function() {
                                        b.state.isShown = !0, B("onShown", [b])
                                    }))
                                }
                            },
                            function() {
                                var e, t = b.props.appendTo,
                                    n = T();
                                e = b.props.interactive && t === pi || "parent" === t ? n.parentNode : gi(t, [n]);
                                e.contains(_) || e.appendChild(_);
                                b.state.isMounted = !0, Q(), !1
                            }()
                    },
                    hide: function() {
                        0;
                        var e = !b.state.isVisible,
                            t = b.state.isDestroyed,
                            n = !b.state.isEnabled,
                            r = fi(b.props.duration, 1, zi.duration);
                        if (e || t || n) return;
                        if (B("onHide", [b], !1), !1 === b.props.onHide(b)) return;
                        b.state.isVisible = !1, b.state.isShown = !1, f = !1, d = !1, C() && (_.style.visibility = "hidden");
                        if (N(), H(), O(!0), C()) {
                            var i = R(),
                                o = i.box,
                                a = i.content;
                            b.props.animation && (Ti([o, a], r), Pi([o, a], "hidden"))
                        }
                        L(), D(), b.props.animation ? C() && function(e, t) {
                            j(e, (function() {
                                !b.state.isVisible && _.parentNode && _.parentNode.contains(_) && t()
                            }))
                        }(r, b.unmount) : b.unmount()
                    },
                    hideWithInteractivity: function(e) {
                        0;
                        P().addEventListener("mousemove", g), bi(Qi, g), g(e)
                    },
                    enable: function() {
                        b.state.isEnabled = !0
                    },
                    disable: function() {
                        b.hide(), b.state.isEnabled = !1
                    },
                    unmount: function() {
                        0;
                        b.state.isVisible && b.hide();
                        if (!b.state.isMounted) return;
                        Z(), $().forEach((function(e) {
                            e._tippy.unmount()
                        })), _.parentNode && _.parentNode.removeChild(_);
                        Zi = Zi.filter((function(e) {
                            return e !== b
                        })), b.state.isMounted = !1, B("onHidden", [b])
                    },
                    destroy: function() {
                        0;
                        if (b.state.isDestroyed) return;
                        b.clearDelayTimeouts(), b.unmount(), q(), delete e._tippy, b.state.isDestroyed = !0, B("onDestroy", [b])
                    }
                };
            if (!u.render) return b;
            var x = u.render(b),
                _ = x.popper,
                M = x.onUpdate;
            _.setAttribute("data-tippy-root", ""), _.id = "tippy-" + b.id, b.popper = _, e._tippy = b, _._tippy = b;
            var w = y.map((function(e) {
                    return e.fn(b)
                })),
                A = e.hasAttribute("aria-expanded");
            return V(), D(), O(), B("onCreate", [b]), u.showOnCreate && ee(), _.addEventListener("mouseenter", (function() {
                b.props.interactive && b.state.isVisible && b.clearDelayTimeouts()
            })), _.addEventListener("mouseleave", (function() {
                b.props.interactive && b.props.trigger.indexOf("mouseenter") >= 0 && P().addEventListener("mousemove", g)
            })), b;

            function S() {
                var e = b.props.touch;
                return Array.isArray(e) ? e : [e, 0]
            }

            function E() {
                return "hold" === S()[0]
            }

            function C() {
                var e;
                return !(null == (e = b.props.render) || !e.$$tippy)
            }

            function T() {
                return l || e
            }

            function P() {
                var e = T().parentNode;
                return e ? Ri(e) : document
            }

            function R() {
                return Ki(_)
            }

            function I(e) {
                return b.state.isMounted && !b.state.isVisible || Bi.isTouch || o && "focus" === o.type ? 0 : fi(b.props.delay, e ? 0 : 1, zi.delay)
            }

            function O(e) {
                void 0 === e && (e = !1), _.style.pointerEvents = b.props.interactive && !e ? "" : "none", _.style.zIndex = "" + b.props.zIndex
            }

            function B(e, t, n) {
                var r;
                (void 0 === n && (n = !0), w.forEach((function(n) {
                    n[e] && n[e].apply(n, t)
                })), n) && (r = b.props)[e].apply(r, t)
            }

            function L() {
                var t = b.props.aria;
                if (t.content) {
                    var n = "aria-" + t.content,
                        r = _.id;
                    yi(b.props.triggerTarget || e).forEach((function(e) {
                        var t = e.getAttribute(n);
                        if (b.state.isVisible) e.setAttribute(n, t ? t + " " + r : r);
                        else {
                            var i = t && t.replace(r, "").trim();
                            i ? e.setAttribute(n, i) : e.removeAttribute(n)
                        }
                    }))
                }
            }

            function D() {
                !A && b.props.aria.expanded && yi(b.props.triggerTarget || e).forEach((function(e) {
                    b.props.interactive ? e.setAttribute("aria-expanded", b.state.isVisible && e === T() ? "true" : "false") : e.removeAttribute("aria-expanded")
                }))
            }

            function N() {
                P().removeEventListener("mousemove", g), Qi = Qi.filter((function(e) {
                    return e !== g
                }))
            }

            function k(t) {
                if (!Bi.isTouch || !p && "mousedown" !== t.type) {
                    var n = t.composedPath && t.composedPath()[0] || t.target;
                    if (!b.props.interactive || !Oi(_, n)) {
                        if (yi(b.props.triggerTarget || e).some((function(e) {
                                return Oi(e, n)
                            }))) {
                            if (Bi.isTouch) return;
                            if (b.state.isVisible && b.props.trigger.indexOf("click") >= 0) return
                        } else B("onClickOutside", [b, t]);
                        !0 === b.props.hideOnClick && (b.clearDelayTimeouts(), b.hide(), h = !0, setTimeout((function() {
                            h = !1
                        })), b.state.isMounted || H())
                    }
                }
            }

            function F() {
                p = !0
            }

            function U() {
                p = !1
            }

            function z() {
                var e = P();
                e.addEventListener("mousedown", k, !0), e.addEventListener("touchend", k, hi), e.addEventListener("touchstart", U, hi), e.addEventListener("touchmove", F, hi)
            }

            function H() {
                var e = P();
                e.removeEventListener("mousedown", k, !0), e.removeEventListener("touchend", k, hi), e.removeEventListener("touchstart", U, hi), e.removeEventListener("touchmove", F, hi)
            }

            function j(e, t) {
                var n = R().box;

                function r(e) {
                    e.target === n && (Ii(n, "remove", r), t())
                }
                if (0 === e) return t();
                Ii(n, "remove", a), Ii(n, "add", r), a = r
            }

            function G(t, n, r) {
                void 0 === r && (r = !1), yi(b.props.triggerTarget || e).forEach((function(e) {
                    e.addEventListener(t, n, r), m.push({
                        node: e,
                        eventType: t,
                        handler: n,
                        options: r
                    })
                }))
            }

            function V() {
                var e;
                E() && (G("touchstart", W, {
                    passive: !0
                }), G("touchend", K, {
                    passive: !0
                })), (e = b.props.trigger, e.split(/\s+/).filter(Boolean)).forEach((function(e) {
                    if ("manual" !== e) switch (G(e, W), e) {
                        case "mouseenter":
                            G("mouseleave", K);
                            break;
                        case "focus":
                            G(Fi ? "focusout" : "blur", J);
                            break;
                        case "focusin":
                            G("focusout", J)
                    }
                }))
            }

            function q() {
                m.forEach((function(e) {
                    var t = e.node,
                        n = e.eventType,
                        r = e.handler,
                        i = e.options;
                    t.removeEventListener(n, r, i)
                })), m = []
            }

            function W(e) {
                var t, n = !1;
                if (b.state.isEnabled && !Y(e) && !h) {
                    var r = "focus" === (null == (t = o) ? void 0 : t.type);
                    o = e, l = e.currentTarget, D(), !b.state.isVisible && Si(e) && Qi.forEach((function(t) {
                        return t(e)
                    })), "click" === e.type && (b.props.trigger.indexOf("mouseenter") < 0 || d) && !1 !== b.props.hideOnClick && b.state.isVisible ? n = !0 : ee(e), "click" === e.type && (d = !n), n && !r && te(e)
                }
            }

            function X(e) {
                var t = e.target,
                    n = T().contains(t) || _.contains(t);
                if ("mousemove" !== e.type || !n) {
                    var r = $().concat(_).map((function(e) {
                        var t, n = null == (t = e._tippy.popperInstance) ? void 0 : t.state;
                        return n ? {
                            popperRect: e.getBoundingClientRect(),
                            popperState: n,
                            props: u
                        } : null
                    })).filter(Boolean);
                    (function(e, t) {
                        var n = t.clientX,
                            r = t.clientY;
                        return e.every((function(e) {
                            var t = e.popperRect,
                                i = e.popperState,
                                o = e.props.interactiveBorder,
                                a = xi(i.placement),
                                s = i.modifiersData.offset;
                            if (!s) return !0;
                            var l = "bottom" === a ? s.top.y : 0,
                                c = "top" === a ? s.bottom.y : 0,
                                u = "right" === a ? s.left.x : 0,
                                d = "left" === a ? s.right.x : 0,
                                h = t.top - r + l > o,
                                p = r - t.bottom - c > o,
                                f = t.left - n + u > o,
                                m = n - t.right - d > o;
                            return h || p || f || m
                        }))
                    })(r, e) && (N(), te(e))
                }
            }

            function K(e) {
                Y(e) || b.props.trigger.indexOf("click") >= 0 && d || (b.props.interactive ? b.hideWithInteractivity(e) : te(e))
            }

            function J(e) {
                b.props.trigger.indexOf("focusin") < 0 && e.target !== T() || b.props.interactive && e.relatedTarget && _.contains(e.relatedTarget) || te(e)
            }

            function Y(e) {
                return !!Bi.isTouch && E() !== e.type.indexOf("touch") >= 0
            }

            function Q() {
                Z();
                var t = b.props,
                    n = t.popperOptions,
                    r = t.placement,
                    i = t.offset,
                    o = t.getReferenceClientRect,
                    a = t.moveTransition,
                    l = C() ? Ki(_).arrow : null,
                    c = o ? {
                        getBoundingClientRect: o,
                        contextElement: o.contextElement || T()
                    } : e,
                    u = {
                        name: "$$tippy",
                        enabled: !0,
                        phase: "beforeWrite",
                        requires: ["computeStyles"],
                        fn: function(e) {
                            var t = e.state;
                            if (C()) {
                                var n = R().box;
                                ["placement", "reference-hidden", "escaped"].forEach((function(e) {
                                    "placement" === e ? n.setAttribute("data-placement", t.placement) : t.attributes.popper["data-popper-" + e] ? n.setAttribute("data-" + e, "") : n.removeAttribute("data-" + e)
                                })), t.attributes.popper = {}
                            }
                        }
                    },
                    d = [{
                        name: "offset",
                        options: {
                            offset: i
                        }
                    }, {
                        name: "preventOverflow",
                        options: {
                            padding: {
                                top: 2,
                                bottom: 2,
                                left: 5,
                                right: 5
                            }
                        }
                    }, {
                        name: "flip",
                        options: {
                            padding: 5
                        }
                    }, {
                        name: "computeStyles",
                        options: {
                            adaptive: !a
                        }
                    }, u];
                C() && l && d.push({
                    name: "arrow",
                    options: {
                        element: l,
                        padding: 3
                    }
                }), d.push.apply(d, (null == n ? void 0 : n.modifiers) || []), b.popperInstance = si(c, _, Object.assign({}, n, {
                    placement: r,
                    onFirstUpdate: s,
                    modifiers: d
                }))
            }

            function Z() {
                b.popperInstance && (b.popperInstance.destroy(), b.popperInstance = null)
            }

            function $() {
                return _i(_.querySelectorAll("[data-tippy-root]"))
            }

            function ee(e) {
                b.clearDelayTimeouts(), e && B("onTrigger", [b, e]), z();
                var t = I(!0),
                    r = S(),
                    i = r[0],
                    o = r[1];
                Bi.isTouch && "hold" === i && o && (t = o), t ? n = setTimeout((function() {
                    b.show()
                }), t) : b.show()
            }

            function te(e) {
                if (b.clearDelayTimeouts(), B("onUntrigger", [b, e]), b.state.isVisible) {
                    if (!(b.props.trigger.indexOf("mouseenter") >= 0 && b.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(e.type) >= 0 && d)) {
                        var t = I(!1);
                        t ? r = setTimeout((function() {
                            b.state.isVisible && b.hide()
                        }), t) : i = requestAnimationFrame((function() {
                            b.hide()
                        }))
                    }
                } else H()
            }
        }

        function eo(e, t) {
            void 0 === t && (t = {});
            var n = zi.plugins.concat(t.plugins || []);
            document.addEventListener("touchstart", Di, hi), window.addEventListener("blur", ki);
            var r = Object.assign({}, t, {
                    plugins: n
                }),
                i = Ci(e).reduce((function(e, t) {
                    var n = t && $i(t, r);
                    return n && e.push(n), e
                }), []);
            return Ai(e) ? i[0] : i
        }
        eo.defaultProps = zi, eo.setDefaultProps = function(e) {
            Object.keys(e).forEach((function(t) {
                zi[t] = e[t]
            }))
        }, eo.currentInput = Bi;
        Object.assign({}, jr, {
            effect: function(e) {
                var t = e.state,
                    n = {
                        popper: {
                            position: t.options.strategy,
                            left: "0",
                            top: "0",
                            margin: "0"
                        },
                        arrow: {
                            position: "absolute"
                        },
                        reference: {}
                    };
                Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow)
            }
        });
        eo.setDefaultProps({
            render: Ji
        });
        const to = eo;
        var no = n(8828);

        function ro(e, t) {
            if (null == e) return {};
            var n, r, i = {},
                o = Object.keys(e);
            for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) >= 0 || (i[n] = e[n]);
            return i
        }
        var io = "undefined" !== typeof window && "undefined" !== typeof document;

        function oo(e, t) {
            e && ("function" === typeof e && e(t), {}.hasOwnProperty.call(e, "current") && (e.current = t))
        }

        function ao() {
            return io && document.createElement("div")
        }

        function so(e, t) {
            if (e === t) return !0;
            if ("object" === typeof e && null != e && "object" === typeof t && null != t) {
                if (Object.keys(e).length !== Object.keys(t).length) return !1;
                for (var n in e) {
                    if (!t.hasOwnProperty(n)) return !1;
                    if (!so(e[n], t[n])) return !1
                }
                return !0
            }
            return !1
        }

        function lo(e) {
            var t = [];
            return e.forEach((function(e) {
                t.find((function(t) {
                    return so(e, t)
                })) || t.push(e)
            })), t
        }

        function co(e, t) {
            var n, r;
            return Object.assign({}, t, {
                popperOptions: Object.assign({}, e.popperOptions, t.popperOptions, {
                    modifiers: lo([].concat((null == (n = e.popperOptions) ? void 0 : n.modifiers) || [], (null == (r = t.popperOptions) ? void 0 : r.modifiers) || []))
                })
            })
        }
        var uo = io ? r.useLayoutEffect : r.useEffect;

        function ho(e) {
            var t = (0, r.useRef)();
            return t.current || (t.current = "function" === typeof e ? e() : e), t.current
        }

        function po(e, t, n) {
            n.split(/\s+/).forEach((function(n) {
                n && e.classList[t](n)
            }))
        }
        var fo = {
            name: "className",
            defaultValue: "",
            fn: function(e) {
                var t = e.popper.firstElementChild,
                    n = function() {
                        var t;
                        return !!(null == (t = e.props.render) ? void 0 : t.$$tippy)
                    };

                function r() {
                    e.props.className && !n() || po(t, "add", e.props.className)
                }
                return {
                    onCreate: r,
                    onBeforeUpdate: function() {
                        n() && po(t, "remove", e.props.className)
                    },
                    onAfterUpdate: r
                }
            }
        };

        function mo(e) {
            return function(t) {
                var n = t.children,
                    i = t.content,
                    o = t.visible,
                    a = t.singleton,
                    s = t.render,
                    l = t.reference,
                    c = t.disabled,
                    u = void 0 !== c && c,
                    d = t.ignoreAttributes,
                    h = void 0 === d || d,
                    p = (t.__source, t.__self, ro(t, ["children", "content", "visible", "singleton", "render", "reference", "disabled", "ignoreAttributes", "__source", "__self"])),
                    f = void 0 !== o,
                    m = void 0 !== a,
                    g = (0, r.useState)(!1),
                    v = g[0],
                    y = g[1],
                    b = (0, r.useState)({}),
                    x = b[0],
                    _ = b[1],
                    M = (0, r.useState)(),
                    w = M[0],
                    A = M[1],
                    S = ho((function() {
                        return {
                            container: ao(),
                            renders: 1
                        }
                    })),
                    E = Object.assign({
                        ignoreAttributes: h
                    }, p, {
                        content: S.container
                    });
                f && (E.trigger = "manual", E.hideOnClick = !1), m && (u = !0);
                var C = E,
                    T = E.plugins || [];
                s && (C = Object.assign({}, E, {
                    plugins: m && null != a.data ? [].concat(T, [{
                        fn: function() {
                            return {
                                onTrigger: function(e, t) {
                                    var n = a.data.children.find((function(e) {
                                        return e.instance.reference === t.currentTarget
                                    }));
                                    e.state.$$activeSingletonInstance = n.instance, A(n.content)
                                }
                            }
                        }
                    }]) : T,
                    render: function() {
                        return {
                            popper: S.container
                        }
                    }
                }));
                var P = [l].concat(n ? [n.type] : []);
                return uo((function() {
                    var t = l;
                    l && l.hasOwnProperty("current") && (t = l.current);
                    var n = e(t || S.ref || ao(), Object.assign({}, C, {
                        plugins: [fo].concat(E.plugins || [])
                    }));
                    return S.instance = n, u && n.disable(), o && n.show(), m && a.hook({
                            instance: n,
                            content: i,
                            props: C,
                            setSingletonContent: A
                        }), y(!0),
                        function() {
                            n.destroy(), null == a || a.cleanup(n)
                        }
                }), P), uo((function() {
                    var e;
                    if (1 !== S.renders) {
                        var t = S.instance;
                        t.setProps(co(t.props, C)), null == (e = t.popperInstance) || e.forceUpdate(), u ? t.disable() : t.enable(), f && (o ? t.show() : t.hide()), m && a.hook({
                            instance: t,
                            content: i,
                            props: C,
                            setSingletonContent: A
                        })
                    } else S.renders++
                })), uo((function() {
                    var e;
                    if (s) {
                        var t = S.instance;
                        t.setProps({
                            popperOptions: Object.assign({}, t.props.popperOptions, {
                                modifiers: [].concat(((null == (e = t.props.popperOptions) ? void 0 : e.modifiers) || []).filter((function(e) {
                                    return "$$tippyReact" !== e.name
                                })), [{
                                    name: "$$tippyReact",
                                    enabled: !0,
                                    phase: "beforeWrite",
                                    requires: ["computeStyles"],
                                    fn: function(e) {
                                        var t, n = e.state,
                                            r = null == (t = n.modifiersData) ? void 0 : t.hide;
                                        x.placement === n.placement && x.referenceHidden === (null == r ? void 0 : r.isReferenceHidden) && x.escaped === (null == r ? void 0 : r.hasPopperEscaped) || _({
                                            placement: n.placement,
                                            referenceHidden: null == r ? void 0 : r.isReferenceHidden,
                                            escaped: null == r ? void 0 : r.hasPopperEscaped
                                        }), n.attributes.popper = {}
                                    }
                                }])
                            })
                        })
                    }
                }), [x.placement, x.referenceHidden, x.escaped].concat(P)), r.createElement(r.Fragment, null, n ? (0, r.cloneElement)(n, {
                    ref: function(e) {
                        S.ref = e, oo(n.ref, e)
                    }
                }) : null, v && (0, no.createPortal)(s ? s(function(e) {
                    var t = {
                        "data-placement": e.placement
                    };
                    return e.referenceHidden && (t["data-reference-hidden"] = ""), e.escaped && (t["data-escaped"] = ""), t
                }(x), w, S.instance) : i, S.container))
            }
        }
        var go = function(e, t) {
            return (0, r.forwardRef)((function(n, i) {
                var o = n.children,
                    a = ro(n, ["children"]);
                return r.createElement(e, Object.assign({}, t, a), o ? (0, r.cloneElement)(o, {
                    ref: function(e) {
                        oo(i, e), oo(o.ref, e)
                    }
                }) : null)
            }))
        };
        const vo = go(mo(to)),
            yo = e => {
                let {
                    isError: t,
                    isLoading: n,
                    title: i,
                    description: o,
                    children: a,
                    span: s,
                    textinfo: l
                } = e;
                const [c, u] = (0, r.useState)(!1), [d, h] = (0, r.useState)("");
                (0, r.useRef)(null);
                return (0, r.useEffect)((() => {
                    (async () => {
                        h("function" === typeof o ? await o() : null !== o && void 0 !== o ? o : "")
                    })()
                })), t ? (0, Nn.jsxs)("div", {
                    className: "CPsection",
                    children: [(0, Nn.jsx)("div", {
                        className: "SectionTitle",
                        children: i
                    }), (0, Nn.jsx)("p", {
                        className: "error_message",
                        children: t.message
                    })]
                }) : (0, Nn.jsxs)("div", {
                    className: "CPsection",
                    children: [(0, Nn.jsxs)("div", {
                        className: "SectionTitle",
                        children: [s ? (0, Nn.jsx)("span", {
                            className: "Optionaltag",
                            children: "Optional"
                        }) : null, i, (0, Nn.jsx)("div", {
                            className: "tooltipWrapper",
                            children: (0, Nn.jsx)(vo, {
                                content: l,
                                animation: "fade",
                                trigger: "click",
                                theme: "custom",
                                children: (0, Nn.jsx)("button", {
                                    className: "SVGcontainer",
                                    children: (0, Nn.jsx)("svg", {
                                        width: "14",
                                        height: "14",
                                        viewBox: "0 0 24 24",
                                        children: (0, Nn.jsx)("path", {
                                            d: "M11 17h2v-6h-2v6zm1-15C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zM11 9h2V7h-2v2z",
                                            fill: "currentColor"
                                        })
                                    })
                                })
                            })
                        })]
                    }), n && (0, Nn.jsx)(Vn, {}), (0, Nn.jsx)("div", {
                        className: "SectionDiscription",
                        children: d
                    }), a]
                })
            },
            bo = {
                btn: "styles_btn__qwmIF",
                btn_primary_border: "styles_btn_primary_border__nhuQz",
                Editbtn: "styles_Editbtn__YvCWl"
            };
        const xo = "https://dealsondiamonds.com/3d-ring-builder/static/media/narr.8624795ab09e02c88583a6aef714e236.svg";

        function _o(e) {
            let {
                children: t,
                onClick: n,
                customStyles: i,
                background: o,
                color: a,
                onlyBorder: s,
                hasEditIcon: l,
                maxwidth: c
            } = e;
            const u = (0, r.useRef)(null),
                d = dn(bo.btn, i),
                h = dn(bo.Editbtn),
                p = (0, r.useMemo)((() => {
                    const e = {};
                    return a && (e.color = a), s && (e.paddingTop = "12%"), s && (e.paddingBottom = "12%"), !s && o && (e.border = "1px solid #6366F1"), !s && o && (e.color = o), e
                }), [a, o, s, c]);
            return (0, r.useEffect)((() => {
                c && u.current && (u.current.style.background = "linear-gradient(93.15deg, #C0C0C0 30%, #FFB442 68%)", u.current.style.webkitBackgroundClip = "text", u.current.style.webkitTextFillColor = "transparent")
            }), [c]), (0, Nn.jsxs)("button", {
                ref: u,
                style: p,
                onClick: n,
                className: d,
                children: [l ? (0, Nn.jsx)("div", {
                    className: h,
                    children: (0, Nn.jsx)("img", {
                        src: xo,
                        alt: "icon"
                    })
                }) : null, t]
            })
        }
        const Mo = {
            btn_primary: "styles_btn_primary__DgUap",
            btn_primary_border: "styles_btn_primary_border__UoEWM"
        };

        function wo(e) {
            let {
                children: t,
                onClick: n,
                onlyBorder: r,
                background: i,
                hasEditIcon: o,
                maxwidth: a,
                setIsOpen: s,
                target: l,
                setPopupTarget: c
            } = e;
            return (0, Nn.jsx)(_o, {
                background: i,
                customStyles: r ? Mo.btn_primary_border : Mo.btn_primary,
                onClick: n,
                hasEditIcon: o,
                maxwidth: a,
                setIsOpen: s,
                target: l,
                setPopupTarget: c,
                children: t
            })
        }

        function Ao(e) {
            let {
                radioItems: t = [],
                activeValue: n,
                onChange: i,
                onlyBorder: o,
                color: a,
                customIndex: s,
                customClick: l
            } = e;
            const c = (0, r.useCallback)(((e, t) => n => {
                n.preventDefault(), null === i || void 0 === i || i(e, t)
            }), [i]);
            return (0, Nn.jsx)(Nn.Fragment, {
                children: t.map(((e, t) => {
                    let r, {
                        label: i,
                        value: u,
                        value3D: d,
                        backgroundColor: h,
                        isNavigator: p,
                        maxwidth: f,
                        isActive: m
                    } = e;
                    const g = s === t;
                    return p || g ? m = !1 : r = u === n || m, "Mixed" === i && "@different" === n && (r = !0), r ? (0, Nn.jsx)(wo, {
                        background: h,
                        onlyBorder: o,
                        onClick: g ? null === l || void 0 === l ? void 0 : l(u) : fn,
                        hasEditIcon: p,
                        maxwidth: f,
                        children: i
                    }, i + t) : (0, Nn.jsx)(_o, {
                        color: a,
                        onClick: g ? null === l || void 0 === l ? void 0 : l(u) : c(u, d),
                        onlyBorder: o,
                        background: h,
                        hasEditIcon: p,
                        maxwidth: f,
                        children: i
                    }, i + t)
                }))
            })
        }

        function So(e) {
            let {
                value: t,
                items: n,
                onClick: r,
                onlyBorder: i,
                color: o,
                isCustomGrid: a,
                customIndex: s,
                customClick: l
            } = e;
            return (0, Nn.jsx)("div", {
                className: "SectionBTNS ".concat(a ? "Metalcolor" : ""),
                children: (0, Nn.jsx)(Ao, {
                    onChange: r,
                    activeValue: t,
                    radioItems: n,
                    onlyBorder: i,
                    color: o,
                    customIndex: s,
                    customClick: l
                })
            })
        }
        const Eo = e => {
                var t, n;
                const {
                    title: i,
                    storeKey: o,
                    buttons: a,
                    onClick: s,
                    isCustomGrid: l,
                    hasOuterNavigator: c,
                    navigationClick: u,
                    position: d,
                    MainTitle: h,
                    invalidateQuery: p,
                    isVisible: f,
                    textinfo: m,
                    description: g
                } = e;
                yn((e => e));
                const v = Un(o),
                    y = null !== (t = null === (n = a.find((e => v === e.value))) || void 0 === n ? void 0 : n.description) && void 0 !== t ? t : g,
                    b = "function" !== typeof f || f(),
                    x = (0, r.useMemo)((() => c ? [...a, c] : a), [a, c]),
                    _ = c ? x.length - 1 : null;
                if ((0, r.useEffect)((() => {
                        null === p || void 0 === p || p()
                    }), [v, p]), b && 0 !== x.length) return (0, Nn.jsx)(yo, {
                    title: i,
                    textinfo: m,
                    description: y,
                    isError: e.isError,
                    isLoading: e.isLoading,
                    position: d,
                    MainTitle: h,
                    children: (0, Nn.jsx)(So, {
                        customIndex: _,
                        MainTitle: h,
                        position: d,
                        customClick: e => () => u(e),
                        items: x,
                        isCustomGrid: l,
                        onClick: s,
                        value: v
                    })
                })
            },
            Co = "styles_text_input__fnpPa",
            To = "styles_submit__tIwIN";

        function Po(e) {
            let {
                placeholder: t,
                value: n,
                onChange: i,
                customStyles: o,
                hasSubmit: a,
                limits: s,
                onSliderUpdate: l,
                onRingUpdate: c,
                stepValue: u
            } = e;
            const [d, h] = (0, r.useState)(n), [p, f] = (0, r.useState)(n), m = dn(Co, o), g = dn(To, o);
            (0, r.useEffect)((() => {
                h(n), v(parseFloat(n)) && f(n)
            }), [n]);
            const v = (0, r.useCallback)((e => {
                    const {
                        min: t,
                        max: n
                    } = (null === s || void 0 === s ? void 0 : s.ownLimits) || {};
                    return e >= t && e <= n
                }), [s]),
                y = (0, r.useCallback)((e => {
                    const {
                        min: t,
                        max: n
                    } = (null === s || void 0 === s ? void 0 : s.ownLimits) || {};
                    return e < t ? t : e > n ? n : e
                }), [s]),
                b = (0, r.useCallback)((e => u ? Math.round(e / u) * u : e), [u]),
                x = (0, r.useCallback)((e => {
                    let t = e.target.value;
                    if ("" === t || "-" === t || "." === t || "-." === t) return void h(t);
                    const n = t.split(".");
                    n.length > 1 && n[1].length > 2 && (t = "".concat(n[0], ".").concat(n[1].slice(0, 2))), h(t);
                    const r = parseFloat(t);
                    !isNaN(r) && v(r) && (f(t), null === i || void 0 === i || i(r, s), null === l || void 0 === l || l(r), null === c || void 0 === c || c(r))
                }), [i, s, l, c, v]),
                _ = (0, r.useCallback)((e => Math.round(100 * (e + Number.EPSILON)) / 100), []),
                M = (0, r.useCallback)((e => {
                    const t = parseFloat(e);
                    if (isNaN(t)) h(p);
                    else {
                        const e = b(t),
                            n = y(e),
                            r = _(n),
                            o = r.toFixed(2);
                        h(o), f(o), null === i || void 0 === i || i(r, s), null === l || void 0 === l || l(r), null === c || void 0 === c || c(r)
                    }
                }), [y, i, s, l, c, p, b, _]),
                w = (0, r.useCallback)((e => {
                    "Enter" === e.key && M(d)
                }), [d, M]),
                A = (0, r.useCallback)((() => {
                    "" === d || "-" === d || "." === d || "-." === d ? (h(p), null === i || void 0 === i || i(parseFloat(p), s), null === l || void 0 === l || l(parseFloat(p)), null === c || void 0 === c || c(parseFloat(p))) : M(d)
                }), [d, p, i, s, l, c, M]);
            return (0, Nn.jsxs)("div", {
                className: a ? "SectionBTNS" : "",
                children: [(0, Nn.jsx)("input", {
                    type: "text",
                    enterKeyHint: "done",
                    inputMode: "decimal",
                    className: m,
                    style: a ? null : {
                        width: "20%"
                    },
                    value: d,
                    onChange: x,
                    onKeyDown: w,
                    onBlur: A,
                    placeholder: p
                }), a ? (0, Nn.jsx)("button", {
                    className: g,
                    children: a.btnName
                }) : null]
            })
        }

        function Ro(e) {
            let {
                placeholder: t,
                value: n,
                onChange: i,
                reducer: o
            } = e;
            const [a, s] = (0, r.useState)(n), l = ((e, t) => {
                const [n, i] = (0, r.useState)(e);
                let o = (0, r.useRef)(null);
                return (0, r.useEffect)((() => (o.current = setTimeout((() => {
                    i(e)
                }), t), () => {
                    clearTimeout(o.current)
                })), [e]), n
            })(a, 350), c = dn(Co);
            return (0, r.useEffect)((() => {
                i(l)
            }), [l]), (0, Nn.jsx)("input", {
                type: "text",
                className: c,
                style: {
                    width: "100%",
                    textAlign: "left"
                },
                value: a,
                onChange: e => {
                    const t = e.target.value;
                    if ("function" === typeof o) {
                        const e = o(a, t);
                        s(e)
                    } else s(t)
                },
                placeholder: t
            })
        }
        const Io = e => {
                var t, n, i, o, a, s, l;
                let {
                    placeholder: c,
                    value: u,
                    onChange: d,
                    limits: h,
                    stepValue: p
                } = e;
                const f = (0, r.useCallback)((e => {
                        const t = e.target.value;
                        if (!h) return null === d || void 0 === d ? void 0 : d(t, h);
                        if ("" === t) null === d || void 0 === d || d(.25, h);
                        else {
                            var n, r;
                            const e = parseFloat(t);
                            e >= (null === h || void 0 === h || null === (n = h.ownLimits) || void 0 === n ? void 0 : n.min) && e <= (null === h || void 0 === h || null === (r = h.ownLimits) || void 0 === r ? void 0 : r.max) ? null === d || void 0 === d || d(e, h) : null === d || void 0 === d || d(.25, h)
                        }
                    }), [d, h]),
                    m = (u - (null === h || void 0 === h || null === (t = h.ownLimits) || void 0 === t ? void 0 : t.min)) / ((null === h || void 0 === h || null === (n = h.ownLimits) || void 0 === n ? void 0 : n.max) - (null === h || void 0 === h || null === (i = h.ownLimits) || void 0 === i ? void 0 : i.min)) * 100;
                return (0, Nn.jsxs)("div", {
                    className: "slider-container",
                    children: [(0, Nn.jsxs)("div", {
                        className: "Limitspan LL",
                        children: [" ", null === h || void 0 === h || null === (o = h.ownLimits) || void 0 === o ? void 0 : o.min]
                    }), (0, Nn.jsxs)("div", {
                        className: "Limitspan RR",
                        children: [" ", null === h || void 0 === h || null === (a = h.ownLimits) || void 0 === a ? void 0 : a.max]
                    }), (0, Nn.jsx)("input", {
                        type: "range",
                        id: "carat-weight",
                        className: "slider",
                        min: null === h || void 0 === h || null === (s = h.ownLimits) || void 0 === s ? void 0 : s.min,
                        max: null === h || void 0 === h || null === (l = h.ownLimits) || void 0 === l ? void 0 : l.max,
                        value: u,
                        step: p,
                        onChange: f,
                        "aria-label": c,
                        style: {
                            background: "linear-gradient(95.31deg, rgb(252, 132, 3) 4.6%, rgb(220, 174, 35) 98.79%) ".concat(m, "%, #dee4ec ").concat(m, "%, #dee4ec 100%)")
                        }
                    })]
                })
            },
            Oo = e => {
                const {
                    inputOptions: t,
                    orDiv: n,
                    value: r,
                    limits: i,
                    Slider: o,
                    stepValue: a
                } = e;
                return (0, Nn.jsxs)("div", {
                    children: [t.isSimple ? (0, Nn.jsx)(Ro, {
                        onChange: t.onChange,
                        reducer: t.reducer,
                        placeholder: t.placeholder,
                        value: r
                    }) : (0, Nn.jsx)(Po, {
                        value: r,
                        onChange: t.onChange,
                        placeholder: t.placeholder,
                        hasSubmit: t.hasSubmit,
                        limits: null !== i && void 0 !== i ? i : null,
                        stepValue: null !== a && void 0 !== a ? a : .01
                    }), o ? (0, Nn.jsx)(Io, {
                        value: r,
                        onChange: t.onChange,
                        placeholder: t.placeholder,
                        limits: null !== i && void 0 !== i ? i : null,
                        stepValue: null !== a && void 0 !== a ? a : .01
                    }) : null, n && (0, Nn.jsx)("div", {
                        className: "ORstyling",
                        children: "OR"
                    })]
                })
            },
            Bo = f((e => ({
                numberOfElements: 0,
                headsVolume: [0, 0, 0],
                bandVolume: 0,
                prongPave: [],
                haloBasketPave: [],
                bandPave: [],
                bridgePave: [],
                surpriseStones: {
                    quantity: 0,
                    size: .8,
                    shape: "Round"
                },
                accentGems: [],
                laserEngraving: {
                    text: "",
                    font: ""
                },
                diamondType: "Natural",
                setNumberOfElements: t => e({
                    numberOfElements: t
                }),
                setHeadsVolume: t => e({
                    headsVolume: t
                }),
                setBandVolume: t => e({
                    bandVolume: t
                }),
                setProngPave: t => e({
                    prongPave: t
                }),
                setHaloBasketPave: t => e({
                    haloBasketPave: t
                }),
                setBandPave: t => e({
                    bandPave: t
                }),
                setBridgePave: t => e({
                    bridgePave: t
                }),
                setSurpriseStones: t => e({
                    surpriseStones: t
                }),
                setAccentGems: t => e({
                    accentGems: t
                }),
                setLaserEngraving: t => e({
                    laserEngraving: t
                }),
                setDiamondType: t => e({
                    diamondType: t
                })
            }))),
            Lo = e => {
                const {
                    title: t,
                    description: n,
                    isInput: r,
                    storeKey: i,
                    orDiv: o,
                    apiData: a,
                    Slider: s,
                    span: l,
                    stepValue: c,
                    position: u,
                    textinfo: d
                } = e, h = Un(i);
                return Bo((e => e)), (0, Nn.jsx)(yo, {
                    title: "function" === typeof t ? t() : t,
                    description: n,
                    span: l,
                    isError: e.isError,
                    isLoading: e.isLoading,
                    position: u,
                    textinfo: d,
                    children: (0, Nn.jsx)(Oo, {
                        limits: a,
                        inputOptions: r,
                        value: h,
                        orDiv: o,
                        Slider: s,
                        stepValue: c
                    })
                })
            },
            Do = e => {
                let {
                    api: t,
                    ...n
                } = e;
                const {
                    componentType: i
                } = n, {
                    queryKeys: a,
                    queryFn: s,
                    queryOptions: l,
                    onQuerySuccess: c,
                    queryInvalidationName: u
                } = t, d = (0, o.useQueryClient)(), {
                    data: h,
                    isLoading: p,
                    error: f
                } = (0, o.useQuery)(Array.isArray(a) ? a : a(), s, l), m = (0, r.useCallback)((() => {
                    u && d.invalidateQueries(u)
                }), [d, u]), g = (0, r.useMemo)((() => {
                    var e;
                    return h ? "Basic" === i ? null === h || void 0 === h || null === (e = h.map) || void 0 === e ? void 0 : e.call(h, c) : h : []
                }), [h, i, c]);
                return "Basic" === i ? (0, Nn.jsx)(Eo, { ...n,
                    invalidateQuery: m,
                    isLoading: p,
                    isError: f,
                    buttons: g
                }) : "Input" === i ? (0, Nn.jsx)(Lo, { ...n,
                    isLoading: p,
                    isError: f,
                    apiData: g
                }) : void 0
            },
            No = e => {
                const t = (e => {
                        const {
                            stone: t
                        } = Mn((t => t.heads[m[e]])), {
                            dimensions: n
                        } = t;
                        return n.length / n.width < 1.1
                    })(e.head),
                    n = t ? "Square" : "Elongated";
                return (0, Nn.jsx)(yo, {
                    title: e.title,
                    textinfo: e.textinfo,
                    description: e.description(n),
                    children: (0, Nn.jsx)(So, {
                        value: n,
                        onClick: t => {
                            e.onClick(t)
                        },
                        items: e.buttons
                    })
                })
            },
            ko = {
                center: mn("Center Diamond", "center"),
                side: mn("Side Diamonds", "side"),
                right: mn("Right Diamond", "right"),
                left: mn("Left Diamond", "left")
            },
            Fo = "65c0f1e448603855475a5f4a",
            Uo = {
                Basic: Eo,
                Dynamic: e => {
                    var t, n;
                    const {
                        storeKey: r,
                        title: i,
                        navigationClick: o,
                        position: a,
                        MainTitle: s,
                        textinfo: l
                    } = e, c = null !== (t = e[Un(r)]) && void 0 !== t ? t : e.Other;
                    if (null === (n = null === c || void 0 === c ? void 0 : c.isVisible) || void 0 === n || n) return c.api ? (0, Nn.jsx)(Do, { ...c
                    }) : c.isBasic ? (0, Nn.jsx)(Eo, { ...c
                    }) : c.isInput ? (0, Nn.jsx)(Lo, { ...c
                    }) : (0, Nn.jsx)(yo, {
                        title: i,
                        description: c.description,
                        position: a,
                        MainTitle: s,
                        textinfo: l,
                        children: (0, Nn.jsx)(So, {
                            items: c.buttons,
                            onClick: o
                        })
                    })
                },
                Input: Lo,
                DataLayer: Do,
                Toggle: e => {
                    const {
                        toggleKeys: t,
                        checkValues: n,
                        toggleItem: r
                    } = e, i = ((e, t) => t(yn((t => pn(e, t)))))(t, n);
                    return i ? (0, Nn.jsx)(No, { ...r
                    }) : null
                }
            },
            zo = [{
                title: "Head & Band Color",
                textinfo: "When buying a gold ring, the purity of the gold is described by the term 'karat' which is represented by a 'k' ranging from 0 to 24, with 24k being pure gold, 18k being 75% gold, and 14k being 58.3% gold. Gold is mixed with other metals that add durability to the metal alloy and also reduce cost. Platinum is also a popular choice since it is stronger and denser than gold and looks similar to white gold.",
                api: {
                    queryKeys: ["allMetalColor"],
                    queryFn: async e => {
                        try {
                            const {
                                data: e
                            } = await cn.get("colorcustomisation/get-all");
                            return e
                        } catch (t) {
                            throw new Error(t)
                        }
                    },
                    queryOptions: {
                        refetchOnWindowFocus: !1,
                        refetchOnMount: !1,
                        staleTime: 1 / 0
                    },
                    onQuerySuccess: e => ({
                        label: e.uiValue,
                        value: e.uiValue,
                        description: e.description,
                        backgroundColor: e.backgroundColor,
                        value3D: e.material.color
                    })
                },
                onClick: (e, t) => {
                    xn("prongMetalColor")(e), xn("band.bandMetalColor")(e), wn("all", "prongMetalColor", t), An("bandMetalColor", t)
                },
                storeKey: ["prongMetalColor", "band.bandMetalColor"],
                isCustomGrid: !0,
                componentType: "Basic",
                hasOuterNavigator: {
                    label: "Mixed",
                    description: "Mixed",
                    value: {
                        modalTitle: "Mixed Metal",
                        modalUI: [{
                            title: "Head Metal Color",
                            api: {
                                queryKeys: ["headMetalColor"],
                                queryFn: Bn,
                                queryOptions: {
                                    refetchOnWindowFocus: !1,
                                    refetchOnMount: !1,
                                    staleTime: 1 / 0
                                },
                                onQuerySuccess: e => ({
                                    label: e.uiValue,
                                    value: e.uiValue,
                                    description: e.description + " Head",
                                    backgroundColor: e.backgroundColor,
                                    value3D: e.material.color
                                })
                            },
                            onClick: (e, t) => {
                                yn.getState().prongMetalColor === Fo ? (xn("prongMetalColor")(e), xn("band.bandMetalColor")(e), wn("all", "prongMetalColor", t), An("bandMetalColor", t)) : (xn("prongMetalColor")(e), wn("all", "prongMetalColor", t))
                            },
                            storeKey: "prongMetalColor",
                            componentType: "Basic"
                        }, {
                            title: "Band Metal Color",
                            api: {
                                queryKeys: ["bandMetalColor"],
                                queryFn: Bn,
                                queryOptions: {
                                    refetchOnWindowFocus: !1,
                                    refetchOnMount: !1,
                                    staleTime: 1 / 0
                                },
                                onQuerySuccess: e => ({
                                    label: e.uiValue,
                                    value: e.uiValue,
                                    description: e.description + " Band",
                                    backgroundColor: e.backgroundColor,
                                    value3D: e.material.color
                                })
                            },
                            onClick: (e, t) => {
                                yn.getState().band.bandMetalColor === Fo ? (xn("prongMetalColor")(e), xn("band.bandMetalColor")(e), wn("all", "prongMetalColor", t), An("bandMetalColor", t)) : (xn("band.bandMetalColor")(e), An("bandMetalColor", t))
                            },
                            storeKey: "band.bandMetalColor",
                            componentType: "Basic"
                        }]
                    },
                    isNavigator: !1
                },
                MainTitle: "Metal",
                position: "oneonly"
            }, {
                title: "Center Stones",
                textinfo: "Select the number of center stones: one (solitaire), two (Toi et Moi), or three. This choice sets the stage for the ring's layout and overall symbolism, reflecting unique personal or shared milestones. Each centerstone is customizable in the next step.",
                buttons: [{
                    label: "One Stone",
                    value: "one",
                    description: "One Stone Ring (Solitaire)"
                }, {
                    label: "Two Stone",
                    value: "two",
                    description: "Two Stone Ring (Toi et Moi)"
                }, {
                    label: "Three Stone",
                    value: "three",
                    description: "Three Stone Ring"
                }],
                storeKey: "numOfStones",
                onClick: e => {
                    "one" !== e && (xn("band.bandCathedral")("None"), An("bandCathedral", "None")), xn("stoneElevation")("Tiered"), Sn("Tiered"), (e => {
                        yn.getState().changeNumOfStones(e)
                    })(e), (e => {
                        Mn.getState().changeNumberOfHeads(e)
                    })(e)
                },
                componentType: "Basic",
                MainTitle: "Diamonds",
                position: "start"
            }, {
                title: "Select Your Stones",
                textinfo: "Customize your ring with a choice of diamond shapes and carat weights. Each shape offers a unique brilliance and character.",
                one: {
                    buttons: [{
                        label: "Center",
                        value: ko.center,
                        isNavigator: !0
                    }],
                    description: () => {
                        const e = yn.getState().center.stone;
                        return "Center: ".concat(e.caratWeight, " carat ").concat(e.diamondShape)
                    }
                },
                two: {
                    buttons: [{
                        label: "Left",
                        value: ko.left,
                        isNavigator: !0
                    }, {
                        label: "Right",
                        value: ko.right,
                        isNavigator: !0
                    }],
                    description: () => {
                        const e = yn.getState().left.stone,
                            t = yn.getState().right.stone;
                        return "Left: ".concat(e.caratWeight, " carat ").concat(e.diamondShape, " | Right: ").concat(t.caratWeight, " carat ").concat(t.diamondShape)
                    }
                },
                three: {
                    buttons: [{
                        label: "Center",
                        value: ko.center,
                        isNavigator: !0
                    }, {
                        label: "Side Stones",
                        value: ko.side,
                        isNavigator: !0
                    }],
                    description: () => {
                        const e = yn.getState().center.stone,
                            t = yn.getState().side.stone;
                        return "Center: ".concat(e.caratWeight, " carat ").concat(e.diamondShape, " | Side: ").concat(t.caratWeight, " carat ").concat(t.diamondShape)
                    }
                },
                position: "mid",
                storeKey: "numOfStones",
                componentType: "Dynamic"
            }, {
                title: "Diamond Type",
                textinfo: "This selection may update the price of your ring if you add pave diamonds or surprise stones to the design. The price for your setting does not include the price of the main center stone(s). You can select your center stones by working with a trusted jeweler before ordering your finished ring. The jeweler is able to order your exact design, made in America by a 4th generation family owned manufacturer who also works with Tiffany & Co. and David Yurman.",
                buttons: [{
                    label: "Natural",
                    value: "Natural",
                    description: "Natural diamond center stones & pave (if applicable)"
                }, {
                    label: "Lab Grown",
                    value: "Lab Grown",
                    description: "Lab Grown diamond center stones & pave (if applicable)"
                }, {
                    label: "Skip",
                    value: "Skip",
                    description: "Skip"
                }],
                position: "end",
                storeKey: "diamondtype",
                onClick: e => {
                    xn("diamondtype")(e), (e => {
                        Mn.getState().alterDiamondType(e)
                    })(e)
                },
                componentType: "Basic"
            }, {
                one: {
                    buttons: [],
                    isVisible: !1
                },
                two: {
                    title: "Stone Elevation",
                    textinfo: "More info",
                    buttons: [{
                        label: "Tiered",
                        value: "Tiered",
                        description: "Tiered"
                    }, {
                        label: "Level Set",
                        value: "Level Set",
                        description: "Level Set"
                    }],
                    storeKey: "stoneElevation",
                    onClick: e => {
                        xn("stoneElevation")(e), Sn(e)
                    },
                    isBasic: !0,
                    position: "mid"
                },
                three: {
                    title: "Stone Elevation",
                    buttons: [{
                        label: "Tiered",
                        value: "Tiered",
                        description: "Tiered"
                    }, {
                        label: "Level Set",
                        value: "Level Set",
                        description: "Level Set"
                    }],
                    storeKey: "stoneElevation",
                    onClick: e => {
                        xn("stoneElevation")(e), Sn(e)
                    },
                    isBasic: !0,
                    position: "mid"
                },
                storeKey: "numOfStones",
                componentType: "Dynamic"
            }, {
                title: "Basket & Halo",
                description: async () => {
                    const {
                        haloBasketPave: e,
                        activeBasketHalo: t
                    } = await vn((e => e({
                        haloBasketPave: Bo.getState().haloBasketPave,
                        activeBasketHalo: yn.getState().basketHalo
                    })), 400);
                    return 0 === e.length ? t : gn(e)
                },
                textinfo: "Adding a basket to your setting helps to increase the strength and security of the prongs that hold your diamond center stone. Adding a halo has a similar affect and adds even more sparkle to your ring.",
                api: {
                    queryKeys: ["getAllBasketHalo"],
                    queryFn: async e => {
                        try {
                            const {
                                data: e
                            } = await cn.get("baskethalo/get-all"), t = ["Double Halo", "Secret Halo", "Cushion Halo", "Pave Basket"];
                            return e.filter((e => !t.includes(e.uiValue)))
                        } catch (t) {
                            throw new Error(t)
                        }
                    },
                    queryOptions: {
                        refetchOnWindowFocus: !1,
                        refetchOnMount: !1,
                        staleTime: 1 / 0
                    },
                    onQuerySuccess: e => ({
                        label: e.uiValue,
                        value: e.uiValue
                    })
                },
                onClick: async e => {
                    if ("None" === e) xn("basketHalo")(e), wn("all", "basketHalo", null);
                    else try {
                        if ("Bezel" === e) {
                            const e = {
                                meshes: [{
                                    name: "ClawTip",
                                    type: "Mesh",
                                    _id: "65c0ed6c496b694e546f46c9"
                                }],
                                glb: "https://stonealgo-configurator.s3.amazonaws.com/glb/ClawTip.glb",
                                name: "Claw"
                            };
                            xn("prongTip")("Claw"), wn("all", "prongTip", e)
                        }
                        const t = await (async e => {
                                const {
                                    left: t,
                                    center: n,
                                    right: r,
                                    side: i
                                } = yn.getState();
                                let o = "";
                                if (t) {
                                    const e = t.stone.diamondShape;
                                    o += "name1=".concat(e, "&")
                                }
                                if (n) {
                                    const e = n.stone.diamondShape;
                                    o += "name2=".concat(e, "&")
                                }
                                if (r) {
                                    const e = r.stone.diamondShape;
                                    o += "name3=".concat(e, "&")
                                }
                                if (i) {
                                    const e = i.stone.diamondShape;
                                    o += "name1=".concat(e, "&"), o += "name3=".concat(e, "&")
                                }
                                o += "uivalue=".concat(e);
                                try {
                                    const {
                                        data: e
                                    } = await cn.get("baskethalo/get-by-stoneid-with-uivalue?".concat(o));
                                    return e
                                } catch (a) {
                                    throw a
                                }
                            })(e),
                            n = [];
                        t.forEach(((e, t) => {
                            e && n.push(t)
                        })), xn("basketHalo")(e), n.forEach((e => {
                            const {
                                glbUrl: n,
                                meshes: r,
                                name: i,
                                splineUrl: o,
                                type: a
                            } = t[e];
                            wn(e, "basketHalo", {
                                glbUrl: n,
                                meshes: r,
                                name: i,
                                splineUrl: o,
                                type: a
                            })
                        }))
                    } catch (t) {
                        console.log({
                            error: t
                        })
                    }
                },
                storeKey: "basketHalo",
                componentType: "Basic",
                MainTitle: "Head",
                position: "oneonly"
            }, {
                title: "Prong Count",
                position: "start",
                MainTitle: "Prongs",
                one: {
                    title: "Prong Count",
                    textinfo: "The number of prongs affects both the security of the diamond center stones and the ring's overall style. More prongs typically provide better security but can obscure more of the diamond. If you choose a two or three stone setting your ring will automatically receive the minimum prong count for each stone to ensure design compatability.",
                    api: {
                        queryKeys: ["prongCount"],
                        queryFn: async e => {
                            try {
                                const {
                                    diamondShape: e
                                } = yn.getState().center.stone, {
                                    data: t
                                } = await cn.get("stoneprong/get-prong-counts/".concat(e));
                                return t
                            } catch (t) {
                                throw new Error(t)
                            }
                        },
                        queryOptions: {
                            refetchOnWindowFocus: !1,
                            refetchOnMount: !1,
                            staleTime: 1 / 0
                        },
                        onQuerySuccess: e => ({
                            label: e.uiValue,
                            value: e.uiValue,
                            description: e.description,
                            value3D: {
                                type: e.uiValue,
                                value: e.value
                            }
                        })
                    },
                    onClick: (e, t) => {
                        xn("center.prongCount")(e), wn("center", "prongCount", t)
                    },
                    storeKey: "center.prongCount",
                    componentType: "Basic",
                    MainTitle: "Prongs",
                    position: "start"
                },
                two: {
                    buttons: [{
                        label: "Auto",
                        value: "",
                        isActive: !0
                    }],
                    description: "The prong count has been auto selected",
                    position: "start",
                    MainTitle: "Prongs"
                },
                three: {
                    buttons: [{
                        label: "Auto",
                        value: "",
                        isActive: !0
                    }],
                    description: "The prong count has been auto selected",
                    position: "start",
                    MainTitle: "Prongs"
                },
                storeKey: "numOfStones",
                componentType: "Dynamic"
            }, {
                Bezel: {
                    isVisible: !1,
                    buttons: []
                },
                Other: {
                    title: "Prong Tips",
                    textinfo: "A signature feature of a truly custom ring, customized prong tips enhance the look of your diamond center stone and differentiates your ring from more generic versions sold off the shelf by big box retailers.",
                    api: {
                        queryKeys: ["prongTips"],
                        queryFn: async e => {
                            try {
                                const {
                                    data: e
                                } = await cn.get("prongoption/get-by-type/Tip"), t = ["Bezel", "Double Claw", "Double Petite"];
                                return e.filter((e => !t.includes(e.uiValue)))
                            } catch (t) {
                                throw new Error(t)
                            }
                        },
                        queryOptions: {
                            refetchOnWindowFocus: !1,
                            refetchOnMount: !1,
                            staleTime: 1 / 0
                        },
                        onQuerySuccess: e => ({
                            label: e.uiValue,
                            value: e.value,
                            description: e.description,
                            backgroundColor: e.backgroundColor,
                            value3D: {
                                meshes: e.meshes,
                                glb: e.glbUrl,
                                name: e.value
                            }
                        })
                    },
                    onClick: (e, t) => {
                        xn("prongTip")(e), wn("all", "prongTip", t)
                    },
                    storeKey: "prongTip",
                    componentType: "Basic"
                },
                storeKey: "basketHalo",
                componentType: "Dynamic"
            }, {
                title: "Prong Arms",
                api: {
                    queryKeys: ["prongArms"],
                    queryFn: async e => {
                        try {
                            const {
                                data: e
                            } = await cn.get("prongoption/get-by-type/Arm"), t = ["Lotus", "Graduated"];
                            return e.filter((e => !t.includes(e.value)))
                        } catch (t) {
                            throw new Error(t)
                        }
                    },
                    queryOptions: {
                        refetchOnWindowFocus: !1,
                        refetchOnMount: !1,
                        staleTime: 1 / 0
                    },
                    onQuerySuccess: e => ({
                        label: e.uiValue,
                        value: e.value,
                        description: e.description,
                        backgroundColor: e.backgroundColor,
                        value3D: {
                            meshes: e.meshes,
                            glb: e.glbUrl,
                            name: e.value
                        }
                    })
                },
                onClick: (e, t) => {
                    xn("prongArm")(e), wn("all", "prongArm", t)
                },
                storeKey: "prongArm",
                componentType: "Basic",
                position: "mid"
            }, {
                title: "Prong Pave",
                textinfo: "Tiny diamonds are added to the prong arms to add even more sparkle and customization to your ring.",
                description: async () => {
                    const e = await vn((e => e(Bo.getState().prongPave)), 400);
                    return 0 === e.length ? "Plain prong arms" : gn(e)
                },
                buttons: [{
                    label: "None",
                    value: !1,
                    value3D: !1
                }, {
                    label: "Pave",
                    value: !0,
                    value3D: !0
                }],
                onClick: e => {
                    xn("prongPave")(e), wn("all", "prongPave", e)
                },
                storeKey: "prongPave",
                componentType: "Basic",
                position: "end"
            }, {
                title: "Style",
                textinfo: "Band style is one of the most prominent features of the ring. Round bands are overwhelmingly the most popular choice. You will be able to customize the interior edge of the band separately in the band fit section.",
                api: {
                    queryKeys: ["getAllBasketHalo", "style"],
                    queryFn: Ln,
                    queryOptions: {
                        refetchOnWindowFocus: !1,
                        refetchOnMount: !1,
                        staleTime: 1 / 0
                    },
                    onQuerySuccess: e => ({
                        label: e,
                        value: e,
                        description: e
                    })
                },
                onClick: async e => {
                    "Knife Edge" === e && (xn("band.bandPaveStyle")("None"), xn("band.bandPaveLength")("Half"), An("bandPaveStyle", "None"), An("bandPaveLength", "Half")), xn("band.bandStyle")(e), An("bandStyle", e)
                },
                storeKey: "band.bandStyle",
                componentType: "Basic",
                position: "start",
                MainTitle: "Band"
            }, {
                one: {
                    title: "Cathedral",
                    textinfo: "A cathedral setting adds elegance and drama to your custom ring. If you choose a basket or halo design, adding a cathedral will also improve the durability of your custom ring by connecting the head and band at multiple points (like the buttresses of a cathedral).",
                    buttons: [{
                        label: "None",
                        value: "None",
                        description: "No Cathedral"
                    }, {
                        label: "Cathedral",
                        value: "Cathedral",
                        description: "With Cathedral"
                    }],
                    position: "mid",
                    storeKey: "band.bandCathedral",
                    onClick: e => {
                        xn("band.bandCathedral")(e), An("bandCathedral", e)
                    },
                    isBasic: !0
                },
                Other: {
                    isVisible: !1,
                    buttons: []
                },
                storeKey: "numOfStones",
                componentType: "Dynamic"
            }, {
                "Knife Edge": {
                    buttons: [],
                    isVisible: !1
                },
                Other: {
                    title: "Pave Style",
                    textinfo: "One of the most premium features you can add to a custom ring. Add maximum sparkle to your ring by adding diamond pave to your band. The pave size will automatically change along with the band width. You can add even more pave to your ring by choosing Three Quarters or Eternity pave",
                    api: {
                        queryKeys: ["getAllBasketHalo", "pave.style"],
                        queryFn: Ln,
                        queryOptions: {
                            refetchOnWindowFocus: !1,
                            refetchOnMount: !1,
                            staleTime: 1 / 0
                        },
                        queryInvalidationName: {
                            querKey: ["getBandOptions", "width"]
                        },
                        onQuerySuccess: e => ({
                            label: e,
                            value: e,
                            description: e
                        })
                    },
                    onClick: async e => {
                        if ("None" === e) xn("band.bandPaveStyle")("None"), xn("band.bandPaveLength")("Half"), An("bandPaveStyle", "None"), An("bandPaveLength", "Half");
                        else {
                            const t = yn.getState().band.bandPaveStyle,
                                n = yn.getState().band.bandWidth;
                            "None" === t && n > 3 && (xn("band.bandWidth")(3), An("bandWidth", 3)), xn("band.bandPaveStyle")(e), An("bandPaveStyle", e)
                        }
                    },
                    storeKey: "band.bandPaveStyle",
                    componentType: "Basic"
                },
                storeKey: "band.bandStyle",
                componentType: "Dynamic"
            }, {
                None: {
                    buttons: [],
                    isVisible: !1
                },
                Other: {
                    title: "Pave Length",
                    textinfo: "Pave can be wrapped all around the band (Eternity) but most custom rings feature either Half or Three Quarter length pave. These designs allow your jeweler to more easily resize the ring if necessary and position the diamonds where they will be most appreciated and remove them where they will receive the most contact with hard surfaces.",
                    api: {
                        queryKeys: ["getAllBasketHalo", "pave.length"],
                        queryFn: Ln,
                        queryOptions: {
                            refetchOnWindowFocus: !1,
                            refetchOnMount: !1,
                            staleTime: 1 / 0
                        },
                        onQuerySuccess: e => ({
                            label: e,
                            value: e,
                            description: e
                        })
                    },
                    onClick: async e => {
                        xn("band.bandPaveLength")(e), An("bandPaveLength", e)
                    },
                    storeKey: "band.bandPaveLength",
                    componentType: "Basic",
                    position: "mid"
                },
                position: "mid",
                storeKey: "band.bandPaveStyle",
                componentType: "Dynamic"
            }, {
                title: () => {
                    const {
                        band: e
                    } = yn.getState(), {
                        bandPaveStyle: t
                    } = e;
                    return "None" === t ? "Band Width" : "Band Width & Pave Size"
                },
                textinfo: "Your custom ring's band width is both a statement of personal style and a practical aspect of ring design. Band width options will change depending on the design of your ring and the size of your center stones.",
                description: async () => {
                    const {
                        bandPave: e,
                        bandWidth: t
                    } = await vn((e => e({
                        bandPave: Bo.getState().bandPave,
                        bandWidth: yn.getState().band.bandWidth
                    })));
                    return 0 === e.length ? "Band Width" : "Band Width " + t + "; " + gn(e)
                },
                isInput: {
                    placeholder: "Width",
                    onChange: e => {
                        xn("band.bandWidth")(e), An("bandWidth", e)
                    }
                },
                Slider: !0,
                api: {
                    queryKeys: ["getBandOptions", "width"],
                    queryFn: Ln,
                    queryOptions: {
                        refetchOnWindowFocus: !1,
                        refetchOnMount: !0
                    }
                },
                position: "mid",
                storeKey: "band.bandWidth",
                stepValue: .1,
                componentType: "Input"
            }, {
                title: "Ring Size (US)",
                textinfo: "It is highly recommended that you get your ring finger sized by a professional jeweler. If you are unsure of your ring size now, you can save your ring and update the ring size later.",
                description: "All ring sizes shown are USA/Canada ring sizes",
                isInput: {
                    placeholder: "Size",
                    onChange: e => {
                        xn("band.ringSize")(e), An("ringSize", e)
                    }
                },
                Slider: !0,
                api: {
                    queryKeys: ["getBandOptions", "ringSize"],
                    queryFn: Ln,
                    queryOptions: {
                        refetchOnWindowFocus: !1,
                        refetchOnMount: !0
                    }
                },
                position: "mid",
                storeKey: "band.ringSize",
                stepValue: .25,
                componentType: "Input"
            }, {
                title: "Fit",
                textinfo: "Band fit describes the shape of the interior edge of the band that sits against your finger. Classic fit refers to a more secure, squared interior edge. Comfort fit is rounded and easier to slide on and off the finger.",
                buttons: [{
                    label: "Comfort Fit",
                    value: "Comfort Fit",
                    description: "Comfort Fit "
                }, {
                    label: "Standard Fit",
                    value: "Standard Fit",
                    description: "Standard Fit"
                }],
                position: "end",
                storeKey: "band.bandFit",
                onClick: e => {
                    xn("band.bandFit")(e), An("bandFit", e)
                },
                componentType: "Basic"
            }, {
                title: "Surprise Stones",
                description: async () => {
                    const e = await vn((e => e(Bo.getState().surpriseStones)), 400);
                    return 0 === e.quantity ? "No Surprise Stones" : gn([e])
                },
                textinfo: "Add tiny diamonds to the sides of the band directly underneath the head.",
                buttons: [{
                    label: "None",
                    value: !1
                }, {
                    label: "Add Stones",
                    value: !0
                }],
                onClick: e => {
                    xn("surpriseStones")(e), wn("all", "surpriseStones", e)
                },
                storeKey: "surpriseStones",
                componentType: "Basic",
                position: "oneonly",
                MainTitle: "More"
            }, {
                title: "Add Engraving",
                textinfo: "Popular engravings include a name, date, or personal message.",
                description: "Type a custom message for engraving (14 characters max)",
                isInput: {
                    isSimple: !0,
                    placeholder: "Your engraving",
                    reducer: (Ho = 14, (e, t) => 0 === t.trim().length && "" !== t || t.length > Ho ? e : t),
                    onChange: e => {
                        xn("engravingText")(e), En("engravingText", e)
                    }
                },
                storeKey: "engravingText",
                componentType: "Input"
            }, {
                title: "Engraving Style",
                textinfo: "Personalize your engraving with different font styles.",
                buttons: [{
                    label: "Block",
                    value: "Block",
                    description: "Choose your font-style"
                }, {
                    label: "Cursive",
                    value: "Cursive",
                    description: "Choose your font-style"
                }],
                onClick: e => {
                    "None" === e && (xn("engravingText")(""), En("engravingText", "")), xn("engravingFont")(e), En("engravingFont", e)
                },
                storeKey: "engravingFont",
                componentType: "Basic"
            }];
        var Ho;
        const jo = [{
                label: "Metal",
                isOpen: !(window.innerWidth < 600),
                options: [zo[0]]
            }, {
                label: "Diamonds",
                options: [zo[1], zo[2], zo[3]]
            }, {
                label: "Head",
                options: [zo[4], zo[5], zo[6], zo[7], zo[9]]
            }, {
                label: "Band",
                options: [zo[10], zo[11], zo[12], zo[13], zo[14], zo[15], zo[16]]
            }, {
                label: "More",
                options: [zo[18], zo[19], zo[17]]
            }],
            Go = e => {
                let {
                    itemData: t,
                    navigationClick: n
                } = e;
                return (0, r.useMemo)((() => {
                    const {
                        componentType: e,
                        api: r
                    } = t;
                    let i;
                    return i = r ? Uo.DataLayer : Uo[e], (0, Nn.jsx)(i, { ...t,
                        navigationClick: n
                    })
                }), [t, n])
            },
            Vo = e => {
                let {
                    modalUI: t
                } = e;
                return t.map(((e, t) => (0, Nn.jsx)(Go, {
                    itemData: e
                }, t)))
            };

        function qo(e) {
            let {
                data: t,
                isVisible: n,
                hide: r
            } = e;
            if (!n) return null;
            const {
                modalTitle: i,
                modalUI: o
            } = null !== t && void 0 !== t ? t : {};
            return (0, Nn.jsx)(Fn, {
                modalTitle: i,
                hide: r,
                children: (0, Nn.jsx)(Vo, {
                    modalUI: o
                })
            })
        }

        function Wo(e) {
            let {
                handleManufacturingButton: t,
                setSavedAndReviewed: n
            } = e;
            const [i, o] = (0, r.useState)(null), [a, s] = (0, r.useState)(null), [l, c] = (0, r.useState)(null), [u, d] = (0, r.useState)(!1), [h, p] = (0, r.useState)(null), [f, m] = (0, r.useState)(null), g = (0, r.useRef)(null), v = (0, r.useRef)(null), y = (0, r.useRef)(0), b = Bo((e => e.numberOfElements)), x = Bo((e => e.headsVolume)), _ = Bo((e => e.prongPave)), M = Bo((e => e.haloBasketPave)), w = Bo((e => e.bandVolume)), A = Bo((e => e.bandPave)), S = Bo((e => e.bridgePave)), E = Bo((e => e.surpriseStones)), C = Bo((e => e.accentGems)), T = Bo((e => e.laserEngraving)), P = Bo((e => e.diamondType)), R = yn((e => e)), {
                band: I,
                prongMetalColor: O
            } = R, B = I.bandMetalColor, L = new URL(window.location.href).searchParams.get("jewelerid");
            (0, r.useEffect)((() => {
                v.current && clearTimeout(v.current);
                const e = {
                    numberOfElements: b,
                    headsMetal: O,
                    headsVolume: x.reduce(((e, t) => e + t), 0),
                    bandMetal: B,
                    bandVolume: w,
                    prongPave: _,
                    haloBasketPave: M,
                    bandPave: A,
                    bridgePave: S,
                    surpriseStones: E,
                    accentGems: C,
                    laserEngraving: T,
                    diamondType: P,
                    jewelerID: L
                };
                return v.current = setTimeout((() => {
                    (async () => {
                        const t = await un(e);
                        t && t.results && s(t.results[0].price)
                    })()
                }), 1e3), () => {
                    v.current && clearTimeout(v.current)
                }
            }), [O, B, C, A, w, S, M, x, T, b, _, E, P, L]);
            (0, r.useEffect)((() => {
                if (f) {
                    const e = new CustomEvent("handleScreenshot", {
                        detail: {
                            data: f
                        }
                    });
                    window.dispatchEvent(e)
                }
            }), [f]);
            const D = (0, r.useCallback)((e => {
                    c(e.detail.screenShoturl)
                }), []),
                N = (0, r.useCallback)((async () => {
                    try {
                        const e = Cn(),
                            t = {
                                numberOfElements: b,
                                headsMetal: e.HeadMetalColor,
                                headsVolume: x.reduce(((e, t) => e + t), 0),
                                bandMetal: e.BandMetalColor,
                                bandVolume: w,
                                prongPave: _,
                                haloBasketPave: M,
                                bandPave: A,
                                bridgePave: S,
                                surpriseStones: E,
                                accentGems: C,
                                laserEngraving: T,
                                diamondType: P,
                                jewelerID: L
                            };
                        e.pricing = t, p(e);
                        const n = await Pn(e);
                        m(n);
                        const r = await un(t);
                        s(r.results[0].price)
                    } catch (e) {
                        console.error("Error fetching ring ID:", e)
                    }
                }), [C, A, w, S, M, x, T, b, _, E, P, L]);
            return (0, r.useEffect)((() => (window.addEventListener("screenshotTaken", D), () => {
                window.removeEventListener("screenshotTaken", D)
            })), [D]), (0, r.useEffect)((() => {
                u && N()
            }), [u]), (0, r.useEffect)((() => {
                if (u && l && h && f && i) {
                    const e = y.current;
                    return g.current && clearTimeout(g.current), g.current = setTimeout((() => {
                        e === y.current && (window.parent.postMessage({
                            type: i,
                            Screenshot: l,
                            ringObject: h,
                            ringID: f.hashedKey
                        }, "*"), d(!1))
                    }), 1e3), () => {
                        g.current && clearTimeout(g.current)
                    }
                }
            }), [u, l, f, h]), (0, r.useEffect)((() => {
                const e = e => {
                    "fromParent" === e.data.type && "remove_loader" === e.data.message && n(!1)
                };
                return window.addEventListener("message", e), () => {
                    window.removeEventListener("message", e)
                }
            }), []), (0, Nn.jsx)("div", {
                className: "NewCPfooter",
                children: (0, Nn.jsxs)("div", {
                    className: "NewFcontent",
                    children: [(0, Nn.jsx)("div", {
                        className: "Fsection contact"
                    }), (0, Nn.jsxs)("div", {
                        className: "Fsection",
                        children: [(0, Nn.jsxs)("div", {
                            className: "Pricemsg",
                            children: [a && (0, Nn.jsxs)("div", {
                                className: "Price",
                                // children: ["MSRP $", "number" === typeof a ? a.toLocaleString("en-US", {
                                //     minimumFractionDigits: 0,
                                //     maximumFractionDigits: 0
                                // }) : a]
                            }), a && (0, Nn.jsx)
                            // ("div", {
                            //     className: "MSG",
                            //     children: "(Setting only)"
                            // })
                        ]
                        }), (0, Nn.jsxs)("div", {
                            className: "SaveBTN",
                            children: [
                        //         (0, Nn.jsxs)("button", {
                        //         className: "Save-icon",
                        //         onClick: () => {
                        //             y.current += 1, d(!0), n(!0), c(null), p(null), m(null), o("design_finished"), window.parent.postMessage({
                        //                 type: "loading_next_step"
                        //             }, "*")
                        //         },
                        //         children: [(0, Nn.jsx)("img", {
                        //             src: "./save.svg",
                        //             alt: "Save Design",
                        //             className: "desk-view"
                        //         })
                        //         , (0, Nn.jsx)("span", {
                        //             className: "mobile-view",
                        //             children: " Save "
                        //         }
                        //     )
                        // ]
                        //     }
                        // ),
                             (0, Nn.jsx)("button", {
                                className: "Save-btn",
                                onClick: () => {       
                                    // console.log(Mn.storeKey)  
                                    
                                    // console.log( yn.setState(yn.getState().initiateDefaultRing()))                           
                                    document.getElementById('wana').style.display = 'flex';
                                    document.getElementById('contactForm').addEventListener('submit', async function (e) {
                                        e.preventDefault(); // Prevent default form submission
                                    
                                        const { changeNumOfStones, availableStones, alterState, initiateDefaultRing, ...bandDetails } = yn.getState();
                                    
                                        const name = document.querySelector('#wana input[type="text"]').value;
                                        const email = document.querySelector('#wana input[type="email"]').value;
                                        const phone = document.querySelector('#wana input[type="tel"]').value;
                                    
                                        const apiUrl = 'https://dealsondiamonds.com/wp-json/open-email/v1/send-deal-alert/'; 
                                    
                                        const messageData = {
                                            name,
                                            email,
                                            phone,
                                            bandDetails
                                        }; 
                                        
                                        
                                        let result = '<div style="font-family: Arial, sans-serif; color: #333; line-height: 1.6; max-width: 600px; margin: 0 auto;">';

                                        function formatBandDetails(obj, prefix = '') {
                                          let entries = [];
                                          for (const key in obj) {
                                            if (obj.hasOwnProperty(key)) {
                                              const fullKey = prefix ? `${prefix}.${key}` : key;
                                              const value = obj[key];
                                              
                                              if (typeof value === 'object' && value !== null) {
                                                entries = entries.concat(formatBandDetails(value, fullKey));
                                              } else {
                                                entries.push({ key: fullKey, value });
                                              }
                                            }
                                          }
                                          return entries;
                                        }
                                        
                                        for (const key in messageData) {
                                          if (messageData.hasOwnProperty(key)) {
                                            if (key.toLowerCase() === 'banddetails') {
                                              result += `<h3 style="color: #2c3e50; border-bottom: 2px solid #eee; padding-bottom: 8px; margin: 25px 0 15px;">Band Details</h3>`;
                                              
                                              const details = formatBandDetails(messageData[key]);
                                              details.forEach(({ key: detailKey, value }) => {
                                                // Clean up key formatting
                                                const cleanKey = detailKey
                                                  .replace(/\./g, ' › ')
                                                  .replace(/([a-z])([A-Z])/g, '$1 $2')
                                                  .replace(/([A-Z])([A-Z][a-z])/g, '$1 $2');
                                                  
                                                result += `
                                                  <div style="margin: 8px 0; padding-left: 15px;">
                                                    <strong style="color: #27ae60; display: inline-block; width: 240px;">${cleanKey}:</strong>
                                                    <span style="color: #2c3e50;">${value}</span>
                                                  </div>
                                                `;
                                              });
                                            } else {
                                              result += `
                                                <div style="margin: 12px 0;">
                                                  <strong style="color: #c0392b; display: inline-block; width: 160px;">${key}:</strong>
                                                  <span style="color: #2c3e50;">${messageData[key]}</span>
                                                </div>
                                              `;
                                            }
                                          }
                                        }
                                        
                                        result += '</div>';
                                        try {
                                            const response = await fetch(apiUrl, {
                                                method: 'POST',
                                                headers: {
                                                    'Content-Type': 'application/json'
                                                },
                                                body: JSON.stringify({ "message": result }) 
                                            });
                                    
                                            if (response.ok) {
                                                console.log("Data sent successfully");
                                                document.getElementById('wana').style.display = 'none';
                                                document.getElementById('succ').style.display = 'inline-block';
                                            } else {
                                                console.error("Failed to send data", await response.text());
                                            }
                                        } catch (error) {
                                            console.error("Error sending data:", error);
                                        }
                                    });
                                    
                                    
                                    },
                                children: (0, Nn.jsx)("span", {
                                    children: [" Order for $","number" === typeof a ? a.toLocaleString("en-US", {
                                    minimumFractionDigits: 0,
                                    maximumFractionDigits: 0
                                }) : a]
                                })
                            }), (0, Nn.jsx)("p", {
                                className: "Mobile-message",
                                children: ""
                            })]
                        })]
                    })]
                })
            })
        }
        const Xo = e => {
                let {
                    children: t,
                    isVisible: n,
                    handleManufacturingButton: r,
                    setSavedAndReviewed: i
                } = e;
                return (0, Nn.jsxs)(Nn.Fragment, {
                    children: [n ? null : (0, Nn.jsxs)("div", {
                        className: "ControlPanelContainer",
                        children: [(0, Nn.jsx)("div", {
                            className: "CPTitle",
                            children: "Custom Engagement Ring"
                        }), (0, Nn.jsx)("div", {
                            className: "CPContent",
                            id: "styleSB",
                            children: t
                        })]
                    }), (0, Nn.jsx)(Wo, {
                        handleManufacturingButton: r,
                        setSavedAndReviewed: i
                    })]
                })
            },
            Ko = {
                container: "styles_container__5gwLD",
                clickable_container: "styles_clickable_container__e+Pfv",
                container_title: "styles_container_title__-35zP",
                animationclass: "styles_animationclass__+p6Ud",
                arrowbtn: "styles_arrowbtn__u4xAJ",
                opened: "styles_opened__r+8Y3"
            },
            Jo = e => {
                let {
                    title: t,
                    isOpenByDefault: n,
                    children: i
                } = e;
                const [o, a] = (0, r.useState)((() => {
                    const e = localStorage.getItem("section_".concat(t));
                    return null !== e ? JSON.parse(e) : n
                })), [s, l] = (0, r.useState)((() => null !== localStorage.getItem("section_".concat(t)))), c = (0, r.useRef)(null), u = (0, r.useCallback)((() => {
                    l(!0), a((e => {
                        const n = !e;
                        return localStorage.setItem("section_".concat(t), JSON.stringify(n)), n
                    }))
                }), [t]);
                return (0, r.useEffect)((() => {
                    if (c.current)
                        if (!s && n) c.current.style.height = "auto";
                        else if (o) {
                        const e = c.current.scrollHeight;
                        c.current.style.height = "0px", c.current.offsetHeight, c.current.style.height = "".concat(e, "px")
                    } else {
                        const e = c.current.scrollHeight;
                        c.current.style.height = "".concat(e, "px"), c.current.offsetHeight, c.current.style.height = "0px"
                    }
                }), [o, s, n]), (0, r.useEffect)((() => {
                    if (o && c.current) {
                        const e = setTimeout((() => {
                            c.current.style.height = "fit-content"
                        }), 400);
                        return () => clearTimeout(e)
                    }
                }), [o]), (0, Nn.jsxs)("div", {
                    className: Ko.container,
                    children: [(0, Nn.jsxs)("div", {
                        className: Ko.clickable_container,
                        onClick: u,
                        children: [(0, Nn.jsx)("p", {
                            className: Ko.container_title,
                            children: t
                        }), (0, Nn.jsx)("button", {
                            className: Ko.arrowbtn,
                            children: (0, Nn.jsx)("img", {
                                src: "arr1.png",
                                alt: "arr1.png",
                                className: o ? "" : Ko.opened
                            })
                        })]
                    }), (0, Nn.jsx)("div", {
                        ref: c,
                        className: "".concat(Ko.animationclass, " ").concat(!s && n ? Ko.no_transition : ""),
                        children: (0, Nn.jsx)("div", {
                            className: Ko.content_inner,
                            children: i
                        })
                    })]
                })
            },
            Yo = e => {
                let {
                    showModal: t
                } = e;
                return (0, r.useEffect)((() => {
                    const e = () => {
                        jo.forEach((e => {
                            let {
                                label: t
                            } = e;
                            localStorage.removeItem("section_".concat(t))
                        }))
                    };
                    return window.addEventListener("beforeunload", e), () => {
                        window.removeEventListener("beforeunload", e)
                    }
                }), []), jo.map((e => {
                    let {
                        label: n,
                        isOpen: r,
                        options: i
                    } = e;
                    return (0, Nn.jsx)(Jo, {
                        isOpenByDefault: r,
                        title: n,
                        children: i.map(((e, n) => (0, Nn.jsx)(Go, {
                            navigationClick: t,
                            itemData: e
                        }, n)))
                    }, n)
                }))
            };

        function Qo(e) {
            let {
                handleManufacturingButton: t,
                setSavedAndReviewed: n
            } = e;
            const {
                modal: r,
                showModal: i,
                hideModal: o
            } = Dn();
            return (0, Nn.jsxs)(Nn.Fragment, {
                children: [(0, Nn.jsx)(Xo, { ...r,
                    handleManufacturingButton: t,
                    setSavedAndReviewed: n,
                    children: (0, Nn.jsx)(Yo, {
                        showModal: i
                    })
                }), (0, Nn.jsx)(qo, {
                    hide: o,
                    ...r
                })]
            })
        }
        const Zo = "161",
            $o = {
                LEFT: 0,
                MIDDLE: 1,
                RIGHT: 2,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2
            },
            ea = {
                ROTATE: 0,
                PAN: 1,
                DOLLY_PAN: 2,
                DOLLY_ROTATE: 3
            },
            ta = 0,
            na = 1,
            ra = 2,
            ia = 3,
            oa = 0,
            aa = 1,
            sa = 2,
            la = 3,
            ca = 0,
            ua = 1,
            da = 2,
            ha = 0,
            pa = 1,
            fa = 2,
            ma = 3,
            ga = 4,
            va = 5,
            ya = 100,
            ba = 101,
            xa = 102,
            _a = 103,
            Ma = 104,
            wa = 200,
            Aa = 201,
            Sa = 202,
            Ea = 203,
            Ca = 204,
            Ta = 205,
            Pa = 206,
            Ra = 207,
            Ia = 208,
            Oa = 209,
            Ba = 210,
            La = 211,
            Da = 212,
            Na = 213,
            ka = 214,
            Fa = 0,
            Ua = 1,
            za = 2,
            Ha = 3,
            ja = 4,
            Ga = 5,
            Va = 6,
            qa = 7,
            Wa = 0,
            Xa = 1,
            Ka = 2,
            Ja = 0,
            Ya = 1,
            Qa = 2,
            Za = 3,
            $a = 4,
            es = 5,
            ts = 6,
            ns = "attached",
            rs = "detached",
            is = 300,
            os = 301,
            as = 302,
            ss = 303,
            ls = 304,
            cs = 306,
            us = 1e3,
            ds = 1001,
            hs = 1002,
            ps = 1003,
            fs = 1004,
            ms = 1004,
            gs = 1005,
            vs = 1005,
            ys = 1006,
            bs = 1007,
            xs = 1007,
            _s = 1008,
            Ms = 1008,
            ws = 1009,
            As = 1010,
            Ss = 1011,
            Es = 1012,
            Cs = 1013,
            Ts = 1014,
            Ps = 1015,
            Rs = 1016,
            Is = 1017,
            Os = 1018,
            Bs = 1020,
            Ls = 1021,
            Ds = 1023,
            Ns = 1024,
            ks = 1025,
            Fs = 1026,
            Us = 1027,
            zs = 1028,
            Hs = 1029,
            js = 1030,
            Gs = 1031,
            Vs = 1033,
            qs = 33776,
            Ws = 33777,
            Xs = 33778,
            Ks = 33779,
            Js = 35840,
            Ys = 35841,
            Qs = 35842,
            Zs = 35843,
            $s = 36196,
            el = 37492,
            tl = 37496,
            nl = 37808,
            rl = 37809,
            il = 37810,
            ol = 37811,
            al = 37812,
            sl = 37813,
            ll = 37814,
            cl = 37815,
            ul = 37816,
            dl = 37817,
            hl = 37818,
            pl = 37819,
            fl = 37820,
            ml = 37821,
            gl = 36492,
            vl = 36494,
            yl = 36495,
            bl = 36283,
            xl = 36284,
            _l = 36285,
            Ml = 36286,
            wl = 2200,
            Al = 2201,
            Sl = 2202,
            El = 2300,
            Cl = 2301,
            Tl = 2302,
            Pl = 2400,
            Rl = 2401,
            Il = 2402,
            Ol = 2500,
            Bl = 2501,
            Ll = 0,
            Dl = 1,
            Nl = 2,
            kl = 3e3,
            Fl = 3001,
            Ul = 3200,
            zl = 3201,
            Hl = 0,
            jl = 1,
            Gl = "",
            Vl = "srgb",
            ql = "srgb-linear",
            Wl = "display-p3",
            Xl = "display-p3-linear",
            Kl = "linear",
            Jl = "srgb",
            Yl = "rec709",
            Ql = "p3",
            Zl = 0,
            $l = 7680,
            ec = 7681,
            tc = 7682,
            nc = 7683,
            rc = 34055,
            ic = 34056,
            oc = 5386,
            ac = 512,
            sc = 513,
            lc = 514,
            cc = 515,
            uc = 516,
            dc = 517,
            hc = 518,
            pc = 519,
            fc = 512,
            mc = 513,
            gc = 514,
            vc = 515,
            yc = 516,
            bc = 517,
            xc = 518,
            _c = 519,
            Mc = 35044,
            wc = 35048,
            Ac = 35040,
            Sc = 35045,
            Ec = 35049,
            Cc = 35041,
            Tc = 35046,
            Pc = 35050,
            Rc = 35042,
            Ic = "100",
            Oc = "300 es",
            Bc = 1035,
            Lc = 2e3,
            Dc = 2001;
        class Nc {
            addEventListener(e, t) {
                void 0 === this._listeners && (this._listeners = {});
                const n = this._listeners;
                void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
            }
            hasEventListener(e, t) {
                if (void 0 === this._listeners) return !1;
                const n = this._listeners;
                return void 0 !== n[e] && -1 !== n[e].indexOf(t)
            }
            removeEventListener(e, t) {
                if (void 0 === this._listeners) return;
                const n = this._listeners[e];
                if (void 0 !== n) {
                    const e = n.indexOf(t); - 1 !== e && n.splice(e, 1)
                }
            }
            dispatchEvent(e) {
                if (void 0 === this._listeners) return;
                const t = this._listeners[e.type];
                if (void 0 !== t) {
                    e.target = this;
                    const n = t.slice(0);
                    for (let t = 0, r = n.length; t < r; t++) n[t].call(this, e);
                    e.target = null
                }
            }
        }
        const kc = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
        let Fc = 1234567;
        const Uc = Math.PI / 180,
            zc = 180 / Math.PI;

        function Hc() {
            const e = 4294967295 * Math.random() | 0,
                t = 4294967295 * Math.random() | 0,
                n = 4294967295 * Math.random() | 0,
                r = 4294967295 * Math.random() | 0;
            return (kc[255 & e] + kc[e >> 8 & 255] + kc[e >> 16 & 255] + kc[e >> 24 & 255] + "-" + kc[255 & t] + kc[t >> 8 & 255] + "-" + kc[t >> 16 & 15 | 64] + kc[t >> 24 & 255] + "-" + kc[63 & n | 128] + kc[n >> 8 & 255] + "-" + kc[n >> 16 & 255] + kc[n >> 24 & 255] + kc[255 & r] + kc[r >> 8 & 255] + kc[r >> 16 & 255] + kc[r >> 24 & 255]).toLowerCase()
        }

        function jc(e, t, n) {
            return Math.max(t, Math.min(n, e))
        }

        function Gc(e, t) {
            return (e % t + t) % t
        }

        function Vc(e, t, n) {
            return (1 - n) * e + n * t
        }

        function qc(e) {
            return 0 === (e & e - 1) && 0 !== e
        }

        function Wc(e) {
            return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
        }

        function Xc(e, t) {
            switch (t.constructor) {
                case Float32Array:
                    return e;
                case Uint32Array:
                    return e / 4294967295;
                case Uint16Array:
                    return e / 65535;
                case Uint8Array:
                    return e / 255;
                case Int32Array:
                    return Math.max(e / 2147483647, -1);
                case Int16Array:
                    return Math.max(e / 32767, -1);
                case Int8Array:
                    return Math.max(e / 127, -1);
                default:
                    throw new Error("Invalid component type.")
            }
        }

        function Kc(e, t) {
            switch (t.constructor) {
                case Float32Array:
                    return e;
                case Uint32Array:
                    return Math.round(4294967295 * e);
                case Uint16Array:
                    return Math.round(65535 * e);
                case Uint8Array:
                    return Math.round(255 * e);
                case Int32Array:
                    return Math.round(2147483647 * e);
                case Int16Array:
                    return Math.round(32767 * e);
                case Int8Array:
                    return Math.round(127 * e);
                default:
                    throw new Error("Invalid component type.")
            }
        }
        const Jc = {
            DEG2RAD: Uc,
            RAD2DEG: zc,
            generateUUID: Hc,
            clamp: jc,
            euclideanModulo: Gc,
            mapLinear: function(e, t, n, r, i) {
                return r + (e - t) * (i - r) / (n - t)
            },
            inverseLerp: function(e, t, n) {
                return e !== t ? (n - e) / (t - e) : 0
            },
            lerp: Vc,
            damp: function(e, t, n, r) {
                return Vc(e, t, 1 - Math.exp(-n * r))
            },
            pingpong: function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                return t - Math.abs(Gc(e, 2 * t) - t)
            },
            smoothstep: function(e, t, n) {
                return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
            },
            smootherstep: function(e, t, n) {
                return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
            },
            randInt: function(e, t) {
                return e + Math.floor(Math.random() * (t - e + 1))
            },
            randFloat: function(e, t) {
                return e + Math.random() * (t - e)
            },
            randFloatSpread: function(e) {
                return e * (.5 - Math.random())
            },
            seededRandom: function(e) {
                void 0 !== e && (Fc = e);
                let t = Fc += 1831565813;
                return t = Math.imul(t ^ t >>> 15, 1 | t), t ^= t + Math.imul(t ^ t >>> 7, 61 | t), ((t ^ t >>> 14) >>> 0) / 4294967296
            },
            degToRad: function(e) {
                return e * Uc
            },
            radToDeg: function(e) {
                return e * zc
            },
            isPowerOfTwo: qc,
            ceilPowerOfTwo: function(e) {
                return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
            },
            floorPowerOfTwo: Wc,
            setQuaternionFromProperEuler: function(e, t, n, r, i) {
                const o = Math.cos,
                    a = Math.sin,
                    s = o(n / 2),
                    l = a(n / 2),
                    c = o((t + r) / 2),
                    u = a((t + r) / 2),
                    d = o((t - r) / 2),
                    h = a((t - r) / 2),
                    p = o((r - t) / 2),
                    f = a((r - t) / 2);
                switch (i) {
                    case "XYX":
                        e.set(s * u, l * d, l * h, s * c);
                        break;
                    case "YZY":
                        e.set(l * h, s * u, l * d, s * c);
                        break;
                    case "ZXZ":
                        e.set(l * d, l * h, s * u, s * c);
                        break;
                    case "XZX":
                        e.set(s * u, l * f, l * p, s * c);
                        break;
                    case "YXY":
                        e.set(l * p, s * u, l * f, s * c);
                        break;
                    case "ZYZ":
                        e.set(l * f, l * p, s * u, s * c);
                        break;
                    default:
                        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
                }
            },
            normalize: Kc,
            denormalize: Xc
        };
        class Yc {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                Yc.prototype.isVector2 = !0, this.x = e, this.y = t
            }
            get width() {
                return this.x
            }
            set width(e) {
                this.x = e
            }
            get height() {
                return this.y
            }
            set height(e) {
                this.y = e
            }
            set(e, t) {
                return this.x = e, this.y = t, this
            }
            setScalar(e) {
                return this.x = e, this.y = e, this
            }
            setX(e) {
                return this.x = e, this
            }
            setY(e) {
                return this.y = e, this
            }
            setComponent(e, t) {
                switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y)
            }
            copy(e) {
                return this.x = e.x, this.y = e.y, this
            }
            add(e) {
                return this.x += e.x, this.y += e.y, this
            }
            addScalar(e) {
                return this.x += e, this.y += e, this
            }
            addVectors(e, t) {
                return this.x = e.x + t.x, this.y = e.y + t.y, this
            }
            addScaledVector(e, t) {
                return this.x += e.x * t, this.y += e.y * t, this
            }
            sub(e) {
                return this.x -= e.x, this.y -= e.y, this
            }
            subScalar(e) {
                return this.x -= e, this.y -= e, this
            }
            subVectors(e, t) {
                return this.x = e.x - t.x, this.y = e.y - t.y, this
            }
            multiply(e) {
                return this.x *= e.x, this.y *= e.y, this
            }
            multiplyScalar(e) {
                return this.x *= e, this.y *= e, this
            }
            divide(e) {
                return this.x /= e.x, this.y /= e.y, this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            applyMatrix3(e) {
                const t = this.x,
                    n = this.y,
                    r = e.elements;
                return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this
            }
            min(e) {
                return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
            }
            clamp(e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
            }
            clampScalar(e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
            }
            clampLength(e, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y
            }
            cross(e) {
                return this.x * e.y - this.y * e.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }
            angleTo(e) {
                const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                if (0 === t) return Math.PI / 2;
                const n = this.dot(e) / t;
                return Math.acos(jc(n, -1, 1))
            }
            distanceTo(e) {
                return Math.sqrt(this.distanceToSquared(e))
            }
            distanceToSquared(e) {
                const t = this.x - e.x,
                    n = this.y - e.y;
                return t * t + n * n
            }
            manhattanDistanceTo(e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, t) {
                return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
            }
            lerpVectors(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y
            }
            fromArray(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return this.x = e[t], this.y = e[t + 1], this
            }
            toArray() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return e[t] = this.x, e[t + 1] = this.y, e
            }
            fromBufferAttribute(e, t) {
                return this.x = e.getX(t), this.y = e.getY(t), this
            }
            rotateAround(e, t) {
                const n = Math.cos(t),
                    r = Math.sin(t),
                    i = this.x - e.x,
                    o = this.y - e.y;
                return this.x = i * n - o * r + e.x, this.y = i * r + o * n + e.y, this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this
            }*[Symbol.iterator]() {
                yield this.x, yield this.y
            }
        }
        class Qc {
            constructor(e, t, n, r, i, o, a, s, l) {
                Qc.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], void 0 !== e && this.set(e, t, n, r, i, o, a, s, l)
            }
            set(e, t, n, r, i, o, a, s, l) {
                const c = this.elements;
                return c[0] = e, c[1] = r, c[2] = a, c[3] = t, c[4] = i, c[5] = s, c[6] = n, c[7] = o, c[8] = l, this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            }
            copy(e) {
                const t = this.elements,
                    n = e.elements;
                return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
            }
            extractBasis(e, t, n) {
                return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
            }
            setFromMatrix4(e) {
                const t = e.elements;
                return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
            }
            multiply(e) {
                return this.multiplyMatrices(this, e)
            }
            premultiply(e) {
                return this.multiplyMatrices(e, this)
            }
            multiplyMatrices(e, t) {
                const n = e.elements,
                    r = t.elements,
                    i = this.elements,
                    o = n[0],
                    a = n[3],
                    s = n[6],
                    l = n[1],
                    c = n[4],
                    u = n[7],
                    d = n[2],
                    h = n[5],
                    p = n[8],
                    f = r[0],
                    m = r[3],
                    g = r[6],
                    v = r[1],
                    y = r[4],
                    b = r[7],
                    x = r[2],
                    _ = r[5],
                    M = r[8];
                return i[0] = o * f + a * v + s * x, i[3] = o * m + a * y + s * _, i[6] = o * g + a * b + s * M, i[1] = l * f + c * v + u * x, i[4] = l * m + c * y + u * _, i[7] = l * g + c * b + u * M, i[2] = d * f + h * v + p * x, i[5] = d * m + h * y + p * _, i[8] = d * g + h * b + p * M, this
            }
            multiplyScalar(e) {
                const t = this.elements;
                return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
            }
            determinant() {
                const e = this.elements,
                    t = e[0],
                    n = e[1],
                    r = e[2],
                    i = e[3],
                    o = e[4],
                    a = e[5],
                    s = e[6],
                    l = e[7],
                    c = e[8];
                return t * o * c - t * a * l - n * i * c + n * a * s + r * i * l - r * o * s
            }
            invert() {
                const e = this.elements,
                    t = e[0],
                    n = e[1],
                    r = e[2],
                    i = e[3],
                    o = e[4],
                    a = e[5],
                    s = e[6],
                    l = e[7],
                    c = e[8],
                    u = c * o - a * l,
                    d = a * s - c * i,
                    h = l * i - o * s,
                    p = t * u + n * d + r * h;
                if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const f = 1 / p;
                return e[0] = u * f, e[1] = (r * l - c * n) * f, e[2] = (a * n - r * o) * f, e[3] = d * f, e[4] = (c * t - r * s) * f, e[5] = (r * i - a * t) * f, e[6] = h * f, e[7] = (n * s - l * t) * f, e[8] = (o * t - n * i) * f, this
            }
            transpose() {
                let e;
                const t = this.elements;
                return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
            }
            getNormalMatrix(e) {
                return this.setFromMatrix4(e).invert().transpose()
            }
            transposeIntoArray(e) {
                const t = this.elements;
                return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
            }
            setUvTransform(e, t, n, r, i, o, a) {
                const s = Math.cos(i),
                    l = Math.sin(i);
                return this.set(n * s, n * l, -n * (s * o + l * a) + o + e, -r * l, r * s, -r * (-l * o + s * a) + a + t, 0, 0, 1), this
            }
            scale(e, t) {
                return this.premultiply(Zc.makeScale(e, t)), this
            }
            rotate(e) {
                return this.premultiply(Zc.makeRotation(-e)), this
            }
            translate(e, t) {
                return this.premultiply(Zc.makeTranslation(e, t)), this
            }
            makeTranslation(e, t) {
                return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this
            }
            makeRotation(e) {
                const t = Math.cos(e),
                    n = Math.sin(e);
                return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this
            }
            makeScale(e, t) {
                return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this
            }
            equals(e) {
                const t = this.elements,
                    n = e.elements;
                for (let r = 0; r < 9; r++)
                    if (t[r] !== n[r]) return !1;
                return !0
            }
            fromArray(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
                return this
            }
            toArray() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                const n = this.elements;
                return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
            }
            clone() {
                return (new this.constructor).fromArray(this.elements)
            }
        }
        const Zc = new Qc;

        function $c(e) {
            for (let t = e.length - 1; t >= 0; --t)
                if (e[t] >= 65535) return !0;
            return !1
        }
        const eu = {
            Int8Array: Int8Array,
            Uint8Array: Uint8Array,
            Uint8ClampedArray: Uint8ClampedArray,
            Int16Array: Int16Array,
            Uint16Array: Uint16Array,
            Int32Array: Int32Array,
            Uint32Array: Uint32Array,
            Float32Array: Float32Array,
            Float64Array: Float64Array
        };

        function tu(e, t) {
            return new eu[e](t)
        }

        function nu(e) {
            return document.createElementNS("http://www.w3.org/1999/xhtml", e)
        }

        function ru() {
            const e = nu("canvas");
            return e.style.display = "block", e
        }
        const iu = {};

        function ou(e) {
            e in iu || (iu[e] = !0, console.warn(e))
        }
        const au = (new Qc).set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199),
            su = (new Qc).set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735),
            lu = {
                [ql]: {
                    transfer: Kl,
                    primaries: Yl,
                    toReference: e => e,
                    fromReference: e => e
                },
                [Vl]: {
                    transfer: Jl,
                    primaries: Yl,
                    toReference: e => e.convertSRGBToLinear(),
                    fromReference: e => e.convertLinearToSRGB()
                },
                [Xl]: {
                    transfer: Kl,
                    primaries: Ql,
                    toReference: e => e.applyMatrix3(su),
                    fromReference: e => e.applyMatrix3(au)
                },
                [Wl]: {
                    transfer: Jl,
                    primaries: Ql,
                    toReference: e => e.convertSRGBToLinear().applyMatrix3(su),
                    fromReference: e => e.applyMatrix3(au).convertLinearToSRGB()
                }
            },
            cu = new Set([ql, Xl]),
            uu = {
                enabled: !0,
                _workingColorSpace: ql,
                get workingColorSpace() {
                    return this._workingColorSpace
                },
                set workingColorSpace(e) {
                    if (!cu.has(e)) throw new Error('Unsupported working color space, "'.concat(e, '".'));
                    this._workingColorSpace = e
                },
                convert: function(e, t, n) {
                    if (!1 === this.enabled || t === n || !t || !n) return e;
                    const r = lu[t].toReference;
                    return (0, lu[n].fromReference)(r(e))
                },
                fromWorkingColorSpace: function(e, t) {
                    return this.convert(e, this._workingColorSpace, t)
                },
                toWorkingColorSpace: function(e, t) {
                    return this.convert(e, t, this._workingColorSpace)
                },
                getPrimaries: function(e) {
                    return lu[e].primaries
                },
                getTransfer: function(e) {
                    return e === Gl ? Kl : lu[e].transfer
                }
            };

        function du(e) {
            return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
        }

        function hu(e) {
            return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
        }
        let pu;
        class fu {
            static getDataURL(e) {
                if (/^data:/i.test(e.src)) return e.src;
                if ("undefined" === typeof HTMLCanvasElement) return e.src;
                let t;
                if (e instanceof HTMLCanvasElement) t = e;
                else {
                    void 0 === pu && (pu = nu("canvas")), pu.width = e.width, pu.height = e.height;
                    const n = pu.getContext("2d");
                    e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = pu
                }
                return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
            }
            static sRGBToLinear(e) {
                if ("undefined" !== typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && e instanceof ImageBitmap) {
                    const t = nu("canvas");
                    t.width = e.width, t.height = e.height;
                    const n = t.getContext("2d");
                    n.drawImage(e, 0, 0, e.width, e.height);
                    const r = n.getImageData(0, 0, e.width, e.height),
                        i = r.data;
                    for (let e = 0; e < i.length; e++) i[e] = 255 * du(i[e] / 255);
                    return n.putImageData(r, 0, 0), t
                }
                if (e.data) {
                    const t = e.data.slice(0);
                    for (let e = 0; e < t.length; e++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * du(t[e] / 255)) : t[e] = du(t[e]);
                    return {
                        data: t,
                        width: e.width,
                        height: e.height
                    }
                }
                return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e
            }
        }
        let mu = 0;
        class gu {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                this.isSource = !0, Object.defineProperty(this, "id", {
                    value: mu++
                }), this.uuid = Hc(), this.data = e, this.dataReady = !0, this.version = 0
            }
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            toJSON(e) {
                const t = void 0 === e || "string" === typeof e;
                if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid];
                const n = {
                        uuid: this.uuid,
                        url: ""
                    },
                    r = this.data;
                if (null !== r) {
                    let e;
                    if (Array.isArray(r)) {
                        e = [];
                        for (let t = 0, n = r.length; t < n; t++) r[t].isDataTexture ? e.push(vu(r[t].image)) : e.push(vu(r[t]))
                    } else e = vu(r);
                    n.url = e
                }
                return t || (e.images[this.uuid] = n), n
            }
        }

        function vu(e) {
            return "undefined" !== typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && e instanceof ImageBitmap ? fu.getDataURL(e) : e.data ? {
                data: Array.from(e.data),
                width: e.width,
                height: e.height,
                type: e.data.constructor.name
            } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
        }
        let yu = 0;
        class bu extends Nc {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : bu.DEFAULT_IMAGE,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : bu.DEFAULT_MAPPING,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ds,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : ds,
                    i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : ys,
                    o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : _s,
                    a = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : Ds,
                    s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : ws,
                    l = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : bu.DEFAULT_ANISOTROPY,
                    c = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : Gl;
                super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                    value: yu++
                }), this.uuid = Hc(), this.name = "", this.source = new gu(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = r, this.magFilter = i, this.minFilter = o, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = s, this.offset = new Yc(0, 0), this.repeat = new Yc(1, 1), this.center = new Yc(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Qc, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, "string" === typeof c ? this.colorSpace = c : (ou("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = c === Fl ? Vl : Gl), this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
            }
            get image() {
                return this.source.data
            }
            set image(e) {
                void 0 === e && (e = null), this.source.data = e
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
            }
            toJSON(e) {
                const t = void 0 === e || "string" === typeof e;
                if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
                const n = {
                    metadata: {
                        version: 4.6,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    image: this.source.toJSON(e).uuid,
                    mapping: this.mapping,
                    channel: this.channel,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    internalFormat: this.internalFormat,
                    type: this.type,
                    colorSpace: this.colorSpace,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    generateMipmaps: this.generateMipmaps,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(e) {
                if (this.mapping !== is) return e;
                if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                    case us:
                        e.x = e.x - Math.floor(e.x);
                        break;
                    case ds:
                        e.x = e.x < 0 ? 0 : 1;
                        break;
                    case hs:
                        1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                }
                if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                    case us:
                        e.y = e.y - Math.floor(e.y);
                        break;
                    case ds:
                        e.y = e.y < 0 ? 0 : 1;
                        break;
                    case hs:
                        1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                }
                return this.flipY && (e.y = 1 - e.y), e
            }
            set needsUpdate(e) {
                !0 === e && (this.version++, this.source.needsUpdate = !0)
            }
            get encoding() {
                return ou("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === Vl ? Fl : kl
            }
            set encoding(e) {
                ou("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = e === Fl ? Vl : Gl
            }
        }
        bu.DEFAULT_IMAGE = null, bu.DEFAULT_MAPPING = is, bu.DEFAULT_ANISOTROPY = 1;
        class xu {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                xu.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = r
            }
            get width() {
                return this.z
            }
            set width(e) {
                this.z = e
            }
            get height() {
                return this.w
            }
            set height(e) {
                this.w = e
            }
            set(e, t, n, r) {
                return this.x = e, this.y = t, this.z = n, this.w = r, this
            }
            setScalar(e) {
                return this.x = e, this.y = e, this.z = e, this.w = e, this
            }
            setX(e) {
                return this.x = e, this
            }
            setY(e) {
                return this.y = e, this
            }
            setZ(e) {
                return this.z = e, this
            }
            setW(e) {
                return this.w = e, this
            }
            setComponent(e, t) {
                switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    case 2:
                        this.z = t;
                        break;
                    case 3:
                        this.w = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z, this.w)
            }
            copy(e) {
                return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
            }
            add(e) {
                return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
            }
            addScalar(e) {
                return this.x += e, this.y += e, this.z += e, this.w += e, this
            }
            addVectors(e, t) {
                return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
            }
            addScaledVector(e, t) {
                return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
            }
            sub(e) {
                return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
            }
            subScalar(e) {
                return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
            }
            subVectors(e, t) {
                return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
            }
            multiply(e) {
                return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
            }
            multiplyScalar(e) {
                return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
            }
            applyMatrix4(e) {
                const t = this.x,
                    n = this.y,
                    r = this.z,
                    i = this.w,
                    o = e.elements;
                return this.x = o[0] * t + o[4] * n + o[8] * r + o[12] * i, this.y = o[1] * t + o[5] * n + o[9] * r + o[13] * i, this.z = o[2] * t + o[6] * n + o[10] * r + o[14] * i, this.w = o[3] * t + o[7] * n + o[11] * r + o[15] * i, this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            setAxisAngleFromQuaternion(e) {
                this.w = 2 * Math.acos(e.w);
                const t = Math.sqrt(1 - e.w * e.w);
                return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
            }
            setAxisAngleFromRotationMatrix(e) {
                let t, n, r, i;
                const o = .01,
                    a = .1,
                    s = e.elements,
                    l = s[0],
                    c = s[4],
                    u = s[8],
                    d = s[1],
                    h = s[5],
                    p = s[9],
                    f = s[2],
                    m = s[6],
                    g = s[10];
                if (Math.abs(c - d) < o && Math.abs(u - f) < o && Math.abs(p - m) < o) {
                    if (Math.abs(c + d) < a && Math.abs(u + f) < a && Math.abs(p + m) < a && Math.abs(l + h + g - 3) < a) return this.set(1, 0, 0, 0), this;
                    t = Math.PI;
                    const e = (l + 1) / 2,
                        s = (h + 1) / 2,
                        v = (g + 1) / 2,
                        y = (c + d) / 4,
                        b = (u + f) / 4,
                        x = (p + m) / 4;
                    return e > s && e > v ? e < o ? (n = 0, r = .707106781, i = .707106781) : (n = Math.sqrt(e), r = y / n, i = b / n) : s > v ? s < o ? (n = .707106781, r = 0, i = .707106781) : (r = Math.sqrt(s), n = y / r, i = x / r) : v < o ? (n = .707106781, r = .707106781, i = 0) : (i = Math.sqrt(v), n = b / i, r = x / i), this.set(n, r, i, t), this
                }
                let v = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (d - c) * (d - c));
                return Math.abs(v) < .001 && (v = 1), this.x = (m - p) / v, this.y = (u - f) / v, this.z = (d - c) / v, this.w = Math.acos((l + h + g - 1) / 2), this
            }
            min(e) {
                return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
            }
            clamp(e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
            }
            clampScalar(e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
            }
            clampLength(e, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, t) {
                return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
            }
            lerpVectors(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
            }
            fromArray(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
            }
            toArray() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
            }
            fromBufferAttribute(e, t) {
                return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
            }*[Symbol.iterator]() {
                yield this.x, yield this.y, yield this.z, yield this.w
            }
        }
        class _u extends Nc {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new xu(0, 0, e, t), this.scissorTest = !1, this.viewport = new xu(0, 0, e, t);
                const r = {
                    width: e,
                    height: t,
                    depth: 1
                };
                void 0 !== n.encoding && (ou("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), n.colorSpace = n.encoding === Fl ? Vl : Gl), n = Object.assign({
                    generateMipmaps: !1,
                    internalFormat: null,
                    minFilter: ys,
                    depthBuffer: !0,
                    stencilBuffer: !1,
                    depthTexture: null,
                    samples: 0
                }, n), this.texture = new bu(r, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = n.generateMipmaps, this.texture.internalFormat = n.internalFormat, this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples
            }
            setSize(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                this.width === e && this.height === t && this.depth === n || (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
                const t = Object.assign({}, e.texture.image);
                return this.texture.source = new gu(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        class Mu extends _u {
            constructor() {
                super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}), this.isWebGLRenderTarget = !0
            }
        }
        class wu extends bu {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                super(null), this.isDataArrayTexture = !0, this.image = {
                    data: e,
                    width: t,
                    height: n,
                    depth: r
                }, this.magFilter = ps, this.minFilter = ps, this.wrapR = ds, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        }
        class Au extends Mu {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                super(e, t, arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}), this.isWebGLArrayRenderTarget = !0, this.depth = n, this.texture = new wu(null, e, t, n), this.texture.isRenderTargetTexture = !0
            }
        }
        class Su extends bu {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                super(null), this.isData3DTexture = !0, this.image = {
                    data: e,
                    width: t,
                    height: n,
                    depth: r
                }, this.magFilter = ps, this.minFilter = ps, this.wrapR = ds, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        }
        class Eu extends Mu {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                super(e, t, arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}), this.isWebGL3DRenderTarget = !0, this.depth = n, this.texture = new Su(null, e, t, n), this.texture.isRenderTargetTexture = !0
            }
        }
        class Cu extends Mu {
            constructor() {
                let e = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}), this.isWebGLMultipleRenderTargets = !0;
                const t = this.texture;
                this.texture = [];
                for (let n = 0; n < e; n++) this.texture[n] = t.clone(), this.texture[n].isRenderTargetTexture = !0
            }
            setSize(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                if (this.width !== e || this.height !== t || this.depth !== n) {
                    this.width = e, this.height = t, this.depth = n;
                    for (let r = 0, i = this.texture.length; r < i; r++) this.texture[r].image.width = e, this.texture[r].image.height = t, this.texture[r].image.depth = n;
                    this.dispose()
                }
                this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
            }
            copy(e) {
                this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
                for (let t = 0, n = e.texture.length; t < n; t++) this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0;
                return this
            }
        }
        class Tu {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = r
            }
            static slerpFlat(e, t, n, r, i, o, a) {
                let s = n[r + 0],
                    l = n[r + 1],
                    c = n[r + 2],
                    u = n[r + 3];
                const d = i[o + 0],
                    h = i[o + 1],
                    p = i[o + 2],
                    f = i[o + 3];
                if (0 === a) return e[t + 0] = s, e[t + 1] = l, e[t + 2] = c, void(e[t + 3] = u);
                if (1 === a) return e[t + 0] = d, e[t + 1] = h, e[t + 2] = p, void(e[t + 3] = f);
                if (u !== f || s !== d || l !== h || c !== p) {
                    let e = 1 - a;
                    const t = s * d + l * h + c * p + u * f,
                        n = t >= 0 ? 1 : -1,
                        r = 1 - t * t;
                    if (r > Number.EPSILON) {
                        const i = Math.sqrt(r),
                            o = Math.atan2(i, t * n);
                        e = Math.sin(e * o) / i, a = Math.sin(a * o) / i
                    }
                    const i = a * n;
                    if (s = s * e + d * i, l = l * e + h * i, c = c * e + p * i, u = u * e + f * i, e === 1 - a) {
                        const e = 1 / Math.sqrt(s * s + l * l + c * c + u * u);
                        s *= e, l *= e, c *= e, u *= e
                    }
                }
                e[t] = s, e[t + 1] = l, e[t + 2] = c, e[t + 3] = u
            }
            static multiplyQuaternionsFlat(e, t, n, r, i, o) {
                const a = n[r],
                    s = n[r + 1],
                    l = n[r + 2],
                    c = n[r + 3],
                    u = i[o],
                    d = i[o + 1],
                    h = i[o + 2],
                    p = i[o + 3];
                return e[t] = a * p + c * u + s * h - l * d, e[t + 1] = s * p + c * d + l * u - a * h, e[t + 2] = l * p + c * h + a * d - s * u, e[t + 3] = c * p - a * u - s * d - l * h, e
            }
            get x() {
                return this._x
            }
            set x(e) {
                this._x = e, this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(e) {
                this._y = e, this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(e) {
                this._z = e, this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(e) {
                this._w = e, this._onChangeCallback()
            }
            set(e, t, n, r) {
                return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._w)
            }
            copy(e) {
                return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
            }
            setFromEuler(e) {
                let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                const n = e._x,
                    r = e._y,
                    i = e._z,
                    o = e._order,
                    a = Math.cos,
                    s = Math.sin,
                    l = a(n / 2),
                    c = a(r / 2),
                    u = a(i / 2),
                    d = s(n / 2),
                    h = s(r / 2),
                    p = s(i / 2);
                switch (o) {
                    case "XYZ":
                        this._x = d * c * u + l * h * p, this._y = l * h * u - d * c * p, this._z = l * c * p + d * h * u, this._w = l * c * u - d * h * p;
                        break;
                    case "YXZ":
                        this._x = d * c * u + l * h * p, this._y = l * h * u - d * c * p, this._z = l * c * p - d * h * u, this._w = l * c * u + d * h * p;
                        break;
                    case "ZXY":
                        this._x = d * c * u - l * h * p, this._y = l * h * u + d * c * p, this._z = l * c * p + d * h * u, this._w = l * c * u - d * h * p;
                        break;
                    case "ZYX":
                        this._x = d * c * u - l * h * p, this._y = l * h * u + d * c * p, this._z = l * c * p - d * h * u, this._w = l * c * u + d * h * p;
                        break;
                    case "YZX":
                        this._x = d * c * u + l * h * p, this._y = l * h * u + d * c * p, this._z = l * c * p - d * h * u, this._w = l * c * u - d * h * p;
                        break;
                    case "XZY":
                        this._x = d * c * u - l * h * p, this._y = l * h * u - d * c * p, this._z = l * c * p + d * h * u, this._w = l * c * u + d * h * p;
                        break;
                    default:
                        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
                }
                return !0 === t && this._onChangeCallback(), this
            }
            setFromAxisAngle(e, t) {
                const n = t / 2,
                    r = Math.sin(n);
                return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this._onChangeCallback(), this
            }
            setFromRotationMatrix(e) {
                const t = e.elements,
                    n = t[0],
                    r = t[4],
                    i = t[8],
                    o = t[1],
                    a = t[5],
                    s = t[9],
                    l = t[2],
                    c = t[6],
                    u = t[10],
                    d = n + a + u;
                if (d > 0) {
                    const e = .5 / Math.sqrt(d + 1);
                    this._w = .25 / e, this._x = (c - s) * e, this._y = (i - l) * e, this._z = (o - r) * e
                } else if (n > a && n > u) {
                    const e = 2 * Math.sqrt(1 + n - a - u);
                    this._w = (c - s) / e, this._x = .25 * e, this._y = (r + o) / e, this._z = (i + l) / e
                } else if (a > u) {
                    const e = 2 * Math.sqrt(1 + a - n - u);
                    this._w = (i - l) / e, this._x = (r + o) / e, this._y = .25 * e, this._z = (s + c) / e
                } else {
                    const e = 2 * Math.sqrt(1 + u - n - a);
                    this._w = (o - r) / e, this._x = (i + l) / e, this._y = (s + c) / e, this._z = .25 * e
                }
                return this._onChangeCallback(), this
            }
            setFromUnitVectors(e, t) {
                let n = e.dot(t) + 1;
                return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize()
            }
            angleTo(e) {
                return 2 * Math.acos(Math.abs(jc(this.dot(e), -1, 1)))
            }
            rotateTowards(e, t) {
                const n = this.angleTo(e);
                if (0 === n) return this;
                const r = Math.min(1, t / n);
                return this.slerp(e, r), this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
            }
            dot(e) {
                return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let e = this.length();
                return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
            }
            multiply(e) {
                return this.multiplyQuaternions(this, e)
            }
            premultiply(e) {
                return this.multiplyQuaternions(e, this)
            }
            multiplyQuaternions(e, t) {
                const n = e._x,
                    r = e._y,
                    i = e._z,
                    o = e._w,
                    a = t._x,
                    s = t._y,
                    l = t._z,
                    c = t._w;
                return this._x = n * c + o * a + r * l - i * s, this._y = r * c + o * s + i * a - n * l, this._z = i * c + o * l + n * s - r * a, this._w = o * c - n * a - r * s - i * l, this._onChangeCallback(), this
            }
            slerp(e, t) {
                if (0 === t) return this;
                if (1 === t) return this.copy(e);
                const n = this._x,
                    r = this._y,
                    i = this._z,
                    o = this._w;
                let a = o * e._w + n * e._x + r * e._y + i * e._z;
                if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = n, this._y = r, this._z = i, this;
                const s = 1 - a * a;
                if (s <= Number.EPSILON) {
                    const e = 1 - t;
                    return this._w = e * o + t * this._w, this._x = e * n + t * this._x, this._y = e * r + t * this._y, this._z = e * i + t * this._z, this.normalize(), this
                }
                const l = Math.sqrt(s),
                    c = Math.atan2(l, a),
                    u = Math.sin((1 - t) * c) / l,
                    d = Math.sin(t * c) / l;
                return this._w = o * u + this._w * d, this._x = n * u + this._x * d, this._y = r * u + this._y * d, this._z = i * u + this._z * d, this._onChangeCallback(), this
            }
            slerpQuaternions(e, t, n) {
                return this.copy(e).slerp(t, n)
            }
            random() {
                const e = Math.random(),
                    t = Math.sqrt(1 - e),
                    n = Math.sqrt(e),
                    r = 2 * Math.PI * Math.random(),
                    i = 2 * Math.PI * Math.random();
                return this.set(t * Math.cos(r), n * Math.sin(i), n * Math.cos(i), t * Math.sin(r))
            }
            equals(e) {
                return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
            }
            fromArray(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
            }
            toArray() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
            }
            fromBufferAttribute(e, t) {
                return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this
            }
            toJSON() {
                return this.toArray()
            }
            _onChange(e) {
                return this._onChangeCallback = e, this
            }
            _onChangeCallback() {}*[Symbol.iterator]() {
                yield this._x, yield this._y, yield this._z, yield this._w
            }
        }
        class Pu {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                Pu.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n
            }
            set(e, t, n) {
                return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this
            }
            setScalar(e) {
                return this.x = e, this.y = e, this.z = e, this
            }
            setX(e) {
                return this.x = e, this
            }
            setY(e) {
                return this.y = e, this
            }
            setZ(e) {
                return this.z = e, this
            }
            setComponent(e, t) {
                switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    case 2:
                        this.z = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z)
            }
            copy(e) {
                return this.x = e.x, this.y = e.y, this.z = e.z, this
            }
            add(e) {
                return this.x += e.x, this.y += e.y, this.z += e.z, this
            }
            addScalar(e) {
                return this.x += e, this.y += e, this.z += e, this
            }
            addVectors(e, t) {
                return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
            }
            addScaledVector(e, t) {
                return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
            }
            sub(e) {
                return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
            }
            subScalar(e) {
                return this.x -= e, this.y -= e, this.z -= e, this
            }
            subVectors(e, t) {
                return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
            }
            multiply(e) {
                return this.x *= e.x, this.y *= e.y, this.z *= e.z, this
            }
            multiplyScalar(e) {
                return this.x *= e, this.y *= e, this.z *= e, this
            }
            multiplyVectors(e, t) {
                return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
            }
            applyEuler(e) {
                return this.applyQuaternion(Iu.setFromEuler(e))
            }
            applyAxisAngle(e, t) {
                return this.applyQuaternion(Iu.setFromAxisAngle(e, t))
            }
            applyMatrix3(e) {
                const t = this.x,
                    n = this.y,
                    r = this.z,
                    i = e.elements;
                return this.x = i[0] * t + i[3] * n + i[6] * r, this.y = i[1] * t + i[4] * n + i[7] * r, this.z = i[2] * t + i[5] * n + i[8] * r, this
            }
            applyNormalMatrix(e) {
                return this.applyMatrix3(e).normalize()
            }
            applyMatrix4(e) {
                const t = this.x,
                    n = this.y,
                    r = this.z,
                    i = e.elements,
                    o = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]);
                return this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * o, this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * o, this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * o, this
            }
            applyQuaternion(e) {
                const t = this.x,
                    n = this.y,
                    r = this.z,
                    i = e.x,
                    o = e.y,
                    a = e.z,
                    s = e.w,
                    l = 2 * (o * r - a * n),
                    c = 2 * (a * t - i * r),
                    u = 2 * (i * n - o * t);
                return this.x = t + s * l + o * u - a * c, this.y = n + s * c + a * l - i * u, this.z = r + s * u + i * c - o * l, this
            }
            project(e) {
                return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
            }
            unproject(e) {
                return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
            }
            transformDirection(e) {
                const t = this.x,
                    n = this.y,
                    r = this.z,
                    i = e.elements;
                return this.x = i[0] * t + i[4] * n + i[8] * r, this.y = i[1] * t + i[5] * n + i[9] * r, this.z = i[2] * t + i[6] * n + i[10] * r, this.normalize()
            }
            divide(e) {
                return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            min(e) {
                return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
            }
            clamp(e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
            }
            clampScalar(e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
            }
            clampLength(e, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y + this.z * e.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, t) {
                return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
            }
            lerpVectors(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
            }
            cross(e) {
                return this.crossVectors(this, e)
            }
            crossVectors(e, t) {
                const n = e.x,
                    r = e.y,
                    i = e.z,
                    o = t.x,
                    a = t.y,
                    s = t.z;
                return this.x = r * s - i * a, this.y = i * o - n * s, this.z = n * a - r * o, this
            }
            projectOnVector(e) {
                const t = e.lengthSq();
                if (0 === t) return this.set(0, 0, 0);
                const n = e.dot(this) / t;
                return this.copy(e).multiplyScalar(n)
            }
            projectOnPlane(e) {
                return Ru.copy(this).projectOnVector(e), this.sub(Ru)
            }
            reflect(e) {
                return this.sub(Ru.copy(e).multiplyScalar(2 * this.dot(e)))
            }
            angleTo(e) {
                const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                if (0 === t) return Math.PI / 2;
                const n = this.dot(e) / t;
                return Math.acos(jc(n, -1, 1))
            }
            distanceTo(e) {
                return Math.sqrt(this.distanceToSquared(e))
            }
            distanceToSquared(e) {
                const t = this.x - e.x,
                    n = this.y - e.y,
                    r = this.z - e.z;
                return t * t + n * n + r * r
            }
            manhattanDistanceTo(e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
            }
            setFromSpherical(e) {
                return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
            }
            setFromSphericalCoords(e, t, n) {
                const r = Math.sin(t) * e;
                return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this
            }
            setFromCylindrical(e) {
                return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
            }
            setFromCylindricalCoords(e, t, n) {
                return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
            }
            setFromMatrixPosition(e) {
                const t = e.elements;
                return this.x = t[12], this.y = t[13], this.z = t[14], this
            }
            setFromMatrixScale(e) {
                const t = this.setFromMatrixColumn(e, 0).length(),
                    n = this.setFromMatrixColumn(e, 1).length(),
                    r = this.setFromMatrixColumn(e, 2).length();
                return this.x = t, this.y = n, this.z = r, this
            }
            setFromMatrixColumn(e, t) {
                return this.fromArray(e.elements, 4 * t)
            }
            setFromMatrix3Column(e, t) {
                return this.fromArray(e.elements, 3 * t)
            }
            setFromEuler(e) {
                return this.x = e._x, this.y = e._y, this.z = e._z, this
            }
            setFromColor(e) {
                return this.x = e.r, this.y = e.g, this.z = e.b, this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y && e.z === this.z
            }
            fromArray(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
            }
            toArray() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
            }
            fromBufferAttribute(e, t) {
                return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
            }
            randomDirection() {
                const e = 2 * (Math.random() - .5),
                    t = Math.random() * Math.PI * 2,
                    n = Math.sqrt(1 - e ** 2);
                return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this
            }*[Symbol.iterator]() {
                yield this.x, yield this.y, yield this.z
            }
        }
        const Ru = new Pu,
            Iu = new Tu;
        class Ou {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Pu(1 / 0, 1 / 0, 1 / 0),
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Pu(-1 / 0, -1 / 0, -1 / 0);
                this.isBox3 = !0, this.min = e, this.max = t
            }
            set(e, t) {
                return this.min.copy(e), this.max.copy(t), this
            }
            setFromArray(e) {
                this.makeEmpty();
                for (let t = 0, n = e.length; t < n; t += 3) this.expandByPoint(Lu.fromArray(e, t));
                return this
            }
            setFromBufferAttribute(e) {
                this.makeEmpty();
                for (let t = 0, n = e.count; t < n; t++) this.expandByPoint(Lu.fromBufferAttribute(e, t));
                return this
            }
            setFromPoints(e) {
                this.makeEmpty();
                for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                return this
            }
            setFromCenterAndSize(e, t) {
                const n = Lu.copy(t).multiplyScalar(.5);
                return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
            }
            setFromObject(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                return this.makeEmpty(), this.expandByObject(e, t)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.min.copy(e.min), this.max.copy(e.max), this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(e) {
                return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(e) {
                return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
            }
            expandByPoint(e) {
                return this.min.min(e), this.max.max(e), this
            }
            expandByVector(e) {
                return this.min.sub(e), this.max.add(e), this
            }
            expandByScalar(e) {
                return this.min.addScalar(-e), this.max.addScalar(e), this
            }
            expandByObject(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                e.updateWorldMatrix(!1, !1);
                const n = e.geometry;
                if (void 0 !== n) {
                    const r = n.getAttribute("position");
                    if (!0 === t && void 0 !== r && !0 !== e.isInstancedMesh)
                        for (let t = 0, n = r.count; t < n; t++) !0 === e.isMesh ? e.getVertexPosition(t, Lu) : Lu.fromBufferAttribute(r, t), Lu.applyMatrix4(e.matrixWorld), this.expandByPoint(Lu);
                    else void 0 !== e.boundingBox ? (null === e.boundingBox && e.computeBoundingBox(), Du.copy(e.boundingBox)) : (null === n.boundingBox && n.computeBoundingBox(), Du.copy(n.boundingBox)), Du.applyMatrix4(e.matrixWorld), this.union(Du)
                }
                const r = e.children;
                for (let i = 0, o = r.length; i < o; i++) this.expandByObject(r[i], t);
                return this
            }
            containsPoint(e) {
                return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
            }
            containsBox(e) {
                return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
            }
            getParameter(e, t) {
                return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(e) {
                return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
            }
            intersectsSphere(e) {
                return this.clampPoint(e.center, Lu), Lu.distanceToSquared(e.center) <= e.radius * e.radius
            }
            intersectsPlane(e) {
                let t, n;
                return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
            }
            intersectsTriangle(e) {
                if (this.isEmpty()) return !1;
                this.getCenter(ju), Gu.subVectors(this.max, ju), Nu.subVectors(e.a, ju), ku.subVectors(e.b, ju), Fu.subVectors(e.c, ju), Uu.subVectors(ku, Nu), zu.subVectors(Fu, ku), Hu.subVectors(Nu, Fu);
                let t = [0, -Uu.z, Uu.y, 0, -zu.z, zu.y, 0, -Hu.z, Hu.y, Uu.z, 0, -Uu.x, zu.z, 0, -zu.x, Hu.z, 0, -Hu.x, -Uu.y, Uu.x, 0, -zu.y, zu.x, 0, -Hu.y, Hu.x, 0];
                return !!Wu(t, Nu, ku, Fu, Gu) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Wu(t, Nu, ku, Fu, Gu) && (Vu.crossVectors(Uu, zu), t = [Vu.x, Vu.y, Vu.z], Wu(t, Nu, ku, Fu, Gu)))
            }
            clampPoint(e, t) {
                return t.copy(e).clamp(this.min, this.max)
            }
            distanceToPoint(e) {
                return this.clampPoint(e, Lu).distanceTo(e)
            }
            getBoundingSphere(e) {
                return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = .5 * this.getSize(Lu).length()), e
            }
            intersect(e) {
                return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
            }
            union(e) {
                return this.min.min(e.min), this.max.max(e.max), this
            }
            applyMatrix4(e) {
                return this.isEmpty() || (Bu[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Bu[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Bu[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Bu[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Bu[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Bu[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Bu[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Bu[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Bu)), this
            }
            translate(e) {
                return this.min.add(e), this.max.add(e), this
            }
            equals(e) {
                return e.min.equals(this.min) && e.max.equals(this.max)
            }
        }
        const Bu = [new Pu, new Pu, new Pu, new Pu, new Pu, new Pu, new Pu, new Pu],
            Lu = new Pu,
            Du = new Ou,
            Nu = new Pu,
            ku = new Pu,
            Fu = new Pu,
            Uu = new Pu,
            zu = new Pu,
            Hu = new Pu,
            ju = new Pu,
            Gu = new Pu,
            Vu = new Pu,
            qu = new Pu;

        function Wu(e, t, n, r, i) {
            for (let o = 0, a = e.length - 3; o <= a; o += 3) {
                qu.fromArray(e, o);
                const a = i.x * Math.abs(qu.x) + i.y * Math.abs(qu.y) + i.z * Math.abs(qu.z),
                    s = t.dot(qu),
                    l = n.dot(qu),
                    c = r.dot(qu);
                if (Math.max(-Math.max(s, l, c), Math.min(s, l, c)) > a) return !1
            }
            return !0
        }
        const Xu = new Ou,
            Ku = new Pu,
            Ju = new Pu;
        class Yu {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Pu,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1;
                this.isSphere = !0, this.center = e, this.radius = t
            }
            set(e, t) {
                return this.center.copy(e), this.radius = t, this
            }
            setFromPoints(e, t) {
                const n = this.center;
                void 0 !== t ? n.copy(t) : Xu.setFromPoints(e).getCenter(n);
                let r = 0;
                for (let i = 0, o = e.length; i < o; i++) r = Math.max(r, n.distanceToSquared(e[i]));
                return this.radius = Math.sqrt(r), this
            }
            copy(e) {
                return this.center.copy(e.center), this.radius = e.radius, this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0), this.radius = -1, this
            }
            containsPoint(e) {
                return e.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(e) {
                return e.distanceTo(this.center) - this.radius
            }
            intersectsSphere(e) {
                const t = this.radius + e.radius;
                return e.center.distanceToSquared(this.center) <= t * t
            }
            intersectsBox(e) {
                return e.intersectsSphere(this)
            }
            intersectsPlane(e) {
                return Math.abs(e.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(e, t) {
                const n = this.center.distanceToSquared(e);
                return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
            }
            getBoundingBox(e) {
                return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
            }
            applyMatrix4(e) {
                return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
            }
            translate(e) {
                return this.center.add(e), this
            }
            expandByPoint(e) {
                if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
                Ku.subVectors(e, this.center);
                const t = Ku.lengthSq();
                if (t > this.radius * this.radius) {
                    const e = Math.sqrt(t),
                        n = .5 * (e - this.radius);
                    this.center.addScaledVector(Ku, n / e), this.radius += n
                }
                return this
            }
            union(e) {
                return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (!0 === this.center.equals(e.center) ? this.radius = Math.max(this.radius, e.radius) : (Ju.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Ku.copy(e.center).add(Ju)), this.expandByPoint(Ku.copy(e.center).sub(Ju))), this)
            }
            equals(e) {
                return e.center.equals(this.center) && e.radius === this.radius
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const Qu = new Pu,
            Zu = new Pu,
            $u = new Pu,
            ed = new Pu,
            td = new Pu,
            nd = new Pu,
            rd = new Pu;
        class id {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Pu,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Pu(0, 0, -1);
                this.origin = e, this.direction = t
            }
            set(e, t) {
                return this.origin.copy(e), this.direction.copy(t), this
            }
            copy(e) {
                return this.origin.copy(e.origin), this.direction.copy(e.direction), this
            }
            at(e, t) {
                return t.copy(this.origin).addScaledVector(this.direction, e)
            }
            lookAt(e) {
                return this.direction.copy(e).sub(this.origin).normalize(), this
            }
            recast(e) {
                return this.origin.copy(this.at(e, Qu)), this
            }
            closestPointToPoint(e, t) {
                t.subVectors(e, this.origin);
                const n = t.dot(this.direction);
                return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
            }
            distanceToPoint(e) {
                return Math.sqrt(this.distanceSqToPoint(e))
            }
            distanceSqToPoint(e) {
                const t = Qu.subVectors(e, this.origin).dot(this.direction);
                return t < 0 ? this.origin.distanceToSquared(e) : (Qu.copy(this.origin).addScaledVector(this.direction, t), Qu.distanceToSquared(e))
            }
            distanceSqToSegment(e, t, n, r) {
                Zu.copy(e).add(t).multiplyScalar(.5), $u.copy(t).sub(e).normalize(), ed.copy(this.origin).sub(Zu);
                const i = .5 * e.distanceTo(t),
                    o = -this.direction.dot($u),
                    a = ed.dot(this.direction),
                    s = -ed.dot($u),
                    l = ed.lengthSq(),
                    c = Math.abs(1 - o * o);
                let u, d, h, p;
                if (c > 0)
                    if (u = o * s - a, d = o * a - s, p = i * c, u >= 0)
                        if (d >= -p)
                            if (d <= p) {
                                const e = 1 / c;
                                u *= e, d *= e, h = u * (u + o * d + 2 * a) + d * (o * u + d + 2 * s) + l
                            } else d = i, u = Math.max(0, -(o * d + a)), h = -u * u + d * (d + 2 * s) + l;
                else d = -i, u = Math.max(0, -(o * d + a)), h = -u * u + d * (d + 2 * s) + l;
                else d <= -p ? (u = Math.max(0, -(-o * i + a)), d = u > 0 ? -i : Math.min(Math.max(-i, -s), i), h = -u * u + d * (d + 2 * s) + l) : d <= p ? (u = 0, d = Math.min(Math.max(-i, -s), i), h = d * (d + 2 * s) + l) : (u = Math.max(0, -(o * i + a)), d = u > 0 ? i : Math.min(Math.max(-i, -s), i), h = -u * u + d * (d + 2 * s) + l);
                else d = o > 0 ? -i : i, u = Math.max(0, -(o * d + a)), h = -u * u + d * (d + 2 * s) + l;
                return n && n.copy(this.origin).addScaledVector(this.direction, u), r && r.copy(Zu).addScaledVector($u, d), h
            }
            intersectSphere(e, t) {
                Qu.subVectors(e.center, this.origin);
                const n = Qu.dot(this.direction),
                    r = Qu.dot(Qu) - n * n,
                    i = e.radius * e.radius;
                if (r > i) return null;
                const o = Math.sqrt(i - r),
                    a = n - o,
                    s = n + o;
                return s < 0 ? null : a < 0 ? this.at(s, t) : this.at(a, t)
            }
            intersectsSphere(e) {
                return this.distanceSqToPoint(e.center) <= e.radius * e.radius
            }
            distanceToPlane(e) {
                const t = e.normal.dot(this.direction);
                if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                const n = -(this.origin.dot(e.normal) + e.constant) / t;
                return n >= 0 ? n : null
            }
            intersectPlane(e, t) {
                const n = this.distanceToPlane(e);
                return null === n ? null : this.at(n, t)
            }
            intersectsPlane(e) {
                const t = e.distanceToPoint(this.origin);
                if (0 === t) return !0;
                return e.normal.dot(this.direction) * t < 0
            }
            intersectBox(e, t) {
                let n, r, i, o, a, s;
                const l = 1 / this.direction.x,
                    c = 1 / this.direction.y,
                    u = 1 / this.direction.z,
                    d = this.origin;
                return l >= 0 ? (n = (e.min.x - d.x) * l, r = (e.max.x - d.x) * l) : (n = (e.max.x - d.x) * l, r = (e.min.x - d.x) * l), c >= 0 ? (i = (e.min.y - d.y) * c, o = (e.max.y - d.y) * c) : (i = (e.max.y - d.y) * c, o = (e.min.y - d.y) * c), n > o || i > r ? null : ((i > n || isNaN(n)) && (n = i), (o < r || isNaN(r)) && (r = o), u >= 0 ? (a = (e.min.z - d.z) * u, s = (e.max.z - d.z) * u) : (a = (e.max.z - d.z) * u, s = (e.min.z - d.z) * u), n > s || a > r ? null : ((a > n || n !== n) && (n = a), (s < r || r !== r) && (r = s), r < 0 ? null : this.at(n >= 0 ? n : r, t)))
            }
            intersectsBox(e) {
                return null !== this.intersectBox(e, Qu)
            }
            intersectTriangle(e, t, n, r, i) {
                td.subVectors(t, e), nd.subVectors(n, e), rd.crossVectors(td, nd);
                let o, a = this.direction.dot(rd);
                if (a > 0) {
                    if (r) return null;
                    o = 1
                } else {
                    if (!(a < 0)) return null;
                    o = -1, a = -a
                }
                ed.subVectors(this.origin, e);
                const s = o * this.direction.dot(nd.crossVectors(ed, nd));
                if (s < 0) return null;
                const l = o * this.direction.dot(td.cross(ed));
                if (l < 0) return null;
                if (s + l > a) return null;
                const c = -o * ed.dot(rd);
                return c < 0 ? null : this.at(c / a, i)
            }
            applyMatrix4(e) {
                return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
            }
            equals(e) {
                return e.origin.equals(this.origin) && e.direction.equals(this.direction)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class od {
            constructor(e, t, n, r, i, o, a, s, l, c, u, d, h, p, f, m) {
                od.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], void 0 !== e && this.set(e, t, n, r, i, o, a, s, l, c, u, d, h, p, f, m)
            }
            set(e, t, n, r, i, o, a, s, l, c, u, d, h, p, f, m) {
                const g = this.elements;
                return g[0] = e, g[4] = t, g[8] = n, g[12] = r, g[1] = i, g[5] = o, g[9] = a, g[13] = s, g[2] = l, g[6] = c, g[10] = u, g[14] = d, g[3] = h, g[7] = p, g[11] = f, g[15] = m, this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }
            clone() {
                return (new od).fromArray(this.elements)
            }
            copy(e) {
                const t = this.elements,
                    n = e.elements;
                return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
            }
            copyPosition(e) {
                const t = this.elements,
                    n = e.elements;
                return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
            }
            setFromMatrix3(e) {
                const t = e.elements;
                return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
            }
            extractBasis(e, t, n) {
                return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
            }
            makeBasis(e, t, n) {
                return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
            }
            extractRotation(e) {
                const t = this.elements,
                    n = e.elements,
                    r = 1 / ad.setFromMatrixColumn(e, 0).length(),
                    i = 1 / ad.setFromMatrixColumn(e, 1).length(),
                    o = 1 / ad.setFromMatrixColumn(e, 2).length();
                return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * i, t[5] = n[5] * i, t[6] = n[6] * i, t[7] = 0, t[8] = n[8] * o, t[9] = n[9] * o, t[10] = n[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
            }
            makeRotationFromEuler(e) {
                const t = this.elements,
                    n = e.x,
                    r = e.y,
                    i = e.z,
                    o = Math.cos(n),
                    a = Math.sin(n),
                    s = Math.cos(r),
                    l = Math.sin(r),
                    c = Math.cos(i),
                    u = Math.sin(i);
                if ("XYZ" === e.order) {
                    const e = o * c,
                        n = o * u,
                        r = a * c,
                        i = a * u;
                    t[0] = s * c, t[4] = -s * u, t[8] = l, t[1] = n + r * l, t[5] = e - i * l, t[9] = -a * s, t[2] = i - e * l, t[6] = r + n * l, t[10] = o * s
                } else if ("YXZ" === e.order) {
                    const e = s * c,
                        n = s * u,
                        r = l * c,
                        i = l * u;
                    t[0] = e + i * a, t[4] = r * a - n, t[8] = o * l, t[1] = o * u, t[5] = o * c, t[9] = -a, t[2] = n * a - r, t[6] = i + e * a, t[10] = o * s
                } else if ("ZXY" === e.order) {
                    const e = s * c,
                        n = s * u,
                        r = l * c,
                        i = l * u;
                    t[0] = e - i * a, t[4] = -o * u, t[8] = r + n * a, t[1] = n + r * a, t[5] = o * c, t[9] = i - e * a, t[2] = -o * l, t[6] = a, t[10] = o * s
                } else if ("ZYX" === e.order) {
                    const e = o * c,
                        n = o * u,
                        r = a * c,
                        i = a * u;
                    t[0] = s * c, t[4] = r * l - n, t[8] = e * l + i, t[1] = s * u, t[5] = i * l + e, t[9] = n * l - r, t[2] = -l, t[6] = a * s, t[10] = o * s
                } else if ("YZX" === e.order) {
                    const e = o * s,
                        n = o * l,
                        r = a * s,
                        i = a * l;
                    t[0] = s * c, t[4] = i - e * u, t[8] = r * u + n, t[1] = u, t[5] = o * c, t[9] = -a * c, t[2] = -l * c, t[6] = n * u + r, t[10] = e - i * u
                } else if ("XZY" === e.order) {
                    const e = o * s,
                        n = o * l,
                        r = a * s,
                        i = a * l;
                    t[0] = s * c, t[4] = -u, t[8] = l * c, t[1] = e * u + i, t[5] = o * c, t[9] = n * u - r, t[2] = r * u - n, t[6] = a * c, t[10] = i * u + e
                }
                return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
            }
            makeRotationFromQuaternion(e) {
                return this.compose(ld, e, cd)
            }
            lookAt(e, t, n) {
                const r = this.elements;
                return hd.subVectors(e, t), 0 === hd.lengthSq() && (hd.z = 1), hd.normalize(), ud.crossVectors(n, hd), 0 === ud.lengthSq() && (1 === Math.abs(n.z) ? hd.x += 1e-4 : hd.z += 1e-4, hd.normalize(), ud.crossVectors(n, hd)), ud.normalize(), dd.crossVectors(hd, ud), r[0] = ud.x, r[4] = dd.x, r[8] = hd.x, r[1] = ud.y, r[5] = dd.y, r[9] = hd.y, r[2] = ud.z, r[6] = dd.z, r[10] = hd.z, this
            }
            multiply(e) {
                return this.multiplyMatrices(this, e)
            }
            premultiply(e) {
                return this.multiplyMatrices(e, this)
            }
            multiplyMatrices(e, t) {
                const n = e.elements,
                    r = t.elements,
                    i = this.elements,
                    o = n[0],
                    a = n[4],
                    s = n[8],
                    l = n[12],
                    c = n[1],
                    u = n[5],
                    d = n[9],
                    h = n[13],
                    p = n[2],
                    f = n[6],
                    m = n[10],
                    g = n[14],
                    v = n[3],
                    y = n[7],
                    b = n[11],
                    x = n[15],
                    _ = r[0],
                    M = r[4],
                    w = r[8],
                    A = r[12],
                    S = r[1],
                    E = r[5],
                    C = r[9],
                    T = r[13],
                    P = r[2],
                    R = r[6],
                    I = r[10],
                    O = r[14],
                    B = r[3],
                    L = r[7],
                    D = r[11],
                    N = r[15];
                return i[0] = o * _ + a * S + s * P + l * B, i[4] = o * M + a * E + s * R + l * L, i[8] = o * w + a * C + s * I + l * D, i[12] = o * A + a * T + s * O + l * N, i[1] = c * _ + u * S + d * P + h * B, i[5] = c * M + u * E + d * R + h * L, i[9] = c * w + u * C + d * I + h * D, i[13] = c * A + u * T + d * O + h * N, i[2] = p * _ + f * S + m * P + g * B, i[6] = p * M + f * E + m * R + g * L, i[10] = p * w + f * C + m * I + g * D, i[14] = p * A + f * T + m * O + g * N, i[3] = v * _ + y * S + b * P + x * B, i[7] = v * M + y * E + b * R + x * L, i[11] = v * w + y * C + b * I + x * D, i[15] = v * A + y * T + b * O + x * N, this
            }
            multiplyScalar(e) {
                const t = this.elements;
                return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
            }
            determinant() {
                const e = this.elements,
                    t = e[0],
                    n = e[4],
                    r = e[8],
                    i = e[12],
                    o = e[1],
                    a = e[5],
                    s = e[9],
                    l = e[13],
                    c = e[2],
                    u = e[6],
                    d = e[10],
                    h = e[14];
                return e[3] * (+i * s * u - r * l * u - i * a * d + n * l * d + r * a * h - n * s * h) + e[7] * (+t * s * h - t * l * d + i * o * d - r * o * h + r * l * c - i * s * c) + e[11] * (+t * l * u - t * a * h - i * o * u + n * o * h + i * a * c - n * l * c) + e[15] * (-r * a * c - t * s * u + t * a * d + r * o * u - n * o * d + n * s * c)
            }
            transpose() {
                const e = this.elements;
                let t;
                return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
            }
            setPosition(e, t, n) {
                const r = this.elements;
                return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = n), this
            }
            invert() {
                const e = this.elements,
                    t = e[0],
                    n = e[1],
                    r = e[2],
                    i = e[3],
                    o = e[4],
                    a = e[5],
                    s = e[6],
                    l = e[7],
                    c = e[8],
                    u = e[9],
                    d = e[10],
                    h = e[11],
                    p = e[12],
                    f = e[13],
                    m = e[14],
                    g = e[15],
                    v = u * m * l - f * d * l + f * s * h - a * m * h - u * s * g + a * d * g,
                    y = p * d * l - c * m * l - p * s * h + o * m * h + c * s * g - o * d * g,
                    b = c * f * l - p * u * l + p * a * h - o * f * h - c * a * g + o * u * g,
                    x = p * u * s - c * f * s - p * a * d + o * f * d + c * a * m - o * u * m,
                    _ = t * v + n * y + r * b + i * x;
                if (0 === _) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const M = 1 / _;
                return e[0] = v * M, e[1] = (f * d * i - u * m * i - f * r * h + n * m * h + u * r * g - n * d * g) * M, e[2] = (a * m * i - f * s * i + f * r * l - n * m * l - a * r * g + n * s * g) * M, e[3] = (u * s * i - a * d * i - u * r * l + n * d * l + a * r * h - n * s * h) * M, e[4] = y * M, e[5] = (c * m * i - p * d * i + p * r * h - t * m * h - c * r * g + t * d * g) * M, e[6] = (p * s * i - o * m * i - p * r * l + t * m * l + o * r * g - t * s * g) * M, e[7] = (o * d * i - c * s * i + c * r * l - t * d * l - o * r * h + t * s * h) * M, e[8] = b * M, e[9] = (p * u * i - c * f * i - p * n * h + t * f * h + c * n * g - t * u * g) * M, e[10] = (o * f * i - p * a * i + p * n * l - t * f * l - o * n * g + t * a * g) * M, e[11] = (c * a * i - o * u * i - c * n * l + t * u * l + o * n * h - t * a * h) * M, e[12] = x * M, e[13] = (c * f * r - p * u * r + p * n * d - t * f * d - c * n * m + t * u * m) * M, e[14] = (p * a * r - o * f * r - p * n * s + t * f * s + o * n * m - t * a * m) * M, e[15] = (o * u * r - c * a * r + c * n * s - t * u * s - o * n * d + t * a * d) * M, this
            }
            scale(e) {
                const t = this.elements,
                    n = e.x,
                    r = e.y,
                    i = e.z;
                return t[0] *= n, t[4] *= r, t[8] *= i, t[1] *= n, t[5] *= r, t[9] *= i, t[2] *= n, t[6] *= r, t[10] *= i, t[3] *= n, t[7] *= r, t[11] *= i, this
            }
            getMaxScaleOnAxis() {
                const e = this.elements,
                    t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                    n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                    r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                return Math.sqrt(Math.max(t, n, r))
            }
            makeTranslation(e, t, n) {
                return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
            }
            makeRotationX(e) {
                const t = Math.cos(e),
                    n = Math.sin(e);
                return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
            }
            makeRotationY(e) {
                const t = Math.cos(e),
                    n = Math.sin(e);
                return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
            }
            makeRotationZ(e) {
                const t = Math.cos(e),
                    n = Math.sin(e);
                return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }
            makeRotationAxis(e, t) {
                const n = Math.cos(t),
                    r = Math.sin(t),
                    i = 1 - n,
                    o = e.x,
                    a = e.y,
                    s = e.z,
                    l = i * o,
                    c = i * a;
                return this.set(l * o + n, l * a - r * s, l * s + r * a, 0, l * a + r * s, c * a + n, c * s - r * o, 0, l * s - r * a, c * s + r * o, i * s * s + n, 0, 0, 0, 0, 1), this
            }
            makeScale(e, t, n) {
                return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
            }
            makeShear(e, t, n, r, i, o) {
                return this.set(1, n, i, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this
            }
            compose(e, t, n) {
                const r = this.elements,
                    i = t._x,
                    o = t._y,
                    a = t._z,
                    s = t._w,
                    l = i + i,
                    c = o + o,
                    u = a + a,
                    d = i * l,
                    h = i * c,
                    p = i * u,
                    f = o * c,
                    m = o * u,
                    g = a * u,
                    v = s * l,
                    y = s * c,
                    b = s * u,
                    x = n.x,
                    _ = n.y,
                    M = n.z;
                return r[0] = (1 - (f + g)) * x, r[1] = (h + b) * x, r[2] = (p - y) * x, r[3] = 0, r[4] = (h - b) * _, r[5] = (1 - (d + g)) * _, r[6] = (m + v) * _, r[7] = 0, r[8] = (p + y) * M, r[9] = (m - v) * M, r[10] = (1 - (d + f)) * M, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this
            }
            decompose(e, t, n) {
                const r = this.elements;
                let i = ad.set(r[0], r[1], r[2]).length();
                const o = ad.set(r[4], r[5], r[6]).length(),
                    a = ad.set(r[8], r[9], r[10]).length();
                this.determinant() < 0 && (i = -i), e.x = r[12], e.y = r[13], e.z = r[14], sd.copy(this);
                const s = 1 / i,
                    l = 1 / o,
                    c = 1 / a;
                return sd.elements[0] *= s, sd.elements[1] *= s, sd.elements[2] *= s, sd.elements[4] *= l, sd.elements[5] *= l, sd.elements[6] *= l, sd.elements[8] *= c, sd.elements[9] *= c, sd.elements[10] *= c, t.setFromRotationMatrix(sd), n.x = i, n.y = o, n.z = a, this
            }
            makePerspective(e, t, n, r, i, o) {
                let a = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : Lc;
                const s = this.elements,
                    l = 2 * i / (t - e),
                    c = 2 * i / (n - r),
                    u = (t + e) / (t - e),
                    d = (n + r) / (n - r);
                let h, p;
                if (a === Lc) h = -(o + i) / (o - i), p = -2 * o * i / (o - i);
                else {
                    if (a !== Dc) throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
                    h = -o / (o - i), p = -o * i / (o - i)
                }
                return s[0] = l, s[4] = 0, s[8] = u, s[12] = 0, s[1] = 0, s[5] = c, s[9] = d, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = h, s[14] = p, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this
            }
            makeOrthographic(e, t, n, r, i, o) {
                let a = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : Lc;
                const s = this.elements,
                    l = 1 / (t - e),
                    c = 1 / (n - r),
                    u = 1 / (o - i),
                    d = (t + e) * l,
                    h = (n + r) * c;
                let p, f;
                if (a === Lc) p = (o + i) * u, f = -2 * u;
                else {
                    if (a !== Dc) throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
                    p = i * u, f = -1 * u
                }
                return s[0] = 2 * l, s[4] = 0, s[8] = 0, s[12] = -d, s[1] = 0, s[5] = 2 * c, s[9] = 0, s[13] = -h, s[2] = 0, s[6] = 0, s[10] = f, s[14] = -p, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this
            }
            equals(e) {
                const t = this.elements,
                    n = e.elements;
                for (let r = 0; r < 16; r++)
                    if (t[r] !== n[r]) return !1;
                return !0
            }
            fromArray(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
                return this
            }
            toArray() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                const n = this.elements;
                return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
            }
        }
        const ad = new Pu,
            sd = new od,
            ld = new Pu(0, 0, 0),
            cd = new Pu(1, 1, 1),
            ud = new Pu,
            dd = new Pu,
            hd = new Pu,
            pd = new od,
            fd = new Tu;
        class md {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : md.DEFAULT_ORDER;
                this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = r
            }
            get x() {
                return this._x
            }
            set x(e) {
                this._x = e, this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(e) {
                this._y = e, this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(e) {
                this._z = e, this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(e) {
                this._order = e, this._onChangeCallback()
            }
            set(e, t, n) {
                let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this._order;
                return this._x = e, this._y = t, this._z = n, this._order = r, this._onChangeCallback(), this
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._order)
            }
            copy(e) {
                return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
            }
            setFromRotationMatrix(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._order,
                    n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                const r = e.elements,
                    i = r[0],
                    o = r[4],
                    a = r[8],
                    s = r[1],
                    l = r[5],
                    c = r[9],
                    u = r[2],
                    d = r[6],
                    h = r[10];
                switch (t) {
                    case "XYZ":
                        this._y = Math.asin(jc(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, h), this._z = Math.atan2(-o, i)) : (this._x = Math.atan2(d, l), this._z = 0);
                        break;
                    case "YXZ":
                        this._x = Math.asin(-jc(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, h), this._z = Math.atan2(s, l)) : (this._y = Math.atan2(-u, i), this._z = 0);
                        break;
                    case "ZXY":
                        this._x = Math.asin(jc(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-u, h), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(s, i));
                        break;
                    case "ZYX":
                        this._y = Math.asin(-jc(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(d, h), this._z = Math.atan2(s, i)) : (this._x = 0, this._z = Math.atan2(-o, l));
                        break;
                    case "YZX":
                        this._z = Math.asin(jc(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, i)) : (this._x = 0, this._y = Math.atan2(a, h));
                        break;
                    case "XZY":
                        this._z = Math.asin(-jc(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(a, i)) : (this._x = Math.atan2(-c, h), this._y = 0);
                        break;
                    default:
                        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
                }
                return this._order = t, !0 === n && this._onChangeCallback(), this
            }
            setFromQuaternion(e, t, n) {
                return pd.makeRotationFromQuaternion(e), this.setFromRotationMatrix(pd, t, n)
            }
            setFromVector3(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._order;
                return this.set(e.x, e.y, e.z, t)
            }
            reorder(e) {
                return fd.setFromEuler(this), this.setFromQuaternion(fd, e)
            }
            equals(e) {
                return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
            }
            fromArray(e) {
                return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
            }
            toArray() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
            }
            _onChange(e) {
                return this._onChangeCallback = e, this
            }
            _onChangeCallback() {}*[Symbol.iterator]() {
                yield this._x, yield this._y, yield this._z, yield this._order
            }
        }
        md.DEFAULT_ORDER = "XYZ";
        class gd {
            constructor() {
                this.mask = 1
            }
            set(e) {
                this.mask = (1 << e | 0) >>> 0
            }
            enable(e) {
                this.mask |= 1 << e | 0
            }
            enableAll() {
                this.mask = -1
            }
            toggle(e) {
                this.mask ^= 1 << e | 0
            }
            disable(e) {
                this.mask &= ~(1 << e | 0)
            }
            disableAll() {
                this.mask = 0
            }
            test(e) {
                return 0 !== (this.mask & e.mask)
            }
            isEnabled(e) {
                return 0 !== (this.mask & (1 << e | 0))
            }
        }
        let vd = 0;
        const yd = new Pu,
            bd = new Tu,
            xd = new od,
            _d = new Pu,
            Md = new Pu,
            wd = new Pu,
            Ad = new Tu,
            Sd = new Pu(1, 0, 0),
            Ed = new Pu(0, 1, 0),
            Cd = new Pu(0, 0, 1),
            Td = {
                type: "added"
            },
            Pd = {
                type: "removed"
            };
        class Rd extends Nc {
            constructor() {
                super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                    value: vd++
                }), this.uuid = Hc(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Rd.DEFAULT_UP.clone();
                const e = new Pu,
                    t = new md,
                    n = new Tu,
                    r = new Pu(1, 1, 1);
                t._onChange((function() {
                    n.setFromEuler(t, !1)
                })), n._onChange((function() {
                    t.setFromQuaternion(n, void 0, !1)
                })), Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: r
                    },
                    modelViewMatrix: {
                        value: new od
                    },
                    normalMatrix: {
                        value: new Qc
                    }
                }), this.matrix = new od, this.matrixWorld = new od, this.matrixAutoUpdate = Rd.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Rd.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new gd, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
            }
            onBeforeShadow() {}
            onAfterShadow() {}
            onBeforeRender() {}
            onAfterRender() {}
            applyMatrix4(e) {
                this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
            }
            applyQuaternion(e) {
                return this.quaternion.premultiply(e), this
            }
            setRotationFromAxisAngle(e, t) {
                this.quaternion.setFromAxisAngle(e, t)
            }
            setRotationFromEuler(e) {
                this.quaternion.setFromEuler(e, !0)
            }
            setRotationFromMatrix(e) {
                this.quaternion.setFromRotationMatrix(e)
            }
            setRotationFromQuaternion(e) {
                this.quaternion.copy(e)
            }
            rotateOnAxis(e, t) {
                return bd.setFromAxisAngle(e, t), this.quaternion.multiply(bd), this
            }
            rotateOnWorldAxis(e, t) {
                return bd.setFromAxisAngle(e, t), this.quaternion.premultiply(bd), this
            }
            rotateX(e) {
                return this.rotateOnAxis(Sd, e)
            }
            rotateY(e) {
                return this.rotateOnAxis(Ed, e)
            }
            rotateZ(e) {
                return this.rotateOnAxis(Cd, e)
            }
            translateOnAxis(e, t) {
                return yd.copy(e).applyQuaternion(this.quaternion), this.position.add(yd.multiplyScalar(t)), this
            }
            translateX(e) {
                return this.translateOnAxis(Sd, e)
            }
            translateY(e) {
                return this.translateOnAxis(Ed, e)
            }
            translateZ(e) {
                return this.translateOnAxis(Cd, e)
            }
            localToWorld(e) {
                return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld)
            }
            worldToLocal(e) {
                return this.updateWorldMatrix(!0, !1), e.applyMatrix4(xd.copy(this.matrixWorld).invert())
            }
            lookAt(e, t, n) {
                e.isVector3 ? _d.copy(e) : _d.set(e, t, n);
                const r = this.parent;
                this.updateWorldMatrix(!0, !1), Md.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? xd.lookAt(Md, _d, this.up) : xd.lookAt(_d, Md, this.up), this.quaternion.setFromRotationMatrix(xd), r && (xd.extractRotation(r.matrixWorld), bd.setFromRotationMatrix(xd), this.quaternion.premultiply(bd.invert()))
            }
            add(e) {
                if (arguments.length > 1) {
                    for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
                    return this
                }
                return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(Td)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
            }
            remove(e) {
                if (arguments.length > 1) {
                    for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                    return this
                }
                const t = this.children.indexOf(e);
                return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(Pd)), this
            }
            removeFromParent() {
                const e = this.parent;
                return null !== e && e.remove(this), this
            }
            clear() {
                return this.remove(...this.children)
            }
            attach(e) {
                return this.updateWorldMatrix(!0, !1), xd.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), xd.multiply(e.parent.matrixWorld)), e.applyMatrix4(xd), this.add(e), e.updateWorldMatrix(!1, !0), this
            }
            getObjectById(e) {
                return this.getObjectByProperty("id", e)
            }
            getObjectByName(e) {
                return this.getObjectByProperty("name", e)
            }
            getObjectByProperty(e, t) {
                if (this[e] === t) return this;
                for (let n = 0, r = this.children.length; n < r; n++) {
                    const r = this.children[n].getObjectByProperty(e, t);
                    if (void 0 !== r) return r
                }
            }
            getObjectsByProperty(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
                this[e] === t && n.push(this);
                const r = this.children;
                for (let i = 0, o = r.length; i < o; i++) r[i].getObjectsByProperty(e, t, n);
                return n
            }
            getWorldPosition(e) {
                return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
            }
            getWorldQuaternion(e) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Md, e, wd), e
            }
            getWorldScale(e) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Md, Ad, e), e
            }
            getWorldDirection(e) {
                this.updateWorldMatrix(!0, !1);
                const t = this.matrixWorld.elements;
                return e.set(t[8], t[9], t[10]).normalize()
            }
            raycast() {}
            traverse(e) {
                e(this);
                const t = this.children;
                for (let n = 0, r = t.length; n < r; n++) t[n].traverse(e)
            }
            traverseVisible(e) {
                if (!1 === this.visible) return;
                e(this);
                const t = this.children;
                for (let n = 0, r = t.length; n < r; n++) t[n].traverseVisible(e)
            }
            traverseAncestors(e) {
                const t = this.parent;
                null !== t && (e(t), t.traverseAncestors(e))
            }
            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            }
            updateMatrixWorld(e) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
                const t = this.children;
                for (let n = 0, r = t.length; n < r; n++) {
                    const r = t[n];
                    !0 !== r.matrixWorldAutoUpdate && !0 !== e || r.updateMatrixWorld(e)
                }
            }
            updateWorldMatrix(e, t) {
                const n = this.parent;
                if (!0 === e && null !== n && !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t) {
                    const e = this.children;
                    for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t];
                        !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0)
                    }
                }
            }
            toJSON(e) {
                const t = void 0 === e || "string" === typeof e,
                    n = {};
                t && (e = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {},
                    nodes: {}
                }, n.metadata = {
                    version: 4.6,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const r = {};

                function i(t, n) {
                    return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid
                }
                if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (r.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (r.type = "BatchedMesh", r.perObjectFrustumCulled = this.perObjectFrustumCulled, r.sortObjects = this.sortObjects, r.drawRanges = this._drawRanges, r.reservedRanges = this._reservedRanges, r.visibility = this._visibility, r.active = this._active, r.bounds = this._bounds.map((e => ({
                        boxInitialized: e.boxInitialized,
                        boxMin: e.box.min.toArray(),
                        boxMax: e.box.max.toArray(),
                        sphereInitialized: e.sphereInitialized,
                        sphereRadius: e.sphere.radius,
                        sphereCenter: e.sphere.center.toArray()
                    }))), r.maxGeometryCount = this._maxGeometryCount, r.maxVertexCount = this._maxVertexCount, r.maxIndexCount = this._maxIndexCount, r.geometryInitialized = this._geometryInitialized, r.geometryCount = this._geometryCount, r.matricesTexture = this._matricesTexture.toJSON(e), null !== this.boundingSphere && (r.boundingSphere = {
                        center: r.boundingSphere.center.toArray(),
                        radius: r.boundingSphere.radius
                    }), null !== this.boundingBox && (r.boundingBox = {
                        min: r.boundingBox.min.toArray(),
                        max: r.boundingBox.max.toArray()
                    })), this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (r.environment = this.environment.toJSON(e).uuid);
                else if (this.isMesh || this.isLine || this.isPoints) {
                    r.geometry = i(e.geometries, this.geometry);
                    const t = this.geometry.parameters;
                    if (void 0 !== t && void 0 !== t.shapes) {
                        const n = t.shapes;
                        if (Array.isArray(n))
                            for (let t = 0, r = n.length; t < r; t++) {
                                const r = n[t];
                                i(e.shapes, r)
                            } else i(e.shapes, n)
                    }
                }
                if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (i(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        const t = [];
                        for (let n = 0, r = this.material.length; n < r; n++) t.push(i(e.materials, this.material[n]));
                        r.material = t
                    } else r.material = i(e.materials, this.material);
                if (this.children.length > 0) {
                    r.children = [];
                    for (let t = 0; t < this.children.length; t++) r.children.push(this.children[t].toJSON(e).object)
                }
                if (this.animations.length > 0) {
                    r.animations = [];
                    for (let t = 0; t < this.animations.length; t++) {
                        const n = this.animations[t];
                        r.animations.push(i(e.animations, n))
                    }
                }
                if (t) {
                    const t = o(e.geometries),
                        r = o(e.materials),
                        i = o(e.textures),
                        a = o(e.images),
                        s = o(e.shapes),
                        l = o(e.skeletons),
                        c = o(e.animations),
                        u = o(e.nodes);
                    t.length > 0 && (n.geometries = t), r.length > 0 && (n.materials = r), i.length > 0 && (n.textures = i), a.length > 0 && (n.images = a), s.length > 0 && (n.shapes = s), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c), u.length > 0 && (n.nodes = u)
                }
                return n.object = r, n;

                function o(e) {
                    const t = [];
                    for (const n in e) {
                        const r = e[n];
                        delete r.metadata, t.push(r)
                    }
                    return t
                }
            }
            clone(e) {
                return (new this.constructor).copy(this, e)
            }
            copy(e) {
                let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                    for (let n = 0; n < e.children.length; n++) {
                        const t = e.children[n];
                        this.add(t.clone())
                    }
                return this
            }
        }
        Rd.DEFAULT_UP = new Pu(0, 1, 0), Rd.DEFAULT_MATRIX_AUTO_UPDATE = !0, Rd.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
        const Id = new Pu,
            Od = new Pu,
            Bd = new Pu,
            Ld = new Pu,
            Dd = new Pu,
            Nd = new Pu,
            kd = new Pu,
            Fd = new Pu,
            Ud = new Pu,
            zd = new Pu;
        class Hd {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Pu,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Pu,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Pu;
                this.a = e, this.b = t, this.c = n
            }
            static getNormal(e, t, n, r) {
                r.subVectors(n, t), Id.subVectors(e, t), r.cross(Id);
                const i = r.lengthSq();
                return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0)
            }
            static getBarycoord(e, t, n, r, i) {
                Id.subVectors(r, t), Od.subVectors(n, t), Bd.subVectors(e, t);
                const o = Id.dot(Id),
                    a = Id.dot(Od),
                    s = Id.dot(Bd),
                    l = Od.dot(Od),
                    c = Od.dot(Bd),
                    u = o * l - a * a;
                if (0 === u) return i.set(0, 0, 0), null;
                const d = 1 / u,
                    h = (l * s - a * c) * d,
                    p = (o * c - a * s) * d;
                return i.set(1 - h - p, p, h)
            }
            static containsPoint(e, t, n, r) {
                return null !== this.getBarycoord(e, t, n, r, Ld) && (Ld.x >= 0 && Ld.y >= 0 && Ld.x + Ld.y <= 1)
            }
            static getInterpolation(e, t, n, r, i, o, a, s) {
                return null === this.getBarycoord(e, t, n, r, Ld) ? (s.x = 0, s.y = 0, "z" in s && (s.z = 0), "w" in s && (s.w = 0), null) : (s.setScalar(0), s.addScaledVector(i, Ld.x), s.addScaledVector(o, Ld.y), s.addScaledVector(a, Ld.z), s)
            }
            static isFrontFacing(e, t, n, r) {
                return Id.subVectors(n, t), Od.subVectors(e, t), Id.cross(Od).dot(r) < 0
            }
            set(e, t, n) {
                return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
            }
            setFromPointsAndIndices(e, t, n, r) {
                return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this
            }
            setFromAttributeAndIndices(e, t, n, r) {
                return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, r), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
            }
            getArea() {
                return Id.subVectors(this.c, this.b), Od.subVectors(this.a, this.b), .5 * Id.cross(Od).length()
            }
            getMidpoint(e) {
                return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(e) {
                return Hd.getNormal(this.a, this.b, this.c, e)
            }
            getPlane(e) {
                return e.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(e, t) {
                return Hd.getBarycoord(e, this.a, this.b, this.c, t)
            }
            getInterpolation(e, t, n, r, i) {
                return Hd.getInterpolation(e, this.a, this.b, this.c, t, n, r, i)
            }
            containsPoint(e) {
                return Hd.containsPoint(e, this.a, this.b, this.c)
            }
            isFrontFacing(e) {
                return Hd.isFrontFacing(this.a, this.b, this.c, e)
            }
            intersectsBox(e) {
                return e.intersectsTriangle(this)
            }
            closestPointToPoint(e, t) {
                const n = this.a,
                    r = this.b,
                    i = this.c;
                let o, a;
                Dd.subVectors(r, n), Nd.subVectors(i, n), Fd.subVectors(e, n);
                const s = Dd.dot(Fd),
                    l = Nd.dot(Fd);
                if (s <= 0 && l <= 0) return t.copy(n);
                Ud.subVectors(e, r);
                const c = Dd.dot(Ud),
                    u = Nd.dot(Ud);
                if (c >= 0 && u <= c) return t.copy(r);
                const d = s * u - c * l;
                if (d <= 0 && s >= 0 && c <= 0) return o = s / (s - c), t.copy(n).addScaledVector(Dd, o);
                zd.subVectors(e, i);
                const h = Dd.dot(zd),
                    p = Nd.dot(zd);
                if (p >= 0 && h <= p) return t.copy(i);
                const f = h * l - s * p;
                if (f <= 0 && l >= 0 && p <= 0) return a = l / (l - p), t.copy(n).addScaledVector(Nd, a);
                const m = c * p - h * u;
                if (m <= 0 && u - c >= 0 && h - p >= 0) return kd.subVectors(i, r), a = (u - c) / (u - c + (h - p)), t.copy(r).addScaledVector(kd, a);
                const g = 1 / (m + f + d);
                return o = f * g, a = d * g, t.copy(n).addScaledVector(Dd, o).addScaledVector(Nd, a)
            }
            equals(e) {
                return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
            }
        }
        const jd = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            },
            Gd = {
                h: 0,
                s: 0,
                l: 0
            },
            Vd = {
                h: 0,
                s: 0,
                l: 0
            };

        function qd(e, t, n) {
            return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
        }
        class Wd {
            constructor(e, t, n) {
                return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n)
            }
            set(e, t, n) {
                if (void 0 === t && void 0 === n) {
                    const t = e;
                    t && t.isColor ? this.copy(t) : "number" === typeof t ? this.setHex(t) : "string" === typeof t && this.setStyle(t)
                } else this.setRGB(e, t, n);
                return this
            }
            setScalar(e) {
                return this.r = e, this.g = e, this.b = e, this
            }
            setHex(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Vl;
                return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, uu.toWorkingColorSpace(this, t), this
            }
            setRGB(e, t, n) {
                let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : uu.workingColorSpace;
                return this.r = e, this.g = t, this.b = n, uu.toWorkingColorSpace(this, r), this
            }
            setHSL(e, t, n) {
                let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : uu.workingColorSpace;
                if (e = Gc(e, 1), t = jc(t, 0, 1), n = jc(n, 0, 1), 0 === t) this.r = this.g = this.b = n;
                else {
                    const r = n <= .5 ? n * (1 + t) : n + t - n * t,
                        i = 2 * n - r;
                    this.r = qd(i, r, e + 1 / 3), this.g = qd(i, r, e), this.b = qd(i, r, e - 1 / 3)
                }
                return uu.toWorkingColorSpace(this, r), this
            }
            setStyle(e) {
                let t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Vl;

                function r(t) {
                    void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                }
                if (t = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                    let i;
                    const o = t[1],
                        a = t[2];
                    switch (o) {
                        case "rgb":
                        case "rgba":
                            if (i = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return r(i[4]), this.setRGB(Math.min(255, parseInt(i[1], 10)) / 255, Math.min(255, parseInt(i[2], 10)) / 255, Math.min(255, parseInt(i[3], 10)) / 255, n);
                            if (i = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return r(i[4]), this.setRGB(Math.min(100, parseInt(i[1], 10)) / 100, Math.min(100, parseInt(i[2], 10)) / 100, Math.min(100, parseInt(i[3], 10)) / 100, n);
                            break;
                        case "hsl":
                        case "hsla":
                            if (i = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return r(i[4]), this.setHSL(parseFloat(i[1]) / 360, parseFloat(i[2]) / 100, parseFloat(i[3]) / 100, n);
                            break;
                        default:
                            console.warn("THREE.Color: Unknown color model " + e)
                    }
                } else if (t = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                    const r = t[1],
                        i = r.length;
                    if (3 === i) return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, n);
                    if (6 === i) return this.setHex(parseInt(r, 16), n);
                    console.warn("THREE.Color: Invalid hex color " + e)
                } else if (e && e.length > 0) return this.setColorName(e, n);
                return this
            }
            setColorName(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Vl;
                const n = jd[e.toLowerCase()];
                return void 0 !== n ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this
            }
            clone() {
                return new this.constructor(this.r, this.g, this.b)
            }
            copy(e) {
                return this.r = e.r, this.g = e.g, this.b = e.b, this
            }
            copySRGBToLinear(e) {
                return this.r = du(e.r), this.g = du(e.g), this.b = du(e.b), this
            }
            copyLinearToSRGB(e) {
                return this.r = hu(e.r), this.g = hu(e.g), this.b = hu(e.b), this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this), this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this), this
            }
            getHex() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vl;
                return uu.fromWorkingColorSpace(Xd.copy(this), e), 65536 * Math.round(jc(255 * Xd.r, 0, 255)) + 256 * Math.round(jc(255 * Xd.g, 0, 255)) + Math.round(jc(255 * Xd.b, 0, 255))
            }
            getHexString() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vl;
                return ("000000" + this.getHex(e).toString(16)).slice(-6)
            }
            getHSL(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : uu.workingColorSpace;
                uu.fromWorkingColorSpace(Xd.copy(this), t);
                const n = Xd.r,
                    r = Xd.g,
                    i = Xd.b,
                    o = Math.max(n, r, i),
                    a = Math.min(n, r, i);
                let s, l;
                const c = (a + o) / 2;
                if (a === o) s = 0, l = 0;
                else {
                    const e = o - a;
                    switch (l = c <= .5 ? e / (o + a) : e / (2 - o - a), o) {
                        case n:
                            s = (r - i) / e + (r < i ? 6 : 0);
                            break;
                        case r:
                            s = (i - n) / e + 2;
                            break;
                        case i:
                            s = (n - r) / e + 4
                    }
                    s /= 6
                }
                return e.h = s, e.s = l, e.l = c, e
            }
            getRGB(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : uu.workingColorSpace;
                return uu.fromWorkingColorSpace(Xd.copy(this), t), e.r = Xd.r, e.g = Xd.g, e.b = Xd.b, e
            }
            getStyle() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Vl;
                uu.fromWorkingColorSpace(Xd.copy(this), e);
                const t = Xd.r,
                    n = Xd.g,
                    r = Xd.b;
                return e !== Vl ? "color(".concat(e, " ").concat(t.toFixed(3), " ").concat(n.toFixed(3), " ").concat(r.toFixed(3), ")") : "rgb(".concat(Math.round(255 * t), ",").concat(Math.round(255 * n), ",").concat(Math.round(255 * r), ")")
            }
            offsetHSL(e, t, n) {
                return this.getHSL(Gd), this.setHSL(Gd.h + e, Gd.s + t, Gd.l + n)
            }
            add(e) {
                return this.r += e.r, this.g += e.g, this.b += e.b, this
            }
            addColors(e, t) {
                return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
            }
            addScalar(e) {
                return this.r += e, this.g += e, this.b += e, this
            }
            sub(e) {
                return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
            }
            multiply(e) {
                return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
            }
            multiplyScalar(e) {
                return this.r *= e, this.g *= e, this.b *= e, this
            }
            lerp(e, t) {
                return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
            }
            lerpColors(e, t, n) {
                return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this
            }
            lerpHSL(e, t) {
                this.getHSL(Gd), e.getHSL(Vd);
                const n = Vc(Gd.h, Vd.h, t),
                    r = Vc(Gd.s, Vd.s, t),
                    i = Vc(Gd.l, Vd.l, t);
                return this.setHSL(n, r, i), this
            }
            setFromVector3(e) {
                return this.r = e.x, this.g = e.y, this.b = e.z, this
            }
            applyMatrix3(e) {
                const t = this.r,
                    n = this.g,
                    r = this.b,
                    i = e.elements;
                return this.r = i[0] * t + i[3] * n + i[6] * r, this.g = i[1] * t + i[4] * n + i[7] * r, this.b = i[2] * t + i[5] * n + i[8] * r, this
            }
            equals(e) {
                return e.r === this.r && e.g === this.g && e.b === this.b
            }
            fromArray(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
            }
            toArray() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
            }
            fromBufferAttribute(e, t) {
                return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this
            }
            toJSON() {
                return this.getHex()
            }*[Symbol.iterator]() {
                yield this.r, yield this.g, yield this.b
            }
        }
        const Xd = new Wd;
        Wd.NAMES = jd;
        let Kd = 0;
        class Jd extends Nc {
            constructor() {
                super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                    value: Kd++
                }), this.uuid = Hc(), this.name = "", this.type = "Material", this.blending = pa, this.side = ca, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Ca, this.blendDst = Ta, this.blendEquation = ya, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Wd(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Ha, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = pc, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = $l, this.stencilZFail = $l, this.stencilZPass = $l, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
            }
            get alphaTest() {
                return this._alphaTest
            }
            set alphaTest(e) {
                this._alphaTest > 0 !== e > 0 && this.version++, this._alphaTest = e
            }
            onBuild() {}
            onBeforeRender() {}
            onBeforeCompile() {}
            customProgramCacheKey() {
                return this.onBeforeCompile.toString()
            }
            setValues(e) {
                if (void 0 !== e)
                    for (const t in e) {
                        const n = e[t];
                        if (void 0 === n) {
                            console.warn("THREE.Material: parameter '".concat(t, "' has value of undefined."));
                            continue
                        }
                        const r = this[t];
                        void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n : console.warn("THREE.Material: '".concat(t, "' is not a property of THREE.").concat(this.type, "."))
                    }
            }
            toJSON(e) {
                const t = void 0 === e || "string" === typeof e;
                t && (e = {
                    textures: {},
                    images: {}
                });
                const n = {
                    metadata: {
                        version: 4.6,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };

                function r(e) {
                    const t = [];
                    for (const n in e) {
                        const r = e[n];
                        delete r.metadata, t.push(r)
                    }
                    return t
                }
                if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (n.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== pa && (n.blending = this.blending), this.side !== ca && (n.side = this.side), !0 === this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = !0), this.blendSrc !== Ca && (n.blendSrc = this.blendSrc), this.blendDst !== Ta && (n.blendDst = this.blendDst), this.blendEquation !== ya && (n.blendEquation = this.blendEquation), null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha), null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha), null !== this.blendEquationAlpha && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), 0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha), this.depthFunc !== Ha && (n.depthFunc = this.depthFunc), !1 === this.depthTest && (n.depthTest = this.depthTest), !1 === this.depthWrite && (n.depthWrite = this.depthWrite), !1 === this.colorWrite && (n.colorWrite = this.colorWrite), 255 !== this.stencilWriteMask && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== pc && (n.stencilFunc = this.stencilFunc), 0 !== this.stencilRef && (n.stencilRef = this.stencilRef), 255 !== this.stencilFuncMask && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== $l && (n.stencilFail = this.stencilFail), this.stencilZFail !== $l && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== $l && (n.stencilZPass = this.stencilZPass), !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite), void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaHash && (n.alphaHash = !0), !0 === this.alphaToCoverage && (n.alphaToCoverage = !0), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0), !0 === this.forceSinglePass && (n.forceSinglePass = !0), !0 === this.wireframe && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), !1 === this.fog && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData), t) {
                    const t = r(e.textures),
                        i = r(e.images);
                    t.length > 0 && (n.textures = t), i.length > 0 && (n.images = i)
                }
                return n
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
                const t = e.clippingPlanes;
                let n = null;
                if (null !== t) {
                    const e = t.length;
                    n = new Array(e);
                    for (let r = 0; r !== e; ++r) n[r] = t[r].clone()
                }
                return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            set needsUpdate(e) {
                !0 === e && this.version++
            }
        }
        class Yd extends Jd {
            constructor(e) {
                super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Wd(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Wa, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
            }
        }
        const Qd = Zd();

        function Zd() {
            const e = new ArrayBuffer(4),
                t = new Float32Array(e),
                n = new Uint32Array(e),
                r = new Uint32Array(512),
                i = new Uint32Array(512);
            for (let l = 0; l < 256; ++l) {
                const e = l - 127;
                e < -27 ? (r[l] = 0, r[256 | l] = 32768, i[l] = 24, i[256 | l] = 24) : e < -14 ? (r[l] = 1024 >> -e - 14, r[256 | l] = 1024 >> -e - 14 | 32768, i[l] = -e - 1, i[256 | l] = -e - 1) : e <= 15 ? (r[l] = e + 15 << 10, r[256 | l] = e + 15 << 10 | 32768, i[l] = 13, i[256 | l] = 13) : e < 128 ? (r[l] = 31744, r[256 | l] = 64512, i[l] = 24, i[256 | l] = 24) : (r[l] = 31744, r[256 | l] = 64512, i[l] = 13, i[256 | l] = 13)
            }
            const o = new Uint32Array(2048),
                a = new Uint32Array(64),
                s = new Uint32Array(64);
            for (let l = 1; l < 1024; ++l) {
                let e = l << 13,
                    t = 0;
                for (; 0 === (8388608 & e);) e <<= 1, t -= 8388608;
                e &= -8388609, t += 947912704, o[l] = e | t
            }
            for (let l = 1024; l < 2048; ++l) o[l] = 939524096 + (l - 1024 << 13);
            for (let l = 1; l < 31; ++l) a[l] = l << 23;
            a[31] = 1199570944, a[32] = 2147483648;
            for (let l = 33; l < 63; ++l) a[l] = 2147483648 + (l - 32 << 23);
            a[63] = 3347054592;
            for (let l = 1; l < 64; ++l) 32 !== l && (s[l] = 1024);
            return {
                floatView: t,
                uint32View: n,
                baseTable: r,
                shiftTable: i,
                mantissaTable: o,
                exponentTable: a,
                offsetTable: s
            }
        }

        function $d(e) {
            Math.abs(e) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), e = jc(e, -65504, 65504), Qd.floatView[0] = e;
            const t = Qd.uint32View[0],
                n = t >> 23 & 511;
            return Qd.baseTable[n] + ((8388607 & t) >> Qd.shiftTable[n])
        }

        function eh(e) {
            const t = e >> 10;
            return Qd.uint32View[0] = Qd.mantissaTable[Qd.offsetTable[t] + (1023 & e)] + Qd.exponentTable[t], Qd.floatView[0]
        }
        const th = {
                toHalfFloat: $d,
                fromHalfFloat: eh
            },
            nh = new Pu,
            rh = new Yc;
        class ih {
            constructor(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = n, this.usage = Mc, this._updateRange = {
                    offset: 0,
                    count: -1
                }, this.updateRanges = [], this.gpuType = Ps, this.version = 0
            }
            onUploadCallback() {}
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            get updateRange() {
                return ou("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
            }
            setUsage(e) {
                return this.usage = e, this
            }
            addUpdateRange(e, t) {
                this.updateRanges.push({
                    start: e,
                    count: t
                })
            }
            clearUpdateRanges() {
                this.updateRanges.length = 0
            }
            copy(e) {
                return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this
            }
            copyAt(e, t, n) {
                e *= this.itemSize, n *= t.itemSize;
                for (let r = 0, i = this.itemSize; r < i; r++) this.array[e + r] = t.array[n + r];
                return this
            }
            copyArray(e) {
                return this.array.set(e), this
            }
            applyMatrix3(e) {
                if (2 === this.itemSize)
                    for (let t = 0, n = this.count; t < n; t++) rh.fromBufferAttribute(this, t), rh.applyMatrix3(e), this.setXY(t, rh.x, rh.y);
                else if (3 === this.itemSize)
                    for (let t = 0, n = this.count; t < n; t++) nh.fromBufferAttribute(this, t), nh.applyMatrix3(e), this.setXYZ(t, nh.x, nh.y, nh.z);
                return this
            }
            applyMatrix4(e) {
                for (let t = 0, n = this.count; t < n; t++) nh.fromBufferAttribute(this, t), nh.applyMatrix4(e), this.setXYZ(t, nh.x, nh.y, nh.z);
                return this
            }
            applyNormalMatrix(e) {
                for (let t = 0, n = this.count; t < n; t++) nh.fromBufferAttribute(this, t), nh.applyNormalMatrix(e), this.setXYZ(t, nh.x, nh.y, nh.z);
                return this
            }
            transformDirection(e) {
                for (let t = 0, n = this.count; t < n; t++) nh.fromBufferAttribute(this, t), nh.transformDirection(e), this.setXYZ(t, nh.x, nh.y, nh.z);
                return this
            }
            set(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return this.array.set(e, t), this
            }
            getComponent(e, t) {
                let n = this.array[e * this.itemSize + t];
                return this.normalized && (n = Xc(n, this.array)), n
            }
            setComponent(e, t, n) {
                return this.normalized && (n = Kc(n, this.array)), this.array[e * this.itemSize + t] = n, this
            }
            getX(e) {
                let t = this.array[e * this.itemSize];
                return this.normalized && (t = Xc(t, this.array)), t
            }
            setX(e, t) {
                return this.normalized && (t = Kc(t, this.array)), this.array[e * this.itemSize] = t, this
            }
            getY(e) {
                let t = this.array[e * this.itemSize + 1];
                return this.normalized && (t = Xc(t, this.array)), t
            }
            setY(e, t) {
                return this.normalized && (t = Kc(t, this.array)), this.array[e * this.itemSize + 1] = t, this
            }
            getZ(e) {
                let t = this.array[e * this.itemSize + 2];
                return this.normalized && (t = Xc(t, this.array)), t
            }
            setZ(e, t) {
                return this.normalized && (t = Kc(t, this.array)), this.array[e * this.itemSize + 2] = t, this
            }
            getW(e) {
                let t = this.array[e * this.itemSize + 3];
                return this.normalized && (t = Xc(t, this.array)), t
            }
            setW(e, t) {
                return this.normalized && (t = Kc(t, this.array)), this.array[e * this.itemSize + 3] = t, this
            }
            setXY(e, t, n) {
                return e *= this.itemSize, this.normalized && (t = Kc(t, this.array), n = Kc(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this
            }
            setXYZ(e, t, n, r) {
                return e *= this.itemSize, this.normalized && (t = Kc(t, this.array), n = Kc(n, this.array), r = Kc(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this
            }
            setXYZW(e, t, n, r, i) {
                return e *= this.itemSize, this.normalized && (t = Kc(t, this.array), n = Kc(n, this.array), r = Kc(r, this.array), i = Kc(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = i, this
            }
            onUpload(e) {
                return this.onUploadCallback = e, this
            }
            clone() {
                return new this.constructor(this.array, this.itemSize).copy(this)
            }
            toJSON() {
                const e = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.from(this.array),
                    normalized: this.normalized
                };
                return "" !== this.name && (e.name = this.name), this.usage !== Mc && (e.usage = this.usage), e
            }
        }
        class oh extends ih {
            constructor(e, t, n) {
                super(new Int8Array(e), t, n)
            }
        }
        class ah extends ih {
            constructor(e, t, n) {
                super(new Uint8Array(e), t, n)
            }
        }
        class sh extends ih {
            constructor(e, t, n) {
                super(new Uint8ClampedArray(e), t, n)
            }
        }
        class lh extends ih {
            constructor(e, t, n) {
                super(new Int16Array(e), t, n)
            }
        }
        class ch extends ih {
            constructor(e, t, n) {
                super(new Uint16Array(e), t, n)
            }
        }
        class uh extends ih {
            constructor(e, t, n) {
                super(new Int32Array(e), t, n)
            }
        }
        class dh extends ih {
            constructor(e, t, n) {
                super(new Uint32Array(e), t, n)
            }
        }
        class hh extends ih {
            constructor(e, t, n) {
                super(new Uint16Array(e), t, n), this.isFloat16BufferAttribute = !0
            }
            getX(e) {
                let t = eh(this.array[e * this.itemSize]);
                return this.normalized && (t = Xc(t, this.array)), t
            }
            setX(e, t) {
                return this.normalized && (t = Kc(t, this.array)), this.array[e * this.itemSize] = $d(t), this
            }
            getY(e) {
                let t = eh(this.array[e * this.itemSize + 1]);
                return this.normalized && (t = Xc(t, this.array)), t
            }
            setY(e, t) {
                return this.normalized && (t = Kc(t, this.array)), this.array[e * this.itemSize + 1] = $d(t), this
            }
            getZ(e) {
                let t = eh(this.array[e * this.itemSize + 2]);
                return this.normalized && (t = Xc(t, this.array)), t
            }
            setZ(e, t) {
                return this.normalized && (t = Kc(t, this.array)), this.array[e * this.itemSize + 2] = $d(t), this
            }
            getW(e) {
                let t = eh(this.array[e * this.itemSize + 3]);
                return this.normalized && (t = Xc(t, this.array)), t
            }
            setW(e, t) {
                return this.normalized && (t = Kc(t, this.array)), this.array[e * this.itemSize + 3] = $d(t), this
            }
            setXY(e, t, n) {
                return e *= this.itemSize, this.normalized && (t = Kc(t, this.array), n = Kc(n, this.array)), this.array[e + 0] = $d(t), this.array[e + 1] = $d(n), this
            }
            setXYZ(e, t, n, r) {
                return e *= this.itemSize, this.normalized && (t = Kc(t, this.array), n = Kc(n, this.array), r = Kc(r, this.array)), this.array[e + 0] = $d(t), this.array[e + 1] = $d(n), this.array[e + 2] = $d(r), this
            }
            setXYZW(e, t, n, r, i) {
                return e *= this.itemSize, this.normalized && (t = Kc(t, this.array), n = Kc(n, this.array), r = Kc(r, this.array), i = Kc(i, this.array)), this.array[e + 0] = $d(t), this.array[e + 1] = $d(n), this.array[e + 2] = $d(r), this.array[e + 3] = $d(i), this
            }
        }
        class ph extends ih {
            constructor(e, t, n) {
                super(new Float32Array(e), t, n)
            }
        }
        class fh extends ih {
            constructor(e, t, n) {
                super(new Float64Array(e), t, n)
            }
        }
        let mh = 0;
        const gh = new od,
            vh = new Rd,
            yh = new Pu,
            bh = new Ou,
            xh = new Ou,
            _h = new Pu;
        class Mh extends Nc {
            constructor() {
                super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                    value: mh++
                }), this.uuid = Hc(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }
            getIndex() {
                return this.index
            }
            setIndex(e) {
                return Array.isArray(e) ? this.index = new($c(e) ? dh : ch)(e, 1) : this.index = e, this
            }
            getAttribute(e) {
                return this.attributes[e]
            }
            setAttribute(e, t) {
                return this.attributes[e] = t, this
            }
            deleteAttribute(e) {
                return delete this.attributes[e], this
            }
            hasAttribute(e) {
                return void 0 !== this.attributes[e]
            }
            addGroup(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                this.groups.push({
                    start: e,
                    count: t,
                    materialIndex: n
                })
            }
            clearGroups() {
                this.groups = []
            }
            setDrawRange(e, t) {
                this.drawRange.start = e, this.drawRange.count = t
            }
            applyMatrix4(e) {
                const t = this.attributes.position;
                void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
                const n = this.attributes.normal;
                if (void 0 !== n) {
                    const t = (new Qc).getNormalMatrix(e);
                    n.applyNormalMatrix(t), n.needsUpdate = !0
                }
                const r = this.attributes.tangent;
                return void 0 !== r && (r.transformDirection(e), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            }
            applyQuaternion(e) {
                return gh.makeRotationFromQuaternion(e), this.applyMatrix4(gh), this
            }
            rotateX(e) {
                return gh.makeRotationX(e), this.applyMatrix4(gh), this
            }
            rotateY(e) {
                return gh.makeRotationY(e), this.applyMatrix4(gh), this
            }
            rotateZ(e) {
                return gh.makeRotationZ(e), this.applyMatrix4(gh), this
            }
            translate(e, t, n) {
                return gh.makeTranslation(e, t, n), this.applyMatrix4(gh), this
            }
            scale(e, t, n) {
                return gh.makeScale(e, t, n), this.applyMatrix4(gh), this
            }
            lookAt(e) {
                return vh.lookAt(e), vh.updateMatrix(), this.applyMatrix4(vh.matrix), this
            }
            center() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(yh).negate(), this.translate(yh.x, yh.y, yh.z), this
            }
            setFromPoints(e) {
                const t = [];
                for (let n = 0, r = e.length; n < r; n++) {
                    const r = e[n];
                    t.push(r.x, r.y, r.z || 0)
                }
                return this.setAttribute("position", new ph(t, 3)), this
            }
            computeBoundingBox() {
                null === this.boundingBox && (this.boundingBox = new Ou);
                const e = this.attributes.position,
                    t = this.morphAttributes.position;
                if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Pu(-1 / 0, -1 / 0, -1 / 0), new Pu(1 / 0, 1 / 0, 1 / 0));
                if (void 0 !== e) {
                    if (this.boundingBox.setFromBufferAttribute(e), t)
                        for (let n = 0, r = t.length; n < r; n++) {
                            const e = t[n];
                            bh.setFromBufferAttribute(e), this.morphTargetsRelative ? (_h.addVectors(this.boundingBox.min, bh.min), this.boundingBox.expandByPoint(_h), _h.addVectors(this.boundingBox.max, bh.max), this.boundingBox.expandByPoint(_h)) : (this.boundingBox.expandByPoint(bh.min), this.boundingBox.expandByPoint(bh.max))
                        }
                } else this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
            computeBoundingSphere() {
                null === this.boundingSphere && (this.boundingSphere = new Yu);
                const e = this.attributes.position,
                    t = this.morphAttributes.position;
                if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Pu, 1 / 0);
                if (e) {
                    const n = this.boundingSphere.center;
                    if (bh.setFromBufferAttribute(e), t)
                        for (let e = 0, i = t.length; e < i; e++) {
                            const n = t[e];
                            xh.setFromBufferAttribute(n), this.morphTargetsRelative ? (_h.addVectors(bh.min, xh.min), bh.expandByPoint(_h), _h.addVectors(bh.max, xh.max), bh.expandByPoint(_h)) : (bh.expandByPoint(xh.min), bh.expandByPoint(xh.max))
                        }
                    bh.getCenter(n);
                    let r = 0;
                    for (let t = 0, i = e.count; t < i; t++) _h.fromBufferAttribute(e, t), r = Math.max(r, n.distanceToSquared(_h));
                    if (t)
                        for (let i = 0, o = t.length; i < o; i++) {
                            const o = t[i],
                                a = this.morphTargetsRelative;
                            for (let t = 0, i = o.count; t < i; t++) _h.fromBufferAttribute(o, t), a && (yh.fromBufferAttribute(e, t), _h.add(yh)), r = Math.max(r, n.distanceToSquared(_h))
                        }
                    this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
            computeTangents() {
                const e = this.index,
                    t = this.attributes;
                if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                const n = e.array,
                    r = t.position.array,
                    i = t.normal.array,
                    o = t.uv.array,
                    a = r.length / 3;
                !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new ih(new Float32Array(4 * a), 4));
                const s = this.getAttribute("tangent").array,
                    l = [],
                    c = [];
                for (let S = 0; S < a; S++) l[S] = new Pu, c[S] = new Pu;
                const u = new Pu,
                    d = new Pu,
                    h = new Pu,
                    p = new Yc,
                    f = new Yc,
                    m = new Yc,
                    g = new Pu,
                    v = new Pu;

                function y(e, t, n) {
                    u.fromArray(r, 3 * e), d.fromArray(r, 3 * t), h.fromArray(r, 3 * n), p.fromArray(o, 2 * e), f.fromArray(o, 2 * t), m.fromArray(o, 2 * n), d.sub(u), h.sub(u), f.sub(p), m.sub(p);
                    const i = 1 / (f.x * m.y - m.x * f.y);
                    isFinite(i) && (g.copy(d).multiplyScalar(m.y).addScaledVector(h, -f.y).multiplyScalar(i), v.copy(h).multiplyScalar(f.x).addScaledVector(d, -m.x).multiplyScalar(i), l[e].add(g), l[t].add(g), l[n].add(g), c[e].add(v), c[t].add(v), c[n].add(v))
                }
                let b = this.groups;
                0 === b.length && (b = [{
                    start: 0,
                    count: n.length
                }]);
                for (let S = 0, E = b.length; S < E; ++S) {
                    const e = b[S],
                        t = e.start;
                    for (let r = t, i = t + e.count; r < i; r += 3) y(n[r + 0], n[r + 1], n[r + 2])
                }
                const x = new Pu,
                    _ = new Pu,
                    M = new Pu,
                    w = new Pu;

                function A(e) {
                    M.fromArray(i, 3 * e), w.copy(M);
                    const t = l[e];
                    x.copy(t), x.sub(M.multiplyScalar(M.dot(t))).normalize(), _.crossVectors(w, t);
                    const n = _.dot(c[e]) < 0 ? -1 : 1;
                    s[4 * e] = x.x, s[4 * e + 1] = x.y, s[4 * e + 2] = x.z, s[4 * e + 3] = n
                }
                for (let S = 0, E = b.length; S < E; ++S) {
                    const e = b[S],
                        t = e.start;
                    for (let r = t, i = t + e.count; r < i; r += 3) A(n[r + 0]), A(n[r + 1]), A(n[r + 2])
                }
            }
            computeVertexNormals() {
                const e = this.index,
                    t = this.getAttribute("position");
                if (void 0 !== t) {
                    let n = this.getAttribute("normal");
                    if (void 0 === n) n = new ih(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n);
                    else
                        for (let e = 0, t = n.count; e < t; e++) n.setXYZ(e, 0, 0, 0);
                    const r = new Pu,
                        i = new Pu,
                        o = new Pu,
                        a = new Pu,
                        s = new Pu,
                        l = new Pu,
                        c = new Pu,
                        u = new Pu;
                    if (e)
                        for (let d = 0, h = e.count; d < h; d += 3) {
                            const h = e.getX(d + 0),
                                p = e.getX(d + 1),
                                f = e.getX(d + 2);
                            r.fromBufferAttribute(t, h), i.fromBufferAttribute(t, p), o.fromBufferAttribute(t, f), c.subVectors(o, i), u.subVectors(r, i), c.cross(u), a.fromBufferAttribute(n, h), s.fromBufferAttribute(n, p), l.fromBufferAttribute(n, f), a.add(c), s.add(c), l.add(c), n.setXYZ(h, a.x, a.y, a.z), n.setXYZ(p, s.x, s.y, s.z), n.setXYZ(f, l.x, l.y, l.z)
                        } else
                            for (let e = 0, d = t.count; e < d; e += 3) r.fromBufferAttribute(t, e + 0), i.fromBufferAttribute(t, e + 1), o.fromBufferAttribute(t, e + 2), c.subVectors(o, i), u.subVectors(r, i), c.cross(u), n.setXYZ(e + 0, c.x, c.y, c.z), n.setXYZ(e + 1, c.x, c.y, c.z), n.setXYZ(e + 2, c.x, c.y, c.z);
                    this.normalizeNormals(), n.needsUpdate = !0
                }
            }
            normalizeNormals() {
                const e = this.attributes.normal;
                for (let t = 0, n = e.count; t < n; t++) _h.fromBufferAttribute(e, t), _h.normalize(), e.setXYZ(t, _h.x, _h.y, _h.z)
            }
            toNonIndexed() {
                function e(e, t) {
                    const n = e.array,
                        r = e.itemSize,
                        i = e.normalized,
                        o = new n.constructor(t.length * r);
                    let a = 0,
                        s = 0;
                    for (let l = 0, c = t.length; l < c; l++) {
                        a = e.isInterleavedBufferAttribute ? t[l] * e.data.stride + e.offset : t[l] * r;
                        for (let e = 0; e < r; e++) o[s++] = n[a++]
                    }
                    return new ih(o, r, i)
                }
                if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                const t = new Mh,
                    n = this.index.array,
                    r = this.attributes;
                for (const a in r) {
                    const i = e(r[a], n);
                    t.setAttribute(a, i)
                }
                const i = this.morphAttributes;
                for (const a in i) {
                    const r = [],
                        o = i[a];
                    for (let t = 0, i = o.length; t < i; t++) {
                        const i = e(o[t], n);
                        r.push(i)
                    }
                    t.morphAttributes[a] = r
                }
                t.morphTargetsRelative = this.morphTargetsRelative;
                const o = this.groups;
                for (let a = 0, s = o.length; a < s; a++) {
                    const e = o[a];
                    t.addGroup(e.start, e.count, e.materialIndex)
                }
                return t
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.6,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
                    const t = this.parameters;
                    for (const n in t) void 0 !== t[n] && (e[n] = t[n]);
                    return e
                }
                e.data = {
                    attributes: {}
                };
                const t = this.index;
                null !== t && (e.data.index = {
                    type: t.array.constructor.name,
                    array: Array.prototype.slice.call(t.array)
                });
                const n = this.attributes;
                for (const s in n) {
                    const t = n[s];
                    e.data.attributes[s] = t.toJSON(e.data)
                }
                const r = {};
                let i = !1;
                for (const s in this.morphAttributes) {
                    const t = this.morphAttributes[s],
                        n = [];
                    for (let r = 0, i = t.length; r < i; r++) {
                        const i = t[r];
                        n.push(i.toJSON(e.data))
                    }
                    n.length > 0 && (r[s] = n, i = !0)
                }
                i && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
                const o = this.groups;
                o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
                const a = this.boundingSphere;
                return null !== a && (e.data.boundingSphere = {
                    center: a.center.toArray(),
                    radius: a.radius
                }), e
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                const t = {};
                this.name = e.name;
                const n = e.index;
                null !== n && this.setIndex(n.clone(t));
                const r = e.attributes;
                for (const l in r) {
                    const e = r[l];
                    this.setAttribute(l, e.clone(t))
                }
                const i = e.morphAttributes;
                for (const l in i) {
                    const e = [],
                        n = i[l];
                    for (let r = 0, i = n.length; r < i; r++) e.push(n[r].clone(t));
                    this.morphAttributes[l] = e
                }
                this.morphTargetsRelative = e.morphTargetsRelative;
                const o = e.groups;
                for (let l = 0, c = o.length; l < c; l++) {
                    const e = o[l];
                    this.addGroup(e.start, e.count, e.materialIndex)
                }
                const a = e.boundingBox;
                null !== a && (this.boundingBox = a.clone());
                const s = e.boundingSphere;
                return null !== s && (this.boundingSphere = s.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        const wh = new od,
            Ah = new id,
            Sh = new Yu,
            Eh = new Pu,
            Ch = new Pu,
            Th = new Pu,
            Ph = new Pu,
            Rh = new Pu,
            Ih = new Pu,
            Oh = new Yc,
            Bh = new Yc,
            Lh = new Yc,
            Dh = new Pu,
            Nh = new Pu,
            kh = new Pu,
            Fh = new Pu,
            Uh = new Pu;
        class zh extends Rd {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Mh,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Yd;
                super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets()
            }
            copy(e, t) {
                return super.copy(e, t), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
            }
            updateMorphTargets() {
                const e = this.geometry.morphAttributes,
                    t = Object.keys(e);
                if (t.length > 0) {
                    const n = e[t[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let e = 0, t = n.length; e < t; e++) {
                            const t = n[e].name || String(e);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e
                        }
                    }
                }
            }
            getVertexPosition(e, t) {
                const n = this.geometry,
                    r = n.attributes.position,
                    i = n.morphAttributes.position,
                    o = n.morphTargetsRelative;
                t.fromBufferAttribute(r, e);
                const a = this.morphTargetInfluences;
                if (i && a) {
                    Ih.set(0, 0, 0);
                    for (let n = 0, r = i.length; n < r; n++) {
                        const r = a[n],
                            s = i[n];
                        0 !== r && (Rh.fromBufferAttribute(s, e), o ? Ih.addScaledVector(Rh, r) : Ih.addScaledVector(Rh.sub(t), r))
                    }
                    t.add(Ih)
                }
                return t
            }
            raycast(e, t) {
                const n = this.geometry,
                    r = this.material,
                    i = this.matrixWorld;
                if (void 0 !== r) {
                    if (null === n.boundingSphere && n.computeBoundingSphere(), Sh.copy(n.boundingSphere), Sh.applyMatrix4(i), Ah.copy(e.ray).recast(e.near), !1 === Sh.containsPoint(Ah.origin)) {
                        if (null === Ah.intersectSphere(Sh, Eh)) return;
                        if (Ah.origin.distanceToSquared(Eh) > (e.far - e.near) ** 2) return
                    }
                    wh.copy(i).invert(), Ah.copy(e.ray).applyMatrix4(wh), null !== n.boundingBox && !1 === Ah.intersectsBox(n.boundingBox) || this._computeIntersections(e, t, Ah)
                }
            }
            _computeIntersections(e, t, n) {
                let r;
                const i = this.geometry,
                    o = this.material,
                    a = i.index,
                    s = i.attributes.position,
                    l = i.attributes.uv,
                    c = i.attributes.uv1,
                    u = i.attributes.normal,
                    d = i.groups,
                    h = i.drawRange;
                if (null !== a)
                    if (Array.isArray(o))
                        for (let p = 0, f = d.length; p < f; p++) {
                            const i = d[p],
                                s = o[i.materialIndex];
                            for (let o = Math.max(i.start, h.start), d = Math.min(a.count, Math.min(i.start + i.count, h.start + h.count)); o < d; o += 3) {
                                r = Hh(this, s, e, n, l, c, u, a.getX(o), a.getX(o + 1), a.getX(o + 2)), r && (r.faceIndex = Math.floor(o / 3), r.face.materialIndex = i.materialIndex, t.push(r))
                            }
                        } else {
                            for (let i = Math.max(0, h.start), s = Math.min(a.count, h.start + h.count); i < s; i += 3) {
                                r = Hh(this, o, e, n, l, c, u, a.getX(i), a.getX(i + 1), a.getX(i + 2)), r && (r.faceIndex = Math.floor(i / 3), t.push(r))
                            }
                        } else if (void 0 !== s)
                            if (Array.isArray(o))
                                for (let p = 0, f = d.length; p < f; p++) {
                                    const i = d[p],
                                        a = o[i.materialIndex];
                                    for (let o = Math.max(i.start, h.start), d = Math.min(s.count, Math.min(i.start + i.count, h.start + h.count)); o < d; o += 3) {
                                        r = Hh(this, a, e, n, l, c, u, o, o + 1, o + 2), r && (r.faceIndex = Math.floor(o / 3), r.face.materialIndex = i.materialIndex, t.push(r))
                                    }
                                } else {
                                    for (let i = Math.max(0, h.start), a = Math.min(s.count, h.start + h.count); i < a; i += 3) {
                                        r = Hh(this, o, e, n, l, c, u, i, i + 1, i + 2), r && (r.faceIndex = Math.floor(i / 3), t.push(r))
                                    }
                                }
            }
        }

        function Hh(e, t, n, r, i, o, a, s, l, c) {
            e.getVertexPosition(s, Ch), e.getVertexPosition(l, Th), e.getVertexPosition(c, Ph);
            const u = function(e, t, n, r, i, o, a, s) {
                let l;
                if (l = t.side === ua ? r.intersectTriangle(a, o, i, !0, s) : r.intersectTriangle(i, o, a, t.side === ca, s), null === l) return null;
                Uh.copy(s), Uh.applyMatrix4(e.matrixWorld);
                const c = n.ray.origin.distanceTo(Uh);
                return c < n.near || c > n.far ? null : {
                    distance: c,
                    point: Uh.clone(),
                    object: e
                }
            }(e, t, n, r, Ch, Th, Ph, Fh);
            if (u) {
                i && (Oh.fromBufferAttribute(i, s), Bh.fromBufferAttribute(i, l), Lh.fromBufferAttribute(i, c), u.uv = Hd.getInterpolation(Fh, Ch, Th, Ph, Oh, Bh, Lh, new Yc)), o && (Oh.fromBufferAttribute(o, s), Bh.fromBufferAttribute(o, l), Lh.fromBufferAttribute(o, c), u.uv1 = Hd.getInterpolation(Fh, Ch, Th, Ph, Oh, Bh, Lh, new Yc), u.uv2 = u.uv1), a && (Dh.fromBufferAttribute(a, s), Nh.fromBufferAttribute(a, l), kh.fromBufferAttribute(a, c), u.normal = Hd.getInterpolation(Fh, Ch, Th, Ph, Dh, Nh, kh, new Pu), u.normal.dot(r.direction) > 0 && u.normal.multiplyScalar(-1));
                const e = {
                    a: s,
                    b: l,
                    c: c,
                    normal: new Pu,
                    materialIndex: 0
                };
                Hd.getNormal(Ch, Th, Ph, e.normal), u.face = e
            }
            return u
        }
        class jh extends Mh {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
                    i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1,
                    o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1;
                super(), this.type = "BoxGeometry", this.parameters = {
                    width: e,
                    height: t,
                    depth: n,
                    widthSegments: r,
                    heightSegments: i,
                    depthSegments: o
                };
                const a = this;
                r = Math.floor(r), i = Math.floor(i), o = Math.floor(o);
                const s = [],
                    l = [],
                    c = [],
                    u = [];
                let d = 0,
                    h = 0;

                function p(e, t, n, r, i, o, p, f, m, g, v) {
                    const y = o / m,
                        b = p / g,
                        x = o / 2,
                        _ = p / 2,
                        M = f / 2,
                        w = m + 1,
                        A = g + 1;
                    let S = 0,
                        E = 0;
                    const C = new Pu;
                    for (let a = 0; a < A; a++) {
                        const o = a * b - _;
                        for (let s = 0; s < w; s++) {
                            const d = s * y - x;
                            C[e] = d * r, C[t] = o * i, C[n] = M, l.push(C.x, C.y, C.z), C[e] = 0, C[t] = 0, C[n] = f > 0 ? 1 : -1, c.push(C.x, C.y, C.z), u.push(s / m), u.push(1 - a / g), S += 1
                        }
                    }
                    for (let a = 0; a < g; a++)
                        for (let e = 0; e < m; e++) {
                            const t = d + e + w * a,
                                n = d + e + w * (a + 1),
                                r = d + (e + 1) + w * (a + 1),
                                i = d + (e + 1) + w * a;
                            s.push(t, n, i), s.push(n, r, i), E += 6
                        }
                    a.addGroup(h, E, v), h += E, d += S
                }
                p("z", "y", "x", -1, -1, n, t, e, o, i, 0), p("z", "y", "x", 1, -1, n, t, -e, o, i, 1), p("x", "z", "y", 1, 1, e, n, t, r, o, 2), p("x", "z", "y", 1, -1, e, n, -t, r, o, 3), p("x", "y", "z", 1, -1, e, t, n, r, i, 4), p("x", "y", "z", -1, -1, e, t, -n, r, i, 5), this.setIndex(s), this.setAttribute("position", new ph(l, 3)), this.setAttribute("normal", new ph(c, 3)), this.setAttribute("uv", new ph(u, 2))
            }
            copy(e) {
                return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
            }
            static fromJSON(e) {
                return new jh(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
            }
        }

        function Gh(e) {
            const t = {};
            for (const n in e) {
                t[n] = {};
                for (const r in e[n]) {
                    const i = e[n][r];
                    i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), t[n][r] = null) : t[n][r] = i.clone() : Array.isArray(i) ? t[n][r] = i.slice() : t[n][r] = i
                }
            }
            return t
        }

        function Vh(e) {
            const t = {};
            for (let n = 0; n < e.length; n++) {
                const r = Gh(e[n]);
                for (const e in r) t[e] = r[e]
            }
            return t
        }

        function qh(e) {
            return null === e.getRenderTarget() ? e.outputColorSpace : uu.workingColorSpace
        }
        const Wh = {
            clone: Gh,
            merge: Vh
        };
        class Xh extends Jd {
            constructor(e) {
                super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1,
                    clipCullDistance: !1,
                    multiDraw: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv1: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Gh(e.uniforms), this.uniformsGroups = function(e) {
                    const t = [];
                    for (let n = 0; n < e.length; n++) t.push(e[n].clone());
                    return t
                }(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                t.glslVersion = this.glslVersion, t.uniforms = {};
                for (const r in this.uniforms) {
                    const n = this.uniforms[r].value;
                    n && n.isTexture ? t.uniforms[r] = {
                        type: "t",
                        value: n.toJSON(e).uuid
                    } : n && n.isColor ? t.uniforms[r] = {
                        type: "c",
                        value: n.getHex()
                    } : n && n.isVector2 ? t.uniforms[r] = {
                        type: "v2",
                        value: n.toArray()
                    } : n && n.isVector3 ? t.uniforms[r] = {
                        type: "v3",
                        value: n.toArray()
                    } : n && n.isVector4 ? t.uniforms[r] = {
                        type: "v4",
                        value: n.toArray()
                    } : n && n.isMatrix3 ? t.uniforms[r] = {
                        type: "m3",
                        value: n.toArray()
                    } : n && n.isMatrix4 ? t.uniforms[r] = {
                        type: "m4",
                        value: n.toArray()
                    } : t.uniforms[r] = {
                        value: n
                    }
                }
                Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
                const n = {};
                for (const r in this.extensions) !0 === this.extensions[r] && (n[r] = !0);
                return Object.keys(n).length > 0 && (t.extensions = n), t
            }
        }
        class Kh extends Rd {
            constructor() {
                super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new od, this.projectionMatrix = new od, this.projectionMatrixInverse = new od, this.coordinateSystem = Lc
            }
            copy(e, t) {
                return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this
            }
            getWorldDirection(e) {
                return super.getWorldDirection(e).negate()
            }
            updateMatrixWorld(e) {
                super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            updateWorldMatrix(e, t) {
                super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const Jh = new Pu,
            Yh = new Yc,
            Qh = new Yc;
        class Zh extends Kh {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 50,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .1,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 2e3;
                super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }
            copy(e, t) {
                return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
            }
            setFocalLength(e) {
                const t = .5 * this.getFilmHeight() / e;
                this.fov = 2 * zc * Math.atan(t), this.updateProjectionMatrix()
            }
            getFocalLength() {
                const e = Math.tan(.5 * Uc * this.fov);
                return .5 * this.getFilmHeight() / e
            }
            getEffectiveFOV() {
                return 2 * zc * Math.atan(Math.tan(.5 * Uc * this.fov) / this.zoom)
            }
            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1)
            }
            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1)
            }
            getViewBounds(e, t, n) {
                Jh.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), t.set(Jh.x, Jh.y).multiplyScalar(-e / Jh.z), Jh.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), n.set(Jh.x, Jh.y).multiplyScalar(-e / Jh.z)
            }
            getViewSize(e, t) {
                return this.getViewBounds(e, Yh, Qh), t.subVectors(Qh, Yh)
            }
            setViewOffset(e, t, n, r, i, o) {
                this.aspect = e / t, null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const e = this.near;
                let t = e * Math.tan(.5 * Uc * this.fov) / this.zoom,
                    n = 2 * t,
                    r = this.aspect * n,
                    i = -.5 * r;
                const o = this.view;
                if (null !== this.view && this.view.enabled) {
                    const e = o.fullWidth,
                        a = o.fullHeight;
                    i += o.offsetX * r / e, t -= o.offsetY * n / a, r *= o.width / e, n *= o.height / a
                }
                const a = this.filmOffset;
                0 !== a && (i += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
            }
        }
        const $h = -90;
        class ep extends Rd {
            constructor(e, t, n) {
                super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
                const r = new Zh($h, 1, e, t);
                r.layers = this.layers, this.add(r);
                const i = new Zh($h, 1, e, t);
                i.layers = this.layers, this.add(i);
                const o = new Zh($h, 1, e, t);
                o.layers = this.layers, this.add(o);
                const a = new Zh($h, 1, e, t);
                a.layers = this.layers, this.add(a);
                const s = new Zh($h, 1, e, t);
                s.layers = this.layers, this.add(s);
                const l = new Zh($h, 1, e, t);
                l.layers = this.layers, this.add(l)
            }
            updateCoordinateSystem() {
                const e = this.coordinateSystem,
                    t = this.children.concat(),
                    [n, r, i, o, a, s] = t;
                for (const l of t) this.remove(l);
                if (e === Lc) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), i.up.set(0, 0, -1), i.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), s.up.set(0, 1, 0), s.lookAt(0, 0, -1);
                else {
                    if (e !== Dc) throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
                    n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), i.up.set(0, 0, 1), i.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), s.up.set(0, -1, 0), s.lookAt(0, 0, -1)
                }
                for (const l of t) this.add(l), l.updateMatrixWorld()
            }
            update(e, t) {
                null === this.parent && this.updateMatrixWorld();
                const {
                    renderTarget: n,
                    activeMipmapLevel: r
                } = this;
                this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
                const [i, o, a, s, l, c] = this.children, u = e.getRenderTarget(), d = e.getActiveCubeFace(), h = e.getActiveMipmapLevel(), p = e.xr.enabled;
                e.xr.enabled = !1;
                const f = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, r), e.render(t, i), e.setRenderTarget(n, 1, r), e.render(t, o), e.setRenderTarget(n, 2, r), e.render(t, a), e.setRenderTarget(n, 3, r), e.render(t, s), e.setRenderTarget(n, 4, r), e.render(t, l), n.texture.generateMipmaps = f, e.setRenderTarget(n, 5, r), e.render(t, c), e.setRenderTarget(u, d, h), e.xr.enabled = p, n.texture.needsPMREMUpdate = !0
            }
        }
        class tp extends bu {
            constructor(e, t, n, r, i, o, a, s, l, c) {
                super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : os, n, r, i, o, a, s, l, c), this.isCubeTexture = !0, this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(e) {
                this.image = e
            }
        }
        class np extends Mu {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                super(e, e, t), this.isWebGLCubeRenderTarget = !0;
                const n = {
                        width: e,
                        height: e,
                        depth: 1
                    },
                    r = [n, n, n, n, n, n];
                void 0 !== t.encoding && (ou("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), t.colorSpace = t.encoding === Fl ? Vl : Gl), this.texture = new tp(r, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : ys
            }
            fromEquirectangularTexture(e, t) {
                this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
                const n = {
                        tEquirect: {
                            value: null
                        }
                    },
                    r = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                    i = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
                    o = new jh(5, 5, 5),
                    a = new Xh({
                        name: "CubemapFromEquirect",
                        uniforms: Gh(n),
                        vertexShader: r,
                        fragmentShader: i,
                        side: ua,
                        blending: ha
                    });
                a.uniforms.tEquirect.value = t;
                const s = new zh(o, a),
                    l = t.minFilter;
                t.minFilter === _s && (t.minFilter = ys);
                return new ep(1, 10, this).update(e, s), t.minFilter = l, s.geometry.dispose(), s.material.dispose(), this
            }
            clear(e, t, n, r) {
                const i = e.getRenderTarget();
                for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, n, r);
                e.setRenderTarget(i)
            }
        }
        const rp = new Pu,
            ip = new Pu,
            op = new Qc;
        class ap {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Pu(1, 0, 0),
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.isPlane = !0, this.normal = e, this.constant = t
            }
            set(e, t) {
                return this.normal.copy(e), this.constant = t, this
            }
            setComponents(e, t, n, r) {
                return this.normal.set(e, t, n), this.constant = r, this
            }
            setFromNormalAndCoplanarPoint(e, t) {
                return this.normal.copy(e), this.constant = -t.dot(this.normal), this
            }
            setFromCoplanarPoints(e, t, n) {
                const r = rp.subVectors(n, t).cross(ip.subVectors(e, t)).normalize();
                return this.setFromNormalAndCoplanarPoint(r, e), this
            }
            copy(e) {
                return this.normal.copy(e.normal), this.constant = e.constant, this
            }
            normalize() {
                const e = 1 / this.normal.length();
                return this.normal.multiplyScalar(e), this.constant *= e, this
            }
            negate() {
                return this.constant *= -1, this.normal.negate(), this
            }
            distanceToPoint(e) {
                return this.normal.dot(e) + this.constant
            }
            distanceToSphere(e) {
                return this.distanceToPoint(e.center) - e.radius
            }
            projectPoint(e, t) {
                return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
            }
            intersectLine(e, t) {
                const n = e.delta(rp),
                    r = this.normal.dot(n);
                if (0 === r) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
                const i = -(e.start.dot(this.normal) + this.constant) / r;
                return i < 0 || i > 1 ? null : t.copy(e.start).addScaledVector(n, i)
            }
            intersectsLine(e) {
                const t = this.distanceToPoint(e.start),
                    n = this.distanceToPoint(e.end);
                return t < 0 && n > 0 || n < 0 && t > 0
            }
            intersectsBox(e) {
                return e.intersectsPlane(this)
            }
            intersectsSphere(e) {
                return e.intersectsPlane(this)
            }
            coplanarPoint(e) {
                return e.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(e, t) {
                const n = t || op.getNormalMatrix(e),
                    r = this.coplanarPoint(rp).applyMatrix4(e),
                    i = this.normal.applyMatrix3(n).normalize();
                return this.constant = -r.dot(i), this
            }
            translate(e) {
                return this.constant -= e.dot(this.normal), this
            }
            equals(e) {
                return e.normal.equals(this.normal) && e.constant === this.constant
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const sp = new Yu,
            lp = new Pu;
        class cp {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new ap,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new ap,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new ap,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : new ap,
                    i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : new ap,
                    o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : new ap;
                this.planes = [e, t, n, r, i, o]
            }
            set(e, t, n, r, i, o) {
                const a = this.planes;
                return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(r), a[4].copy(i), a[5].copy(o), this
            }
            copy(e) {
                const t = this.planes;
                for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
                return this
            }
            setFromProjectionMatrix(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Lc;
                const n = this.planes,
                    r = e.elements,
                    i = r[0],
                    o = r[1],
                    a = r[2],
                    s = r[3],
                    l = r[4],
                    c = r[5],
                    u = r[6],
                    d = r[7],
                    h = r[8],
                    p = r[9],
                    f = r[10],
                    m = r[11],
                    g = r[12],
                    v = r[13],
                    y = r[14],
                    b = r[15];
                if (n[0].setComponents(s - i, d - l, m - h, b - g).normalize(), n[1].setComponents(s + i, d + l, m + h, b + g).normalize(), n[2].setComponents(s + o, d + c, m + p, b + v).normalize(), n[3].setComponents(s - o, d - c, m - p, b - v).normalize(), n[4].setComponents(s - a, d - u, m - f, b - y).normalize(), t === Lc) n[5].setComponents(s + a, d + u, m + f, b + y).normalize();
                else {
                    if (t !== Dc) throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
                    n[5].setComponents(a, u, f, y).normalize()
                }
                return this
            }
            intersectsObject(e) {
                if (void 0 !== e.boundingSphere) null === e.boundingSphere && e.computeBoundingSphere(), sp.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
                else {
                    const t = e.geometry;
                    null === t.boundingSphere && t.computeBoundingSphere(), sp.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
                }
                return this.intersectsSphere(sp)
            }
            intersectsSprite(e) {
                return sp.center.set(0, 0, 0), sp.radius = .7071067811865476, sp.applyMatrix4(e.matrixWorld), this.intersectsSphere(sp)
            }
            intersectsSphere(e) {
                const t = this.planes,
                    n = e.center,
                    r = -e.radius;
                for (let i = 0; i < 6; i++) {
                    if (t[i].distanceToPoint(n) < r) return !1
                }
                return !0
            }
            intersectsBox(e) {
                const t = this.planes;
                for (let n = 0; n < 6; n++) {
                    const r = t[n];
                    if (lp.x = r.normal.x > 0 ? e.max.x : e.min.x, lp.y = r.normal.y > 0 ? e.max.y : e.min.y, lp.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(lp) < 0) return !1
                }
                return !0
            }
            containsPoint(e) {
                const t = this.planes;
                for (let n = 0; n < 6; n++)
                    if (t[n].distanceToPoint(e) < 0) return !1;
                return !0
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }

        function up() {
            let e = null,
                t = !1,
                n = null,
                r = null;

            function i(t, o) {
                n(t, o), r = e.requestAnimationFrame(i)
            }
            return {
                start: function() {
                    !0 !== t && null !== n && (r = e.requestAnimationFrame(i), t = !0)
                },
                stop: function() {
                    e.cancelAnimationFrame(r), t = !1
                },
                setAnimationLoop: function(e) {
                    n = e
                },
                setContext: function(t) {
                    e = t
                }
            }
        }

        function dp(e, t) {
            const n = t.isWebGL2,
                r = new WeakMap;
            return {
                get: function(e) {
                    return e.isInterleavedBufferAttribute && (e = e.data), r.get(e)
                },
                remove: function(t) {
                    t.isInterleavedBufferAttribute && (t = t.data);
                    const n = r.get(t);
                    n && (e.deleteBuffer(n.buffer), r.delete(t))
                },
                update: function(t, i) {
                    if (t.isGLBufferAttribute) {
                        const e = r.get(t);
                        return void((!e || e.version < t.version) && r.set(t, {
                            buffer: t.buffer,
                            type: t.type,
                            bytesPerElement: t.elementSize,
                            version: t.version
                        }))
                    }
                    t.isInterleavedBufferAttribute && (t = t.data);
                    const o = r.get(t);
                    if (void 0 === o) r.set(t, function(t, r) {
                        const i = t.array,
                            o = t.usage,
                            a = i.byteLength,
                            s = e.createBuffer();
                        let l;
                        if (e.bindBuffer(r, s), e.bufferData(r, i, o), t.onUploadCallback(), i instanceof Float32Array) l = e.FLOAT;
                        else if (i instanceof Uint16Array)
                            if (t.isFloat16BufferAttribute) {
                                if (!n) throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                                l = e.HALF_FLOAT
                            } else l = e.UNSIGNED_SHORT;
                        else if (i instanceof Int16Array) l = e.SHORT;
                        else if (i instanceof Uint32Array) l = e.UNSIGNED_INT;
                        else if (i instanceof Int32Array) l = e.INT;
                        else if (i instanceof Int8Array) l = e.BYTE;
                        else if (i instanceof Uint8Array) l = e.UNSIGNED_BYTE;
                        else {
                            if (!(i instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + i);
                            l = e.UNSIGNED_BYTE
                        }
                        return {
                            buffer: s,
                            type: l,
                            bytesPerElement: i.BYTES_PER_ELEMENT,
                            version: t.version,
                            size: a
                        }
                    }(t, i));
                    else if (o.version < t.version) {
                        if (o.size !== t.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                        ! function(t, r, i) {
                            const o = r.array,
                                a = r._updateRange,
                                s = r.updateRanges;
                            if (e.bindBuffer(i, t), -1 === a.count && 0 === s.length && e.bufferSubData(i, 0, o), 0 !== s.length) {
                                for (let t = 0, r = s.length; t < r; t++) {
                                    const r = s[t];
                                    n ? e.bufferSubData(i, r.start * o.BYTES_PER_ELEMENT, o, r.start, r.count) : e.bufferSubData(i, r.start * o.BYTES_PER_ELEMENT, o.subarray(r.start, r.start + r.count))
                                }
                                r.clearUpdateRanges()
                            } - 1 !== a.count && (n ? e.bufferSubData(i, a.offset * o.BYTES_PER_ELEMENT, o, a.offset, a.count) : e.bufferSubData(i, a.offset * o.BYTES_PER_ELEMENT, o.subarray(a.offset, a.offset + a.count)), a.count = -1), r.onUploadCallback()
                        }(o.buffer, t, i), o.version = t.version
                    }
                }
            }
        }
        class hp extends Mh {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                super(), this.type = "PlaneGeometry", this.parameters = {
                    width: e,
                    height: t,
                    widthSegments: n,
                    heightSegments: r
                };
                const i = e / 2,
                    o = t / 2,
                    a = Math.floor(n),
                    s = Math.floor(r),
                    l = a + 1,
                    c = s + 1,
                    u = e / a,
                    d = t / s,
                    h = [],
                    p = [],
                    f = [],
                    m = [];
                for (let g = 0; g < c; g++) {
                    const e = g * d - o;
                    for (let t = 0; t < l; t++) {
                        const n = t * u - i;
                        p.push(n, -e, 0), f.push(0, 0, 1), m.push(t / a), m.push(1 - g / s)
                    }
                }
                for (let g = 0; g < s; g++)
                    for (let e = 0; e < a; e++) {
                        const t = e + l * g,
                            n = e + l * (g + 1),
                            r = e + 1 + l * (g + 1),
                            i = e + 1 + l * g;
                        h.push(t, n, i), h.push(n, r, i)
                    }
                this.setIndex(h), this.setAttribute("position", new ph(p, 3)), this.setAttribute("normal", new ph(f, 3)), this.setAttribute("uv", new ph(m, 2))
            }
            copy(e) {
                return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
            }
            static fromJSON(e) {
                return new hp(e.width, e.height, e.widthSegments, e.heightSegments)
            }
        }
        const pp = {
                alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
                alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
                alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
                alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                alphatest_fragment: "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",
                alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                batching_pars_vertex: "#ifdef USE_BATCHING\n\tattribute float batchId;\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
                batching_vertex: "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif",
                begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
                beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
                iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
                bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",
                clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
                cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
                emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                colorspace_pars_fragment: "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}",
                envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
                envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
                fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
                fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
                lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
                lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
                lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
                lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
                lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
                lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
                lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
                lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
                lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
                logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
                map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
                morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
                morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
                morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
                normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
                normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
                normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
                clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
                clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
                clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
                iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
                opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
                premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
                shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
                skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
                transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
                uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
                uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
                uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
                worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
                meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
                meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
                sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
            },
            fp = {
                common: {
                    diffuse: {
                        value: new Wd(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    mapTransform: {
                        value: new Qc
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaMapTransform: {
                        value: new Qc
                    },
                    alphaTest: {
                        value: 0
                    }
                },
                specularmap: {
                    specularMap: {
                        value: null
                    },
                    specularMapTransform: {
                        value: new Qc
                    }
                },
                envmap: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    ior: {
                        value: 1.5
                    },
                    refractionRatio: {
                        value: .98
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    },
                    aoMapTransform: {
                        value: new Qc
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    },
                    lightMapTransform: {
                        value: new Qc
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpMapTransform: {
                        value: new Qc
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalMapTransform: {
                        value: new Qc
                    },
                    normalScale: {
                        value: new Yc(1, 1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementMapTransform: {
                        value: new Qc
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    },
                    emissiveMapTransform: {
                        value: new Qc
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    },
                    metalnessMapTransform: {
                        value: new Qc
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    },
                    roughnessMapTransform: {
                        value: new Qc
                    }
                },
                gradientmap: {
                    gradientMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new Wd(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    lightProbe: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {}
                        }
                    },
                    directionalLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {}
                        }
                    },
                    spotLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotLightMap: {
                        value: []
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotLightMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {}
                        }
                    },
                    pointLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {},
                            shadowCameraNear: {},
                            shadowCameraFar: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    },
                    rectAreaLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            width: {},
                            height: {}
                        }
                    },
                    ltc_1: {
                        value: null
                    },
                    ltc_2: {
                        value: null
                    }
                },
                points: {
                    diffuse: {
                        value: new Wd(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaMapTransform: {
                        value: new Qc
                    },
                    alphaTest: {
                        value: 0
                    },
                    uvTransform: {
                        value: new Qc
                    }
                },
                sprite: {
                    diffuse: {
                        value: new Wd(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    center: {
                        value: new Yc(.5, .5)
                    },
                    rotation: {
                        value: 0
                    },
                    map: {
                        value: null
                    },
                    mapTransform: {
                        value: new Qc
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaMapTransform: {
                        value: new Qc
                    },
                    alphaTest: {
                        value: 0
                    }
                }
            },
            mp = {
                basic: {
                    uniforms: Vh([fp.common, fp.specularmap, fp.envmap, fp.aomap, fp.lightmap, fp.fog]),
                    vertexShader: pp.meshbasic_vert,
                    fragmentShader: pp.meshbasic_frag
                },
                lambert: {
                    uniforms: Vh([fp.common, fp.specularmap, fp.envmap, fp.aomap, fp.lightmap, fp.emissivemap, fp.bumpmap, fp.normalmap, fp.displacementmap, fp.fog, fp.lights, {
                        emissive: {
                            value: new Wd(0)
                        }
                    }]),
                    vertexShader: pp.meshlambert_vert,
                    fragmentShader: pp.meshlambert_frag
                },
                phong: {
                    uniforms: Vh([fp.common, fp.specularmap, fp.envmap, fp.aomap, fp.lightmap, fp.emissivemap, fp.bumpmap, fp.normalmap, fp.displacementmap, fp.fog, fp.lights, {
                        emissive: {
                            value: new Wd(0)
                        },
                        specular: {
                            value: new Wd(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: pp.meshphong_vert,
                    fragmentShader: pp.meshphong_frag
                },
                standard: {
                    uniforms: Vh([fp.common, fp.envmap, fp.aomap, fp.lightmap, fp.emissivemap, fp.bumpmap, fp.normalmap, fp.displacementmap, fp.roughnessmap, fp.metalnessmap, fp.fog, fp.lights, {
                        emissive: {
                            value: new Wd(0)
                        },
                        roughness: {
                            value: 1
                        },
                        metalness: {
                            value: 0
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: pp.meshphysical_vert,
                    fragmentShader: pp.meshphysical_frag
                },
                toon: {
                    uniforms: Vh([fp.common, fp.aomap, fp.lightmap, fp.emissivemap, fp.bumpmap, fp.normalmap, fp.displacementmap, fp.gradientmap, fp.fog, fp.lights, {
                        emissive: {
                            value: new Wd(0)
                        }
                    }]),
                    vertexShader: pp.meshtoon_vert,
                    fragmentShader: pp.meshtoon_frag
                },
                matcap: {
                    uniforms: Vh([fp.common, fp.bumpmap, fp.normalmap, fp.displacementmap, fp.fog, {
                        matcap: {
                            value: null
                        }
                    }]),
                    vertexShader: pp.meshmatcap_vert,
                    fragmentShader: pp.meshmatcap_frag
                },
                points: {
                    uniforms: Vh([fp.points, fp.fog]),
                    vertexShader: pp.points_vert,
                    fragmentShader: pp.points_frag
                },
                dashed: {
                    uniforms: Vh([fp.common, fp.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: pp.linedashed_vert,
                    fragmentShader: pp.linedashed_frag
                },
                depth: {
                    uniforms: Vh([fp.common, fp.displacementmap]),
                    vertexShader: pp.depth_vert,
                    fragmentShader: pp.depth_frag
                },
                normal: {
                    uniforms: Vh([fp.common, fp.bumpmap, fp.normalmap, fp.displacementmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: pp.meshnormal_vert,
                    fragmentShader: pp.meshnormal_frag
                },
                sprite: {
                    uniforms: Vh([fp.sprite, fp.fog]),
                    vertexShader: pp.sprite_vert,
                    fragmentShader: pp.sprite_frag
                },
                background: {
                    uniforms: {
                        uvTransform: {
                            value: new Qc
                        },
                        t2D: {
                            value: null
                        },
                        backgroundIntensity: {
                            value: 1
                        }
                    },
                    vertexShader: pp.background_vert,
                    fragmentShader: pp.background_frag
                },
                backgroundCube: {
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        backgroundBlurriness: {
                            value: 0
                        },
                        backgroundIntensity: {
                            value: 1
                        }
                    },
                    vertexShader: pp.backgroundCube_vert,
                    fragmentShader: pp.backgroundCube_frag
                },
                cube: {
                    uniforms: {
                        tCube: {
                            value: null
                        },
                        tFlip: {
                            value: -1
                        },
                        opacity: {
                            value: 1
                        }
                    },
                    vertexShader: pp.cube_vert,
                    fragmentShader: pp.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: pp.equirect_vert,
                    fragmentShader: pp.equirect_frag
                },
                distanceRGBA: {
                    uniforms: Vh([fp.common, fp.displacementmap, {
                        referencePosition: {
                            value: new Pu
                        },
                        nearDistance: {
                            value: 1
                        },
                        farDistance: {
                            value: 1e3
                        }
                    }]),
                    vertexShader: pp.distanceRGBA_vert,
                    fragmentShader: pp.distanceRGBA_frag
                },
                shadow: {
                    uniforms: Vh([fp.lights, fp.fog, {
                        color: {
                            value: new Wd(0)
                        },
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: pp.shadow_vert,
                    fragmentShader: pp.shadow_frag
                }
            };
        mp.physical = {
            uniforms: Vh([mp.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatMapTransform: {
                    value: new Qc
                },
                clearcoatNormalMap: {
                    value: null
                },
                clearcoatNormalMapTransform: {
                    value: new Qc
                },
                clearcoatNormalScale: {
                    value: new Yc(1, 1)
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatRoughnessMapTransform: {
                    value: new Qc
                },
                iridescence: {
                    value: 0
                },
                iridescenceMap: {
                    value: null
                },
                iridescenceMapTransform: {
                    value: new Qc
                },
                iridescenceIOR: {
                    value: 1.3
                },
                iridescenceThicknessMinimum: {
                    value: 100
                },
                iridescenceThicknessMaximum: {
                    value: 400
                },
                iridescenceThicknessMap: {
                    value: null
                },
                iridescenceThicknessMapTransform: {
                    value: new Qc
                },
                sheen: {
                    value: 0
                },
                sheenColor: {
                    value: new Wd(0)
                },
                sheenColorMap: {
                    value: null
                },
                sheenColorMapTransform: {
                    value: new Qc
                },
                sheenRoughness: {
                    value: 1
                },
                sheenRoughnessMap: {
                    value: null
                },
                sheenRoughnessMapTransform: {
                    value: new Qc
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionMapTransform: {
                    value: new Qc
                },
                transmissionSamplerSize: {
                    value: new Yc
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                thicknessMapTransform: {
                    value: new Qc
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationColor: {
                    value: new Wd(0)
                },
                specularColor: {
                    value: new Wd(1, 1, 1)
                },
                specularColorMap: {
                    value: null
                },
                specularColorMapTransform: {
                    value: new Qc
                },
                specularIntensity: {
                    value: 1
                },
                specularIntensityMap: {
                    value: null
                },
                specularIntensityMapTransform: {
                    value: new Qc
                },
                anisotropyVector: {
                    value: new Yc
                },
                anisotropyMap: {
                    value: null
                },
                anisotropyMapTransform: {
                    value: new Qc
                }
            }]),
            vertexShader: pp.meshphysical_vert,
            fragmentShader: pp.meshphysical_frag
        };
        const gp = {
            r: 0,
            b: 0,
            g: 0
        };

        function vp(e, t, n, r, i, o, a) {
            const s = new Wd(0);
            let l, c, u = !0 === o ? 0 : 1,
                d = null,
                h = 0,
                p = null;

            function f(t, n) {
                t.getRGB(gp, qh(e)), r.buffers.color.setClear(gp.r, gp.g, gp.b, n, a)
            }
            return {
                getClearColor: function() {
                    return s
                },
                setClearColor: function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                    s.set(e), u = t, f(s, u)
                },
                getClearAlpha: function() {
                    return u
                },
                setClearAlpha: function(e) {
                    u = e, f(s, u)
                },
                render: function(o, m) {
                    let g = !1,
                        v = !0 === m.isScene ? m.background : null;
                    if (v && v.isTexture) {
                        v = (m.backgroundBlurriness > 0 ? n : t).get(v)
                    }
                    null === v ? f(s, u) : v && v.isColor && (f(v, 1), g = !0);
                    const y = e.xr.getEnvironmentBlendMode();
                    "additive" === y ? r.buffers.color.setClear(0, 0, 0, 1, a) : "alpha-blend" === y && r.buffers.color.setClear(0, 0, 0, 0, a), (e.autoClear || g) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), v && (v.isCubeTexture || v.mapping === cs) ? (void 0 === c && (c = new zh(new jh(1, 1, 1), new Xh({
                        name: "BackgroundCubeMaterial",
                        uniforms: Gh(mp.backgroundCube.uniforms),
                        vertexShader: mp.backgroundCube.vertexShader,
                        fragmentShader: mp.backgroundCube.fragmentShader,
                        side: ua,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function(e, t, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }, Object.defineProperty(c.material, "envMap", {
                        get: function() {
                            return this.uniforms.envMap.value
                        }
                    }), i.update(c)), c.material.uniforms.envMap.value = v, c.material.uniforms.flipEnvMap.value = v.isCubeTexture && !1 === v.isRenderTargetTexture ? -1 : 1, c.material.uniforms.backgroundBlurriness.value = m.backgroundBlurriness, c.material.uniforms.backgroundIntensity.value = m.backgroundIntensity, c.material.toneMapped = uu.getTransfer(v.colorSpace) !== Jl, d === v && h === v.version && p === e.toneMapping || (c.material.needsUpdate = !0, d = v, h = v.version, p = e.toneMapping), c.layers.enableAll(), o.unshift(c, c.geometry, c.material, 0, 0, null)) : v && v.isTexture && (void 0 === l && (l = new zh(new hp(2, 2), new Xh({
                        name: "BackgroundMaterial",
                        uniforms: Gh(mp.background.uniforms),
                        vertexShader: mp.background.vertexShader,
                        fragmentShader: mp.background.fragmentShader,
                        side: ca,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
                        get: function() {
                            return this.uniforms.t2D.value
                        }
                    }), i.update(l)), l.material.uniforms.t2D.value = v, l.material.uniforms.backgroundIntensity.value = m.backgroundIntensity, l.material.toneMapped = uu.getTransfer(v.colorSpace) !== Jl, !0 === v.matrixAutoUpdate && v.updateMatrix(), l.material.uniforms.uvTransform.value.copy(v.matrix), d === v && h === v.version && p === e.toneMapping || (l.material.needsUpdate = !0, d = v, h = v.version, p = e.toneMapping), l.layers.enableAll(), o.unshift(l, l.geometry, l.material, 0, 0, null))
                }
            }
        }

        function yp(e, t, n, r) {
            const i = e.getParameter(e.MAX_VERTEX_ATTRIBS),
                o = r.isWebGL2 ? null : t.get("OES_vertex_array_object"),
                a = r.isWebGL2 || null !== o,
                s = {},
                l = p(null);
            let c = l,
                u = !1;

            function d(t) {
                return r.isWebGL2 ? e.bindVertexArray(t) : o.bindVertexArrayOES(t)
            }

            function h(t) {
                return r.isWebGL2 ? e.deleteVertexArray(t) : o.deleteVertexArrayOES(t)
            }

            function p(e) {
                const t = [],
                    n = [],
                    r = [];
                for (let o = 0; o < i; o++) t[o] = 0, n[o] = 0, r[o] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: t,
                    enabledAttributes: n,
                    attributeDivisors: r,
                    object: e,
                    attributes: {},
                    index: null
                }
            }

            function f() {
                const e = c.newAttributes;
                for (let t = 0, n = e.length; t < n; t++) e[t] = 0
            }

            function m(e) {
                g(e, 0)
            }

            function g(n, i) {
                const o = c.newAttributes,
                    a = c.enabledAttributes,
                    s = c.attributeDivisors;
                if (o[n] = 1, 0 === a[n] && (e.enableVertexAttribArray(n), a[n] = 1), s[n] !== i) {
                    (r.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), s[n] = i
                }
            }

            function v() {
                const t = c.newAttributes,
                    n = c.enabledAttributes;
                for (let r = 0, i = n.length; r < i; r++) n[r] !== t[r] && (e.disableVertexAttribArray(r), n[r] = 0)
            }

            function y(t, n, r, i, o, a, s) {
                !0 === s ? e.vertexAttribIPointer(t, n, r, o, a) : e.vertexAttribPointer(t, n, r, i, o, a)
            }

            function b() {
                x(), u = !0, c !== l && (c = l, d(c.object))
            }

            function x() {
                l.geometry = null, l.program = null, l.wireframe = !1
            }
            return {
                setup: function(i, l, h, b, x) {
                    let _ = !1;
                    if (a) {
                        const t = function(t, n, i) {
                            const a = !0 === i.wireframe;
                            let l = s[t.id];
                            void 0 === l && (l = {}, s[t.id] = l);
                            let c = l[n.id];
                            void 0 === c && (c = {}, l[n.id] = c);
                            let u = c[a];
                            void 0 === u && (u = p(r.isWebGL2 ? e.createVertexArray() : o.createVertexArrayOES()), c[a] = u);
                            return u
                        }(b, h, l);
                        c !== t && (c = t, d(c.object)), _ = function(e, t, n, r) {
                            const i = c.attributes,
                                o = t.attributes;
                            let a = 0;
                            const s = n.getAttributes();
                            for (const l in s) {
                                if (s[l].location >= 0) {
                                    const t = i[l];
                                    let n = o[l];
                                    if (void 0 === n && ("instanceMatrix" === l && e.instanceMatrix && (n = e.instanceMatrix), "instanceColor" === l && e.instanceColor && (n = e.instanceColor)), void 0 === t) return !0;
                                    if (t.attribute !== n) return !0;
                                    if (n && t.data !== n.data) return !0;
                                    a++
                                }
                            }
                            return c.attributesNum !== a || c.index !== r
                        }(i, b, h, x), _ && function(e, t, n, r) {
                            const i = {},
                                o = t.attributes;
                            let a = 0;
                            const s = n.getAttributes();
                            for (const l in s) {
                                if (s[l].location >= 0) {
                                    let t = o[l];
                                    void 0 === t && ("instanceMatrix" === l && e.instanceMatrix && (t = e.instanceMatrix), "instanceColor" === l && e.instanceColor && (t = e.instanceColor));
                                    const n = {};
                                    n.attribute = t, t && t.data && (n.data = t.data), i[l] = n, a++
                                }
                            }
                            c.attributes = i, c.attributesNum = a, c.index = r
                        }(i, b, h, x)
                    } else {
                        const e = !0 === l.wireframe;
                        c.geometry === b.id && c.program === h.id && c.wireframe === e || (c.geometry = b.id, c.program = h.id, c.wireframe = e, _ = !0)
                    }
                    null !== x && n.update(x, e.ELEMENT_ARRAY_BUFFER), (_ || u) && (u = !1, function(i, o, a, s) {
                        if (!1 === r.isWebGL2 && (i.isInstancedMesh || s.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays")) return;
                        f();
                        const l = s.attributes,
                            c = a.getAttributes(),
                            u = o.defaultAttributeValues;
                        for (const t in c) {
                            const o = c[t];
                            if (o.location >= 0) {
                                let a = l[t];
                                if (void 0 === a && ("instanceMatrix" === t && i.instanceMatrix && (a = i.instanceMatrix), "instanceColor" === t && i.instanceColor && (a = i.instanceColor)), void 0 !== a) {
                                    const t = a.normalized,
                                        l = a.itemSize,
                                        c = n.get(a);
                                    if (void 0 === c) continue;
                                    const u = c.buffer,
                                        d = c.type,
                                        h = c.bytesPerElement,
                                        p = !0 === r.isWebGL2 && (d === e.INT || d === e.UNSIGNED_INT || a.gpuType === Cs);
                                    if (a.isInterleavedBufferAttribute) {
                                        const n = a.data,
                                            r = n.stride,
                                            c = a.offset;
                                        if (n.isInstancedInterleavedBuffer) {
                                            for (let e = 0; e < o.locationSize; e++) g(o.location + e, n.meshPerAttribute);
                                            !0 !== i.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = n.meshPerAttribute * n.count)
                                        } else
                                            for (let e = 0; e < o.locationSize; e++) m(o.location + e);
                                        e.bindBuffer(e.ARRAY_BUFFER, u);
                                        for (let e = 0; e < o.locationSize; e++) y(o.location + e, l / o.locationSize, d, t, r * h, (c + l / o.locationSize * e) * h, p)
                                    } else {
                                        if (a.isInstancedBufferAttribute) {
                                            for (let e = 0; e < o.locationSize; e++) g(o.location + e, a.meshPerAttribute);
                                            !0 !== i.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = a.meshPerAttribute * a.count)
                                        } else
                                            for (let e = 0; e < o.locationSize; e++) m(o.location + e);
                                        e.bindBuffer(e.ARRAY_BUFFER, u);
                                        for (let e = 0; e < o.locationSize; e++) y(o.location + e, l / o.locationSize, d, t, l * h, l / o.locationSize * e * h, p)
                                    }
                                } else if (void 0 !== u) {
                                    const n = u[t];
                                    if (void 0 !== n) switch (n.length) {
                                        case 2:
                                            e.vertexAttrib2fv(o.location, n);
                                            break;
                                        case 3:
                                            e.vertexAttrib3fv(o.location, n);
                                            break;
                                        case 4:
                                            e.vertexAttrib4fv(o.location, n);
                                            break;
                                        default:
                                            e.vertexAttrib1fv(o.location, n)
                                    }
                                }
                            }
                        }
                        v()
                    }(i, l, h, b), null !== x && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n.get(x).buffer))
                },
                reset: b,
                resetDefaultState: x,
                dispose: function() {
                    b();
                    for (const e in s) {
                        const t = s[e];
                        for (const e in t) {
                            const n = t[e];
                            for (const e in n) h(n[e].object), delete n[e];
                            delete t[e]
                        }
                        delete s[e]
                    }
                },
                releaseStatesOfGeometry: function(e) {
                    if (void 0 === s[e.id]) return;
                    const t = s[e.id];
                    for (const n in t) {
                        const e = t[n];
                        for (const t in e) h(e[t].object), delete e[t];
                        delete t[n]
                    }
                    delete s[e.id]
                },
                releaseStatesOfProgram: function(e) {
                    for (const t in s) {
                        const n = s[t];
                        if (void 0 === n[e.id]) continue;
                        const r = n[e.id];
                        for (const e in r) h(r[e].object), delete r[e];
                        delete n[e.id]
                    }
                },
                initAttributes: f,
                enableAttribute: m,
                disableUnusedAttributes: v
            }
        }

        function bp(e, t, n, r) {
            const i = r.isWebGL2;
            let o;
            this.setMode = function(e) {
                o = e
            }, this.render = function(t, r) {
                e.drawArrays(o, t, r), n.update(r, o, 1)
            }, this.renderInstances = function(r, a, s) {
                if (0 === s) return;
                let l, c;
                if (i) l = e, c = "drawArraysInstanced";
                else if (l = t.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                l[c](o, r, a, s), n.update(a, o, s)
            }, this.renderMultiDraw = function(e, r, i) {
                if (0 === i) return;
                const a = t.get("WEBGL_multi_draw");
                if (null === a)
                    for (let t = 0; t < i; t++) this.render(e[t], r[t]);
                else {
                    a.multiDrawArraysWEBGL(o, e, 0, r, 0, i);
                    let t = 0;
                    for (let e = 0; e < i; e++) t += r[e];
                    n.update(t, o, 1)
                }
            }
        }

        function xp(e, t, n) {
            let r;

            function i(t) {
                if ("highp" === t) {
                    if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0) return "highp";
                    t = "mediump"
                }
                return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
            }
            const o = "undefined" !== typeof WebGL2RenderingContext && "WebGL2RenderingContext" === e.constructor.name;
            let a = void 0 !== n.precision ? n.precision : "highp";
            const s = i(a);
            s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."), a = s);
            const l = o || t.has("WEBGL_draw_buffers"),
                c = !0 === n.logarithmicDepthBuffer,
                u = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
                d = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                h = e.getParameter(e.MAX_TEXTURE_SIZE),
                p = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
                f = e.getParameter(e.MAX_VERTEX_ATTRIBS),
                m = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
                g = e.getParameter(e.MAX_VARYING_VECTORS),
                v = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
                y = d > 0,
                b = o || t.has("OES_texture_float");
            return {
                isWebGL2: o,
                drawBuffers: l,
                getMaxAnisotropy: function() {
                    if (void 0 !== r) return r;
                    if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                        const n = t.get("EXT_texture_filter_anisotropic");
                        r = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    } else r = 0;
                    return r
                },
                getMaxPrecision: i,
                precision: a,
                logarithmicDepthBuffer: c,
                maxTextures: u,
                maxVertexTextures: d,
                maxTextureSize: h,
                maxCubemapSize: p,
                maxAttributes: f,
                maxVertexUniforms: m,
                maxVaryings: g,
                maxFragmentUniforms: v,
                vertexTextures: y,
                floatFragmentTextures: b,
                floatVertexTextures: y && b,
                maxSamples: o ? e.getParameter(e.MAX_SAMPLES) : 0
            }
        }

        function _p(e) {
            const t = this;
            let n = null,
                r = 0,
                i = !1,
                o = !1;
            const a = new ap,
                s = new Qc,
                l = {
                    value: null,
                    needsUpdate: !1
                };

            function c(e, n, r, i) {
                const o = null !== e ? e.length : 0;
                let c = null;
                if (0 !== o) {
                    if (c = l.value, !0 !== i || null === c) {
                        const t = r + 4 * o,
                            i = n.matrixWorldInverse;
                        s.getNormalMatrix(i), (null === c || c.length < t) && (c = new Float32Array(t));
                        for (let n = 0, l = r; n !== o; ++n, l += 4) a.copy(e[n]).applyMatrix4(i, s), a.normal.toArray(c, l), c[l + 3] = a.constant
                    }
                    l.value = c, l.needsUpdate = !0
                }
                return t.numPlanes = o, t.numIntersection = 0, c
            }
            this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e, t) {
                const n = 0 !== e.length || t || 0 !== r || i;
                return i = t, r = e.length, n
            }, this.beginShadows = function() {
                o = !0, c(null)
            }, this.endShadows = function() {
                o = !1
            }, this.setGlobalState = function(e, t) {
                n = c(e, t, 0)
            }, this.setState = function(a, s, u) {
                const d = a.clippingPlanes,
                    h = a.clipIntersection,
                    p = a.clipShadows,
                    f = e.get(a);
                if (!i || null === d || 0 === d.length || o && !p) o ? c(null) : function() {
                    l.value !== n && (l.value = n, l.needsUpdate = r > 0);
                    t.numPlanes = r, t.numIntersection = 0
                }();
                else {
                    const e = o ? 0 : r,
                        t = 4 * e;
                    let i = f.clippingState || null;
                    l.value = i, i = c(d, s, t, u);
                    for (let r = 0; r !== t; ++r) i[r] = n[r];
                    f.clippingState = i, this.numIntersection = h ? this.numPlanes : 0, this.numPlanes += e
                }
            }
        }

        function Mp(e) {
            let t = new WeakMap;

            function n(e, t) {
                return t === ss ? e.mapping = os : t === ls && (e.mapping = as), e
            }

            function r(e) {
                const n = e.target;
                n.removeEventListener("dispose", r);
                const i = t.get(n);
                void 0 !== i && (t.delete(n), i.dispose())
            }
            return {
                get: function(i) {
                    if (i && i.isTexture) {
                        const o = i.mapping;
                        if (o === ss || o === ls) {
                            if (t.has(i)) {
                                return n(t.get(i).texture, i.mapping)
                            } {
                                const o = i.image;
                                if (o && o.height > 0) {
                                    const a = new np(o.height);
                                    return a.fromEquirectangularTexture(e, i), t.set(i, a), i.addEventListener("dispose", r), n(a.texture, i.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return i
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }
        class wp extends Kh {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : -1,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : -1,
                    i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : .1,
                    o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 2e3;
                super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = r, this.near = i, this.far = o, this.updateProjectionMatrix()
            }
            copy(e, t) {
                return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
            }
            setViewOffset(e, t, n, r, i, o) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const e = (this.right - this.left) / (2 * this.zoom),
                    t = (this.top - this.bottom) / (2 * this.zoom),
                    n = (this.right + this.left) / 2,
                    r = (this.top + this.bottom) / 2;
                let i = n - e,
                    o = n + e,
                    a = r + t,
                    s = r - t;
                if (null !== this.view && this.view.enabled) {
                    const e = (this.right - this.left) / this.view.fullWidth / this.zoom,
                        t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    i += e * this.view.offsetX, o = i + e * this.view.width, a -= t * this.view.offsetY, s = a - t * this.view.height
                }
                this.projectionMatrix.makeOrthographic(i, o, a, s, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
            }
        }
        const Ap = [.125, .215, .35, .446, .526, .582],
            Sp = 20,
            Ep = new wp,
            Cp = new Wd;
        let Tp = null,
            Pp = 0,
            Rp = 0;
        const Ip = (1 + Math.sqrt(5)) / 2,
            Op = 1 / Ip,
            Bp = [new Pu(1, 1, 1), new Pu(-1, 1, 1), new Pu(1, 1, -1), new Pu(-1, 1, -1), new Pu(0, Ip, Op), new Pu(0, Ip, -Op), new Pu(Op, 0, Ip), new Pu(-Op, 0, Ip), new Pu(Ip, Op, 0), new Pu(-Ip, Op, 0)];
        class Lp {
            constructor(e) {
                this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
            }
            fromScene(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .1,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 100;
                Tp = this._renderer.getRenderTarget(), Pp = this._renderer.getActiveCubeFace(), Rp = this._renderer.getActiveMipmapLevel(), this._setSize(256);
                const i = this._allocateTargets();
                return i.depthBuffer = !0, this._sceneToCubeUV(e, n, r, i), t > 0 && this._blur(i, 0, 0, t), this._applyPMREM(i), this._cleanup(i), i
            }
            fromEquirectangular(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                return this._fromTexture(e, t)
            }
            fromCubemap(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                return this._fromTexture(e, t)
            }
            compileCubemapShader() {
                null === this._cubemapMaterial && (this._cubemapMaterial = Fp(), this._compileMaterial(this._cubemapMaterial))
            }
            compileEquirectangularShader() {
                null === this._equirectMaterial && (this._equirectMaterial = kp(), this._compileMaterial(this._equirectMaterial))
            }
            dispose() {
                this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose()
            }
            _setSize(e) {
                this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax)
            }
            _dispose() {
                null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose()
            }
            _cleanup(e) {
                this._renderer.setRenderTarget(Tp, Pp, Rp), e.scissorTest = !1, Np(e, 0, 0, e.width, e.height)
            }
            _fromTexture(e, t) {
                e.mapping === os || e.mapping === as ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Tp = this._renderer.getRenderTarget(), Pp = this._renderer.getActiveCubeFace(), Rp = this._renderer.getActiveMipmapLevel();
                const n = t || this._allocateTargets();
                return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
            }
            _allocateTargets() {
                const e = 3 * Math.max(this._cubeSize, 112),
                    t = 4 * this._cubeSize,
                    n = {
                        magFilter: ys,
                        minFilter: ys,
                        generateMipmaps: !1,
                        type: Rs,
                        format: Ds,
                        colorSpace: ql,
                        depthBuffer: !1
                    },
                    r = Dp(e, t, n);
                if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
                    null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = Dp(e, t, n);
                    const {
                        _lodMax: r
                    } = this;
                    ({
                        sizeLods: this._sizeLods,
                        lodPlanes: this._lodPlanes,
                        sigmas: this._sigmas
                    } = function(e) {
                        const t = [],
                            n = [],
                            r = [];
                        let i = e;
                        const o = e - 4 + 1 + Ap.length;
                        for (let a = 0; a < o; a++) {
                            const o = Math.pow(2, i);
                            n.push(o);
                            let s = 1 / o;
                            a > e - 4 ? s = Ap[a - e + 4 - 1] : 0 === a && (s = 0), r.push(s);
                            const l = 1 / (o - 2),
                                c = -l,
                                u = 1 + l,
                                d = [c, c, u, c, u, u, c, c, u, u, c, u],
                                h = 6,
                                p = 6,
                                f = 3,
                                m = 2,
                                g = 1,
                                v = new Float32Array(f * p * h),
                                y = new Float32Array(m * p * h),
                                b = new Float32Array(g * p * h);
                            for (let e = 0; e < h; e++) {
                                const t = e % 3 * 2 / 3 - 1,
                                    n = e > 2 ? 0 : -1,
                                    r = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0];
                                v.set(r, f * p * e), y.set(d, m * p * e);
                                const i = [e, e, e, e, e, e];
                                b.set(i, g * p * e)
                            }
                            const x = new Mh;
                            x.setAttribute("position", new ih(v, f)), x.setAttribute("uv", new ih(y, m)), x.setAttribute("faceIndex", new ih(b, g)), t.push(x), i > 4 && i--
                        }
                        return {
                            lodPlanes: t,
                            sizeLods: n,
                            sigmas: r
                        }
                    }(r)), this._blurMaterial = function(e, t, n) {
                        const r = new Float32Array(Sp),
                            i = new Pu(0, 1, 0),
                            o = new Xh({
                                name: "SphericalGaussianBlur",
                                defines: {
                                    n: Sp,
                                    CUBEUV_TEXEL_WIDTH: 1 / t,
                                    CUBEUV_TEXEL_HEIGHT: 1 / n,
                                    CUBEUV_MAX_MIP: "".concat(e, ".0")
                                },
                                uniforms: {
                                    envMap: {
                                        value: null
                                    },
                                    samples: {
                                        value: 1
                                    },
                                    weights: {
                                        value: r
                                    },
                                    latitudinal: {
                                        value: !1
                                    },
                                    dTheta: {
                                        value: 0
                                    },
                                    mipInt: {
                                        value: 0
                                    },
                                    poleAxis: {
                                        value: i
                                    }
                                },
                                vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                                blending: ha,
                                depthTest: !1,
                                depthWrite: !1
                            });
                        return o
                    }(r, e, t)
                }
                return r
            }
            _compileMaterial(e) {
                const t = new zh(this._lodPlanes[0], e);
                this._renderer.compile(t, Ep)
            }
            _sceneToCubeUV(e, t, n, r) {
                const i = new Zh(90, 1, t, n),
                    o = [1, -1, 1, 1, 1, 1],
                    a = [1, 1, 1, -1, -1, -1],
                    s = this._renderer,
                    l = s.autoClear,
                    c = s.toneMapping;
                s.getClearColor(Cp), s.toneMapping = Ja, s.autoClear = !1;
                const u = new Yd({
                        name: "PMREM.Background",
                        side: ua,
                        depthWrite: !1,
                        depthTest: !1
                    }),
                    d = new zh(new jh, u);
                let h = !1;
                const p = e.background;
                p ? p.isColor && (u.color.copy(p), e.background = null, h = !0) : (u.color.copy(Cp), h = !0);
                for (let f = 0; f < 6; f++) {
                    const t = f % 3;
                    0 === t ? (i.up.set(0, o[f], 0), i.lookAt(a[f], 0, 0)) : 1 === t ? (i.up.set(0, 0, o[f]), i.lookAt(0, a[f], 0)) : (i.up.set(0, o[f], 0), i.lookAt(0, 0, a[f]));
                    const n = this._cubeSize;
                    Np(r, t * n, f > 2 ? n : 0, n, n), s.setRenderTarget(r), h && s.render(d, i), s.render(e, i)
                }
                d.geometry.dispose(), d.material.dispose(), s.toneMapping = c, s.autoClear = l, e.background = p
            }
            _textureToCubeUV(e, t) {
                const n = this._renderer,
                    r = e.mapping === os || e.mapping === as;
                r ? (null === this._cubemapMaterial && (this._cubemapMaterial = Fp()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = kp());
                const i = r ? this._cubemapMaterial : this._equirectMaterial,
                    o = new zh(this._lodPlanes[0], i);
                i.uniforms.envMap.value = e;
                const a = this._cubeSize;
                Np(t, 0, 0, 3 * a, 2 * a), n.setRenderTarget(t), n.render(o, Ep)
            }
            _applyPMREM(e) {
                const t = this._renderer,
                    n = t.autoClear;
                t.autoClear = !1;
                for (let r = 1; r < this._lodPlanes.length; r++) {
                    const t = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]),
                        n = Bp[(r - 1) % Bp.length];
                    this._blur(e, r - 1, r, t, n)
                }
                t.autoClear = n
            }
            _blur(e, t, n, r, i) {
                const o = this._pingPongRenderTarget;
                this._halfBlur(e, o, t, n, r, "latitudinal", i), this._halfBlur(o, e, n, n, r, "longitudinal", i)
            }
            _halfBlur(e, t, n, r, i, o, a) {
                const s = this._renderer,
                    l = this._blurMaterial;
                "latitudinal" !== o && "longitudinal" !== o && console.error("blur direction must be either latitudinal or longitudinal!");
                const c = new zh(this._lodPlanes[r], l),
                    u = l.uniforms,
                    d = this._sizeLods[n] - 1,
                    h = isFinite(i) ? Math.PI / (2 * d) : 2 * Math.PI / 39,
                    p = i / h,
                    f = isFinite(i) ? 1 + Math.floor(3 * p) : Sp;
                f > Sp && console.warn("sigmaRadians, ".concat(i, ", is too large and will clip, as it requested ").concat(f, " samples when the maximum is set to ").concat(Sp));
                const m = [];
                let g = 0;
                for (let b = 0; b < Sp; ++b) {
                    const e = b / p,
                        t = Math.exp(-e * e / 2);
                    m.push(t), 0 === b ? g += t : b < f && (g += 2 * t)
                }
                for (let b = 0; b < m.length; b++) m[b] = m[b] / g;
                u.envMap.value = e.texture, u.samples.value = f, u.weights.value = m, u.latitudinal.value = "latitudinal" === o, a && (u.poleAxis.value = a);
                const {
                    _lodMax: v
                } = this;
                u.dTheta.value = h, u.mipInt.value = v - n;
                const y = this._sizeLods[r];
                Np(t, 3 * y * (r > v - 4 ? r - v + 4 : 0), 4 * (this._cubeSize - y), 3 * y, 2 * y), s.setRenderTarget(t), s.render(c, Ep)
            }
        }

        function Dp(e, t, n) {
            const r = new Mu(e, t, n);
            return r.texture.mapping = cs, r.texture.name = "PMREM.cubeUv", r.scissorTest = !0, r
        }

        function Np(e, t, n, r, i) {
            e.viewport.set(t, n, r, i), e.scissor.set(t, n, r, i)
        }

        function kp() {
            return new Xh({
                name: "EquirectangularToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    }
                },
                vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                blending: ha,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function Fp() {
            return new Xh({
                name: "CubemapToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    }
                },
                vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                blending: ha,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function Up(e) {
            let t = new WeakMap,
                n = null;

            function r(e) {
                const n = e.target;
                n.removeEventListener("dispose", r);
                const i = t.get(n);
                void 0 !== i && (t.delete(n), i.dispose())
            }
            return {
                get: function(i) {
                    if (i && i.isTexture) {
                        const o = i.mapping,
                            a = o === ss || o === ls,
                            s = o === os || o === as;
                        if (a || s) {
                            if (i.isRenderTargetTexture && !0 === i.needsPMREMUpdate) {
                                i.needsPMREMUpdate = !1;
                                let r = t.get(i);
                                return null === n && (n = new Lp(e)), r = a ? n.fromEquirectangular(i, r) : n.fromCubemap(i, r), t.set(i, r), r.texture
                            }
                            if (t.has(i)) return t.get(i).texture; {
                                const o = i.image;
                                if (a && o && o.height > 0 || s && o && function(e) {
                                        let t = 0;
                                        const n = 6;
                                        for (let r = 0; r < n; r++) void 0 !== e[r] && t++;
                                        return t === n
                                    }(o)) {
                                    null === n && (n = new Lp(e));
                                    const o = a ? n.fromEquirectangular(i) : n.fromCubemap(i);
                                    return t.set(i, o), i.addEventListener("dispose", r), o.texture
                                }
                                return null
                            }
                        }
                    }
                    return i
                },
                dispose: function() {
                    t = new WeakMap, null !== n && (n.dispose(), n = null)
                }
            }
        }

        function zp(e) {
            const t = {};

            function n(n) {
                if (void 0 !== t[n]) return t[n];
                let r;
                switch (n) {
                    case "WEBGL_depth_texture":
                        r = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        r = e.getExtension(n)
                }
                return t[n] = r, r
            }
            return {
                has: function(e) {
                    return null !== n(e)
                },
                init: function(e) {
                    e.isWebGL2 ? (n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance")) : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture")
                },
                get: function(e) {
                    const t = n(e);
                    return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), t
                }
            }
        }

        function Hp(e, t, n, r) {
            const i = {},
                o = new WeakMap;

            function a(e) {
                const s = e.target;
                null !== s.index && t.remove(s.index);
                for (const n in s.attributes) t.remove(s.attributes[n]);
                for (const n in s.morphAttributes) {
                    const e = s.morphAttributes[n];
                    for (let n = 0, r = e.length; n < r; n++) t.remove(e[n])
                }
                s.removeEventListener("dispose", a), delete i[s.id];
                const l = o.get(s);
                l && (t.remove(l), o.delete(s)), r.releaseStatesOfGeometry(s), !0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount, n.memory.geometries--
            }

            function s(e) {
                const n = [],
                    r = e.index,
                    i = e.attributes.position;
                let a = 0;
                if (null !== r) {
                    const e = r.array;
                    a = r.version;
                    for (let t = 0, r = e.length; t < r; t += 3) {
                        const r = e[t + 0],
                            i = e[t + 1],
                            o = e[t + 2];
                        n.push(r, i, i, o, o, r)
                    }
                } else {
                    if (void 0 === i) return; {
                        const e = i.array;
                        a = i.version;
                        for (let t = 0, r = e.length / 3 - 1; t < r; t += 3) {
                            const e = t + 0,
                                r = t + 1,
                                i = t + 2;
                            n.push(e, r, r, i, i, e)
                        }
                    }
                }
                const s = new($c(n) ? dh : ch)(n, 1);
                s.version = a;
                const l = o.get(e);
                l && t.remove(l), o.set(e, s)
            }
            return {
                get: function(e, t) {
                    return !0 === i[t.id] || (t.addEventListener("dispose", a), i[t.id] = !0, n.memory.geometries++), t
                },
                update: function(n) {
                    const r = n.attributes;
                    for (const o in r) t.update(r[o], e.ARRAY_BUFFER);
                    const i = n.morphAttributes;
                    for (const o in i) {
                        const n = i[o];
                        for (let r = 0, i = n.length; r < i; r++) t.update(n[r], e.ARRAY_BUFFER)
                    }
                },
                getWireframeAttribute: function(e) {
                    const t = o.get(e);
                    if (t) {
                        const n = e.index;
                        null !== n && t.version < n.version && s(e)
                    } else s(e);
                    return o.get(e)
                }
            }
        }

        function jp(e, t, n, r) {
            const i = r.isWebGL2;
            let o, a, s;
            this.setMode = function(e) {
                o = e
            }, this.setIndex = function(e) {
                a = e.type, s = e.bytesPerElement
            }, this.render = function(t, r) {
                e.drawElements(o, r, a, t * s), n.update(r, o, 1)
            }, this.renderInstances = function(r, l, c) {
                if (0 === c) return;
                let u, d;
                if (i) u = e, d = "drawElementsInstanced";
                else if (u = t.get("ANGLE_instanced_arrays"), d = "drawElementsInstancedANGLE", null === u) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                u[d](o, l, a, r * s, c), n.update(l, o, c)
            }, this.renderMultiDraw = function(e, r, i) {
                if (0 === i) return;
                const l = t.get("WEBGL_multi_draw");
                if (null === l)
                    for (let t = 0; t < i; t++) this.render(e[t] / s, r[t]);
                else {
                    l.multiDrawElementsWEBGL(o, r, 0, a, e, 0, i);
                    let t = 0;
                    for (let e = 0; e < i; e++) t += r[e];
                    n.update(t, o, 1)
                }
            }
        }

        function Gp(e) {
            const t = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: t,
                programs: null,
                autoReset: !0,
                reset: function() {
                    t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
                },
                update: function(n, r, i) {
                    switch (t.calls++, r) {
                        case e.TRIANGLES:
                            t.triangles += i * (n / 3);
                            break;
                        case e.LINES:
                            t.lines += i * (n / 2);
                            break;
                        case e.LINE_STRIP:
                            t.lines += i * (n - 1);
                            break;
                        case e.LINE_LOOP:
                            t.lines += i * n;
                            break;
                        case e.POINTS:
                            t.points += i * n;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", r)
                    }
                }
            }
        }

        function Vp(e, t) {
            return e[0] - t[0]
        }

        function qp(e, t) {
            return Math.abs(t[1]) - Math.abs(e[1])
        }

        function Wp(e, t, n) {
            const r = {},
                i = new Float32Array(8),
                o = new WeakMap,
                a = new xu,
                s = [];
            for (let l = 0; l < 8; l++) s[l] = [l, 0];
            return {
                update: function(l, c, u) {
                    const d = l.morphTargetInfluences;
                    if (!0 === t.isWebGL2) {
                        const h = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color,
                            p = void 0 !== h ? h.length : 0;
                        let f = o.get(c);
                        if (void 0 === f || f.count !== p) {
                            void 0 !== f && f.texture.dispose();
                            const v = void 0 !== c.morphAttributes.position,
                                y = void 0 !== c.morphAttributes.normal,
                                b = void 0 !== c.morphAttributes.color,
                                x = c.morphAttributes.position || [],
                                _ = c.morphAttributes.normal || [],
                                M = c.morphAttributes.color || [];
                            let w = 0;
                            !0 === v && (w = 1), !0 === y && (w = 2), !0 === b && (w = 3);
                            let A = c.attributes.position.count * w,
                                S = 1;
                            A > t.maxTextureSize && (S = Math.ceil(A / t.maxTextureSize), A = t.maxTextureSize);
                            const E = new Float32Array(A * S * 4 * p),
                                C = new wu(E, A, S, p);
                            C.type = Ps, C.needsUpdate = !0;
                            const T = 4 * w;
                            for (let R = 0; R < p; R++) {
                                const I = x[R],
                                    O = _[R],
                                    B = M[R],
                                    L = A * S * 4 * R;
                                for (let D = 0; D < I.count; D++) {
                                    const N = D * T;
                                    !0 === v && (a.fromBufferAttribute(I, D), E[L + N + 0] = a.x, E[L + N + 1] = a.y, E[L + N + 2] = a.z, E[L + N + 3] = 0), !0 === y && (a.fromBufferAttribute(O, D), E[L + N + 4] = a.x, E[L + N + 5] = a.y, E[L + N + 6] = a.z, E[L + N + 7] = 0), !0 === b && (a.fromBufferAttribute(B, D), E[L + N + 8] = a.x, E[L + N + 9] = a.y, E[L + N + 10] = a.z, E[L + N + 11] = 4 === B.itemSize ? a.w : 1)
                                }
                            }

                            function P() {
                                C.dispose(), o.delete(c), c.removeEventListener("dispose", P)
                            }
                            f = {
                                count: p,
                                texture: C,
                                size: new Yc(A, S)
                            }, o.set(c, f), c.addEventListener("dispose", P)
                        }
                        let m = 0;
                        for (let k = 0; k < d.length; k++) m += d[k];
                        const g = c.morphTargetsRelative ? 1 : 1 - m;
                        u.getUniforms().setValue(e, "morphTargetBaseInfluence", g), u.getUniforms().setValue(e, "morphTargetInfluences", d), u.getUniforms().setValue(e, "morphTargetsTexture", f.texture, n), u.getUniforms().setValue(e, "morphTargetsTextureSize", f.size)
                    } else {
                        const F = void 0 === d ? 0 : d.length;
                        let U = r[c.id];
                        if (void 0 === U || U.length !== F) {
                            U = [];
                            for (let V = 0; V < F; V++) U[V] = [V, 0];
                            r[c.id] = U
                        }
                        for (let q = 0; q < F; q++) {
                            const W = U[q];
                            W[0] = q, W[1] = d[q]
                        }
                        U.sort(qp);
                        for (let X = 0; X < 8; X++) X < F && U[X][1] ? (s[X][0] = U[X][0], s[X][1] = U[X][1]) : (s[X][0] = Number.MAX_SAFE_INTEGER, s[X][1] = 0);
                        s.sort(Vp);
                        const z = c.morphAttributes.position,
                            H = c.morphAttributes.normal;
                        let j = 0;
                        for (let K = 0; K < 8; K++) {
                            const J = s[K],
                                Y = J[0],
                                Q = J[1];
                            Y !== Number.MAX_SAFE_INTEGER && Q ? (z && c.getAttribute("morphTarget" + K) !== z[Y] && c.setAttribute("morphTarget" + K, z[Y]), H && c.getAttribute("morphNormal" + K) !== H[Y] && c.setAttribute("morphNormal" + K, H[Y]), i[K] = Q, j += Q) : (z && !0 === c.hasAttribute("morphTarget" + K) && c.deleteAttribute("morphTarget" + K), H && !0 === c.hasAttribute("morphNormal" + K) && c.deleteAttribute("morphNormal" + K), i[K] = 0)
                        }
                        const G = c.morphTargetsRelative ? 1 : 1 - j;
                        u.getUniforms().setValue(e, "morphTargetBaseInfluence", G), u.getUniforms().setValue(e, "morphTargetInfluences", i)
                    }
                }
            }
        }

        function Xp(e, t, n, r) {
            let i = new WeakMap;

            function o(e) {
                const t = e.target;
                t.removeEventListener("dispose", o), n.remove(t.instanceMatrix), null !== t.instanceColor && n.remove(t.instanceColor)
            }
            return {
                update: function(a) {
                    const s = r.render.frame,
                        l = a.geometry,
                        c = t.get(a, l);
                    if (i.get(c) !== s && (t.update(c), i.set(c, s)), a.isInstancedMesh && (!1 === a.hasEventListener("dispose", o) && a.addEventListener("dispose", o), i.get(a) !== s && (n.update(a.instanceMatrix, e.ARRAY_BUFFER), null !== a.instanceColor && n.update(a.instanceColor, e.ARRAY_BUFFER), i.set(a, s))), a.isSkinnedMesh) {
                        const e = a.skeleton;
                        i.get(e) !== s && (e.update(), i.set(e, s))
                    }
                    return c
                },
                dispose: function() {
                    i = new WeakMap
                }
            }
        }
        class Kp extends bu {
            constructor(e, t, n, r, i, o, a, s, l, c) {
                if ((c = void 0 !== c ? c : Fs) !== Fs && c !== Us) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && c === Fs && (n = Ts), void 0 === n && c === Us && (n = Bs), super(null, r, i, o, a, s, c, n, l), this.isDepthTexture = !0, this.image = {
                    width: e,
                    height: t
                }, this.magFilter = void 0 !== a ? a : ps, this.minFilter = void 0 !== s ? s : ps, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
            }
            copy(e) {
                return super.copy(e), this.compareFunction = e.compareFunction, this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return null !== this.compareFunction && (t.compareFunction = this.compareFunction), t
            }
        }
        const Jp = new bu,
            Yp = new Kp(1, 1);
        Yp.compareFunction = vc;
        const Qp = new wu,
            Zp = new Su,
            $p = new tp,
            ef = [],
            tf = [],
            nf = new Float32Array(16),
            rf = new Float32Array(9),
            of = new Float32Array(4);

        function af(e, t, n) {
            const r = e[0];
            if (r <= 0 || r > 0) return e;
            const i = t * n;
            let o = ef[i];
            if (void 0 === o && (o = new Float32Array(i), ef[i] = o), 0 !== t) {
                r.toArray(o, 0);
                for (let r = 1, i = 0; r !== t; ++r) i += n, e[r].toArray(o, i)
            }
            return o
        }

        function sf(e, t) {
            if (e.length !== t.length) return !1;
            for (let n = 0, r = e.length; n < r; n++)
                if (e[n] !== t[n]) return !1;
            return !0
        }

        function lf(e, t) {
            for (let n = 0, r = t.length; n < r; n++) e[n] = t[n]
        }

        function cf(e, t) {
            let n = tf[t];
            void 0 === n && (n = new Int32Array(t), tf[t] = n);
            for (let r = 0; r !== t; ++r) n[r] = e.allocateTextureUnit();
            return n
        }

        function uf(e, t) {
            const n = this.cache;
            n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
        }

        function df(e, t) {
            const n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
            else {
                if (sf(n, t)) return;
                e.uniform2fv(this.addr, t), lf(n, t)
            }
        }

        function hf(e, t) {
            const n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
            else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
            else {
                if (sf(n, t)) return;
                e.uniform3fv(this.addr, t), lf(n, t)
            }
        }

        function pf(e, t) {
            const n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
            else {
                if (sf(n, t)) return;
                e.uniform4fv(this.addr, t), lf(n, t)
            }
        }

        function ff(e, t) {
            const n = this.cache,
                r = t.elements;
            if (void 0 === r) {
                if (sf(n, t)) return;
                e.uniformMatrix2fv(this.addr, !1, t), lf(n, t)
            } else {
                if (sf(n, r)) return; of .set(r), e.uniformMatrix2fv(this.addr, !1, of ), lf(n, r)
            }
        }

        function mf(e, t) {
            const n = this.cache,
                r = t.elements;
            if (void 0 === r) {
                if (sf(n, t)) return;
                e.uniformMatrix3fv(this.addr, !1, t), lf(n, t)
            } else {
                if (sf(n, r)) return;
                rf.set(r), e.uniformMatrix3fv(this.addr, !1, rf), lf(n, r)
            }
        }

        function gf(e, t) {
            const n = this.cache,
                r = t.elements;
            if (void 0 === r) {
                if (sf(n, t)) return;
                e.uniformMatrix4fv(this.addr, !1, t), lf(n, t)
            } else {
                if (sf(n, r)) return;
                nf.set(r), e.uniformMatrix4fv(this.addr, !1, nf), lf(n, r)
            }
        }

        function vf(e, t) {
            const n = this.cache;
            n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
        }

        function yf(e, t) {
            const n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2i(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
            else {
                if (sf(n, t)) return;
                e.uniform2iv(this.addr, t), lf(n, t)
            }
        }

        function bf(e, t) {
            const n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3i(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
            else {
                if (sf(n, t)) return;
                e.uniform3iv(this.addr, t), lf(n, t)
            }
        }

        function xf(e, t) {
            const n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4i(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
            else {
                if (sf(n, t)) return;
                e.uniform4iv(this.addr, t), lf(n, t)
            }
        }

        function _f(e, t) {
            const n = this.cache;
            n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t)
        }

        function Mf(e, t) {
            const n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2ui(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
            else {
                if (sf(n, t)) return;
                e.uniform2uiv(this.addr, t), lf(n, t)
            }
        }

        function wf(e, t) {
            const n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3ui(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
            else {
                if (sf(n, t)) return;
                e.uniform3uiv(this.addr, t), lf(n, t)
            }
        }

        function Af(e, t) {
            const n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
            else {
                if (sf(n, t)) return;
                e.uniform4uiv(this.addr, t), lf(n, t)
            }
        }

        function Sf(e, t, n) {
            const r = this.cache,
                i = n.allocateTextureUnit();
            r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i);
            const o = this.type === e.SAMPLER_2D_SHADOW ? Yp : Jp;
            n.setTexture2D(t || o, i)
        }

        function Ef(e, t, n) {
            const r = this.cache,
                i = n.allocateTextureUnit();
            r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(t || Zp, i)
        }

        function Cf(e, t, n) {
            const r = this.cache,
                i = n.allocateTextureUnit();
            r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTextureCube(t || $p, i)
        }

        function Tf(e, t, n) {
            const r = this.cache,
                i = n.allocateTextureUnit();
            r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(t || Qp, i)
        }

        function Pf(e, t) {
            e.uniform1fv(this.addr, t)
        }

        function Rf(e, t) {
            const n = af(t, this.size, 2);
            e.uniform2fv(this.addr, n)
        }

        function If(e, t) {
            const n = af(t, this.size, 3);
            e.uniform3fv(this.addr, n)
        }

        function Of(e, t) {
            const n = af(t, this.size, 4);
            e.uniform4fv(this.addr, n)
        }

        function Bf(e, t) {
            const n = af(t, this.size, 4);
            e.uniformMatrix2fv(this.addr, !1, n)
        }

        function Lf(e, t) {
            const n = af(t, this.size, 9);
            e.uniformMatrix3fv(this.addr, !1, n)
        }

        function Df(e, t) {
            const n = af(t, this.size, 16);
            e.uniformMatrix4fv(this.addr, !1, n)
        }

        function Nf(e, t) {
            e.uniform1iv(this.addr, t)
        }

        function kf(e, t) {
            e.uniform2iv(this.addr, t)
        }

        function Ff(e, t) {
            e.uniform3iv(this.addr, t)
        }

        function Uf(e, t) {
            e.uniform4iv(this.addr, t)
        }

        function zf(e, t) {
            e.uniform1uiv(this.addr, t)
        }

        function Hf(e, t) {
            e.uniform2uiv(this.addr, t)
        }

        function jf(e, t) {
            e.uniform3uiv(this.addr, t)
        }

        function Gf(e, t) {
            e.uniform4uiv(this.addr, t)
        }

        function Vf(e, t, n) {
            const r = this.cache,
                i = t.length,
                o = cf(n, i);
            sf(r, o) || (e.uniform1iv(this.addr, o), lf(r, o));
            for (let a = 0; a !== i; ++a) n.setTexture2D(t[a] || Jp, o[a])
        }

        function qf(e, t, n) {
            const r = this.cache,
                i = t.length,
                o = cf(n, i);
            sf(r, o) || (e.uniform1iv(this.addr, o), lf(r, o));
            for (let a = 0; a !== i; ++a) n.setTexture3D(t[a] || Zp, o[a])
        }

        function Wf(e, t, n) {
            const r = this.cache,
                i = t.length,
                o = cf(n, i);
            sf(r, o) || (e.uniform1iv(this.addr, o), lf(r, o));
            for (let a = 0; a !== i; ++a) n.setTextureCube(t[a] || $p, o[a])
        }

        function Xf(e, t, n) {
            const r = this.cache,
                i = t.length,
                o = cf(n, i);
            sf(r, o) || (e.uniform1iv(this.addr, o), lf(r, o));
            for (let a = 0; a !== i; ++a) n.setTexture2DArray(t[a] || Qp, o[a])
        }
        class Kf {
            constructor(e, t, n) {
                this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = function(e) {
                    switch (e) {
                        case 5126:
                            return uf;
                        case 35664:
                            return df;
                        case 35665:
                            return hf;
                        case 35666:
                            return pf;
                        case 35674:
                            return ff;
                        case 35675:
                            return mf;
                        case 35676:
                            return gf;
                        case 5124:
                        case 35670:
                            return vf;
                        case 35667:
                        case 35671:
                            return yf;
                        case 35668:
                        case 35672:
                            return bf;
                        case 35669:
                        case 35673:
                            return xf;
                        case 5125:
                            return _f;
                        case 36294:
                            return Mf;
                        case 36295:
                            return wf;
                        case 36296:
                            return Af;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return Sf;
                        case 35679:
                        case 36299:
                        case 36307:
                            return Ef;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return Cf;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return Tf
                    }
                }(t.type)
            }
        }
        class Jf {
            constructor(e, t, n) {
                this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = function(e) {
                    switch (e) {
                        case 5126:
                            return Pf;
                        case 35664:
                            return Rf;
                        case 35665:
                            return If;
                        case 35666:
                            return Of;
                        case 35674:
                            return Bf;
                        case 35675:
                            return Lf;
                        case 35676:
                            return Df;
                        case 5124:
                        case 35670:
                            return Nf;
                        case 35667:
                        case 35671:
                            return kf;
                        case 35668:
                        case 35672:
                            return Ff;
                        case 35669:
                        case 35673:
                            return Uf;
                        case 5125:
                            return zf;
                        case 36294:
                            return Hf;
                        case 36295:
                            return jf;
                        case 36296:
                            return Gf;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return Vf;
                        case 35679:
                        case 36299:
                        case 36307:
                            return qf;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return Wf;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return Xf
                    }
                }(t.type)
            }
        }
        class Yf {
            constructor(e) {
                this.id = e, this.seq = [], this.map = {}
            }
            setValue(e, t, n) {
                const r = this.seq;
                for (let i = 0, o = r.length; i !== o; ++i) {
                    const o = r[i];
                    o.setValue(e, t[o.id], n)
                }
            }
        }
        const Qf = /(\w+)(\])?(\[|\.)?/g;

        function Zf(e, t) {
            e.seq.push(t), e.map[t.id] = t
        }

        function $f(e, t, n) {
            const r = e.name,
                i = r.length;
            for (Qf.lastIndex = 0;;) {
                const o = Qf.exec(r),
                    a = Qf.lastIndex;
                let s = o[1];
                const l = "]" === o[2],
                    c = o[3];
                if (l && (s |= 0), void 0 === c || "[" === c && a + 2 === i) {
                    Zf(n, void 0 === c ? new Kf(s, e, t) : new Jf(s, e, t));
                    break
                } {
                    let e = n.map[s];
                    void 0 === e && (e = new Yf(s), Zf(n, e)), n = e
                }
            }
        }
        class em {
            constructor(e, t) {
                this.seq = [], this.map = {};
                const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
                for (let r = 0; r < n; ++r) {
                    const n = e.getActiveUniform(t, r);
                    $f(n, e.getUniformLocation(t, n.name), this)
                }
            }
            setValue(e, t, n, r) {
                const i = this.map[t];
                void 0 !== i && i.setValue(e, n, r)
            }
            setOptional(e, t, n) {
                const r = t[n];
                void 0 !== r && this.setValue(e, n, r)
            }
            static upload(e, t, n, r) {
                for (let i = 0, o = t.length; i !== o; ++i) {
                    const o = t[i],
                        a = n[o.id];
                    !1 !== a.needsUpdate && o.setValue(e, a.value, r)
                }
            }
            static seqWithValue(e, t) {
                const n = [];
                for (let r = 0, i = e.length; r !== i; ++r) {
                    const i = e[r];
                    i.id in t && n.push(i)
                }
                return n
            }
        }

        function tm(e, t, n) {
            const r = e.createShader(t);
            return e.shaderSource(r, n), e.compileShader(r), r
        }
        const nm = 37297;
        let rm = 0;

        function im(e, t, n) {
            const r = e.getShaderParameter(t, e.COMPILE_STATUS),
                i = e.getShaderInfoLog(t).trim();
            if (r && "" === i) return "";
            const o = /ERROR: 0:(\d+)/.exec(i);
            if (o) {
                const r = parseInt(o[1]);
                return n.toUpperCase() + "\n\n" + i + "\n\n" + function(e, t) {
                    const n = e.split("\n"),
                        r = [],
                        i = Math.max(t - 6, 0),
                        o = Math.min(t + 6, n.length);
                    for (let a = i; a < o; a++) {
                        const e = a + 1;
                        r.push("".concat(e === t ? ">" : " ", " ").concat(e, ": ").concat(n[a]))
                    }
                    return r.join("\n")
                }(e.getShaderSource(t), r)
            }
            return i
        }

        function om(e, t) {
            const n = function(e) {
                const t = uu.getPrimaries(uu.workingColorSpace),
                    n = uu.getPrimaries(e);
                let r;
                switch (t === n ? r = "" : t === Ql && n === Yl ? r = "LinearDisplayP3ToLinearSRGB" : t === Yl && n === Ql && (r = "LinearSRGBToLinearDisplayP3"), e) {
                    case ql:
                    case Xl:
                        return [r, "LinearTransferOETF"];
                    case Vl:
                    case Wl:
                        return [r, "sRGBTransferOETF"];
                    default:
                        return console.warn("THREE.WebGLProgram: Unsupported color space:", e), [r, "LinearTransferOETF"]
                }
            }(t);
            return "vec4 ".concat(e, "( vec4 value ) { return ").concat(n[0], "( ").concat(n[1], "( value ) ); }")
        }

        function am(e, t) {
            let n;
            switch (t) {
                case Ya:
                    n = "Linear";
                    break;
                case Qa:
                    n = "Reinhard";
                    break;
                case Za:
                    n = "OptimizedCineon";
                    break;
                case $a:
                    n = "ACESFilmic";
                    break;
                case ts:
                    n = "AgX";
                    break;
                case es:
                    n = "Custom";
                    break;
                default:
                    console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), n = "Linear"
            }
            return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }

        function sm(e) {
            return "" !== e
        }

        function lm(e, t) {
            const n = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
            return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
        }

        function cm(e, t) {
            return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
        }
        const um = /^[ \t]*#include +<([\w\d./]+)>/gm;

        function dm(e) {
            return e.replace(um, pm)
        }
        const hm = new Map([
            ["encodings_fragment", "colorspace_fragment"],
            ["encodings_pars_fragment", "colorspace_pars_fragment"],
            ["output_fragment", "opaque_fragment"]
        ]);

        function pm(e, t) {
            let n = pp[t];
            if (void 0 === n) {
                const e = hm.get(t);
                if (void 0 === e) throw new Error("Can not resolve #include <" + t + ">");
                n = pp[e], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, e)
            }
            return dm(n)
        }
        const fm = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

        function mm(e) {
            return e.replace(fm, gm)
        }

        function gm(e, t, n, r) {
            let i = "";
            for (let o = parseInt(t); o < parseInt(n); o++) i += r.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
            return i
        }

        function vm(e) {
            let t = "precision ".concat(e.precision, " float;\n\tprecision ").concat(e.precision, " int;\n\tprecision ").concat(e.precision, " sampler2D;\n\tprecision ").concat(e.precision, " samplerCube;\n\t");
            return e.isWebGL2 && (t += "precision ".concat(e.precision, " sampler3D;\n\t\tprecision ").concat(e.precision, " sampler2DArray;\n\t\tprecision ").concat(e.precision, " sampler2DShadow;\n\t\tprecision ").concat(e.precision, " samplerCubeShadow;\n\t\tprecision ").concat(e.precision, " sampler2DArrayShadow;\n\t\tprecision ").concat(e.precision, " isampler2D;\n\t\tprecision ").concat(e.precision, " isampler3D;\n\t\tprecision ").concat(e.precision, " isamplerCube;\n\t\tprecision ").concat(e.precision, " isampler2DArray;\n\t\tprecision ").concat(e.precision, " usampler2D;\n\t\tprecision ").concat(e.precision, " usampler3D;\n\t\tprecision ").concat(e.precision, " usamplerCube;\n\t\tprecision ").concat(e.precision, " usampler2DArray;\n\t\t")), "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
        }

        function ym(e, t, n, r) {
            const i = e.getContext(),
                o = n.defines;
            let a = n.vertexShader,
                s = n.fragmentShader;
            const l = function(e) {
                    let t = "SHADOWMAP_TYPE_BASIC";
                    return e.shadowMapType === aa ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === sa ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === la && (t = "SHADOWMAP_TYPE_VSM"), t
                }(n),
                c = function(e) {
                    let t = "ENVMAP_TYPE_CUBE";
                    if (e.envMap) switch (e.envMapMode) {
                        case os:
                        case as:
                            t = "ENVMAP_TYPE_CUBE";
                            break;
                        case cs:
                            t = "ENVMAP_TYPE_CUBE_UV"
                    }
                    return t
                }(n),
                u = function(e) {
                    let t = "ENVMAP_MODE_REFLECTION";
                    e.envMap && e.envMapMode === as && (t = "ENVMAP_MODE_REFRACTION");
                    return t
                }(n),
                d = function(e) {
                    let t = "ENVMAP_BLENDING_NONE";
                    if (e.envMap) switch (e.combine) {
                        case Wa:
                            t = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case Xa:
                            t = "ENVMAP_BLENDING_MIX";
                            break;
                        case Ka:
                            t = "ENVMAP_BLENDING_ADD"
                    }
                    return t
                }(n),
                h = function(e) {
                    const t = e.envMapCubeUVHeight;
                    if (null === t) return null;
                    const n = Math.log2(t) - 2,
                        r = 1 / t;
                    return {
                        texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                        texelHeight: r,
                        maxMip: n
                    }
                }(n),
                p = n.isWebGL2 ? "" : function(e) {
                    return [e.extensionDerivatives || e.envMapCubeUVHeight || e.bumpMap || e.normalMapTangentSpace || e.clearcoatNormalMap || e.flatShading || e.alphaToCoverage || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(sm).join("\n")
                }(n),
                f = function(e) {
                    return [e.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", e.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(sm).join("\n")
                }(n),
                m = function(e) {
                    const t = [];
                    for (const n in e) {
                        const r = e[n];
                        !1 !== r && t.push("#define " + n + " " + r)
                    }
                    return t.join("\n")
                }(o),
                g = i.createProgram();
            let v, y, b = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
            n.isRawShaderMaterial ? (v = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m].filter(sm).join("\n"), v.length > 0 && (v += "\n"), y = [p, "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m].filter(sm).join("\n"), y.length > 0 && (y += "\n")) : (v = [vm(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(sm).join("\n"), y = [p, vm(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + d : "", h ? "#define CUBEUV_TEXEL_WIDTH " + h.texelWidth : "", h ? "#define CUBEUV_TEXEL_HEIGHT " + h.texelHeight : "", h ? "#define CUBEUV_MAX_MIP " + h.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== Ja ? "#define TONE_MAPPING" : "", n.toneMapping !== Ja ? pp.tonemapping_pars_fragment : "", n.toneMapping !== Ja ? am("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", pp.colorspace_pars_fragment, om("linearToOutputTexel", n.outputColorSpace), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(sm).join("\n")), a = dm(a), a = lm(a, n), a = cm(a, n), s = dm(s), s = lm(s, n), s = cm(s, n), a = mm(a), s = mm(s), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (b = "#version 300 es\n", v = [f, "precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + v, y = ["precision mediump sampler2DArray;", "#define varying in", n.glslVersion === Oc ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === Oc ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y);
            const x = b + v + a,
                _ = b + y + s,
                M = tm(i, i.VERTEX_SHADER, x),
                w = tm(i, i.FRAGMENT_SHADER, _);

            function A(t) {
                if (e.debug.checkShaderErrors) {
                    const n = i.getProgramInfoLog(g).trim(),
                        r = i.getShaderInfoLog(M).trim(),
                        o = i.getShaderInfoLog(w).trim();
                    let a = !0,
                        s = !0;
                    if (!1 === i.getProgramParameter(g, i.LINK_STATUS))
                        if (a = !1, "function" === typeof e.debug.onShaderError) e.debug.onShaderError(i, g, M, w);
                        else {
                            const e = im(i, M, "vertex"),
                                r = im(i, w, "fragment");
                            console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(g, i.VALIDATE_STATUS) + "\n\nMaterial Name: " + t.name + "\nMaterial Type: " + t.type + "\n\nProgram Info Log: " + n + "\n" + e + "\n" + r)
                        }
                    else "" !== n ? console.warn("THREE.WebGLProgram: Program Info Log:", n) : "" !== r && "" !== o || (s = !1);
                    s && (t.diagnostics = {
                        runnable: a,
                        programLog: n,
                        vertexShader: {
                            log: r,
                            prefix: v
                        },
                        fragmentShader: {
                            log: o,
                            prefix: y
                        }
                    })
                }
                i.deleteShader(M), i.deleteShader(w), S = new em(i, g), E = function(e, t) {
                    const n = {},
                        r = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
                    for (let i = 0; i < r; i++) {
                        const r = e.getActiveAttrib(t, i),
                            o = r.name;
                        let a = 1;
                        r.type === e.FLOAT_MAT2 && (a = 2), r.type === e.FLOAT_MAT3 && (a = 3), r.type === e.FLOAT_MAT4 && (a = 4), n[o] = {
                            type: r.type,
                            location: e.getAttribLocation(t, o),
                            locationSize: a
                        }
                    }
                    return n
                }(i, g)
            }
            let S, E;
            i.attachShader(g, M), i.attachShader(g, w), void 0 !== n.index0AttributeName ? i.bindAttribLocation(g, 0, n.index0AttributeName) : !0 === n.morphTargets && i.bindAttribLocation(g, 0, "position"), i.linkProgram(g), this.getUniforms = function() {
                return void 0 === S && A(this), S
            }, this.getAttributes = function() {
                return void 0 === E && A(this), E
            };
            let C = !1 === n.rendererExtensionParallelShaderCompile;
            return this.isReady = function() {
                return !1 === C && (C = i.getProgramParameter(g, nm)), C
            }, this.destroy = function() {
                r.releaseStatesOfProgram(this), i.deleteProgram(g), this.program = void 0
            }, this.type = n.shaderType, this.name = n.shaderName, this.id = rm++, this.cacheKey = t, this.usedTimes = 1, this.program = g, this.vertexShader = M, this.fragmentShader = w, this
        }
        let bm = 0;
        class xm {
            constructor() {
                this.shaderCache = new Map, this.materialCache = new Map
            }
            update(e) {
                const t = e.vertexShader,
                    n = e.fragmentShader,
                    r = this._getShaderStage(t),
                    i = this._getShaderStage(n),
                    o = this._getShaderCacheForMaterial(e);
                return !1 === o.has(r) && (o.add(r), r.usedTimes++), !1 === o.has(i) && (o.add(i), i.usedTimes++), this
            }
            remove(e) {
                const t = this.materialCache.get(e);
                for (const n of t) n.usedTimes--, 0 === n.usedTimes && this.shaderCache.delete(n.code);
                return this.materialCache.delete(e), this
            }
            getVertexShaderID(e) {
                return this._getShaderStage(e.vertexShader).id
            }
            getFragmentShaderID(e) {
                return this._getShaderStage(e.fragmentShader).id
            }
            dispose() {
                this.shaderCache.clear(), this.materialCache.clear()
            }
            _getShaderCacheForMaterial(e) {
                const t = this.materialCache;
                let n = t.get(e);
                return void 0 === n && (n = new Set, t.set(e, n)), n
            }
            _getShaderStage(e) {
                const t = this.shaderCache;
                let n = t.get(e);
                return void 0 === n && (n = new _m(e), t.set(e, n)), n
            }
        }
        class _m {
            constructor(e) {
                this.id = bm++, this.code = e, this.usedTimes = 0
            }
        }

        function Mm(e, t, n, r, i, o, a) {
            const s = new gd,
                l = new xm,
                c = new Set,
                u = [],
                d = i.isWebGL2,
                h = i.logarithmicDepthBuffer,
                p = i.vertexTextures;
            let f = i.precision;
            const m = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            };

            function g(e) {
                return c.add(e), 0 === e ? "uv" : "uv".concat(e)
            }
            return {
                getParameters: function(o, s, u, v, y) {
                    const b = v.fog,
                        x = y.geometry,
                        _ = o.isMeshStandardMaterial ? v.environment : null,
                        M = (o.isMeshStandardMaterial ? n : t).get(o.envMap || _),
                        w = M && M.mapping === cs ? M.image.height : null,
                        A = m[o.type];
                    null !== o.precision && (f = i.getMaxPrecision(o.precision), f !== o.precision && console.warn("THREE.WebGLProgram.getParameters:", o.precision, "not supported, using", f, "instead."));
                    const S = x.morphAttributes.position || x.morphAttributes.normal || x.morphAttributes.color,
                        E = void 0 !== S ? S.length : 0;
                    let C, T, P, R, I = 0;
                    if (void 0 !== x.morphAttributes.position && (I = 1), void 0 !== x.morphAttributes.normal && (I = 2), void 0 !== x.morphAttributes.color && (I = 3), A) {
                        const e = mp[A];
                        C = e.vertexShader, T = e.fragmentShader
                    } else C = o.vertexShader, T = o.fragmentShader, l.update(o), P = l.getVertexShaderID(o), R = l.getFragmentShaderID(o);
                    const O = e.getRenderTarget(),
                        B = !0 === y.isInstancedMesh,
                        L = !0 === y.isBatchedMesh,
                        D = !!o.map,
                        N = !!o.matcap,
                        k = !!M,
                        F = !!o.aoMap,
                        U = !!o.lightMap,
                        z = !!o.bumpMap,
                        H = !!o.normalMap,
                        j = !!o.displacementMap,
                        G = !!o.emissiveMap,
                        V = !!o.metalnessMap,
                        q = !!o.roughnessMap,
                        W = o.anisotropy > 0,
                        X = o.clearcoat > 0,
                        K = o.iridescence > 0,
                        J = o.sheen > 0,
                        Y = o.transmission > 0,
                        Q = W && !!o.anisotropyMap,
                        Z = X && !!o.clearcoatMap,
                        $ = X && !!o.clearcoatNormalMap,
                        ee = X && !!o.clearcoatRoughnessMap,
                        te = K && !!o.iridescenceMap,
                        ne = K && !!o.iridescenceThicknessMap,
                        re = J && !!o.sheenColorMap,
                        ie = J && !!o.sheenRoughnessMap,
                        oe = !!o.specularMap,
                        ae = !!o.specularColorMap,
                        se = !!o.specularIntensityMap,
                        le = Y && !!o.transmissionMap,
                        ce = Y && !!o.thicknessMap,
                        ue = !!o.gradientMap,
                        de = !!o.alphaMap,
                        he = o.alphaTest > 0,
                        pe = !!o.alphaHash,
                        fe = !!o.extensions;
                    let me = Ja;
                    o.toneMapped && (null !== O && !0 !== O.isXRRenderTarget || (me = e.toneMapping));
                    const ge = {
                        isWebGL2: d,
                        shaderID: A,
                        shaderType: o.type,
                        shaderName: o.name,
                        vertexShader: C,
                        fragmentShader: T,
                        defines: o.defines,
                        customVertexShaderID: P,
                        customFragmentShaderID: R,
                        isRawShaderMaterial: !0 === o.isRawShaderMaterial,
                        glslVersion: o.glslVersion,
                        precision: f,
                        batching: L,
                        instancing: B,
                        instancingColor: B && null !== y.instanceColor,
                        supportsVertexTextures: p,
                        outputColorSpace: null === O ? e.outputColorSpace : !0 === O.isXRRenderTarget ? O.texture.colorSpace : ql,
                        alphaToCoverage: !!o.alphaToCoverage,
                        map: D,
                        matcap: N,
                        envMap: k,
                        envMapMode: k && M.mapping,
                        envMapCubeUVHeight: w,
                        aoMap: F,
                        lightMap: U,
                        bumpMap: z,
                        normalMap: H,
                        displacementMap: p && j,
                        emissiveMap: G,
                        normalMapObjectSpace: H && o.normalMapType === jl,
                        normalMapTangentSpace: H && o.normalMapType === Hl,
                        metalnessMap: V,
                        roughnessMap: q,
                        anisotropy: W,
                        anisotropyMap: Q,
                        clearcoat: X,
                        clearcoatMap: Z,
                        clearcoatNormalMap: $,
                        clearcoatRoughnessMap: ee,
                        iridescence: K,
                        iridescenceMap: te,
                        iridescenceThicknessMap: ne,
                        sheen: J,
                        sheenColorMap: re,
                        sheenRoughnessMap: ie,
                        specularMap: oe,
                        specularColorMap: ae,
                        specularIntensityMap: se,
                        transmission: Y,
                        transmissionMap: le,
                        thicknessMap: ce,
                        gradientMap: ue,
                        opaque: !1 === o.transparent && o.blending === pa && !1 === o.alphaToCoverage,
                        alphaMap: de,
                        alphaTest: he,
                        alphaHash: pe,
                        combine: o.combine,
                        mapUv: D && g(o.map.channel),
                        aoMapUv: F && g(o.aoMap.channel),
                        lightMapUv: U && g(o.lightMap.channel),
                        bumpMapUv: z && g(o.bumpMap.channel),
                        normalMapUv: H && g(o.normalMap.channel),
                        displacementMapUv: j && g(o.displacementMap.channel),
                        emissiveMapUv: G && g(o.emissiveMap.channel),
                        metalnessMapUv: V && g(o.metalnessMap.channel),
                        roughnessMapUv: q && g(o.roughnessMap.channel),
                        anisotropyMapUv: Q && g(o.anisotropyMap.channel),
                        clearcoatMapUv: Z && g(o.clearcoatMap.channel),
                        clearcoatNormalMapUv: $ && g(o.clearcoatNormalMap.channel),
                        clearcoatRoughnessMapUv: ee && g(o.clearcoatRoughnessMap.channel),
                        iridescenceMapUv: te && g(o.iridescenceMap.channel),
                        iridescenceThicknessMapUv: ne && g(o.iridescenceThicknessMap.channel),
                        sheenColorMapUv: re && g(o.sheenColorMap.channel),
                        sheenRoughnessMapUv: ie && g(o.sheenRoughnessMap.channel),
                        specularMapUv: oe && g(o.specularMap.channel),
                        specularColorMapUv: ae && g(o.specularColorMap.channel),
                        specularIntensityMapUv: se && g(o.specularIntensityMap.channel),
                        transmissionMapUv: le && g(o.transmissionMap.channel),
                        thicknessMapUv: ce && g(o.thicknessMap.channel),
                        alphaMapUv: de && g(o.alphaMap.channel),
                        vertexTangents: !!x.attributes.tangent && (H || W),
                        vertexColors: o.vertexColors,
                        vertexAlphas: !0 === o.vertexColors && !!x.attributes.color && 4 === x.attributes.color.itemSize,
                        pointsUvs: !0 === y.isPoints && !!x.attributes.uv && (D || de),
                        fog: !!b,
                        useFog: !0 === o.fog,
                        fogExp2: !!b && b.isFogExp2,
                        flatShading: !0 === o.flatShading,
                        sizeAttenuation: !0 === o.sizeAttenuation,
                        logarithmicDepthBuffer: h,
                        skinning: !0 === y.isSkinnedMesh,
                        morphTargets: void 0 !== x.morphAttributes.position,
                        morphNormals: void 0 !== x.morphAttributes.normal,
                        morphColors: void 0 !== x.morphAttributes.color,
                        morphTargetsCount: E,
                        morphTextureStride: I,
                        numDirLights: s.directional.length,
                        numPointLights: s.point.length,
                        numSpotLights: s.spot.length,
                        numSpotLightMaps: s.spotLightMap.length,
                        numRectAreaLights: s.rectArea.length,
                        numHemiLights: s.hemi.length,
                        numDirLightShadows: s.directionalShadowMap.length,
                        numPointLightShadows: s.pointShadowMap.length,
                        numSpotLightShadows: s.spotShadowMap.length,
                        numSpotLightShadowsWithMaps: s.numSpotLightShadowsWithMaps,
                        numLightProbes: s.numLightProbes,
                        numClippingPlanes: a.numPlanes,
                        numClipIntersection: a.numIntersection,
                        dithering: o.dithering,
                        shadowMapEnabled: e.shadowMap.enabled && u.length > 0,
                        shadowMapType: e.shadowMap.type,
                        toneMapping: me,
                        useLegacyLights: e._useLegacyLights,
                        decodeVideoTexture: D && !0 === o.map.isVideoTexture && uu.getTransfer(o.map.colorSpace) === Jl,
                        premultipliedAlpha: o.premultipliedAlpha,
                        doubleSided: o.side === da,
                        flipSided: o.side === ua,
                        useDepthPacking: o.depthPacking >= 0,
                        depthPacking: o.depthPacking || 0,
                        index0AttributeName: o.index0AttributeName,
                        extensionDerivatives: fe && !0 === o.extensions.derivatives,
                        extensionFragDepth: fe && !0 === o.extensions.fragDepth,
                        extensionDrawBuffers: fe && !0 === o.extensions.drawBuffers,
                        extensionShaderTextureLOD: fe && !0 === o.extensions.shaderTextureLOD,
                        extensionClipCullDistance: fe && !0 === o.extensions.clipCullDistance && r.has("WEBGL_clip_cull_distance"),
                        extensionMultiDraw: fe && !0 === o.extensions.multiDraw && r.has("WEBGL_multi_draw"),
                        rendererExtensionFragDepth: d || r.has("EXT_frag_depth"),
                        rendererExtensionDrawBuffers: d || r.has("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod: d || r.has("EXT_shader_texture_lod"),
                        rendererExtensionParallelShaderCompile: r.has("KHR_parallel_shader_compile"),
                        customProgramCacheKey: o.customProgramCacheKey()
                    };
                    return ge.vertexUv1s = c.has(1), ge.vertexUv2s = c.has(2), ge.vertexUv3s = c.has(3), c.clear(), ge
                },
                getProgramCacheKey: function(t) {
                    const n = [];
                    if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID), n.push(t.customFragmentShaderID)), void 0 !== t.defines)
                        for (const e in t.defines) n.push(e), n.push(t.defines[e]);
                    return !1 === t.isRawShaderMaterial && (! function(e, t) {
                        e.push(t.precision), e.push(t.outputColorSpace), e.push(t.envMapMode), e.push(t.envMapCubeUVHeight), e.push(t.mapUv), e.push(t.alphaMapUv), e.push(t.lightMapUv), e.push(t.aoMapUv), e.push(t.bumpMapUv), e.push(t.normalMapUv), e.push(t.displacementMapUv), e.push(t.emissiveMapUv), e.push(t.metalnessMapUv), e.push(t.roughnessMapUv), e.push(t.anisotropyMapUv), e.push(t.clearcoatMapUv), e.push(t.clearcoatNormalMapUv), e.push(t.clearcoatRoughnessMapUv), e.push(t.iridescenceMapUv), e.push(t.iridescenceThicknessMapUv), e.push(t.sheenColorMapUv), e.push(t.sheenRoughnessMapUv), e.push(t.specularMapUv), e.push(t.specularColorMapUv), e.push(t.specularIntensityMapUv), e.push(t.transmissionMapUv), e.push(t.thicknessMapUv), e.push(t.combine), e.push(t.fogExp2), e.push(t.sizeAttenuation), e.push(t.morphTargetsCount), e.push(t.morphAttributeCount), e.push(t.numDirLights), e.push(t.numPointLights), e.push(t.numSpotLights), e.push(t.numSpotLightMaps), e.push(t.numHemiLights), e.push(t.numRectAreaLights), e.push(t.numDirLightShadows), e.push(t.numPointLightShadows), e.push(t.numSpotLightShadows), e.push(t.numSpotLightShadowsWithMaps), e.push(t.numLightProbes), e.push(t.shadowMapType), e.push(t.toneMapping), e.push(t.numClippingPlanes), e.push(t.numClipIntersection), e.push(t.depthPacking)
                    }(n, t), function(e, t) {
                        s.disableAll(), t.isWebGL2 && s.enable(0);
                        t.supportsVertexTextures && s.enable(1);
                        t.instancing && s.enable(2);
                        t.instancingColor && s.enable(3);
                        t.matcap && s.enable(4);
                        t.envMap && s.enable(5);
                        t.normalMapObjectSpace && s.enable(6);
                        t.normalMapTangentSpace && s.enable(7);
                        t.clearcoat && s.enable(8);
                        t.iridescence && s.enable(9);
                        t.alphaTest && s.enable(10);
                        t.vertexColors && s.enable(11);
                        t.vertexAlphas && s.enable(12);
                        t.vertexUv1s && s.enable(13);
                        t.vertexUv2s && s.enable(14);
                        t.vertexUv3s && s.enable(15);
                        t.vertexTangents && s.enable(16);
                        t.anisotropy && s.enable(17);
                        t.alphaHash && s.enable(18);
                        t.batching && s.enable(19);
                        e.push(s.mask), s.disableAll(), t.fog && s.enable(0);
                        t.useFog && s.enable(1);
                        t.flatShading && s.enable(2);
                        t.logarithmicDepthBuffer && s.enable(3);
                        t.skinning && s.enable(4);
                        t.morphTargets && s.enable(5);
                        t.morphNormals && s.enable(6);
                        t.morphColors && s.enable(7);
                        t.premultipliedAlpha && s.enable(8);
                        t.shadowMapEnabled && s.enable(9);
                        t.useLegacyLights && s.enable(10);
                        t.doubleSided && s.enable(11);
                        t.flipSided && s.enable(12);
                        t.useDepthPacking && s.enable(13);
                        t.dithering && s.enable(14);
                        t.transmission && s.enable(15);
                        t.sheen && s.enable(16);
                        t.opaque && s.enable(17);
                        t.pointsUvs && s.enable(18);
                        t.decodeVideoTexture && s.enable(19);
                        t.alphaToCoverage && s.enable(20);
                        e.push(s.mask)
                    }(n, t), n.push(e.outputColorSpace)), n.push(t.customProgramCacheKey), n.join()
                },
                getUniforms: function(e) {
                    const t = m[e.type];
                    let n;
                    if (t) {
                        const e = mp[t];
                        n = Wh.clone(e.uniforms)
                    } else n = e.uniforms;
                    return n
                },
                acquireProgram: function(t, n) {
                    let r;
                    for (let e = 0, i = u.length; e < i; e++) {
                        const t = u[e];
                        if (t.cacheKey === n) {
                            r = t, ++r.usedTimes;
                            break
                        }
                    }
                    return void 0 === r && (r = new ym(e, n, t, o), u.push(r)), r
                },
                releaseProgram: function(e) {
                    if (0 === --e.usedTimes) {
                        const t = u.indexOf(e);
                        u[t] = u[u.length - 1], u.pop(), e.destroy()
                    }
                },
                releaseShaderCache: function(e) {
                    l.remove(e)
                },
                programs: u,
                dispose: function() {
                    l.dispose()
                }
            }
        }

        function wm() {
            let e = new WeakMap;
            return {
                get: function(t) {
                    let n = e.get(t);
                    return void 0 === n && (n = {}, e.set(t, n)), n
                },
                remove: function(t) {
                    e.delete(t)
                },
                update: function(t, n, r) {
                    e.get(t)[n] = r
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }

        function Am(e, t) {
            return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
        }

        function Sm(e, t) {
            return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
        }

        function Em() {
            const e = [];
            let t = 0;
            const n = [],
                r = [],
                i = [];

            function o(n, r, i, o, a, s) {
                let l = e[t];
                return void 0 === l ? (l = {
                    id: n.id,
                    object: n,
                    geometry: r,
                    material: i,
                    groupOrder: o,
                    renderOrder: n.renderOrder,
                    z: a,
                    group: s
                }, e[t] = l) : (l.id = n.id, l.object = n, l.geometry = r, l.material = i, l.groupOrder = o, l.renderOrder = n.renderOrder, l.z = a, l.group = s), t++, l
            }
            return {
                opaque: n,
                transmissive: r,
                transparent: i,
                init: function() {
                    t = 0, n.length = 0, r.length = 0, i.length = 0
                },
                push: function(e, t, a, s, l, c) {
                    const u = o(e, t, a, s, l, c);
                    a.transmission > 0 ? r.push(u) : !0 === a.transparent ? i.push(u) : n.push(u)
                },
                unshift: function(e, t, a, s, l, c) {
                    const u = o(e, t, a, s, l, c);
                    a.transmission > 0 ? r.unshift(u) : !0 === a.transparent ? i.unshift(u) : n.unshift(u)
                },
                finish: function() {
                    for (let n = t, r = e.length; n < r; n++) {
                        const t = e[n];
                        if (null === t.id) break;
                        t.id = null, t.object = null, t.geometry = null, t.material = null, t.group = null
                    }
                },
                sort: function(e, t) {
                    n.length > 1 && n.sort(e || Am), r.length > 1 && r.sort(t || Sm), i.length > 1 && i.sort(t || Sm)
                }
            }
        }

        function Cm() {
            let e = new WeakMap;
            return {
                get: function(t, n) {
                    const r = e.get(t);
                    let i;
                    return void 0 === r ? (i = new Em, e.set(t, [i])) : n >= r.length ? (i = new Em, r.push(i)) : i = r[n], i
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }

        function Tm() {
            const e = {};
            return {
                get: function(t) {
                    if (void 0 !== e[t.id]) return e[t.id];
                    let n;
                    switch (t.type) {
                        case "DirectionalLight":
                            n = {
                                direction: new Pu,
                                color: new Wd
                            };
                            break;
                        case "SpotLight":
                            n = {
                                position: new Pu,
                                direction: new Pu,
                                color: new Wd,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0
                            };
                            break;
                        case "PointLight":
                            n = {
                                position: new Pu,
                                color: new Wd,
                                distance: 0,
                                decay: 0
                            };
                            break;
                        case "HemisphereLight":
                            n = {
                                direction: new Pu,
                                skyColor: new Wd,
                                groundColor: new Wd
                            };
                            break;
                        case "RectAreaLight":
                            n = {
                                color: new Wd,
                                position: new Pu,
                                halfWidth: new Pu,
                                halfHeight: new Pu
                            }
                    }
                    return e[t.id] = n, n
                }
            }
        }
        let Pm = 0;

        function Rm(e, t) {
            return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0)
        }

        function Im(e, t) {
            const n = new Tm,
                r = function() {
                    const e = {};
                    return {
                        get: function(t) {
                            if (void 0 !== e[t.id]) return e[t.id];
                            let n;
                            switch (t.type) {
                                case "DirectionalLight":
                                case "SpotLight":
                                    n = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new Yc
                                    };
                                    break;
                                case "PointLight":
                                    n = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new Yc,
                                        shadowCameraNear: 1,
                                        shadowCameraFar: 1e3
                                    }
                            }
                            return e[t.id] = n, n
                        }
                    }
                }(),
                i = {
                    version: 0,
                    hash: {
                        directionalLength: -1,
                        pointLength: -1,
                        spotLength: -1,
                        rectAreaLength: -1,
                        hemiLength: -1,
                        numDirectionalShadows: -1,
                        numPointShadows: -1,
                        numSpotShadows: -1,
                        numSpotMaps: -1,
                        numLightProbes: -1
                    },
                    ambient: [0, 0, 0],
                    probe: [],
                    directional: [],
                    directionalShadow: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotLightMap: [],
                    spotShadow: [],
                    spotShadowMap: [],
                    spotLightMatrix: [],
                    rectArea: [],
                    rectAreaLTC1: null,
                    rectAreaLTC2: null,
                    point: [],
                    pointShadow: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: [],
                    numSpotLightShadowsWithMaps: 0,
                    numLightProbes: 0
                };
            for (let l = 0; l < 9; l++) i.probe.push(new Pu);
            const o = new Pu,
                a = new od,
                s = new od;
            return {
                setup: function(o, a) {
                    let s = 0,
                        l = 0,
                        c = 0;
                    for (let e = 0; e < 9; e++) i.probe[e].set(0, 0, 0);
                    let u = 0,
                        d = 0,
                        h = 0,
                        p = 0,
                        f = 0,
                        m = 0,
                        g = 0,
                        v = 0,
                        y = 0,
                        b = 0,
                        x = 0;
                    o.sort(Rm);
                    const _ = !0 === a ? Math.PI : 1;
                    for (let e = 0, t = o.length; e < t; e++) {
                        const t = o[e],
                            a = t.color,
                            M = t.intensity,
                            w = t.distance,
                            A = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
                        if (t.isAmbientLight) s += a.r * M * _, l += a.g * M * _, c += a.b * M * _;
                        else if (t.isLightProbe) {
                            for (let e = 0; e < 9; e++) i.probe[e].addScaledVector(t.sh.coefficients[e], M);
                            x++
                        } else if (t.isDirectionalLight) {
                            const e = n.get(t);
                            if (e.color.copy(t.color).multiplyScalar(t.intensity * _), t.castShadow) {
                                const e = t.shadow,
                                    n = r.get(t);
                                n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, i.directionalShadow[u] = n, i.directionalShadowMap[u] = A, i.directionalShadowMatrix[u] = t.shadow.matrix, m++
                            }
                            i.directional[u] = e, u++
                        } else if (t.isSpotLight) {
                            const e = n.get(t);
                            e.position.setFromMatrixPosition(t.matrixWorld), e.color.copy(a).multiplyScalar(M * _), e.distance = w, e.coneCos = Math.cos(t.angle), e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)), e.decay = t.decay, i.spot[h] = e;
                            const o = t.shadow;
                            if (t.map && (i.spotLightMap[y] = t.map, y++, o.updateMatrices(t), t.castShadow && b++), i.spotLightMatrix[h] = o.matrix, t.castShadow) {
                                const e = r.get(t);
                                e.shadowBias = o.bias, e.shadowNormalBias = o.normalBias, e.shadowRadius = o.radius, e.shadowMapSize = o.mapSize, i.spotShadow[h] = e, i.spotShadowMap[h] = A, v++
                            }
                            h++
                        } else if (t.isRectAreaLight) {
                            const e = n.get(t);
                            e.color.copy(a).multiplyScalar(M), e.halfWidth.set(.5 * t.width, 0, 0), e.halfHeight.set(0, .5 * t.height, 0), i.rectArea[p] = e, p++
                        } else if (t.isPointLight) {
                            const e = n.get(t);
                            if (e.color.copy(t.color).multiplyScalar(t.intensity * _), e.distance = t.distance, e.decay = t.decay, t.castShadow) {
                                const e = t.shadow,
                                    n = r.get(t);
                                n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, n.shadowCameraNear = e.camera.near, n.shadowCameraFar = e.camera.far, i.pointShadow[d] = n, i.pointShadowMap[d] = A, i.pointShadowMatrix[d] = t.shadow.matrix, g++
                            }
                            i.point[d] = e, d++
                        } else if (t.isHemisphereLight) {
                            const e = n.get(t);
                            e.skyColor.copy(t.color).multiplyScalar(M * _), e.groundColor.copy(t.groundColor).multiplyScalar(M * _), i.hemi[f] = e, f++
                        }
                    }
                    p > 0 && (t.isWebGL2 ? !0 === e.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = fp.LTC_FLOAT_1, i.rectAreaLTC2 = fp.LTC_FLOAT_2) : (i.rectAreaLTC1 = fp.LTC_HALF_1, i.rectAreaLTC2 = fp.LTC_HALF_2) : !0 === e.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = fp.LTC_FLOAT_1, i.rectAreaLTC2 = fp.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (i.rectAreaLTC1 = fp.LTC_HALF_1, i.rectAreaLTC2 = fp.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = s, i.ambient[1] = l, i.ambient[2] = c;
                    const M = i.hash;
                    M.directionalLength === u && M.pointLength === d && M.spotLength === h && M.rectAreaLength === p && M.hemiLength === f && M.numDirectionalShadows === m && M.numPointShadows === g && M.numSpotShadows === v && M.numSpotMaps === y && M.numLightProbes === x || (i.directional.length = u, i.spot.length = h, i.rectArea.length = p, i.point.length = d, i.hemi.length = f, i.directionalShadow.length = m, i.directionalShadowMap.length = m, i.pointShadow.length = g, i.pointShadowMap.length = g, i.spotShadow.length = v, i.spotShadowMap.length = v, i.directionalShadowMatrix.length = m, i.pointShadowMatrix.length = g, i.spotLightMatrix.length = v + y - b, i.spotLightMap.length = y, i.numSpotLightShadowsWithMaps = b, i.numLightProbes = x, M.directionalLength = u, M.pointLength = d, M.spotLength = h, M.rectAreaLength = p, M.hemiLength = f, M.numDirectionalShadows = m, M.numPointShadows = g, M.numSpotShadows = v, M.numSpotMaps = y, M.numLightProbes = x, i.version = Pm++)
                },
                setupView: function(e, t) {
                    let n = 0,
                        r = 0,
                        l = 0,
                        c = 0,
                        u = 0;
                    const d = t.matrixWorldInverse;
                    for (let h = 0, p = e.length; h < p; h++) {
                        const t = e[h];
                        if (t.isDirectionalLight) {
                            const e = i.directional[n];
                            e.direction.setFromMatrixPosition(t.matrixWorld), o.setFromMatrixPosition(t.target.matrixWorld), e.direction.sub(o), e.direction.transformDirection(d), n++
                        } else if (t.isSpotLight) {
                            const e = i.spot[l];
                            e.position.setFromMatrixPosition(t.matrixWorld), e.position.applyMatrix4(d), e.direction.setFromMatrixPosition(t.matrixWorld), o.setFromMatrixPosition(t.target.matrixWorld), e.direction.sub(o), e.direction.transformDirection(d), l++
                        } else if (t.isRectAreaLight) {
                            const e = i.rectArea[c];
                            e.position.setFromMatrixPosition(t.matrixWorld), e.position.applyMatrix4(d), s.identity(), a.copy(t.matrixWorld), a.premultiply(d), s.extractRotation(a), e.halfWidth.set(.5 * t.width, 0, 0), e.halfHeight.set(0, .5 * t.height, 0), e.halfWidth.applyMatrix4(s), e.halfHeight.applyMatrix4(s), c++
                        } else if (t.isPointLight) {
                            const e = i.point[r];
                            e.position.setFromMatrixPosition(t.matrixWorld), e.position.applyMatrix4(d), r++
                        } else if (t.isHemisphereLight) {
                            const e = i.hemi[u];
                            e.direction.setFromMatrixPosition(t.matrixWorld), e.direction.transformDirection(d), u++
                        }
                    }
                },
                state: i
            }
        }

        function Om(e, t) {
            const n = new Im(e, t),
                r = [],
                i = [];
            return {
                init: function() {
                    r.length = 0, i.length = 0
                },
                state: {
                    lightsArray: r,
                    shadowsArray: i,
                    lights: n
                },
                setupLights: function(e) {
                    n.setup(r, e)
                },
                setupLightsView: function(e) {
                    n.setupView(r, e)
                },
                pushLight: function(e) {
                    r.push(e)
                },
                pushShadow: function(e) {
                    i.push(e)
                }
            }
        }

        function Bm(e, t) {
            let n = new WeakMap;
            return {
                get: function(r) {
                    let i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                    const o = n.get(r);
                    let a;
                    return void 0 === o ? (a = new Om(e, t), n.set(r, [a])) : i >= o.length ? (a = new Om(e, t), o.push(a)) : a = o[i], a
                },
                dispose: function() {
                    n = new WeakMap
                }
            }
        }
        class Lm extends Jd {
            constructor(e) {
                super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = Ul, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
            }
        }
        class Dm extends Jd {
            constructor(e) {
                super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
            }
        }

        function Nm(e, t, n) {
            let r = new cp;
            const i = new Yc,
                o = new Yc,
                a = new xu,
                s = new Lm({
                    depthPacking: zl
                }),
                l = new Dm,
                c = {},
                u = n.maxTextureSize,
                d = {
                    [ca]: ua,
                    [ua]: ca,
                    [da]: da
                },
                h = new Xh({
                    defines: {
                        VSM_SAMPLES: 8
                    },
                    uniforms: {
                        shadow_pass: {
                            value: null
                        },
                        resolution: {
                            value: new Yc
                        },
                        radius: {
                            value: 4
                        }
                    },
                    vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                    fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                }),
                p = h.clone();
            p.defines.HORIZONTAL_PASS = 1;
            const f = new Mh;
            f.setAttribute("position", new ih(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
            const m = new zh(f, h),
                g = this;
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = aa;
            let v = this.type;

            function y(n, r) {
                const o = t.update(m);
                h.defines.VSM_SAMPLES !== n.blurSamples && (h.defines.VSM_SAMPLES = n.blurSamples, p.defines.VSM_SAMPLES = n.blurSamples, h.needsUpdate = !0, p.needsUpdate = !0), null === n.mapPass && (n.mapPass = new Mu(i.x, i.y)), h.uniforms.shadow_pass.value = n.map.texture, h.uniforms.resolution.value = n.mapSize, h.uniforms.radius.value = n.radius, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(r, null, o, h, m, null), p.uniforms.shadow_pass.value = n.mapPass.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(r, null, o, p, m, null)
            }

            function b(t, n, r, i) {
                let o = null;
                const a = !0 === r.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
                if (void 0 !== a) o = a;
                else if (o = !0 === r.isPointLight ? l : s, e.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) {
                    const e = o.uuid,
                        t = n.uuid;
                    let r = c[e];
                    void 0 === r && (r = {}, c[e] = r);
                    let i = r[t];
                    void 0 === i && (i = o.clone(), r[t] = i, n.addEventListener("dispose", _)), o = i
                }
                if (o.visible = n.visible, o.wireframe = n.wireframe, o.side = i === la ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : d[n.side], o.alphaMap = n.alphaMap, o.alphaTest = n.alphaTest, o.map = n.map, o.clipShadows = n.clipShadows, o.clippingPlanes = n.clippingPlanes, o.clipIntersection = n.clipIntersection, o.displacementMap = n.displacementMap, o.displacementScale = n.displacementScale, o.displacementBias = n.displacementBias, o.wireframeLinewidth = n.wireframeLinewidth, o.linewidth = n.linewidth, !0 === r.isPointLight && !0 === o.isMeshDistanceMaterial) {
                    e.properties.get(o).light = r
                }
                return o
            }

            function x(n, i, o, a, s) {
                if (!1 === n.visible) return;
                if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && s === la) && (!n.frustumCulled || r.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
                    const r = t.update(n),
                        l = n.material;
                    if (Array.isArray(l)) {
                        const t = r.groups;
                        for (let c = 0, u = t.length; c < u; c++) {
                            const u = t[c],
                                d = l[u.materialIndex];
                            if (d && d.visible) {
                                const t = b(n, d, a, s);
                                n.onBeforeShadow(e, n, i, o, r, t, u), e.renderBufferDirect(o, null, r, t, n, u), n.onAfterShadow(e, n, i, o, r, t, u)
                            }
                        }
                    } else if (l.visible) {
                        const t = b(n, l, a, s);
                        n.onBeforeShadow(e, n, i, o, r, t, null), e.renderBufferDirect(o, null, r, t, n, null), n.onAfterShadow(e, n, i, o, r, t, null)
                    }
                }
                const l = n.children;
                for (let e = 0, t = l.length; e < t; e++) x(l[e], i, o, a, s)
            }

            function _(e) {
                e.target.removeEventListener("dispose", _);
                for (const t in c) {
                    const n = c[t],
                        r = e.target.uuid;
                    if (r in n) {
                        n[r].dispose(), delete n[r]
                    }
                }
            }
            this.render = function(t, n, s) {
                if (!1 === g.enabled) return;
                if (!1 === g.autoUpdate && !1 === g.needsUpdate) return;
                if (0 === t.length) return;
                const l = e.getRenderTarget(),
                    c = e.getActiveCubeFace(),
                    d = e.getActiveMipmapLevel(),
                    h = e.state;
                h.setBlending(ha), h.buffers.color.setClear(1, 1, 1, 1), h.buffers.depth.setTest(!0), h.setScissorTest(!1);
                const p = v !== la && this.type === la,
                    f = v === la && this.type !== la;
                for (let m = 0, g = t.length; m < g; m++) {
                    const l = t[m],
                        c = l.shadow;
                    if (void 0 === c) {
                        console.warn("THREE.WebGLShadowMap:", l, "has no shadow.");
                        continue
                    }
                    if (!1 === c.autoUpdate && !1 === c.needsUpdate) continue;
                    i.copy(c.mapSize);
                    const d = c.getFrameExtents();
                    if (i.multiply(d), o.copy(c.mapSize), (i.x > u || i.y > u) && (i.x > u && (o.x = Math.floor(u / d.x), i.x = o.x * d.x, c.mapSize.x = o.x), i.y > u && (o.y = Math.floor(u / d.y), i.y = o.y * d.y, c.mapSize.y = o.y)), null === c.map || !0 === p || !0 === f) {
                        const e = this.type !== la ? {
                            minFilter: ps,
                            magFilter: ps
                        } : {};
                        null !== c.map && c.map.dispose(), c.map = new Mu(i.x, i.y, e), c.map.texture.name = l.name + ".shadowMap", c.camera.updateProjectionMatrix()
                    }
                    e.setRenderTarget(c.map), e.clear();
                    const g = c.getViewportCount();
                    for (let e = 0; e < g; e++) {
                        const t = c.getViewport(e);
                        a.set(o.x * t.x, o.y * t.y, o.x * t.z, o.y * t.w), h.viewport(a), c.updateMatrices(l, e), r = c.getFrustum(), x(n, s, c.camera, l, this.type)
                    }!0 !== c.isPointLightShadow && this.type === la && y(c, s), c.needsUpdate = !1
                }
                v = this.type, g.needsUpdate = !1, e.setRenderTarget(l, c, d)
            }
        }

        function km(e, t, n) {
            const r = n.isWebGL2;
            const i = new function() {
                    let t = !1;
                    const n = new xu;
                    let r = null;
                    const i = new xu(0, 0, 0, 0);
                    return {
                        setMask: function(n) {
                            r === n || t || (e.colorMask(n, n, n, n), r = n)
                        },
                        setLocked: function(e) {
                            t = e
                        },
                        setClear: function(t, r, o, a, s) {
                            !0 === s && (t *= a, r *= a, o *= a), n.set(t, r, o, a), !1 === i.equals(n) && (e.clearColor(t, r, o, a), i.copy(n))
                        },
                        reset: function() {
                            t = !1, r = null, i.set(-1, 0, 0, 0)
                        }
                    }
                },
                o = new function() {
                    let t = !1,
                        n = null,
                        r = null,
                        i = null;
                    return {
                        setTest: function(t) {
                            t ? j(e.DEPTH_TEST) : G(e.DEPTH_TEST)
                        },
                        setMask: function(r) {
                            n === r || t || (e.depthMask(r), n = r)
                        },
                        setFunc: function(t) {
                            if (r !== t) {
                                switch (t) {
                                    case Fa:
                                        e.depthFunc(e.NEVER);
                                        break;
                                    case Ua:
                                        e.depthFunc(e.ALWAYS);
                                        break;
                                    case za:
                                        e.depthFunc(e.LESS);
                                        break;
                                    case Ha:
                                        e.depthFunc(e.LEQUAL);
                                        break;
                                    case ja:
                                        e.depthFunc(e.EQUAL);
                                        break;
                                    case Ga:
                                        e.depthFunc(e.GEQUAL);
                                        break;
                                    case Va:
                                        e.depthFunc(e.GREATER);
                                        break;
                                    case qa:
                                        e.depthFunc(e.NOTEQUAL);
                                        break;
                                    default:
                                        e.depthFunc(e.LEQUAL)
                                }
                                r = t
                            }
                        },
                        setLocked: function(e) {
                            t = e
                        },
                        setClear: function(t) {
                            i !== t && (e.clearDepth(t), i = t)
                        },
                        reset: function() {
                            t = !1, n = null, r = null, i = null
                        }
                    }
                },
                a = new function() {
                    let t = !1,
                        n = null,
                        r = null,
                        i = null,
                        o = null,
                        a = null,
                        s = null,
                        l = null,
                        c = null;
                    return {
                        setTest: function(n) {
                            t || (n ? j(e.STENCIL_TEST) : G(e.STENCIL_TEST))
                        },
                        setMask: function(r) {
                            n === r || t || (e.stencilMask(r), n = r)
                        },
                        setFunc: function(t, n, a) {
                            r === t && i === n && o === a || (e.stencilFunc(t, n, a), r = t, i = n, o = a)
                        },
                        setOp: function(t, n, r) {
                            a === t && s === n && l === r || (e.stencilOp(t, n, r), a = t, s = n, l = r)
                        },
                        setLocked: function(e) {
                            t = e
                        },
                        setClear: function(t) {
                            c !== t && (e.clearStencil(t), c = t)
                        },
                        reset: function() {
                            t = !1, n = null, r = null, i = null, o = null, a = null, s = null, l = null, c = null
                        }
                    }
                },
                s = new WeakMap,
                l = new WeakMap;
            let c = {},
                u = {},
                d = new WeakMap,
                h = [],
                p = null,
                f = !1,
                m = null,
                g = null,
                v = null,
                y = null,
                b = null,
                x = null,
                _ = null,
                M = new Wd(0, 0, 0),
                w = 0,
                A = !1,
                S = null,
                E = null,
                C = null,
                T = null,
                P = null;
            const R = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            let I = !1,
                O = 0;
            const B = e.getParameter(e.VERSION); - 1 !== B.indexOf("WebGL") ? (O = parseFloat(/^WebGL (\d)/.exec(B)[1]), I = O >= 1) : -1 !== B.indexOf("OpenGL ES") && (O = parseFloat(/^OpenGL ES (\d)/.exec(B)[1]), I = O >= 2);
            let L = null,
                D = {};
            const N = e.getParameter(e.SCISSOR_BOX),
                k = e.getParameter(e.VIEWPORT),
                F = (new xu).fromArray(N),
                U = (new xu).fromArray(k);

            function z(t, n, i, o) {
                const a = new Uint8Array(4),
                    s = e.createTexture();
                e.bindTexture(t, s), e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST);
                for (let l = 0; l < i; l++) !r || t !== e.TEXTURE_3D && t !== e.TEXTURE_2D_ARRAY ? e.texImage2D(n + l, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, a) : e.texImage3D(n, 0, e.RGBA, 1, 1, o, 0, e.RGBA, e.UNSIGNED_BYTE, a);
                return s
            }
            const H = {};

            function j(t) {
                !0 !== c[t] && (e.enable(t), c[t] = !0)
            }

            function G(t) {
                !1 !== c[t] && (e.disable(t), c[t] = !1)
            }
            H[e.TEXTURE_2D] = z(e.TEXTURE_2D, e.TEXTURE_2D, 1), H[e.TEXTURE_CUBE_MAP] = z(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6), r && (H[e.TEXTURE_2D_ARRAY] = z(e.TEXTURE_2D_ARRAY, e.TEXTURE_2D_ARRAY, 1, 1), H[e.TEXTURE_3D] = z(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1)), i.setClear(0, 0, 0, 1), o.setClear(1), a.setClear(0), j(e.DEPTH_TEST), o.setFunc(Ha), X(!1), K(na), j(e.CULL_FACE), W(ha);
            const V = {
                [ya]: e.FUNC_ADD,
                [ba]: e.FUNC_SUBTRACT,
                [xa]: e.FUNC_REVERSE_SUBTRACT
            };
            if (r) V[_a] = e.MIN, V[Ma] = e.MAX;
            else {
                const e = t.get("EXT_blend_minmax");
                null !== e && (V[_a] = e.MIN_EXT, V[Ma] = e.MAX_EXT)
            }
            const q = {
                [wa]: e.ZERO,
                [Aa]: e.ONE,
                [Sa]: e.SRC_COLOR,
                [Ca]: e.SRC_ALPHA,
                [Ba]: e.SRC_ALPHA_SATURATE,
                [Ia]: e.DST_COLOR,
                [Pa]: e.DST_ALPHA,
                [Ea]: e.ONE_MINUS_SRC_COLOR,
                [Ta]: e.ONE_MINUS_SRC_ALPHA,
                [Oa]: e.ONE_MINUS_DST_COLOR,
                [Ra]: e.ONE_MINUS_DST_ALPHA,
                [La]: e.CONSTANT_COLOR,
                [Da]: e.ONE_MINUS_CONSTANT_COLOR,
                [Na]: e.CONSTANT_ALPHA,
                [ka]: e.ONE_MINUS_CONSTANT_ALPHA
            };

            function W(t, n, r, i, o, a, s, l, c, u) {
                if (t !== ha) {
                    if (!1 === f && (j(e.BLEND), f = !0), t === va) o = o || n, a = a || r, s = s || i, n === g && o === b || (e.blendEquationSeparate(V[n], V[o]), g = n, b = o), r === v && i === y && a === x && s === _ || (e.blendFuncSeparate(q[r], q[i], q[a], q[s]), v = r, y = i, x = a, _ = s), !1 !== l.equals(M) && c === w || (e.blendColor(l.r, l.g, l.b, c), M.copy(l), w = c), m = t, A = !1;
                    else if (t !== m || u !== A) {
                        if (g === ya && b === ya || (e.blendEquation(e.FUNC_ADD), g = ya, b = ya), u) switch (t) {
                            case pa:
                                e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                break;
                            case fa:
                                e.blendFunc(e.ONE, e.ONE);
                                break;
                            case ma:
                                e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                break;
                            case ga:
                                e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", t)
                        } else switch (t) {
                            case pa:
                                e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                break;
                            case fa:
                                e.blendFunc(e.SRC_ALPHA, e.ONE);
                                break;
                            case ma:
                                e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                break;
                            case ga:
                                e.blendFunc(e.ZERO, e.SRC_COLOR);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", t)
                        }
                        v = null, y = null, x = null, _ = null, M.set(0, 0, 0), w = 0, m = t, A = u
                    }
                } else !0 === f && (G(e.BLEND), f = !1)
            }

            function X(t) {
                S !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), S = t)
            }

            function K(t) {
                t !== ta ? (j(e.CULL_FACE), t !== E && (t === na ? e.cullFace(e.BACK) : t === ra ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : G(e.CULL_FACE), E = t
            }

            function J(t, n, r) {
                t ? (j(e.POLYGON_OFFSET_FILL), T === n && P === r || (e.polygonOffset(n, r), T = n, P = r)) : G(e.POLYGON_OFFSET_FILL)
            }
            return {
                buffers: {
                    color: i,
                    depth: o,
                    stencil: a
                },
                enable: j,
                disable: G,
                bindFramebuffer: function(t, n) {
                    return u[t] !== n && (e.bindFramebuffer(t, n), u[t] = n, r && (t === e.DRAW_FRAMEBUFFER && (u[e.FRAMEBUFFER] = n), t === e.FRAMEBUFFER && (u[e.DRAW_FRAMEBUFFER] = n)), !0)
                },
                drawBuffers: function(r, i) {
                    let o = h,
                        a = !1;
                    if (r)
                        if (o = d.get(i), void 0 === o && (o = [], d.set(i, o)), r.isWebGLMultipleRenderTargets) {
                            const t = r.texture;
                            if (o.length !== t.length || o[0] !== e.COLOR_ATTACHMENT0) {
                                for (let n = 0, r = t.length; n < r; n++) o[n] = e.COLOR_ATTACHMENT0 + n;
                                o.length = t.length, a = !0
                            }
                        } else o[0] !== e.COLOR_ATTACHMENT0 && (o[0] = e.COLOR_ATTACHMENT0, a = !0);
                    else o[0] !== e.BACK && (o[0] = e.BACK, a = !0);
                    a && (n.isWebGL2 ? e.drawBuffers(o) : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(o))
                },
                useProgram: function(t) {
                    return p !== t && (e.useProgram(t), p = t, !0)
                },
                setBlending: W,
                setMaterial: function(t, n) {
                    t.side === da ? G(e.CULL_FACE) : j(e.CULL_FACE);
                    let r = t.side === ua;
                    n && (r = !r), X(r), t.blending === pa && !1 === t.transparent ? W(ha) : W(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.blendColor, t.blendAlpha, t.premultipliedAlpha), o.setFunc(t.depthFunc), o.setTest(t.depthTest), o.setMask(t.depthWrite), i.setMask(t.colorWrite);
                    const s = t.stencilWrite;
                    a.setTest(s), s && (a.setMask(t.stencilWriteMask), a.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), a.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), J(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? j(e.SAMPLE_ALPHA_TO_COVERAGE) : G(e.SAMPLE_ALPHA_TO_COVERAGE)
                },
                setFlipSided: X,
                setCullFace: K,
                setLineWidth: function(t) {
                    t !== C && (I && e.lineWidth(t), C = t)
                },
                setPolygonOffset: J,
                setScissorTest: function(t) {
                    t ? j(e.SCISSOR_TEST) : G(e.SCISSOR_TEST)
                },
                activeTexture: function(t) {
                    void 0 === t && (t = e.TEXTURE0 + R - 1), L !== t && (e.activeTexture(t), L = t)
                },
                bindTexture: function(t, n, r) {
                    void 0 === r && (r = null === L ? e.TEXTURE0 + R - 1 : L);
                    let i = D[r];
                    void 0 === i && (i = {
                        type: void 0,
                        texture: void 0
                    }, D[r] = i), i.type === t && i.texture === n || (L !== r && (e.activeTexture(r), L = r), e.bindTexture(t, n || H[t]), i.type = t, i.texture = n)
                },
                unbindTexture: function() {
                    const t = D[L];
                    void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0)
                },
                compressedTexImage2D: function() {
                    try {
                        e.compressedTexImage2D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                compressedTexImage3D: function() {
                    try {
                        e.compressedTexImage3D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage2D: function() {
                    try {
                        e.texImage2D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage3D: function() {
                    try {
                        e.texImage3D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                updateUBOMapping: function(t, n) {
                    let r = l.get(n);
                    void 0 === r && (r = new WeakMap, l.set(n, r));
                    let i = r.get(t);
                    void 0 === i && (i = e.getUniformBlockIndex(n, t.name), r.set(t, i))
                },
                uniformBlockBinding: function(t, n) {
                    const r = l.get(n).get(t);
                    s.get(n) !== r && (e.uniformBlockBinding(n, r, t.__bindingPointIndex), s.set(n, r))
                },
                texStorage2D: function() {
                    try {
                        e.texStorage2D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texStorage3D: function() {
                    try {
                        e.texStorage3D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texSubImage2D: function() {
                    try {
                        e.texSubImage2D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texSubImage3D: function() {
                    try {
                        e.texSubImage3D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                compressedTexSubImage2D: function() {
                    try {
                        e.compressedTexSubImage2D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                compressedTexSubImage3D: function() {
                    try {
                        e.compressedTexSubImage3D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                scissor: function(t) {
                    !1 === F.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), F.copy(t))
                },
                viewport: function(t) {
                    !1 === U.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), U.copy(t))
                },
                reset: function() {
                    e.disable(e.BLEND), e.disable(e.CULL_FACE), e.disable(e.DEPTH_TEST), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SCISSOR_TEST), e.disable(e.STENCIL_TEST), e.disable(e.SAMPLE_ALPHA_TO_COVERAGE), e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ONE, e.ZERO), e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO), e.blendColor(0, 0, 0, 0), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(e.LESS), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(e.ALWAYS, 0, 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP), e.clearStencil(0), e.cullFace(e.BACK), e.frontFace(e.CCW), e.polygonOffset(0, 0), e.activeTexture(e.TEXTURE0), e.bindFramebuffer(e.FRAMEBUFFER, null), !0 === r && (e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), e.bindFramebuffer(e.READ_FRAMEBUFFER, null)), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), c = {}, L = null, D = {}, u = {}, d = new WeakMap, h = [], p = null, f = !1, m = null, g = null, v = null, y = null, b = null, x = null, _ = null, M = new Wd(0, 0, 0), w = 0, A = !1, S = null, E = null, C = null, T = null, P = null, F.set(0, 0, e.canvas.width, e.canvas.height), U.set(0, 0, e.canvas.width, e.canvas.height), i.reset(), o.reset(), a.reset()
                }
            }
        }

        function Fm(e, t, n, r, i, o, a) {
            const s = i.isWebGL2,
                l = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null,
                c = "undefined" !== typeof navigator && /OculusBrowser/g.test(navigator.userAgent),
                u = new WeakMap;
            let d;
            const h = new WeakMap;
            let p = !1;
            try {
                p = "undefined" !== typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
            } catch (U) {}

            function f(e, t) {
                return p ? new OffscreenCanvas(e, t) : nu("canvas")
            }

            function m(e, t, n, r) {
                let i = 1;
                if ((e.width > r || e.height > r) && (i = r / Math.max(e.width, e.height)), i < 1 || !0 === t) {
                    if ("undefined" !== typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && e instanceof ImageBitmap) {
                        const r = t ? Wc : Math.floor,
                            o = r(i * e.width),
                            a = r(i * e.height);
                        void 0 === d && (d = f(o, a));
                        const s = n ? f(o, a) : d;
                        s.width = o, s.height = a;
                        return s.getContext("2d").drawImage(e, 0, 0, o, a), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + o + "x" + a + ")."), s
                    }
                    return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e
                }
                return e
            }

            function g(e) {
                return qc(e.width) && qc(e.height)
            }

            function v(e, t) {
                return e.generateMipmaps && t && e.minFilter !== ps && e.minFilter !== ys
            }

            function y(t) {
                e.generateMipmap(t)
            }

            function b(n, r, i, o) {
                let a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                if (!1 === s) return r;
                if (null !== n) {
                    if (void 0 !== e[n]) return e[n];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                }
                let l = r;
                if (r === e.RED && (i === e.FLOAT && (l = e.R32F), i === e.HALF_FLOAT && (l = e.R16F), i === e.UNSIGNED_BYTE && (l = e.R8)), r === e.RED_INTEGER && (i === e.UNSIGNED_BYTE && (l = e.R8UI), i === e.UNSIGNED_SHORT && (l = e.R16UI), i === e.UNSIGNED_INT && (l = e.R32UI), i === e.BYTE && (l = e.R8I), i === e.SHORT && (l = e.R16I), i === e.INT && (l = e.R32I)), r === e.RG && (i === e.FLOAT && (l = e.RG32F), i === e.HALF_FLOAT && (l = e.RG16F), i === e.UNSIGNED_BYTE && (l = e.RG8)), r === e.RGBA) {
                    const t = a ? Kl : uu.getTransfer(o);
                    i === e.FLOAT && (l = e.RGBA32F), i === e.HALF_FLOAT && (l = e.RGBA16F), i === e.UNSIGNED_BYTE && (l = t === Jl ? e.SRGB8_ALPHA8 : e.RGBA8), i === e.UNSIGNED_SHORT_4_4_4_4 && (l = e.RGBA4), i === e.UNSIGNED_SHORT_5_5_5_1 && (l = e.RGB5_A1)
                }
                return l !== e.R16F && l !== e.R32F && l !== e.RG16F && l !== e.RG32F && l !== e.RGBA16F && l !== e.RGBA32F || t.get("EXT_color_buffer_float"), l
            }

            function x(e, t, n) {
                return !0 === v(e, n) || e.isFramebufferTexture && e.minFilter !== ps && e.minFilter !== ys ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
            }

            function _(t) {
                return t === ps || t === fs || t === gs ? e.NEAREST : e.LINEAR
            }

            function M(e) {
                const t = e.target;
                t.removeEventListener("dispose", M),
                    function(e) {
                        const t = r.get(e);
                        if (void 0 === t.__webglInit) return;
                        const n = e.source,
                            i = h.get(n);
                        if (i) {
                            const r = i[t.__cacheKey];
                            r.usedTimes--, 0 === r.usedTimes && A(e), 0 === Object.keys(i).length && h.delete(n)
                        }
                        r.remove(e)
                    }(t), t.isVideoTexture && u.delete(t)
            }

            function w(t) {
                const n = t.target;
                n.removeEventListener("dispose", w),
                    function(t) {
                        const n = t.texture,
                            i = r.get(t),
                            o = r.get(n);
                        void 0 !== o.__webglTexture && (e.deleteTexture(o.__webglTexture), a.memory.textures--);
                        t.depthTexture && t.depthTexture.dispose();
                        if (t.isWebGLCubeRenderTarget)
                            for (let r = 0; r < 6; r++) {
                                if (Array.isArray(i.__webglFramebuffer[r]))
                                    for (let t = 0; t < i.__webglFramebuffer[r].length; t++) e.deleteFramebuffer(i.__webglFramebuffer[r][t]);
                                else e.deleteFramebuffer(i.__webglFramebuffer[r]);
                                i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer[r])
                            } else {
                                if (Array.isArray(i.__webglFramebuffer))
                                    for (let t = 0; t < i.__webglFramebuffer.length; t++) e.deleteFramebuffer(i.__webglFramebuffer[t]);
                                else e.deleteFramebuffer(i.__webglFramebuffer);
                                if (i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer), i.__webglMultisampledFramebuffer && e.deleteFramebuffer(i.__webglMultisampledFramebuffer), i.__webglColorRenderbuffer)
                                    for (let t = 0; t < i.__webglColorRenderbuffer.length; t++) i.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(i.__webglColorRenderbuffer[t]);
                                i.__webglDepthRenderbuffer && e.deleteRenderbuffer(i.__webglDepthRenderbuffer)
                            }
                        if (t.isWebGLMultipleRenderTargets)
                            for (let s = 0, l = n.length; s < l; s++) {
                                const t = r.get(n[s]);
                                t.__webglTexture && (e.deleteTexture(t.__webglTexture), a.memory.textures--), r.remove(n[s])
                            }
                        r.remove(n), r.remove(t)
                    }(n)
            }

            function A(t) {
                const n = r.get(t);
                e.deleteTexture(n.__webglTexture);
                const i = t.source;
                delete h.get(i)[n.__cacheKey], a.memory.textures--
            }
            let S = 0;

            function E(t, i) {
                const o = r.get(t);
                if (t.isVideoTexture && function(e) {
                        const t = a.render.frame;
                        u.get(e) !== t && (u.set(e, t), e.update())
                    }(t), !1 === t.isRenderTargetTexture && t.version > 0 && o.__version !== t.version) {
                    const e = t.image;
                    if (null === e) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                    else {
                        if (!1 !== e.complete) return void O(o, t, i);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                n.bindTexture(e.TEXTURE_2D, o.__webglTexture, e.TEXTURE0 + i)
            }
            const C = {
                    [us]: e.REPEAT,
                    [ds]: e.CLAMP_TO_EDGE,
                    [hs]: e.MIRRORED_REPEAT
                },
                T = {
                    [ps]: e.NEAREST,
                    [fs]: e.NEAREST_MIPMAP_NEAREST,
                    [gs]: e.NEAREST_MIPMAP_LINEAR,
                    [ys]: e.LINEAR,
                    [bs]: e.LINEAR_MIPMAP_NEAREST,
                    [_s]: e.LINEAR_MIPMAP_LINEAR
                },
                P = {
                    [fc]: e.NEVER,
                    [_c]: e.ALWAYS,
                    [mc]: e.LESS,
                    [vc]: e.LEQUAL,
                    [gc]: e.EQUAL,
                    [xc]: e.GEQUAL,
                    [yc]: e.GREATER,
                    [bc]: e.NOTEQUAL
                };

            function R(n, o, a) {
                if (o.type !== Ps || !1 !== t.has("OES_texture_float_linear") || o.magFilter !== ys && o.magFilter !== bs && o.magFilter !== gs && o.magFilter !== _s && o.minFilter !== ys && o.minFilter !== bs && o.minFilter !== gs && o.minFilter !== _s || console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), a ? (e.texParameteri(n, e.TEXTURE_WRAP_S, C[o.wrapS]), e.texParameteri(n, e.TEXTURE_WRAP_T, C[o.wrapT]), n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, C[o.wrapR]), e.texParameteri(n, e.TEXTURE_MAG_FILTER, T[o.magFilter]), e.texParameteri(n, e.TEXTURE_MIN_FILTER, T[o.minFilter])) : (e.texParameteri(n, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(n, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, e.CLAMP_TO_EDGE), o.wrapS === ds && o.wrapT === ds || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(n, e.TEXTURE_MAG_FILTER, _(o.magFilter)), e.texParameteri(n, e.TEXTURE_MIN_FILTER, _(o.minFilter)), o.minFilter !== ps && o.minFilter !== ys && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), o.compareFunction && (e.texParameteri(n, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE), e.texParameteri(n, e.TEXTURE_COMPARE_FUNC, P[o.compareFunction])), !0 === t.has("EXT_texture_filter_anisotropic")) {
                    const a = t.get("EXT_texture_filter_anisotropic");
                    if (o.magFilter === ps) return;
                    if (o.minFilter !== gs && o.minFilter !== _s) return;
                    if (o.type === Ps && !1 === t.has("OES_texture_float_linear")) return;
                    if (!1 === s && o.type === Rs && !1 === t.has("OES_texture_half_float_linear")) return;
                    (o.anisotropy > 1 || r.get(o).__currentAnisotropy) && (e.texParameterf(n, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, i.getMaxAnisotropy())), r.get(o).__currentAnisotropy = o.anisotropy)
                }
            }

            function I(t, n) {
                let r = !1;
                void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", M));
                const i = n.source;
                let o = h.get(i);
                void 0 === o && (o = {}, h.set(i, o));
                const s = function(e) {
                    const t = [];
                    return t.push(e.wrapS), t.push(e.wrapT), t.push(e.wrapR || 0), t.push(e.magFilter), t.push(e.minFilter), t.push(e.anisotropy), t.push(e.internalFormat), t.push(e.format), t.push(e.type), t.push(e.generateMipmaps), t.push(e.premultiplyAlpha), t.push(e.flipY), t.push(e.unpackAlignment), t.push(e.colorSpace), t.join()
                }(n);
                if (s !== t.__cacheKey) {
                    void 0 === o[s] && (o[s] = {
                        texture: e.createTexture(),
                        usedTimes: 0
                    }, a.memory.textures++, r = !0), o[s].usedTimes++;
                    const i = o[t.__cacheKey];
                    void 0 !== i && (o[t.__cacheKey].usedTimes--, 0 === i.usedTimes && A(n)), t.__cacheKey = s, t.__webglTexture = o[s].texture
                }
                return r
            }

            function O(t, a, l) {
                let c = e.TEXTURE_2D;
                (a.isDataArrayTexture || a.isCompressedArrayTexture) && (c = e.TEXTURE_2D_ARRAY), a.isData3DTexture && (c = e.TEXTURE_3D);
                const u = I(t, a),
                    d = a.source;
                n.bindTexture(c, t.__webglTexture, e.TEXTURE0 + l);
                const h = r.get(d);
                if (d.version !== h.__version || !0 === u) {
                    n.activeTexture(e.TEXTURE0 + l);
                    const t = uu.getPrimaries(uu.workingColorSpace),
                        r = a.colorSpace === Gl ? null : uu.getPrimaries(a.colorSpace),
                        p = a.colorSpace === Gl || t === r ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                    e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, a.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, a.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, p);
                    const f = function(e) {
                        return !s && (e.wrapS !== ds || e.wrapT !== ds || e.minFilter !== ps && e.minFilter !== ys)
                    }(a) && !1 === g(a.image);
                    let _ = m(a.image, f, !1, i.maxTextureSize);
                    _ = F(a, _);
                    const M = g(_) || s,
                        w = o.convert(a.format, a.colorSpace);
                    let A, S = o.convert(a.type),
                        E = b(a.internalFormat, w, S, a.colorSpace, a.isVideoTexture);
                    R(c, a, M);
                    const C = a.mipmaps,
                        T = s && !0 !== a.isVideoTexture && E !== $s,
                        P = void 0 === h.__version || !0 === u,
                        I = d.dataReady,
                        O = x(a, _, M);
                    if (a.isDepthTexture) E = e.DEPTH_COMPONENT, s ? E = a.type === Ps ? e.DEPTH_COMPONENT32F : a.type === Ts ? e.DEPTH_COMPONENT24 : a.type === Bs ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT16 : a.type === Ps && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), a.format === Fs && E === e.DEPTH_COMPONENT && a.type !== Es && a.type !== Ts && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), a.type = Ts, S = o.convert(a.type)), a.format === Us && E === e.DEPTH_COMPONENT && (E = e.DEPTH_STENCIL, a.type !== Bs && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), a.type = Bs, S = o.convert(a.type))), P && (T ? n.texStorage2D(e.TEXTURE_2D, 1, E, _.width, _.height) : n.texImage2D(e.TEXTURE_2D, 0, E, _.width, _.height, 0, w, S, null));
                    else if (a.isDataTexture)
                        if (C.length > 0 && M) {
                            T && P && n.texStorage2D(e.TEXTURE_2D, O, E, C[0].width, C[0].height);
                            for (let t = 0, r = C.length; t < r; t++) A = C[t], T ? I && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, A.width, A.height, w, S, A.data) : n.texImage2D(e.TEXTURE_2D, t, E, A.width, A.height, 0, w, S, A.data);
                            a.generateMipmaps = !1
                        } else T ? (P && n.texStorage2D(e.TEXTURE_2D, O, E, _.width, _.height), I && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, _.width, _.height, w, S, _.data)) : n.texImage2D(e.TEXTURE_2D, 0, E, _.width, _.height, 0, w, S, _.data);
                    else if (a.isCompressedTexture)
                        if (a.isCompressedArrayTexture) {
                            T && P && n.texStorage3D(e.TEXTURE_2D_ARRAY, O, E, C[0].width, C[0].height, _.depth);
                            for (let t = 0, r = C.length; t < r; t++) A = C[t], a.format !== Ds ? null !== w ? T ? I && n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, A.width, A.height, _.depth, w, A.data, 0, 0) : n.compressedTexImage3D(e.TEXTURE_2D_ARRAY, t, E, A.width, A.height, _.depth, 0, A.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : T ? I && n.texSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, A.width, A.height, _.depth, w, S, A.data) : n.texImage3D(e.TEXTURE_2D_ARRAY, t, E, A.width, A.height, _.depth, 0, w, S, A.data)
                        } else {
                            T && P && n.texStorage2D(e.TEXTURE_2D, O, E, C[0].width, C[0].height);
                            for (let t = 0, r = C.length; t < r; t++) A = C[t], a.format !== Ds ? null !== w ? T ? I && n.compressedTexSubImage2D(e.TEXTURE_2D, t, 0, 0, A.width, A.height, w, A.data) : n.compressedTexImage2D(e.TEXTURE_2D, t, E, A.width, A.height, 0, A.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : T ? I && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, A.width, A.height, w, S, A.data) : n.texImage2D(e.TEXTURE_2D, t, E, A.width, A.height, 0, w, S, A.data)
                        }
                    else if (a.isDataArrayTexture) T ? (P && n.texStorage3D(e.TEXTURE_2D_ARRAY, O, E, _.width, _.height, _.depth), I && n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, 0, _.width, _.height, _.depth, w, S, _.data)) : n.texImage3D(e.TEXTURE_2D_ARRAY, 0, E, _.width, _.height, _.depth, 0, w, S, _.data);
                    else if (a.isData3DTexture) T ? (P && n.texStorage3D(e.TEXTURE_3D, O, E, _.width, _.height, _.depth), I && n.texSubImage3D(e.TEXTURE_3D, 0, 0, 0, 0, _.width, _.height, _.depth, w, S, _.data)) : n.texImage3D(e.TEXTURE_3D, 0, E, _.width, _.height, _.depth, 0, w, S, _.data);
                    else if (a.isFramebufferTexture) {
                        if (P)
                            if (T) n.texStorage2D(e.TEXTURE_2D, O, E, _.width, _.height);
                            else {
                                let t = _.width,
                                    r = _.height;
                                for (let i = 0; i < O; i++) n.texImage2D(e.TEXTURE_2D, i, E, t, r, 0, w, S, null), t >>= 1, r >>= 1
                            }
                    } else if (C.length > 0 && M) {
                        T && P && n.texStorage2D(e.TEXTURE_2D, O, E, C[0].width, C[0].height);
                        for (let t = 0, r = C.length; t < r; t++) A = C[t], T ? I && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, w, S, A) : n.texImage2D(e.TEXTURE_2D, t, E, w, S, A);
                        a.generateMipmaps = !1
                    } else T ? (P && n.texStorage2D(e.TEXTURE_2D, O, E, _.width, _.height), I && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, w, S, _)) : n.texImage2D(e.TEXTURE_2D, 0, E, w, S, _);
                    v(a, M) && y(c), h.__version = d.version, a.onUpdate && a.onUpdate(a)
                }
                t.__version = a.version
            }

            function B(t, i, a, s, c, u) {
                const d = o.convert(a.format, a.colorSpace),
                    h = o.convert(a.type),
                    p = b(a.internalFormat, d, h, a.colorSpace);
                if (!r.get(i).__hasExternalTextures) {
                    const t = Math.max(1, i.width >> u),
                        r = Math.max(1, i.height >> u);
                    c === e.TEXTURE_3D || c === e.TEXTURE_2D_ARRAY ? n.texImage3D(c, u, p, t, r, i.depth, 0, d, h, null) : n.texImage2D(c, u, p, t, r, 0, d, h, null)
                }
                n.bindFramebuffer(e.FRAMEBUFFER, t), k(i) ? l.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, s, c, r.get(a).__webglTexture, 0, N(i)) : (c === e.TEXTURE_2D || c >= e.TEXTURE_CUBE_MAP_POSITIVE_X && c <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z) && e.framebufferTexture2D(e.FRAMEBUFFER, s, c, r.get(a).__webglTexture, u), n.bindFramebuffer(e.FRAMEBUFFER, null)
            }

            function L(t, n, r) {
                if (e.bindRenderbuffer(e.RENDERBUFFER, t), n.depthBuffer && !n.stencilBuffer) {
                    let i = !0 === s ? e.DEPTH_COMPONENT24 : e.DEPTH_COMPONENT16;
                    if (r || k(n)) {
                        const t = n.depthTexture;
                        t && t.isDepthTexture && (t.type === Ps ? i = e.DEPTH_COMPONENT32F : t.type === Ts && (i = e.DEPTH_COMPONENT24));
                        const r = N(n);
                        k(n) ? l.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, r, i, n.width, n.height) : e.renderbufferStorageMultisample(e.RENDERBUFFER, r, i, n.width, n.height)
                    } else e.renderbufferStorage(e.RENDERBUFFER, i, n.width, n.height);
                    e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t)
                } else if (n.depthBuffer && n.stencilBuffer) {
                    const i = N(n);
                    r && !1 === k(n) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, i, e.DEPTH24_STENCIL8, n.width, n.height) : k(n) ? l.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, i, e.DEPTH24_STENCIL8, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, n.width, n.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, t)
                } else {
                    const t = !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture];
                    for (let i = 0; i < t.length; i++) {
                        const a = t[i],
                            s = o.convert(a.format, a.colorSpace),
                            c = o.convert(a.type),
                            u = b(a.internalFormat, s, c, a.colorSpace),
                            d = N(n);
                        r && !1 === k(n) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, d, u, n.width, n.height) : k(n) ? l.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, d, u, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, u, n.width, n.height)
                    }
                }
                e.bindRenderbuffer(e.RENDERBUFFER, null)
            }

            function D(t) {
                const i = r.get(t),
                    o = !0 === t.isWebGLCubeRenderTarget;
                if (t.depthTexture && !i.__autoAllocateDepthBuffer) {
                    if (o) throw new Error("target.depthTexture not supported in Cube render targets");
                    ! function(t, i) {
                        if (i && i.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                        if (n.bindFramebuffer(e.FRAMEBUFFER, t), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), E(i.depthTexture, 0);
                        const o = r.get(i.depthTexture).__webglTexture,
                            a = N(i);
                        if (i.depthTexture.format === Fs) k(i) ? l.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, o, 0, a) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, o, 0);
                        else {
                            if (i.depthTexture.format !== Us) throw new Error("Unknown depthTexture format");
                            k(i) ? l.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, o, 0, a) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, o, 0)
                        }
                    }(i.__webglFramebuffer, t)
                } else if (o) {
                    i.__webglDepthbuffer = [];
                    for (let r = 0; r < 6; r++) n.bindFramebuffer(e.FRAMEBUFFER, i.__webglFramebuffer[r]), i.__webglDepthbuffer[r] = e.createRenderbuffer(), L(i.__webglDepthbuffer[r], t, !1)
                } else n.bindFramebuffer(e.FRAMEBUFFER, i.__webglFramebuffer), i.__webglDepthbuffer = e.createRenderbuffer(), L(i.__webglDepthbuffer, t, !1);
                n.bindFramebuffer(e.FRAMEBUFFER, null)
            }

            function N(e) {
                return Math.min(i.maxSamples, e.samples)
            }

            function k(e) {
                const n = r.get(e);
                return s && e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
            }

            function F(e, n) {
                const r = e.colorSpace,
                    i = e.format,
                    o = e.type;
                return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || e.format === Bc || r !== ql && r !== Gl && (uu.getTransfer(r) === Jl ? !1 === s ? !0 === t.has("EXT_sRGB") && i === Ds ? (e.format = Bc, e.minFilter = ys, e.generateMipmaps = !1) : n = fu.sRGBToLinear(n) : i === Ds && o === ws || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", r)), n
            }
            this.allocateTextureUnit = function() {
                const e = S;
                return e >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + i.maxTextures), S += 1, e
            }, this.resetTextureUnits = function() {
                S = 0
            }, this.setTexture2D = E, this.setTexture2DArray = function(t, i) {
                const o = r.get(t);
                t.version > 0 && o.__version !== t.version ? O(o, t, i) : n.bindTexture(e.TEXTURE_2D_ARRAY, o.__webglTexture, e.TEXTURE0 + i)
            }, this.setTexture3D = function(t, i) {
                const o = r.get(t);
                t.version > 0 && o.__version !== t.version ? O(o, t, i) : n.bindTexture(e.TEXTURE_3D, o.__webglTexture, e.TEXTURE0 + i)
            }, this.setTextureCube = function(t, a) {
                const l = r.get(t);
                t.version > 0 && l.__version !== t.version ? function(t, a, l) {
                    if (6 !== a.image.length) return;
                    const c = I(t, a),
                        u = a.source;
                    n.bindTexture(e.TEXTURE_CUBE_MAP, t.__webglTexture, e.TEXTURE0 + l);
                    const d = r.get(u);
                    if (u.version !== d.__version || !0 === c) {
                        n.activeTexture(e.TEXTURE0 + l);
                        const t = uu.getPrimaries(uu.workingColorSpace),
                            r = a.colorSpace === Gl ? null : uu.getPrimaries(a.colorSpace),
                            h = a.colorSpace === Gl || t === r ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                        e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, a.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, a.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, h);
                        const p = a.isCompressedTexture || a.image[0].isCompressedTexture,
                            f = a.image[0] && a.image[0].isDataTexture,
                            _ = [];
                        for (let e = 0; e < 6; e++) _[e] = p || f ? f ? a.image[e].image : a.image[e] : m(a.image[e], !1, !0, i.maxCubemapSize), _[e] = F(a, _[e]);
                        const M = _[0],
                            w = g(M) || s,
                            A = o.convert(a.format, a.colorSpace),
                            S = o.convert(a.type),
                            E = b(a.internalFormat, A, S, a.colorSpace),
                            C = s && !0 !== a.isVideoTexture,
                            T = void 0 === d.__version || !0 === c,
                            P = u.dataReady;
                        let I, O = x(a, M, w);
                        if (R(e.TEXTURE_CUBE_MAP, a, w), p) {
                            C && T && n.texStorage2D(e.TEXTURE_CUBE_MAP, O, E, M.width, M.height);
                            for (let t = 0; t < 6; t++) {
                                I = _[t].mipmaps;
                                for (let r = 0; r < I.length; r++) {
                                    const i = I[r];
                                    a.format !== Ds ? null !== A ? C ? P && n.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, 0, 0, i.width, i.height, A, i.data) : n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, E, i.width, i.height, 0, i.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : C ? P && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, 0, 0, i.width, i.height, A, S, i.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, E, i.width, i.height, 0, A, S, i.data)
                                }
                            }
                        } else {
                            I = a.mipmaps, C && T && (I.length > 0 && O++, n.texStorage2D(e.TEXTURE_CUBE_MAP, O, E, _[0].width, _[0].height));
                            for (let t = 0; t < 6; t++)
                                if (f) {
                                    C ? P && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, _[t].width, _[t].height, A, S, _[t].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, E, _[t].width, _[t].height, 0, A, S, _[t].data);
                                    for (let r = 0; r < I.length; r++) {
                                        const i = I[r].image[t].image;
                                        C ? P && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r + 1, 0, 0, i.width, i.height, A, S, i.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r + 1, E, i.width, i.height, 0, A, S, i.data)
                                    }
                                } else {
                                    C ? P && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, A, S, _[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, E, A, S, _[t]);
                                    for (let r = 0; r < I.length; r++) {
                                        const i = I[r];
                                        C ? P && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r + 1, 0, 0, A, S, i.image[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r + 1, E, A, S, i.image[t])
                                    }
                                }
                        }
                        v(a, w) && y(e.TEXTURE_CUBE_MAP), d.__version = u.version, a.onUpdate && a.onUpdate(a)
                    }
                    t.__version = a.version
                }(l, t, a) : n.bindTexture(e.TEXTURE_CUBE_MAP, l.__webglTexture, e.TEXTURE0 + a)
            }, this.rebindTextures = function(t, n, i) {
                const o = r.get(t);
                void 0 !== n && B(o.__webglFramebuffer, t, t.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, 0), void 0 !== i && D(t)
            }, this.setupRenderTarget = function(t) {
                const l = t.texture,
                    c = r.get(t),
                    u = r.get(l);
                t.addEventListener("dispose", w), !0 !== t.isWebGLMultipleRenderTargets && (void 0 === u.__webglTexture && (u.__webglTexture = e.createTexture()), u.__version = l.version, a.memory.textures++);
                const d = !0 === t.isWebGLCubeRenderTarget,
                    h = !0 === t.isWebGLMultipleRenderTargets,
                    p = g(t) || s;
                if (d) {
                    c.__webglFramebuffer = [];
                    for (let t = 0; t < 6; t++)
                        if (s && l.mipmaps && l.mipmaps.length > 0) {
                            c.__webglFramebuffer[t] = [];
                            for (let n = 0; n < l.mipmaps.length; n++) c.__webglFramebuffer[t][n] = e.createFramebuffer()
                        } else c.__webglFramebuffer[t] = e.createFramebuffer()
                } else {
                    if (s && l.mipmaps && l.mipmaps.length > 0) {
                        c.__webglFramebuffer = [];
                        for (let t = 0; t < l.mipmaps.length; t++) c.__webglFramebuffer[t] = e.createFramebuffer()
                    } else c.__webglFramebuffer = e.createFramebuffer();
                    if (h)
                        if (i.drawBuffers) {
                            const n = t.texture;
                            for (let t = 0, i = n.length; t < i; t++) {
                                const i = r.get(n[t]);
                                void 0 === i.__webglTexture && (i.__webglTexture = e.createTexture(), a.memory.textures++)
                            }
                        } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                    if (s && t.samples > 0 && !1 === k(t)) {
                        const r = h ? l : [l];
                        c.__webglMultisampledFramebuffer = e.createFramebuffer(), c.__webglColorRenderbuffer = [], n.bindFramebuffer(e.FRAMEBUFFER, c.__webglMultisampledFramebuffer);
                        for (let n = 0; n < r.length; n++) {
                            const i = r[n];
                            c.__webglColorRenderbuffer[n] = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, c.__webglColorRenderbuffer[n]);
                            const a = o.convert(i.format, i.colorSpace),
                                s = o.convert(i.type),
                                l = b(i.internalFormat, a, s, i.colorSpace, !0 === t.isXRRenderTarget),
                                u = N(t);
                            e.renderbufferStorageMultisample(e.RENDERBUFFER, u, l, t.width, t.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + n, e.RENDERBUFFER, c.__webglColorRenderbuffer[n])
                        }
                        e.bindRenderbuffer(e.RENDERBUFFER, null), t.depthBuffer && (c.__webglDepthRenderbuffer = e.createRenderbuffer(), L(c.__webglDepthRenderbuffer, t, !0)), n.bindFramebuffer(e.FRAMEBUFFER, null)
                    }
                }
                if (d) {
                    n.bindTexture(e.TEXTURE_CUBE_MAP, u.__webglTexture), R(e.TEXTURE_CUBE_MAP, l, p);
                    for (let n = 0; n < 6; n++)
                        if (s && l.mipmaps && l.mipmaps.length > 0)
                            for (let r = 0; r < l.mipmaps.length; r++) B(c.__webglFramebuffer[n][r], t, l, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, r);
                        else B(c.__webglFramebuffer[n], t, l, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0);
                    v(l, p) && y(e.TEXTURE_CUBE_MAP), n.unbindTexture()
                } else if (h) {
                    const i = t.texture;
                    for (let o = 0, a = i.length; o < a; o++) {
                        const a = i[o],
                            s = r.get(a);
                        n.bindTexture(e.TEXTURE_2D, s.__webglTexture), R(e.TEXTURE_2D, a, p), B(c.__webglFramebuffer, t, a, e.COLOR_ATTACHMENT0 + o, e.TEXTURE_2D, 0), v(a, p) && y(e.TEXTURE_2D)
                    }
                    n.unbindTexture()
                } else {
                    let r = e.TEXTURE_2D;
                    if ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (s ? r = t.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), n.bindTexture(r, u.__webglTexture), R(r, l, p), s && l.mipmaps && l.mipmaps.length > 0)
                        for (let n = 0; n < l.mipmaps.length; n++) B(c.__webglFramebuffer[n], t, l, e.COLOR_ATTACHMENT0, r, n);
                    else B(c.__webglFramebuffer, t, l, e.COLOR_ATTACHMENT0, r, 0);
                    v(l, p) && y(r), n.unbindTexture()
                }
                t.depthBuffer && D(t)
            }, this.updateRenderTargetMipmap = function(t) {
                const i = g(t) || s,
                    o = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
                for (let a = 0, s = o.length; a < s; a++) {
                    const s = o[a];
                    if (v(s, i)) {
                        const i = t.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : e.TEXTURE_2D,
                            o = r.get(s).__webglTexture;
                        n.bindTexture(i, o), y(i), n.unbindTexture()
                    }
                }
            }, this.updateMultisampleRenderTarget = function(t) {
                if (s && t.samples > 0 && !1 === k(t)) {
                    const i = t.isWebGLMultipleRenderTargets ? t.texture : [t.texture],
                        o = t.width,
                        a = t.height;
                    let s = e.COLOR_BUFFER_BIT;
                    const l = [],
                        u = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT,
                        d = r.get(t),
                        h = !0 === t.isWebGLMultipleRenderTargets;
                    if (h)
                        for (let t = 0; t < i.length; t++) n.bindFramebuffer(e.FRAMEBUFFER, d.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, null), n.bindFramebuffer(e.FRAMEBUFFER, d.__webglFramebuffer), e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, null, 0);
                    n.bindFramebuffer(e.READ_FRAMEBUFFER, d.__webglMultisampledFramebuffer), n.bindFramebuffer(e.DRAW_FRAMEBUFFER, d.__webglFramebuffer);
                    for (let n = 0; n < i.length; n++) {
                        l.push(e.COLOR_ATTACHMENT0 + n), t.depthBuffer && l.push(u);
                        const p = void 0 !== d.__ignoreDepthValues && d.__ignoreDepthValues;
                        if (!1 === p && (t.depthBuffer && (s |= e.DEPTH_BUFFER_BIT), t.stencilBuffer && (s |= e.STENCIL_BUFFER_BIT)), h && e.framebufferRenderbuffer(e.READ_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, d.__webglColorRenderbuffer[n]), !0 === p && (e.invalidateFramebuffer(e.READ_FRAMEBUFFER, [u]), e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [u])), h) {
                            const t = r.get(i[n]).__webglTexture;
                            e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0)
                        }
                        e.blitFramebuffer(0, 0, o, a, 0, 0, o, a, s, e.NEAREST), c && e.invalidateFramebuffer(e.READ_FRAMEBUFFER, l)
                    }
                    if (n.bindFramebuffer(e.READ_FRAMEBUFFER, null), n.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), h)
                        for (let t = 0; t < i.length; t++) {
                            n.bindFramebuffer(e.FRAMEBUFFER, d.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, d.__webglColorRenderbuffer[t]);
                            const o = r.get(i[t]).__webglTexture;
                            n.bindFramebuffer(e.FRAMEBUFFER, d.__webglFramebuffer), e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, o, 0)
                        }
                    n.bindFramebuffer(e.DRAW_FRAMEBUFFER, d.__webglMultisampledFramebuffer)
                }
            }, this.setupDepthRenderbuffer = D, this.setupFrameBufferTexture = B, this.useMultisampledRTT = k
        }

        function Um(e, t, n) {
            const r = n.isWebGL2;
            return {
                convert: function(n) {
                    let i, o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Gl;
                    const a = uu.getTransfer(o);
                    if (n === ws) return e.UNSIGNED_BYTE;
                    if (n === Is) return e.UNSIGNED_SHORT_4_4_4_4;
                    if (n === Os) return e.UNSIGNED_SHORT_5_5_5_1;
                    if (n === As) return e.BYTE;
                    if (n === Ss) return e.SHORT;
                    if (n === Es) return e.UNSIGNED_SHORT;
                    if (n === Cs) return e.INT;
                    if (n === Ts) return e.UNSIGNED_INT;
                    if (n === Ps) return e.FLOAT;
                    if (n === Rs) return r ? e.HALF_FLOAT : (i = t.get("OES_texture_half_float"), null !== i ? i.HALF_FLOAT_OES : null);
                    if (n === Ls) return e.ALPHA;
                    if (n === Ds) return e.RGBA;
                    if (n === Ns) return e.LUMINANCE;
                    if (n === ks) return e.LUMINANCE_ALPHA;
                    if (n === Fs) return e.DEPTH_COMPONENT;
                    if (n === Us) return e.DEPTH_STENCIL;
                    if (n === Bc) return i = t.get("EXT_sRGB"), null !== i ? i.SRGB_ALPHA_EXT : null;
                    if (n === zs) return e.RED;
                    if (n === Hs) return e.RED_INTEGER;
                    if (n === js) return e.RG;
                    if (n === Gs) return e.RG_INTEGER;
                    if (n === Vs) return e.RGBA_INTEGER;
                    if (n === qs || n === Ws || n === Xs || n === Ks)
                        if (a === Jl) {
                            if (i = t.get("WEBGL_compressed_texture_s3tc_srgb"), null === i) return null;
                            if (n === qs) return i.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                            if (n === Ws) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                            if (n === Xs) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                            if (n === Ks) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                        } else {
                            if (i = t.get("WEBGL_compressed_texture_s3tc"), null === i) return null;
                            if (n === qs) return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (n === Ws) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (n === Xs) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (n === Ks) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                    if (n === Js || n === Ys || n === Qs || n === Zs) {
                        if (i = t.get("WEBGL_compressed_texture_pvrtc"), null === i) return null;
                        if (n === Js) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (n === Ys) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (n === Qs) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (n === Zs) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (n === $s) return i = t.get("WEBGL_compressed_texture_etc1"), null !== i ? i.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if (n === el || n === tl) {
                        if (i = t.get("WEBGL_compressed_texture_etc"), null === i) return null;
                        if (n === el) return a === Jl ? i.COMPRESSED_SRGB8_ETC2 : i.COMPRESSED_RGB8_ETC2;
                        if (n === tl) return a === Jl ? i.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : i.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    if (n === nl || n === rl || n === il || n === ol || n === al || n === sl || n === ll || n === cl || n === ul || n === dl || n === hl || n === pl || n === fl || n === ml) {
                        if (i = t.get("WEBGL_compressed_texture_astc"), null === i) return null;
                        if (n === nl) return a === Jl ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : i.COMPRESSED_RGBA_ASTC_4x4_KHR;
                        if (n === rl) return a === Jl ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : i.COMPRESSED_RGBA_ASTC_5x4_KHR;
                        if (n === il) return a === Jl ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : i.COMPRESSED_RGBA_ASTC_5x5_KHR;
                        if (n === ol) return a === Jl ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : i.COMPRESSED_RGBA_ASTC_6x5_KHR;
                        if (n === al) return a === Jl ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : i.COMPRESSED_RGBA_ASTC_6x6_KHR;
                        if (n === sl) return a === Jl ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : i.COMPRESSED_RGBA_ASTC_8x5_KHR;
                        if (n === ll) return a === Jl ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : i.COMPRESSED_RGBA_ASTC_8x6_KHR;
                        if (n === cl) return a === Jl ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : i.COMPRESSED_RGBA_ASTC_8x8_KHR;
                        if (n === ul) return a === Jl ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : i.COMPRESSED_RGBA_ASTC_10x5_KHR;
                        if (n === dl) return a === Jl ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : i.COMPRESSED_RGBA_ASTC_10x6_KHR;
                        if (n === hl) return a === Jl ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : i.COMPRESSED_RGBA_ASTC_10x8_KHR;
                        if (n === pl) return a === Jl ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : i.COMPRESSED_RGBA_ASTC_10x10_KHR;
                        if (n === fl) return a === Jl ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : i.COMPRESSED_RGBA_ASTC_12x10_KHR;
                        if (n === ml) return a === Jl ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : i.COMPRESSED_RGBA_ASTC_12x12_KHR
                    }
                    if (n === gl || n === vl || n === yl) {
                        if (i = t.get("EXT_texture_compression_bptc"), null === i) return null;
                        if (n === gl) return a === Jl ? i.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : i.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                        if (n === vl) return i.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                        if (n === yl) return i.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                    }
                    if (n === bl || n === xl || n === _l || n === Ml) {
                        if (i = t.get("EXT_texture_compression_rgtc"), null === i) return null;
                        if (n === gl) return i.COMPRESSED_RED_RGTC1_EXT;
                        if (n === xl) return i.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                        if (n === _l) return i.COMPRESSED_RED_GREEN_RGTC2_EXT;
                        if (n === Ml) return i.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                    }
                    return n === Bs ? r ? e.UNSIGNED_INT_24_8 : (i = t.get("WEBGL_depth_texture"), null !== i ? i.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== e[n] ? e[n] : null
                }
            }
        }
        class zm extends Zh {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                super(), this.isArrayCamera = !0, this.cameras = e
            }
        }
        class Hm extends Rd {
            constructor() {
                super(), this.isGroup = !0, this.type = "Group"
            }
        }
        const jm = {
            type: "move"
        };
        class Gm {
            constructor() {
                this._targetRay = null, this._grip = null, this._hand = null
            }
            getHandSpace() {
                return null === this._hand && (this._hand = new Hm, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                    pinching: !1
                }), this._hand
            }
            getTargetRaySpace() {
                return null === this._targetRay && (this._targetRay = new Hm, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Pu, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Pu), this._targetRay
            }
            getGripSpace() {
                return null === this._grip && (this._grip = new Hm, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Pu, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Pu), this._grip
            }
            dispatchEvent(e) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this
            }
            connect(e) {
                if (e && e.hand) {
                    const t = this._hand;
                    if (t)
                        for (const n of e.hand.values()) this._getHandJoint(t, n)
                }
                return this.dispatchEvent({
                    type: "connected",
                    data: e
                }), this
            }
            disconnect(e) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: e
                }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
            }
            update(e, t, n) {
                let r = null,
                    i = null,
                    o = null;
                const a = this._targetRay,
                    s = this._grip,
                    l = this._hand;
                if (e && "visible-blurred" !== t.session.visibilityState) {
                    if (l && e.hand) {
                        o = !0;
                        for (const o of e.hand.values()) {
                            const e = t.getJointPose(o, n),
                                r = this._getHandJoint(l, o);
                            null !== e && (r.matrix.fromArray(e.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.matrixWorldNeedsUpdate = !0, r.jointRadius = e.radius), r.visible = null !== e
                        }
                        const r = l.joints["index-finger-tip"],
                            i = l.joints["thumb-tip"],
                            a = r.position.distanceTo(i.position),
                            s = .02,
                            c = .005;
                        l.inputState.pinching && a > s + c ? (l.inputState.pinching = !1, this.dispatchEvent({
                            type: "pinchend",
                            handedness: e.handedness,
                            target: this
                        })) : !l.inputState.pinching && a <= s - c && (l.inputState.pinching = !0, this.dispatchEvent({
                            type: "pinchstart",
                            handedness: e.handedness,
                            target: this
                        }))
                    } else null !== s && e.gripSpace && (i = t.getPose(e.gripSpace, n), null !== i && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), s.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(i.linearVelocity)) : s.hasLinearVelocity = !1, i.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(i.angularVelocity)) : s.hasAngularVelocity = !1));
                    null !== a && (r = t.getPose(e.targetRaySpace, n), null === r && null !== i && (r = i), null !== r && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(jm)))
                }
                return null !== a && (a.visible = null !== r), null !== s && (s.visible = null !== i), null !== l && (l.visible = null !== o), this
            }
            _getHandJoint(e, t) {
                if (void 0 === e.joints[t.jointName]) {
                    const n = new Hm;
                    n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n)
                }
                return e.joints[t.jointName]
            }
        }
        class Vm {
            constructor() {
                this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0
            }
            init(e, t, n) {
                if (null === this.texture) {
                    const r = new bu;
                    e.properties.get(r).__webglTexture = t.texture, t.depthNear == n.depthNear && t.depthFar == n.depthFar || (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = r
                }
            }
            render(e, t) {
                if (null !== this.texture) {
                    if (null === this.mesh) {
                        const e = t.cameras[0].viewport,
                            n = new Xh({
                                extensions: {
                                    fragDepth: !0
                                },
                                vertexShader: "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",
                                fragmentShader: "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepthEXT = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepthEXT = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",
                                uniforms: {
                                    depthColor: {
                                        value: this.texture
                                    },
                                    depthWidth: {
                                        value: e.z
                                    },
                                    depthHeight: {
                                        value: e.w
                                    }
                                }
                            });
                        this.mesh = new zh(new hp(20, 20), n)
                    }
                    e.render(this.mesh, t)
                }
            }
            reset() {
                this.texture = null, this.mesh = null
            }
        }
        class qm extends Nc {
            constructor(e, t) {
                super();
                const n = this;
                let r = null,
                    i = 1,
                    o = null,
                    a = "local-floor",
                    s = 1,
                    l = null,
                    c = null,
                    u = null,
                    d = null,
                    h = null,
                    p = null;
                const f = new Vm,
                    m = t.getContextAttributes();
                let g = null,
                    v = null;
                const y = [],
                    b = [],
                    x = new Yc;
                let _ = null;
                const M = new Zh;
                M.layers.enable(1), M.viewport = new xu;
                const w = new Zh;
                w.layers.enable(2), w.viewport = new xu;
                const A = [M, w],
                    S = new zm;
                S.layers.enable(1), S.layers.enable(2);
                let E = null,
                    C = null;

                function T(e) {
                    const t = b.indexOf(e.inputSource);
                    if (-1 === t) return;
                    const n = y[t];
                    void 0 !== n && (n.update(e.inputSource, e.frame, l || o), n.dispatchEvent({
                        type: e.type,
                        data: e.inputSource
                    }))
                }

                function P() {
                    r.removeEventListener("select", T), r.removeEventListener("selectstart", T), r.removeEventListener("selectend", T), r.removeEventListener("squeeze", T), r.removeEventListener("squeezestart", T), r.removeEventListener("squeezeend", T), r.removeEventListener("end", P), r.removeEventListener("inputsourceschange", R);
                    for (let e = 0; e < y.length; e++) {
                        const t = b[e];
                        null !== t && (b[e] = null, y[e].disconnect(t))
                    }
                    E = null, C = null, f.reset(), e.setRenderTarget(g), h = null, d = null, u = null, r = null, v = null, D.stop(), n.isPresenting = !1, e.setPixelRatio(_), e.setSize(x.width, x.height, !1), n.dispatchEvent({
                        type: "sessionend"
                    })
                }

                function R(e) {
                    for (let t = 0; t < e.removed.length; t++) {
                        const n = e.removed[t],
                            r = b.indexOf(n);
                        r >= 0 && (b[r] = null, y[r].disconnect(n))
                    }
                    for (let t = 0; t < e.added.length; t++) {
                        const n = e.added[t];
                        let r = b.indexOf(n);
                        if (-1 === r) {
                            for (let e = 0; e < y.length; e++) {
                                if (e >= b.length) {
                                    b.push(n), r = e;
                                    break
                                }
                                if (null === b[e]) {
                                    b[e] = n, r = e;
                                    break
                                }
                            }
                            if (-1 === r) break
                        }
                        const i = y[r];
                        i && i.connect(n)
                    }
                }
                this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(e) {
                    let t = y[e];
                    return void 0 === t && (t = new Gm, y[e] = t), t.getTargetRaySpace()
                }, this.getControllerGrip = function(e) {
                    let t = y[e];
                    return void 0 === t && (t = new Gm, y[e] = t), t.getGripSpace()
                }, this.getHand = function(e) {
                    let t = y[e];
                    return void 0 === t && (t = new Gm, y[e] = t), t.getHandSpace()
                }, this.setFramebufferScaleFactor = function(e) {
                    i = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }, this.setReferenceSpaceType = function(e) {
                    a = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }, this.getReferenceSpace = function() {
                    return l || o
                }, this.setReferenceSpace = function(e) {
                    l = e
                }, this.getBaseLayer = function() {
                    return null !== d ? d : h
                }, this.getBinding = function() {
                    return u
                }, this.getFrame = function() {
                    return p
                }, this.getSession = function() {
                    return r
                }, this.setSession = async function(c) {
                    if (r = c, null !== r) {
                        if (g = e.getRenderTarget(), r.addEventListener("select", T), r.addEventListener("selectstart", T), r.addEventListener("selectend", T), r.addEventListener("squeeze", T), r.addEventListener("squeezestart", T), r.addEventListener("squeezeend", T), r.addEventListener("end", P), r.addEventListener("inputsourceschange", R), !0 !== m.xrCompatible && await t.makeXRCompatible(), _ = e.getPixelRatio(), e.getSize(x), void 0 === r.renderState.layers || !1 === e.capabilities.isWebGL2) {
                            const n = {
                                antialias: void 0 !== r.renderState.layers || m.antialias,
                                alpha: !0,
                                depth: m.depth,
                                stencil: m.stencil,
                                framebufferScaleFactor: i
                            };
                            h = new XRWebGLLayer(r, t, n), r.updateRenderState({
                                baseLayer: h
                            }), e.setPixelRatio(1), e.setSize(h.framebufferWidth, h.framebufferHeight, !1), v = new Mu(h.framebufferWidth, h.framebufferHeight, {
                                format: Ds,
                                type: ws,
                                colorSpace: e.outputColorSpace,
                                stencilBuffer: m.stencil
                            })
                        } else {
                            let n = null,
                                o = null,
                                a = null;
                            m.depth && (a = m.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, n = m.stencil ? Us : Fs, o = m.stencil ? Bs : Ts);
                            const s = {
                                colorFormat: t.RGBA8,
                                depthFormat: a,
                                scaleFactor: i
                            };
                            u = new XRWebGLBinding(r, t), d = u.createProjectionLayer(s), r.updateRenderState({
                                layers: [d]
                            }), e.setPixelRatio(1), e.setSize(d.textureWidth, d.textureHeight, !1), v = new Mu(d.textureWidth, d.textureHeight, {
                                format: Ds,
                                type: ws,
                                depthTexture: new Kp(d.textureWidth, d.textureHeight, o, void 0, void 0, void 0, void 0, void 0, void 0, n),
                                stencilBuffer: m.stencil,
                                colorSpace: e.outputColorSpace,
                                samples: m.antialias ? 4 : 0
                            });
                            e.properties.get(v).__ignoreDepthValues = d.ignoreDepthValues
                        }
                        v.isXRRenderTarget = !0, this.setFoveation(s), l = null, o = await r.requestReferenceSpace(a), D.setContext(r), D.start(), n.isPresenting = !0, n.dispatchEvent({
                            type: "sessionstart"
                        })
                    }
                }, this.getEnvironmentBlendMode = function() {
                    if (null !== r) return r.environmentBlendMode
                };
                const I = new Pu,
                    O = new Pu;

                function B(e, t) {
                    null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert()
                }
                this.updateCamera = function(e) {
                    if (null === r) return;
                    null !== f.texture && (e.near = f.depthNear, e.far = f.depthFar), S.near = w.near = M.near = e.near, S.far = w.far = M.far = e.far, E === S.near && C === S.far || (r.updateRenderState({
                        depthNear: S.near,
                        depthFar: S.far
                    }), E = S.near, C = S.far, M.near = E, M.far = C, w.near = E, w.far = C, M.updateProjectionMatrix(), w.updateProjectionMatrix(), e.updateProjectionMatrix());
                    const t = e.parent,
                        n = S.cameras;
                    B(S, t);
                    for (let r = 0; r < n.length; r++) B(n[r], t);
                    2 === n.length ? function(e, t, n) {
                            I.setFromMatrixPosition(t.matrixWorld), O.setFromMatrixPosition(n.matrixWorld);
                            const r = I.distanceTo(O),
                                i = t.projectionMatrix.elements,
                                o = n.projectionMatrix.elements,
                                a = i[14] / (i[10] - 1),
                                s = i[14] / (i[10] + 1),
                                l = (i[9] + 1) / i[5],
                                c = (i[9] - 1) / i[5],
                                u = (i[8] - 1) / i[0],
                                d = (o[8] + 1) / o[0],
                                h = a * u,
                                p = a * d,
                                f = r / (-u + d),
                                m = f * -u;
                            t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert();
                            const g = a + f,
                                v = s + f,
                                y = h - m,
                                b = p + (r - m),
                                x = l * s / v * g,
                                _ = c * s / v * g;
                            e.projectionMatrix.makePerspective(y, b, x, _, g, v), e.projectionMatrixInverse.copy(e.projectionMatrix).invert()
                        }(S, M, w) : S.projectionMatrix.copy(M.projectionMatrix),
                        function(e, t, n) {
                            null === n ? e.matrix.copy(t.matrixWorld) : (e.matrix.copy(n.matrixWorld), e.matrix.invert(), e.matrix.multiply(t.matrixWorld));
                            e.matrix.decompose(e.position, e.quaternion, e.scale), e.updateMatrixWorld(!0), e.projectionMatrix.copy(t.projectionMatrix), e.projectionMatrixInverse.copy(t.projectionMatrixInverse), e.isPerspectiveCamera && (e.fov = 2 * zc * Math.atan(1 / e.projectionMatrix.elements[5]), e.zoom = 1)
                        }(e, S, t)
                }, this.getCamera = function() {
                    return S
                }, this.getFoveation = function() {
                    if (null !== d || null !== h) return s
                }, this.setFoveation = function(e) {
                    s = e, null !== d && (d.fixedFoveation = e), null !== h && void 0 !== h.fixedFoveation && (h.fixedFoveation = e)
                }, this.hasDepthSensing = function() {
                    return null !== f.texture
                };
                let L = null;
                const D = new up;
                D.setAnimationLoop((function(t, i) {
                    if (c = i.getViewerPose(l || o), p = i, null !== c) {
                        const t = c.views;
                        null !== h && (e.setRenderTargetFramebuffer(v, h.framebuffer), e.setRenderTarget(v));
                        let n = !1;
                        t.length !== S.cameras.length && (S.cameras.length = 0, n = !0);
                        for (let r = 0; r < t.length; r++) {
                            const i = t[r];
                            let o = null;
                            if (null !== h) o = h.getViewport(i);
                            else {
                                const t = u.getViewSubImage(d, i);
                                o = t.viewport, 0 === r && (e.setRenderTargetTextures(v, t.colorTexture, d.ignoreDepthValues ? void 0 : t.depthStencilTexture), e.setRenderTarget(v))
                            }
                            let a = A[r];
                            void 0 === a && (a = new Zh, a.layers.enable(r), a.viewport = new xu, A[r] = a), a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.quaternion, a.scale), a.projectionMatrix.fromArray(i.projectionMatrix), a.projectionMatrixInverse.copy(a.projectionMatrix).invert(), a.viewport.set(o.x, o.y, o.width, o.height), 0 === r && (S.matrix.copy(a.matrix), S.matrix.decompose(S.position, S.quaternion, S.scale)), !0 === n && S.cameras.push(a)
                        }
                        const i = r.enabledFeatures;
                        if (i && i.includes("depth-sensing")) {
                            const n = u.getDepthInformation(t[0]);
                            n && n.isValid && n.texture && f.init(e, n, r.renderState)
                        }
                    }
                    for (let e = 0; e < y.length; e++) {
                        const t = b[e],
                            n = y[e];
                        null !== t && void 0 !== n && n.update(t, i, l || o)
                    }
                    f.render(e, S), L && L(t, i), i.detectedPlanes && n.dispatchEvent({
                        type: "planesdetected",
                        data: i
                    }), p = null
                })), this.setAnimationLoop = function(e) {
                    L = e
                }, this.dispose = function() {}
            }
        }

        function Wm(e, t) {
            function n(e, t) {
                !0 === e.matrixAutoUpdate && e.updateMatrix(), t.value.copy(e.matrix)
            }

            function r(r, i) {
                r.opacity.value = i.opacity, i.color && r.diffuse.value.copy(i.color), i.emissive && r.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity), i.map && (r.map.value = i.map, n(i.map, r.mapTransform)), i.alphaMap && (r.alphaMap.value = i.alphaMap, n(i.alphaMap, r.alphaMapTransform)), i.bumpMap && (r.bumpMap.value = i.bumpMap, n(i.bumpMap, r.bumpMapTransform), r.bumpScale.value = i.bumpScale, i.side === ua && (r.bumpScale.value *= -1)), i.normalMap && (r.normalMap.value = i.normalMap, n(i.normalMap, r.normalMapTransform), r.normalScale.value.copy(i.normalScale), i.side === ua && r.normalScale.value.negate()), i.displacementMap && (r.displacementMap.value = i.displacementMap, n(i.displacementMap, r.displacementMapTransform), r.displacementScale.value = i.displacementScale, r.displacementBias.value = i.displacementBias), i.emissiveMap && (r.emissiveMap.value = i.emissiveMap, n(i.emissiveMap, r.emissiveMapTransform)), i.specularMap && (r.specularMap.value = i.specularMap, n(i.specularMap, r.specularMapTransform)), i.alphaTest > 0 && (r.alphaTest.value = i.alphaTest);
                const o = t.get(i).envMap;
                if (o && (r.envMap.value = o, r.flipEnvMap.value = o.isCubeTexture && !1 === o.isRenderTargetTexture ? -1 : 1, r.reflectivity.value = i.reflectivity, r.ior.value = i.ior, r.refractionRatio.value = i.refractionRatio), i.lightMap) {
                    r.lightMap.value = i.lightMap;
                    const t = !0 === e._useLegacyLights ? Math.PI : 1;
                    r.lightMapIntensity.value = i.lightMapIntensity * t, n(i.lightMap, r.lightMapTransform)
                }
                i.aoMap && (r.aoMap.value = i.aoMap, r.aoMapIntensity.value = i.aoMapIntensity, n(i.aoMap, r.aoMapTransform))
            }
            return {
                refreshFogUniforms: function(t, n) {
                    n.color.getRGB(t.fogColor.value, qh(e)), n.isFog ? (t.fogNear.value = n.near, t.fogFar.value = n.far) : n.isFogExp2 && (t.fogDensity.value = n.density)
                },
                refreshMaterialUniforms: function(e, i, o, a, s) {
                    i.isMeshBasicMaterial || i.isMeshLambertMaterial ? r(e, i) : i.isMeshToonMaterial ? (r(e, i), function(e, t) {
                        t.gradientMap && (e.gradientMap.value = t.gradientMap)
                    }(e, i)) : i.isMeshPhongMaterial ? (r(e, i), function(e, t) {
                        e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4)
                    }(e, i)) : i.isMeshStandardMaterial ? (r(e, i), function(e, r) {
                        e.metalness.value = r.metalness, r.metalnessMap && (e.metalnessMap.value = r.metalnessMap, n(r.metalnessMap, e.metalnessMapTransform));
                        e.roughness.value = r.roughness, r.roughnessMap && (e.roughnessMap.value = r.roughnessMap, n(r.roughnessMap, e.roughnessMapTransform));
                        const i = t.get(r).envMap;
                        i && (e.envMapIntensity.value = r.envMapIntensity)
                    }(e, i), i.isMeshPhysicalMaterial && function(e, t, r) {
                        e.ior.value = t.ior, t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen), e.sheenRoughness.value = t.sheenRoughness, t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap, n(t.sheenColorMap, e.sheenColorMapTransform)), t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap, n(t.sheenRoughnessMap, e.sheenRoughnessMapTransform)));
                        t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap, n(t.clearcoatMap, e.clearcoatMapTransform)), t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap, n(t.clearcoatRoughnessMap, e.clearcoatRoughnessMapTransform)), t.clearcoatNormalMap && (e.clearcoatNormalMap.value = t.clearcoatNormalMap, n(t.clearcoatNormalMap, e.clearcoatNormalMapTransform), e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), t.side === ua && e.clearcoatNormalScale.value.negate()));
                        t.iridescence > 0 && (e.iridescence.value = t.iridescence, e.iridescenceIOR.value = t.iridescenceIOR, e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0], e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1], t.iridescenceMap && (e.iridescenceMap.value = t.iridescenceMap, n(t.iridescenceMap, e.iridescenceMapTransform)), t.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = t.iridescenceThicknessMap, n(t.iridescenceThicknessMap, e.iridescenceThicknessMapTransform)));
                        t.transmission > 0 && (e.transmission.value = t.transmission, e.transmissionSamplerMap.value = r.texture, e.transmissionSamplerSize.value.set(r.width, r.height), t.transmissionMap && (e.transmissionMap.value = t.transmissionMap, n(t.transmissionMap, e.transmissionMapTransform)), e.thickness.value = t.thickness, t.thicknessMap && (e.thicknessMap.value = t.thicknessMap, n(t.thicknessMap, e.thicknessMapTransform)), e.attenuationDistance.value = t.attenuationDistance, e.attenuationColor.value.copy(t.attenuationColor));
                        t.anisotropy > 0 && (e.anisotropyVector.value.set(t.anisotropy * Math.cos(t.anisotropyRotation), t.anisotropy * Math.sin(t.anisotropyRotation)), t.anisotropyMap && (e.anisotropyMap.value = t.anisotropyMap, n(t.anisotropyMap, e.anisotropyMapTransform)));
                        e.specularIntensity.value = t.specularIntensity, e.specularColor.value.copy(t.specularColor), t.specularColorMap && (e.specularColorMap.value = t.specularColorMap, n(t.specularColorMap, e.specularColorMapTransform));
                        t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap, n(t.specularIntensityMap, e.specularIntensityMapTransform))
                    }(e, i, s)) : i.isMeshMatcapMaterial ? (r(e, i), function(e, t) {
                        t.matcap && (e.matcap.value = t.matcap)
                    }(e, i)) : i.isMeshDepthMaterial ? r(e, i) : i.isMeshDistanceMaterial ? (r(e, i), function(e, n) {
                        const r = t.get(n).light;
                        e.referencePosition.value.setFromMatrixPosition(r.matrixWorld), e.nearDistance.value = r.shadow.camera.near, e.farDistance.value = r.shadow.camera.far
                    }(e, i)) : i.isMeshNormalMaterial ? r(e, i) : i.isLineBasicMaterial ? (function(e, t) {
                        e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, t.map && (e.map.value = t.map, n(t.map, e.mapTransform))
                    }(e, i), i.isLineDashedMaterial && function(e, t) {
                        e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale
                    }(e, i)) : i.isPointsMaterial ? function(e, t, r, i) {
                        e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * r, e.scale.value = .5 * i, t.map && (e.map.value = t.map, n(t.map, e.uvTransform));
                        t.alphaMap && (e.alphaMap.value = t.alphaMap, n(t.alphaMap, e.alphaMapTransform));
                        t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
                    }(e, i, o, a) : i.isSpriteMaterial ? function(e, t) {
                        e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map, n(t.map, e.mapTransform));
                        t.alphaMap && (e.alphaMap.value = t.alphaMap, n(t.alphaMap, e.alphaMapTransform));
                        t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
                    }(e, i) : i.isShadowMaterial ? (e.color.value.copy(i.color), e.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
                }
            }
        }

        function Xm(e, t, n, r) {
            let i = {},
                o = {},
                a = [];
            const s = n.isWebGL2 ? e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS) : 0;

            function l(e, t, n, r) {
                const i = e.value,
                    o = t + "_" + n;
                if (void 0 === r[o]) return r[o] = "number" === typeof i || "boolean" === typeof i ? i : i.clone(), !0; {
                    const e = r[o];
                    if ("number" === typeof i || "boolean" === typeof i) {
                        if (e !== i) return r[o] = i, !0
                    } else if (!1 === e.equals(i)) return e.copy(i), !0
                }
                return !1
            }

            function c(e) {
                const t = {
                    boundary: 0,
                    storage: 0
                };
                return "number" === typeof e || "boolean" === typeof e ? (t.boundary = 4, t.storage = 4) : e.isVector2 ? (t.boundary = 8, t.storage = 8) : e.isVector3 || e.isColor ? (t.boundary = 16, t.storage = 12) : e.isVector4 ? (t.boundary = 16, t.storage = 16) : e.isMatrix3 ? (t.boundary = 48, t.storage = 48) : e.isMatrix4 ? (t.boundary = 64, t.storage = 64) : e.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", e), t
            }

            function u(t) {
                const n = t.target;
                n.removeEventListener("dispose", u);
                const r = a.indexOf(n.__bindingPointIndex);
                a.splice(r, 1), e.deleteBuffer(i[n.id]), delete i[n.id], delete o[n.id]
            }
            return {
                bind: function(e, t) {
                    const n = t.program;
                    r.uniformBlockBinding(e, n)
                },
                update: function(n, d) {
                    let h = i[n.id];
                    void 0 === h && (! function(e) {
                        const t = e.uniforms;
                        let n = 0;
                        const r = 16;
                        for (let o = 0, a = t.length; o < a; o++) {
                            const e = Array.isArray(t[o]) ? t[o] : [t[o]];
                            for (let t = 0, i = e.length; t < i; t++) {
                                const i = e[t],
                                    o = Array.isArray(i.value) ? i.value : [i.value];
                                for (let e = 0, t = o.length; e < t; e++) {
                                    const t = c(o[e]),
                                        a = n % r;
                                    0 !== a && r - a < t.boundary && (n += r - a), i.__data = new Float32Array(t.storage / Float32Array.BYTES_PER_ELEMENT), i.__offset = n, n += t.storage
                                }
                            }
                        }
                        const i = n % r;
                        i > 0 && (n += r - i);
                        e.__size = n, e.__cache = {}
                    }(n), h = function(t) {
                        const n = function() {
                            for (let e = 0; e < s; e++)
                                if (-1 === a.indexOf(e)) return a.push(e), e;
                            return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
                        }();
                        t.__bindingPointIndex = n;
                        const r = e.createBuffer(),
                            i = t.__size,
                            o = t.usage;
                        return e.bindBuffer(e.UNIFORM_BUFFER, r), e.bufferData(e.UNIFORM_BUFFER, i, o), e.bindBuffer(e.UNIFORM_BUFFER, null), e.bindBufferBase(e.UNIFORM_BUFFER, n, r), r
                    }(n), i[n.id] = h, n.addEventListener("dispose", u));
                    const p = d.program;
                    r.updateUBOMapping(n, p);
                    const f = t.render.frame;
                    o[n.id] !== f && (! function(t) {
                        const n = i[t.id],
                            r = t.uniforms,
                            o = t.__cache;
                        e.bindBuffer(e.UNIFORM_BUFFER, n);
                        for (let i = 0, a = r.length; i < a; i++) {
                            const t = Array.isArray(r[i]) ? r[i] : [r[i]];
                            for (let n = 0, r = t.length; n < r; n++) {
                                const r = t[n];
                                if (!0 === l(r, i, n, o)) {
                                    const t = r.__offset,
                                        n = Array.isArray(r.value) ? r.value : [r.value];
                                    let i = 0;
                                    for (let o = 0; o < n.length; o++) {
                                        const a = n[o],
                                            s = c(a);
                                        "number" === typeof a || "boolean" === typeof a ? (r.__data[0] = a, e.bufferSubData(e.UNIFORM_BUFFER, t + i, r.__data)) : a.isMatrix3 ? (r.__data[0] = a.elements[0], r.__data[1] = a.elements[1], r.__data[2] = a.elements[2], r.__data[3] = 0, r.__data[4] = a.elements[3], r.__data[5] = a.elements[4], r.__data[6] = a.elements[5], r.__data[7] = 0, r.__data[8] = a.elements[6], r.__data[9] = a.elements[7], r.__data[10] = a.elements[8], r.__data[11] = 0) : (a.toArray(r.__data, i), i += s.storage / Float32Array.BYTES_PER_ELEMENT)
                                    }
                                    e.bufferSubData(e.UNIFORM_BUFFER, t, r.__data)
                                }
                            }
                        }
                        e.bindBuffer(e.UNIFORM_BUFFER, null)
                    }(n), o[n.id] = f)
                },
                dispose: function() {
                    for (const t in i) e.deleteBuffer(i[t]);
                    a = [], i = {}, o = {}
                }
            }
        }
        class Km {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                const {
                    canvas: t = ru(),
                    context: n = null,
                    depth: r = !0,
                    stencil: i = !0,
                    alpha: o = !1,
                    antialias: a = !1,
                    premultipliedAlpha: s = !0,
                    preserveDrawingBuffer: l = !1,
                    powerPreference: c = "default",
                    failIfMajorPerformanceCaveat: u = !1
                } = e;
                let d;
                this.isWebGLRenderer = !0, d = null !== n ? n.getContextAttributes().alpha : o;
                const h = new Uint32Array(4),
                    p = new Int32Array(4);
                let f = null,
                    m = null;
                const g = [],
                    v = [];
                this.domElement = t, this.debug = {
                    checkShaderErrors: !0,
                    onShaderError: null
                }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = Vl, this._useLegacyLights = !1, this.toneMapping = Ja, this.toneMappingExposure = 1;
                const y = this;
                let b = !1,
                    x = 0,
                    _ = 0,
                    M = null,
                    w = -1,
                    A = null;
                const S = new xu,
                    E = new xu;
                let C = null;
                const T = new Wd(0);
                let P = 0,
                    R = t.width,
                    I = t.height,
                    O = 1,
                    B = null,
                    L = null;
                const D = new xu(0, 0, R, I),
                    N = new xu(0, 0, R, I);
                let k = !1;
                const F = new cp;
                let U = !1,
                    z = !1,
                    H = null;
                const j = new od,
                    G = new Yc,
                    V = new Pu,
                    q = {
                        background: null,
                        fog: null,
                        environment: null,
                        overrideMaterial: null,
                        isScene: !0
                    };

                function W() {
                    return null === M ? O : 1
                }
                let X, K, J, Y, Q, Z, $, ee, te, ne, re, ie, oe, ae, se, le, ce, ue, de, he, pe, fe, me, ge, ve = n;

                function ye(e, n) {
                    for (let r = 0; r < e.length; r++) {
                        const i = e[r],
                            o = t.getContext(i, n);
                        if (null !== o) return o
                    }
                    return null
                }
                try {
                    const e = {
                        alpha: !0,
                        depth: r,
                        stencil: i,
                        antialias: a,
                        premultipliedAlpha: s,
                        preserveDrawingBuffer: l,
                        powerPreference: c,
                        failIfMajorPerformanceCaveat: u
                    };
                    if ("setAttribute" in t && t.setAttribute("data-engine", "three.js r".concat(Zo)), t.addEventListener("webglcontextlost", _e, !1), t.addEventListener("webglcontextrestored", Me, !1), t.addEventListener("webglcontextcreationerror", we, !1), null === ve) {
                        const t = ["webgl2", "webgl", "experimental-webgl"];
                        if (!0 === y.isWebGL1Renderer && t.shift(), ve = ye(t, e), null === ve) throw ye(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                    }
                    "undefined" !== typeof WebGLRenderingContext && ve instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), void 0 === ve.getShaderPrecisionFormat && (ve.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (ke) {
                    throw console.error("THREE.WebGLRenderer: " + ke.message), ke
                }

                function be() {
                    X = new zp(ve), K = new xp(ve, X, e), X.init(K), fe = new Um(ve, X, K), J = new km(ve, X, K), Y = new Gp(ve), Q = new wm, Z = new Fm(ve, X, J, Q, K, fe, Y), $ = new Mp(y), ee = new Up(y), te = new dp(ve, K), me = new yp(ve, X, te, K), ne = new Hp(ve, te, Y, me), re = new Xp(ve, ne, te, Y), de = new Wp(ve, K, Z), le = new _p(Q), ie = new Mm(y, $, ee, X, K, me, le), oe = new Wm(y, Q), ae = new Cm, se = new Bm(X, K), ue = new vp(y, $, ee, J, re, d, s), ce = new Nm(y, re, K), ge = new Xm(ve, Y, K, J), he = new bp(ve, X, Y, K), pe = new jp(ve, X, Y, K), Y.programs = ie.programs, y.capabilities = K, y.extensions = X, y.properties = Q, y.renderLists = ae, y.shadowMap = ce, y.state = J, y.info = Y
                }
                be();
                const xe = new qm(y, ve);

                function _e(e) {
                    e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), b = !0
                }

                function Me() {
                    console.log("THREE.WebGLRenderer: Context Restored."), b = !1;
                    const e = Y.autoReset,
                        t = ce.enabled,
                        n = ce.autoUpdate,
                        r = ce.needsUpdate,
                        i = ce.type;
                    be(), Y.autoReset = e, ce.enabled = t, ce.autoUpdate = n, ce.needsUpdate = r, ce.type = i
                }

                function we(e) {
                    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e.statusMessage)
                }

                function Ae(e) {
                    const t = e.target;
                    t.removeEventListener("dispose", Ae),
                        function(e) {
                            (function(e) {
                                const t = Q.get(e).programs;
                                void 0 !== t && (t.forEach((function(e) {
                                    ie.releaseProgram(e)
                                })), e.isShaderMaterial && ie.releaseShaderCache(e))
                            })(e), Q.remove(e)
                        }(t)
                }

                function Se(e, t, n) {
                    !0 === e.transparent && e.side === da && !1 === e.forceSinglePass ? (e.side = ua, e.needsUpdate = !0, Le(e, t, n), e.side = ca, e.needsUpdate = !0, Le(e, t, n), e.side = da) : Le(e, t, n)
                }
                this.xr = xe, this.getContext = function() {
                    return ve
                }, this.getContextAttributes = function() {
                    return ve.getContextAttributes()
                }, this.forceContextLoss = function() {
                    const e = X.get("WEBGL_lose_context");
                    e && e.loseContext()
                }, this.forceContextRestore = function() {
                    const e = X.get("WEBGL_lose_context");
                    e && e.restoreContext()
                }, this.getPixelRatio = function() {
                    return O
                }, this.setPixelRatio = function(e) {
                    void 0 !== e && (O = e, this.setSize(R, I, !1))
                }, this.getSize = function(e) {
                    return e.set(R, I)
                }, this.setSize = function(e, n) {
                    let r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                    xe.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (R = e, I = n, t.width = Math.floor(e * O), t.height = Math.floor(n * O), !0 === r && (t.style.width = e + "px", t.style.height = n + "px"), this.setViewport(0, 0, e, n))
                }, this.getDrawingBufferSize = function(e) {
                    return e.set(R * O, I * O).floor()
                }, this.setDrawingBufferSize = function(e, n, r) {
                    R = e, I = n, O = r, t.width = Math.floor(e * r), t.height = Math.floor(n * r), this.setViewport(0, 0, e, n)
                }, this.getCurrentViewport = function(e) {
                    return e.copy(S)
                }, this.getViewport = function(e) {
                    return e.copy(D)
                }, this.setViewport = function(e, t, n, r) {
                    e.isVector4 ? D.set(e.x, e.y, e.z, e.w) : D.set(e, t, n, r), J.viewport(S.copy(D).multiplyScalar(O).floor())
                }, this.getScissor = function(e) {
                    return e.copy(N)
                }, this.setScissor = function(e, t, n, r) {
                    e.isVector4 ? N.set(e.x, e.y, e.z, e.w) : N.set(e, t, n, r), J.scissor(E.copy(N).multiplyScalar(O).floor())
                }, this.getScissorTest = function() {
                    return k
                }, this.setScissorTest = function(e) {
                    J.setScissorTest(k = e)
                }, this.setOpaqueSort = function(e) {
                    B = e
                }, this.setTransparentSort = function(e) {
                    L = e
                }, this.getClearColor = function(e) {
                    return e.copy(ue.getClearColor())
                }, this.setClearColor = function() {
                    ue.setClearColor.apply(ue, arguments)
                }, this.getClearAlpha = function() {
                    return ue.getClearAlpha()
                }, this.setClearAlpha = function() {
                    ue.setClearAlpha.apply(ue, arguments)
                }, this.clear = function() {
                    let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                        t = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                        n = 0;
                    if (!(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]) {
                        let e = !1;
                        if (null !== M) {
                            const t = M.texture.format;
                            e = t === Vs || t === Gs || t === Hs
                        }
                        if (e) {
                            const e = M.texture.type,
                                t = e === ws || e === Ts || e === Es || e === Bs || e === Is || e === Os,
                                n = ue.getClearColor(),
                                r = ue.getClearAlpha(),
                                i = n.r,
                                o = n.g,
                                a = n.b;
                            t ? (h[0] = i, h[1] = o, h[2] = a, h[3] = r, ve.clearBufferuiv(ve.COLOR, 0, h)) : (p[0] = i, p[1] = o, p[2] = a, p[3] = r, ve.clearBufferiv(ve.COLOR, 0, p))
                        } else n |= ve.COLOR_BUFFER_BIT
                    }
                    e && (n |= ve.DEPTH_BUFFER_BIT), t && (n |= ve.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), ve.clear(n)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.dispose = function() {
                    t.removeEventListener("webglcontextlost", _e, !1), t.removeEventListener("webglcontextrestored", Me, !1), t.removeEventListener("webglcontextcreationerror", we, !1), ae.dispose(), se.dispose(), Q.dispose(), $.dispose(), ee.dispose(), re.dispose(), me.dispose(), ge.dispose(), ie.dispose(), xe.dispose(), xe.removeEventListener("sessionstart", Ce), xe.removeEventListener("sessionend", Te), H && (H.dispose(), H = null), Pe.stop()
                }, this.renderBufferDirect = function(e, t, n, r, i, o) {
                    null === t && (t = q);
                    const a = i.isMesh && i.matrixWorld.determinant() < 0,
                        s = function(e, t, n, r, i) {
                            !0 !== t.isScene && (t = q);
                            Z.resetTextureUnits();
                            const o = t.fog,
                                a = r.isMeshStandardMaterial ? t.environment : null,
                                s = null === M ? y.outputColorSpace : !0 === M.isXRRenderTarget ? M.texture.colorSpace : ql,
                                l = (r.isMeshStandardMaterial ? ee : $).get(r.envMap || a),
                                c = !0 === r.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                                u = !!n.attributes.tangent && (!!r.normalMap || r.anisotropy > 0),
                                d = !!n.morphAttributes.position,
                                h = !!n.morphAttributes.normal,
                                p = !!n.morphAttributes.color;
                            let f = Ja;
                            r.toneMapped && (null !== M && !0 !== M.isXRRenderTarget || (f = y.toneMapping));
                            const g = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color,
                                v = void 0 !== g ? g.length : 0,
                                b = Q.get(r),
                                x = m.state.lights;
                            if (!0 === U && (!0 === z || e !== A)) {
                                const t = e === A && r.id === w;
                                le.setState(r, e, t)
                            }
                            let _ = !1;
                            r.version === b.__version ? b.needsLights && b.lightsStateVersion !== x.state.version || b.outputColorSpace !== s || i.isBatchedMesh && !1 === b.batching ? _ = !0 : i.isBatchedMesh || !0 !== b.batching ? i.isInstancedMesh && !1 === b.instancing ? _ = !0 : i.isInstancedMesh || !0 !== b.instancing ? i.isSkinnedMesh && !1 === b.skinning ? _ = !0 : i.isSkinnedMesh || !0 !== b.skinning ? i.isInstancedMesh && !0 === b.instancingColor && null === i.instanceColor || i.isInstancedMesh && !1 === b.instancingColor && null !== i.instanceColor || b.envMap !== l || !0 === r.fog && b.fog !== o ? _ = !0 : void 0 === b.numClippingPlanes || b.numClippingPlanes === le.numPlanes && b.numIntersection === le.numIntersection ? (b.vertexAlphas !== c || b.vertexTangents !== u || b.morphTargets !== d || b.morphNormals !== h || b.morphColors !== p || b.toneMapping !== f || !0 === K.isWebGL2 && b.morphTargetsCount !== v) && (_ = !0) : _ = !0 : _ = !0 : _ = !0 : _ = !0 : (_ = !0, b.__version = r.version);
                            let S = b.currentProgram;
                            !0 === _ && (S = Le(r, t, i));
                            let E = !1,
                                C = !1,
                                T = !1;
                            const P = S.getUniforms(),
                                R = b.uniforms;
                            J.useProgram(S.program) && (E = !0, C = !0, T = !0);
                            r.id !== w && (w = r.id, C = !0);
                            if (E || A !== e) {
                                P.setValue(ve, "projectionMatrix", e.projectionMatrix), P.setValue(ve, "viewMatrix", e.matrixWorldInverse);
                                const t = P.map.cameraPosition;
                                void 0 !== t && t.setValue(ve, V.setFromMatrixPosition(e.matrixWorld)), K.logarithmicDepthBuffer && P.setValue(ve, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), (r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial) && P.setValue(ve, "isOrthographic", !0 === e.isOrthographicCamera), A !== e && (A = e, C = !0, T = !0)
                            }
                            if (i.isSkinnedMesh) {
                                P.setOptional(ve, i, "bindMatrix"), P.setOptional(ve, i, "bindMatrixInverse");
                                const e = i.skeleton;
                                e && (K.floatVertexTextures ? (null === e.boneTexture && e.computeBoneTexture(), P.setValue(ve, "boneTexture", e.boneTexture, Z)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
                            }
                            i.isBatchedMesh && (P.setOptional(ve, i, "batchingTexture"), P.setValue(ve, "batchingTexture", i._matricesTexture, Z));
                            const B = n.morphAttributes;
                            (void 0 !== B.position || void 0 !== B.normal || void 0 !== B.color && !0 === K.isWebGL2) && de.update(i, n, S);
                            (C || b.receiveShadow !== i.receiveShadow) && (b.receiveShadow = i.receiveShadow, P.setValue(ve, "receiveShadow", i.receiveShadow));
                            r.isMeshGouraudMaterial && null !== r.envMap && (R.envMap.value = l, R.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1);
                            C && (P.setValue(ve, "toneMappingExposure", y.toneMappingExposure), b.needsLights && (D = T, (L = R).ambientLightColor.needsUpdate = D, L.lightProbe.needsUpdate = D, L.directionalLights.needsUpdate = D, L.directionalLightShadows.needsUpdate = D, L.pointLights.needsUpdate = D, L.pointLightShadows.needsUpdate = D, L.spotLights.needsUpdate = D, L.spotLightShadows.needsUpdate = D, L.rectAreaLights.needsUpdate = D, L.hemisphereLights.needsUpdate = D), o && !0 === r.fog && oe.refreshFogUniforms(R, o), oe.refreshMaterialUniforms(R, r, O, I, H), em.upload(ve, De(b), R, Z));
                            var L, D;
                            r.isShaderMaterial && !0 === r.uniformsNeedUpdate && (em.upload(ve, De(b), R, Z), r.uniformsNeedUpdate = !1);
                            r.isSpriteMaterial && P.setValue(ve, "center", i.center);
                            if (P.setValue(ve, "modelViewMatrix", i.modelViewMatrix), P.setValue(ve, "normalMatrix", i.normalMatrix), P.setValue(ve, "modelMatrix", i.matrixWorld), r.isShaderMaterial || r.isRawShaderMaterial) {
                                const e = r.uniformsGroups;
                                for (let t = 0, n = e.length; t < n; t++)
                                    if (K.isWebGL2) {
                                        const n = e[t];
                                        ge.update(n, S), ge.bind(n, S)
                                    } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
                            }
                            return S
                        }(e, t, n, r, i);
                    J.setMaterial(r, a);
                    let l = n.index,
                        c = 1;
                    if (!0 === r.wireframe) {
                        if (l = ne.getWireframeAttribute(n), void 0 === l) return;
                        c = 2
                    }
                    const u = n.drawRange,
                        d = n.attributes.position;
                    let h = u.start * c,
                        p = (u.start + u.count) * c;
                    null !== o && (h = Math.max(h, o.start * c), p = Math.min(p, (o.start + o.count) * c)), null !== l ? (h = Math.max(h, 0), p = Math.min(p, l.count)) : void 0 !== d && null !== d && (h = Math.max(h, 0), p = Math.min(p, d.count));
                    const f = p - h;
                    if (f < 0 || f === 1 / 0) return;
                    let g;
                    me.setup(i, r, s, n, l);
                    let v = he;
                    if (null !== l && (g = te.get(l), v = pe, v.setIndex(g)), i.isMesh) !0 === r.wireframe ? (J.setLineWidth(r.wireframeLinewidth * W()), v.setMode(ve.LINES)) : v.setMode(ve.TRIANGLES);
                    else if (i.isLine) {
                        let e = r.linewidth;
                        void 0 === e && (e = 1), J.setLineWidth(e * W()), i.isLineSegments ? v.setMode(ve.LINES) : i.isLineLoop ? v.setMode(ve.LINE_LOOP) : v.setMode(ve.LINE_STRIP)
                    } else i.isPoints ? v.setMode(ve.POINTS) : i.isSprite && v.setMode(ve.TRIANGLES);
                    if (i.isBatchedMesh) v.renderMultiDraw(i._multiDrawStarts, i._multiDrawCounts, i._multiDrawCount);
                    else if (i.isInstancedMesh) v.renderInstances(h, f, i.count);
                    else if (n.isInstancedBufferGeometry) {
                        const e = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0,
                            t = Math.min(n.instanceCount, e);
                        v.renderInstances(h, f, t)
                    } else v.render(h, f)
                }, this.compile = function(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                    null === n && (n = e), m = se.get(n), m.init(), v.push(m), n.traverseVisible((function(e) {
                        e.isLight && e.layers.test(t.layers) && (m.pushLight(e), e.castShadow && m.pushShadow(e))
                    })), e !== n && e.traverseVisible((function(e) {
                        e.isLight && e.layers.test(t.layers) && (m.pushLight(e), e.castShadow && m.pushShadow(e))
                    })), m.setupLights(y._useLegacyLights);
                    const r = new Set;
                    return e.traverse((function(e) {
                        const t = e.material;
                        if (t)
                            if (Array.isArray(t))
                                for (let i = 0; i < t.length; i++) {
                                    const o = t[i];
                                    Se(o, n, e), r.add(o)
                                } else Se(t, n, e), r.add(t)
                    })), v.pop(), m = null, r
                }, this.compileAsync = function(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                    const r = this.compile(e, t, n);
                    return new Promise((t => {
                        function n() {
                            r.forEach((function(e) {
                                Q.get(e).currentProgram.isReady() && r.delete(e)
                            })), 0 !== r.size ? setTimeout(n, 10) : t(e)
                        }
                        null !== X.get("KHR_parallel_shader_compile") ? n() : setTimeout(n, 10)
                    }))
                };
                let Ee = null;

                function Ce() {
                    Pe.stop()
                }

                function Te() {
                    Pe.start()
                }
                const Pe = new up;

                function Re(e, t, n, r) {
                    if (!1 === e.visible) return;
                    if (e.layers.test(t.layers))
                        if (e.isGroup) n = e.renderOrder;
                        else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
                    else if (e.isLight) m.pushLight(e), e.castShadow && m.pushShadow(e);
                    else if (e.isSprite) {
                        if (!e.frustumCulled || F.intersectsSprite(e)) {
                            r && V.setFromMatrixPosition(e.matrixWorld).applyMatrix4(j);
                            const t = re.update(e),
                                i = e.material;
                            i.visible && f.push(e, t, i, n, V.z, null)
                        }
                    } else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || F.intersectsObject(e))) {
                        const t = re.update(e),
                            i = e.material;
                        if (r && (void 0 !== e.boundingSphere ? (null === e.boundingSphere && e.computeBoundingSphere(), V.copy(e.boundingSphere.center)) : (null === t.boundingSphere && t.computeBoundingSphere(), V.copy(t.boundingSphere.center)), V.applyMatrix4(e.matrixWorld).applyMatrix4(j)), Array.isArray(i)) {
                            const r = t.groups;
                            for (let o = 0, a = r.length; o < a; o++) {
                                const a = r[o],
                                    s = i[a.materialIndex];
                                s && s.visible && f.push(e, t, s, n, V.z, a)
                            }
                        } else i.visible && f.push(e, t, i, n, V.z, null)
                    }
                    const i = e.children;
                    for (let o = 0, a = i.length; o < a; o++) Re(i[o], t, n, r)
                }

                function Ie(e, t, n, r) {
                    const i = e.opaque,
                        o = e.transmissive,
                        a = e.transparent;
                    m.setupLightsView(n), !0 === U && le.setGlobalState(y.clippingPlanes, n), o.length > 0 && function(e, t, n, r) {
                        const i = !0 === n.isScene ? n.overrideMaterial : null;
                        if (null !== i) return;
                        const o = K.isWebGL2;
                        null === H && (H = new Mu(1, 1, {
                            generateMipmaps: !0,
                            type: X.has("EXT_color_buffer_half_float") ? Rs : ws,
                            minFilter: _s,
                            samples: o ? 4 : 0
                        }));
                        y.getDrawingBufferSize(G), o ? H.setSize(G.x, G.y) : H.setSize(Wc(G.x), Wc(G.y));
                        const a = y.getRenderTarget();
                        y.setRenderTarget(H), y.getClearColor(T), P = y.getClearAlpha(), P < 1 && y.setClearColor(16777215, .5);
                        y.clear();
                        const s = y.toneMapping;
                        y.toneMapping = Ja, Oe(e, n, r), Z.updateMultisampleRenderTarget(H), Z.updateRenderTargetMipmap(H);
                        let l = !1;
                        for (let c = 0, u = t.length; c < u; c++) {
                            const e = t[c],
                                i = e.object,
                                o = e.geometry,
                                a = e.material,
                                s = e.group;
                            if (a.side === da && i.layers.test(r.layers)) {
                                const e = a.side;
                                a.side = ua, a.needsUpdate = !0, Be(i, n, r, o, a, s), a.side = e, a.needsUpdate = !0, l = !0
                            }
                        }!0 === l && (Z.updateMultisampleRenderTarget(H), Z.updateRenderTargetMipmap(H));
                        y.setRenderTarget(a), y.setClearColor(T, P), y.toneMapping = s
                    }(i, o, t, n), r && J.viewport(S.copy(r)), i.length > 0 && Oe(i, t, n), o.length > 0 && Oe(o, t, n), a.length > 0 && Oe(a, t, n), J.buffers.depth.setTest(!0), J.buffers.depth.setMask(!0), J.buffers.color.setMask(!0), J.setPolygonOffset(!1)
                }

                function Oe(e, t, n) {
                    const r = !0 === t.isScene ? t.overrideMaterial : null;
                    for (let i = 0, o = e.length; i < o; i++) {
                        const o = e[i],
                            a = o.object,
                            s = o.geometry,
                            l = null === r ? o.material : r,
                            c = o.group;
                        a.layers.test(n.layers) && Be(a, t, n, s, l, c)
                    }
                }

                function Be(e, t, n, r, i, o) {
                    e.onBeforeRender(y, t, n, r, i, o), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), i.onBeforeRender(y, t, n, r, e, o), !0 === i.transparent && i.side === da && !1 === i.forceSinglePass ? (i.side = ua, i.needsUpdate = !0, y.renderBufferDirect(n, t, r, i, e, o), i.side = ca, i.needsUpdate = !0, y.renderBufferDirect(n, t, r, i, e, o), i.side = da) : y.renderBufferDirect(n, t, r, i, e, o), e.onAfterRender(y, t, n, r, i, o)
                }

                function Le(e, t, n) {
                    !0 !== t.isScene && (t = q);
                    const r = Q.get(e),
                        i = m.state.lights,
                        o = m.state.shadowsArray,
                        a = i.state.version,
                        s = ie.getParameters(e, i.state, o, t, n),
                        l = ie.getProgramCacheKey(s);
                    let c = r.programs;
                    r.environment = e.isMeshStandardMaterial ? t.environment : null, r.fog = t.fog, r.envMap = (e.isMeshStandardMaterial ? ee : $).get(e.envMap || r.environment), void 0 === c && (e.addEventListener("dispose", Ae), c = new Map, r.programs = c);
                    let u = c.get(l);
                    if (void 0 !== u) {
                        if (r.currentProgram === u && r.lightsStateVersion === a) return Ne(e, s), u
                    } else s.uniforms = ie.getUniforms(e), e.onBuild(n, s, y), e.onBeforeCompile(s, y), u = ie.acquireProgram(s, l), c.set(l, u), r.uniforms = s.uniforms;
                    const d = r.uniforms;
                    return (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (d.clippingPlanes = le.uniform), Ne(e, s), r.needsLights = function(e) {
                        return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
                    }(e), r.lightsStateVersion = a, r.needsLights && (d.ambientLightColor.value = i.state.ambient, d.lightProbe.value = i.state.probe, d.directionalLights.value = i.state.directional, d.directionalLightShadows.value = i.state.directionalShadow, d.spotLights.value = i.state.spot, d.spotLightShadows.value = i.state.spotShadow, d.rectAreaLights.value = i.state.rectArea, d.ltc_1.value = i.state.rectAreaLTC1, d.ltc_2.value = i.state.rectAreaLTC2, d.pointLights.value = i.state.point, d.pointLightShadows.value = i.state.pointShadow, d.hemisphereLights.value = i.state.hemi, d.directionalShadowMap.value = i.state.directionalShadowMap, d.directionalShadowMatrix.value = i.state.directionalShadowMatrix, d.spotShadowMap.value = i.state.spotShadowMap, d.spotLightMatrix.value = i.state.spotLightMatrix, d.spotLightMap.value = i.state.spotLightMap, d.pointShadowMap.value = i.state.pointShadowMap, d.pointShadowMatrix.value = i.state.pointShadowMatrix), r.currentProgram = u, r.uniformsList = null, u
                }

                function De(e) {
                    if (null === e.uniformsList) {
                        const t = e.currentProgram.getUniforms();
                        e.uniformsList = em.seqWithValue(t.seq, e.uniforms)
                    }
                    return e.uniformsList
                }

                function Ne(e, t) {
                    const n = Q.get(e);
                    n.outputColorSpace = t.outputColorSpace, n.batching = t.batching, n.instancing = t.instancing, n.instancingColor = t.instancingColor, n.skinning = t.skinning, n.morphTargets = t.morphTargets, n.morphNormals = t.morphNormals, n.morphColors = t.morphColors, n.morphTargetsCount = t.morphTargetsCount, n.numClippingPlanes = t.numClippingPlanes, n.numIntersection = t.numClipIntersection, n.vertexAlphas = t.vertexAlphas, n.vertexTangents = t.vertexTangents, n.toneMapping = t.toneMapping
                }
                Pe.setAnimationLoop((function(e) {
                    Ee && Ee(e)
                })), "undefined" !== typeof self && Pe.setContext(self), this.setAnimationLoop = function(e) {
                    Ee = e, xe.setAnimationLoop(e), null === e ? Pe.stop() : Pe.start()
                }, xe.addEventListener("sessionstart", Ce), xe.addEventListener("sessionend", Te), this.render = function(e, t) {
                    if (void 0 !== t && !0 !== t.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    if (!0 === b) return;
                    !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), !0 === xe.enabled && !0 === xe.isPresenting && (!0 === xe.cameraAutoUpdate && xe.updateCamera(t), t = xe.getCamera()), !0 === e.isScene && e.onBeforeRender(y, e, t, M), m = se.get(e, v.length), m.init(), v.push(m), j.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), F.setFromProjectionMatrix(j), z = this.localClippingEnabled, U = le.init(this.clippingPlanes, z), f = ae.get(e, g.length), f.init(), g.push(f), Re(e, t, 0, y.sortObjects), f.finish(), !0 === y.sortObjects && f.sort(B, L), this.info.render.frame++, !0 === U && le.beginShadows();
                    const n = m.state.shadowsArray;
                    if (ce.render(n, e, t), !0 === U && le.endShadows(), !0 === this.info.autoReset && this.info.reset(), !1 !== xe.enabled && !1 !== xe.isPresenting && !1 !== xe.hasDepthSensing() || ue.render(f, e), m.setupLights(y._useLegacyLights), t.isArrayCamera) {
                        const n = t.cameras;
                        for (let t = 0, r = n.length; t < r; t++) {
                            const r = n[t];
                            Ie(f, e, r, r.viewport)
                        }
                    } else Ie(f, e, t);
                    null !== M && (Z.updateMultisampleRenderTarget(M), Z.updateRenderTargetMipmap(M)), !0 === e.isScene && e.onAfterRender(y, e, t), me.resetDefaultState(), w = -1, A = null, v.pop(), m = v.length > 0 ? v[v.length - 1] : null, g.pop(), f = g.length > 0 ? g[g.length - 1] : null
                }, this.getActiveCubeFace = function() {
                    return x
                }, this.getActiveMipmapLevel = function() {
                    return _
                }, this.getRenderTarget = function() {
                    return M
                }, this.setRenderTargetTextures = function(e, t, n) {
                    Q.get(e.texture).__webglTexture = t, Q.get(e.depthTexture).__webglTexture = n;
                    const r = Q.get(e);
                    r.__hasExternalTextures = !0, r.__hasExternalTextures && (r.__autoAllocateDepthBuffer = void 0 === n, r.__autoAllocateDepthBuffer || !0 === X.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), r.__useRenderToTexture = !1))
                }, this.setRenderTargetFramebuffer = function(e, t) {
                    const n = Q.get(e);
                    n.__webglFramebuffer = t, n.__useDefaultFramebuffer = void 0 === t
                }, this.setRenderTarget = function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                    M = e, x = t, _ = n;
                    let r = !0,
                        i = null,
                        o = !1,
                        a = !1;
                    if (e) {
                        const s = Q.get(e);
                        void 0 !== s.__useDefaultFramebuffer ? (J.bindFramebuffer(ve.FRAMEBUFFER, null), r = !1) : void 0 === s.__webglFramebuffer ? Z.setupRenderTarget(e) : s.__hasExternalTextures && Z.rebindTextures(e, Q.get(e.texture).__webglTexture, Q.get(e.depthTexture).__webglTexture);
                        const l = e.texture;
                        (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) && (a = !0);
                        const c = Q.get(e).__webglFramebuffer;
                        e.isWebGLCubeRenderTarget ? (i = Array.isArray(c[t]) ? c[t][n] : c[t], o = !0) : i = K.isWebGL2 && e.samples > 0 && !1 === Z.useMultisampledRTT(e) ? Q.get(e).__webglMultisampledFramebuffer : Array.isArray(c) ? c[n] : c, S.copy(e.viewport), E.copy(e.scissor), C = e.scissorTest
                    } else S.copy(D).multiplyScalar(O).floor(), E.copy(N).multiplyScalar(O).floor(), C = k;
                    if (J.bindFramebuffer(ve.FRAMEBUFFER, i) && K.drawBuffers && r && J.drawBuffers(e, i), J.viewport(S), J.scissor(E), J.setScissorTest(C), o) {
                        const r = Q.get(e.texture);
                        ve.framebufferTexture2D(ve.FRAMEBUFFER, ve.COLOR_ATTACHMENT0, ve.TEXTURE_CUBE_MAP_POSITIVE_X + t, r.__webglTexture, n)
                    } else if (a) {
                        const r = Q.get(e.texture),
                            i = t || 0;
                        ve.framebufferTextureLayer(ve.FRAMEBUFFER, ve.COLOR_ATTACHMENT0, r.__webglTexture, n || 0, i)
                    }
                    w = -1
                }, this.readRenderTargetPixels = function(e, t, n, r, i, o, a) {
                    if (!e || !e.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    let s = Q.get(e).__webglFramebuffer;
                    if (e.isWebGLCubeRenderTarget && void 0 !== a && (s = s[a]), s) {
                        J.bindFramebuffer(ve.FRAMEBUFFER, s);
                        try {
                            const a = e.texture,
                                s = a.format,
                                l = a.type;
                            if (s !== Ds && fe.convert(s) !== ve.getParameter(ve.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            const c = l === Rs && (X.has("EXT_color_buffer_half_float") || K.isWebGL2 && X.has("EXT_color_buffer_float"));
                            if (l !== ws && fe.convert(l) !== ve.getParameter(ve.IMPLEMENTATION_COLOR_READ_TYPE) && (l !== Ps || !(K.isWebGL2 || X.has("OES_texture_float") || X.has("WEBGL_color_buffer_float"))) && !c) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            t >= 0 && t <= e.width - r && n >= 0 && n <= e.height - i && ve.readPixels(t, n, r, i, fe.convert(s), fe.convert(l), o)
                        } finally {
                            const e = null !== M ? Q.get(M).__webglFramebuffer : null;
                            J.bindFramebuffer(ve.FRAMEBUFFER, e)
                        }
                    }
                }, this.copyFramebufferToTexture = function(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                    const r = Math.pow(2, -n),
                        i = Math.floor(t.image.width * r),
                        o = Math.floor(t.image.height * r);
                    Z.setTexture2D(t, 0), ve.copyTexSubImage2D(ve.TEXTURE_2D, n, 0, 0, e.x, e.y, i, o), J.unbindTexture()
                }, this.copyTextureToTexture = function(e, t, n) {
                    let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
                    const i = t.image.width,
                        o = t.image.height,
                        a = fe.convert(n.format),
                        s = fe.convert(n.type);
                    Z.setTexture2D(n, 0), ve.pixelStorei(ve.UNPACK_FLIP_Y_WEBGL, n.flipY), ve.pixelStorei(ve.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha), ve.pixelStorei(ve.UNPACK_ALIGNMENT, n.unpackAlignment), t.isDataTexture ? ve.texSubImage2D(ve.TEXTURE_2D, r, e.x, e.y, i, o, a, s, t.image.data) : t.isCompressedTexture ? ve.compressedTexSubImage2D(ve.TEXTURE_2D, r, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, a, t.mipmaps[0].data) : ve.texSubImage2D(ve.TEXTURE_2D, r, e.x, e.y, a, s, t.image), 0 === r && n.generateMipmaps && ve.generateMipmap(ve.TEXTURE_2D), J.unbindTexture()
                }, this.copyTextureToTexture3D = function(e, t, n, r) {
                    let i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
                    if (y.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                    const o = e.max.x - e.min.x + 1,
                        a = e.max.y - e.min.y + 1,
                        s = e.max.z - e.min.z + 1,
                        l = fe.convert(r.format),
                        c = fe.convert(r.type);
                    let u;
                    if (r.isData3DTexture) Z.setTexture3D(r, 0), u = ve.TEXTURE_3D;
                    else {
                        if (!r.isDataArrayTexture && !r.isCompressedArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                        Z.setTexture2DArray(r, 0), u = ve.TEXTURE_2D_ARRAY
                    }
                    ve.pixelStorei(ve.UNPACK_FLIP_Y_WEBGL, r.flipY), ve.pixelStorei(ve.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha), ve.pixelStorei(ve.UNPACK_ALIGNMENT, r.unpackAlignment);
                    const d = ve.getParameter(ve.UNPACK_ROW_LENGTH),
                        h = ve.getParameter(ve.UNPACK_IMAGE_HEIGHT),
                        p = ve.getParameter(ve.UNPACK_SKIP_PIXELS),
                        f = ve.getParameter(ve.UNPACK_SKIP_ROWS),
                        m = ve.getParameter(ve.UNPACK_SKIP_IMAGES),
                        g = n.isCompressedTexture ? n.mipmaps[i] : n.image;
                    ve.pixelStorei(ve.UNPACK_ROW_LENGTH, g.width), ve.pixelStorei(ve.UNPACK_IMAGE_HEIGHT, g.height), ve.pixelStorei(ve.UNPACK_SKIP_PIXELS, e.min.x), ve.pixelStorei(ve.UNPACK_SKIP_ROWS, e.min.y), ve.pixelStorei(ve.UNPACK_SKIP_IMAGES, e.min.z), n.isDataTexture || n.isData3DTexture ? ve.texSubImage3D(u, i, t.x, t.y, t.z, o, a, s, l, c, g.data) : n.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), ve.compressedTexSubImage3D(u, i, t.x, t.y, t.z, o, a, s, l, g.data)) : ve.texSubImage3D(u, i, t.x, t.y, t.z, o, a, s, l, c, g), ve.pixelStorei(ve.UNPACK_ROW_LENGTH, d), ve.pixelStorei(ve.UNPACK_IMAGE_HEIGHT, h), ve.pixelStorei(ve.UNPACK_SKIP_PIXELS, p), ve.pixelStorei(ve.UNPACK_SKIP_ROWS, f), ve.pixelStorei(ve.UNPACK_SKIP_IMAGES, m), 0 === i && r.generateMipmaps && ve.generateMipmap(u), J.unbindTexture()
                }, this.initTexture = function(e) {
                    e.isCubeTexture ? Z.setTextureCube(e, 0) : e.isData3DTexture ? Z.setTexture3D(e, 0) : e.isDataArrayTexture || e.isCompressedArrayTexture ? Z.setTexture2DArray(e, 0) : Z.setTexture2D(e, 0), J.unbindTexture()
                }, this.resetState = function() {
                    x = 0, _ = 0, M = null, J.reset(), me.reset()
                }, "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            get coordinateSystem() {
                return Lc
            }
            get outputColorSpace() {
                return this._outputColorSpace
            }
            set outputColorSpace(e) {
                this._outputColorSpace = e;
                const t = this.getContext();
                t.drawingBufferColorSpace = e === Wl ? "display-p3" : "srgb", t.unpackColorSpace = uu.workingColorSpace === Xl ? "display-p3" : "srgb"
            }
            get outputEncoding() {
                return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === Vl ? Fl : kl
            }
            set outputEncoding(e) {
                console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = e === Fl ? Vl : ql
            }
            get useLegacyLights() {
                return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights
            }
            set useLegacyLights(e) {
                console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e
            }
        }
        class Jm extends Km {}
        Jm.prototype.isWebGL1Renderer = !0;
        class Ym {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 25e-5;
                this.isFogExp2 = !0, this.name = "", this.color = new Wd(e), this.density = t
            }
            clone() {
                return new Ym(this.color, this.density)
            }
            toJSON() {
                return {
                    type: "FogExp2",
                    name: this.name,
                    color: this.color.getHex(),
                    density: this.density
                }
            }
        }
        class Qm {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e3;
                this.isFog = !0, this.name = "", this.color = new Wd(e), this.near = t, this.far = n
            }
            clone() {
                return new Qm(this.color, this.near, this.far)
            }
            toJSON() {
                return {
                    type: "Fog",
                    name: this.name,
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }
        }
        class Zm extends Rd {
            constructor() {
                super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            copy(e, t) {
                return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return null !== this.fog && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (t.object.backgroundIntensity = this.backgroundIntensity), t
            }
        }
        class $m {
            constructor(e, t) {
                this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = Mc, this._updateRange = {
                    offset: 0,
                    count: -1
                }, this.updateRanges = [], this.version = 0, this.uuid = Hc()
            }
            onUploadCallback() {}
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            get updateRange() {
                return ou("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
            }
            setUsage(e) {
                return this.usage = e, this
            }
            addUpdateRange(e, t) {
                this.updateRanges.push({
                    start: e,
                    count: t
                })
            }
            clearUpdateRanges() {
                this.updateRanges.length = 0
            }
            copy(e) {
                return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
            }
            copyAt(e, t, n) {
                e *= this.stride, n *= t.stride;
                for (let r = 0, i = this.stride; r < i; r++) this.array[e + r] = t.array[n + r];
                return this
            }
            set(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return this.array.set(e, t), this
            }
            clone(e) {
                void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Hc()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
                    n = new this.constructor(t, this.stride);
                return n.setUsage(this.usage), n
            }
            onUpload(e) {
                return this.onUploadCallback = e, this
            }
            toJSON(e) {
                return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Hc()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        }
        const eg = new Pu;
        class tg {
            constructor(e, t, n) {
                let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = r
            }
            get count() {
                return this.data.count
            }
            get array() {
                return this.data.array
            }
            set needsUpdate(e) {
                this.data.needsUpdate = e
            }
            applyMatrix4(e) {
                for (let t = 0, n = this.data.count; t < n; t++) eg.fromBufferAttribute(this, t), eg.applyMatrix4(e), this.setXYZ(t, eg.x, eg.y, eg.z);
                return this
            }
            applyNormalMatrix(e) {
                for (let t = 0, n = this.count; t < n; t++) eg.fromBufferAttribute(this, t), eg.applyNormalMatrix(e), this.setXYZ(t, eg.x, eg.y, eg.z);
                return this
            }
            transformDirection(e) {
                for (let t = 0, n = this.count; t < n; t++) eg.fromBufferAttribute(this, t), eg.transformDirection(e), this.setXYZ(t, eg.x, eg.y, eg.z);
                return this
            }
            getComponent(e, t) {
                let n = this.array[e * this.data.stride + this.offset + t];
                return this.normalized && (n = Xc(n, this.array)), n
            }
            setComponent(e, t, n) {
                return this.normalized && (n = Kc(n, this.array)), this.data.array[e * this.data.stride + this.offset + t] = n, this
            }
            setX(e, t) {
                return this.normalized && (t = Kc(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this
            }
            setY(e, t) {
                return this.normalized && (t = Kc(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this
            }
            setZ(e, t) {
                return this.normalized && (t = Kc(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this
            }
            setW(e, t) {
                return this.normalized && (t = Kc(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this
            }
            getX(e) {
                let t = this.data.array[e * this.data.stride + this.offset];
                return this.normalized && (t = Xc(t, this.array)), t
            }
            getY(e) {
                let t = this.data.array[e * this.data.stride + this.offset + 1];
                return this.normalized && (t = Xc(t, this.array)), t
            }
            getZ(e) {
                let t = this.data.array[e * this.data.stride + this.offset + 2];
                return this.normalized && (t = Xc(t, this.array)), t
            }
            getW(e) {
                let t = this.data.array[e * this.data.stride + this.offset + 3];
                return this.normalized && (t = Xc(t, this.array)), t
            }
            setXY(e, t, n) {
                return e = e * this.data.stride + this.offset, this.normalized && (t = Kc(t, this.array), n = Kc(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
            }
            setXYZ(e, t, n, r) {
                return e = e * this.data.stride + this.offset, this.normalized && (t = Kc(t, this.array), n = Kc(n, this.array), r = Kc(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this
            }
            setXYZW(e, t, n, r, i) {
                return e = e * this.data.stride + this.offset, this.normalized && (t = Kc(t, this.array), n = Kc(n, this.array), r = Kc(r, this.array), i = Kc(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = i, this
            }
            clone(e) {
                if (void 0 === e) {
                    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                    const e = [];
                    for (let t = 0; t < this.count; t++) {
                        const n = t * this.data.stride + this.offset;
                        for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
                    }
                    return new ih(new this.array.constructor(e), this.itemSize, this.normalized)
                }
                return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new tg(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
            }
            toJSON(e) {
                if (void 0 === e) {
                    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                    const e = [];
                    for (let t = 0; t < this.count; t++) {
                        const n = t * this.data.stride + this.offset;
                        for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: e,
                        normalized: this.normalized
                    }
                }
                return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                }
            }
        }
        class ng extends Jd {
            constructor(e) {
                super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Wd(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
            }
        }
        let rg;
        const ig = new Pu,
            og = new Pu,
            ag = new Pu,
            sg = new Yc,
            lg = new Yc,
            cg = new od,
            ug = new Pu,
            dg = new Pu,
            hg = new Pu,
            pg = new Yc,
            fg = new Yc,
            mg = new Yc;
        class gg extends Rd {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new ng;
                if (super(), this.isSprite = !0, this.type = "Sprite", void 0 === rg) {
                    rg = new Mh;
                    const e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                        t = new $m(e, 5);
                    rg.setIndex([0, 1, 2, 0, 2, 3]), rg.setAttribute("position", new tg(t, 3, 0, !1)), rg.setAttribute("uv", new tg(t, 2, 3, !1))
                }
                this.geometry = rg, this.material = e, this.center = new Yc(.5, .5)
            }
            raycast(e, t) {
                null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), og.setFromMatrixScale(this.matrixWorld), cg.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), ag.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && og.multiplyScalar(-ag.z);
                const n = this.material.rotation;
                let r, i;
                0 !== n && (i = Math.cos(n), r = Math.sin(n));
                const o = this.center;
                vg(ug.set(-.5, -.5, 0), ag, o, og, r, i), vg(dg.set(.5, -.5, 0), ag, o, og, r, i), vg(hg.set(.5, .5, 0), ag, o, og, r, i), pg.set(0, 0), fg.set(1, 0), mg.set(1, 1);
                let a = e.ray.intersectTriangle(ug, dg, hg, !1, ig);
                if (null === a && (vg(dg.set(-.5, .5, 0), ag, o, og, r, i), fg.set(0, 1), a = e.ray.intersectTriangle(ug, hg, dg, !1, ig), null === a)) return;
                const s = e.ray.origin.distanceTo(ig);
                s < e.near || s > e.far || t.push({
                    distance: s,
                    point: ig.clone(),
                    uv: Hd.getInterpolation(ig, ug, dg, hg, pg, fg, mg, new Yc),
                    face: null,
                    object: this
                })
            }
            copy(e, t) {
                return super.copy(e, t), void 0 !== e.center && this.center.copy(e.center), this.material = e.material, this
            }
        }

        function vg(e, t, n, r, i, o) {
            sg.subVectors(e, n).addScalar(.5).multiply(r), void 0 !== i ? (lg.x = o * sg.x - i * sg.y, lg.y = i * sg.x + o * sg.y) : lg.copy(sg), e.copy(t), e.x += lg.x, e.y += lg.y, e.applyMatrix4(cg)
        }
        const yg = new Pu,
            bg = new Pu;
        class xg extends Rd {
            constructor() {
                super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    },
                    isLOD: {
                        value: !0
                    }
                }), this.autoUpdate = !0
            }
            copy(e) {
                super.copy(e, !1);
                const t = e.levels;
                for (let n = 0, r = t.length; n < r; n++) {
                    const e = t[n];
                    this.addLevel(e.object.clone(), e.distance, e.hysteresis)
                }
                return this.autoUpdate = e.autoUpdate, this
            }
            addLevel(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                t = Math.abs(t);
                const r = this.levels;
                let i;
                for (i = 0; i < r.length && !(t < r[i].distance); i++);
                return r.splice(i, 0, {
                    distance: t,
                    hysteresis: n,
                    object: e
                }), this.add(e), this
            }
            getCurrentLevel() {
                return this._currentLevel
            }
            getObjectForDistance(e) {
                const t = this.levels;
                if (t.length > 0) {
                    let n, r;
                    for (n = 1, r = t.length; n < r; n++) {
                        let r = t[n].distance;
                        if (t[n].object.visible && (r -= r * t[n].hysteresis), e < r) break
                    }
                    return t[n - 1].object
                }
                return null
            }
            raycast(e, t) {
                if (this.levels.length > 0) {
                    yg.setFromMatrixPosition(this.matrixWorld);
                    const n = e.ray.origin.distanceTo(yg);
                    this.getObjectForDistance(n).raycast(e, t)
                }
            }
            update(e) {
                const t = this.levels;
                if (t.length > 1) {
                    yg.setFromMatrixPosition(e.matrixWorld), bg.setFromMatrixPosition(this.matrixWorld);
                    const n = yg.distanceTo(bg) / e.zoom;
                    let r, i;
                    for (t[0].object.visible = !0, r = 1, i = t.length; r < i; r++) {
                        let e = t[r].distance;
                        if (t[r].object.visible && (e -= e * t[r].hysteresis), !(n >= e)) break;
                        t[r - 1].object.visible = !1, t[r].object.visible = !0
                    }
                    for (this._currentLevel = r - 1; r < i; r++) t[r].object.visible = !1
                }
            }
            toJSON(e) {
                const t = super.toJSON(e);
                !1 === this.autoUpdate && (t.object.autoUpdate = !1), t.object.levels = [];
                const n = this.levels;
                for (let r = 0, i = n.length; r < i; r++) {
                    const e = n[r];
                    t.object.levels.push({
                        object: e.object.uuid,
                        distance: e.distance,
                        hysteresis: e.hysteresis
                    })
                }
                return t
            }
        }
        const _g = new Pu,
            Mg = new xu,
            wg = new xu,
            Ag = new Pu,
            Sg = new od,
            Eg = new Pu,
            Cg = new Yu,
            Tg = new od,
            Pg = new id;
        class Rg extends zh {
            constructor(e, t) {
                super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = ns, this.bindMatrix = new od, this.bindMatrixInverse = new od, this.boundingBox = null, this.boundingSphere = null
            }
            computeBoundingBox() {
                const e = this.geometry;
                null === this.boundingBox && (this.boundingBox = new Ou), this.boundingBox.makeEmpty();
                const t = e.getAttribute("position");
                for (let n = 0; n < t.count; n++) this.getVertexPosition(n, Eg), this.boundingBox.expandByPoint(Eg)
            }
            computeBoundingSphere() {
                const e = this.geometry;
                null === this.boundingSphere && (this.boundingSphere = new Yu), this.boundingSphere.makeEmpty();
                const t = e.getAttribute("position");
                for (let n = 0; n < t.count; n++) this.getVertexPosition(n, Eg), this.boundingSphere.expandByPoint(Eg)
            }
            copy(e, t) {
                return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
            }
            raycast(e, t) {
                const n = this.material,
                    r = this.matrixWorld;
                void 0 !== n && (null === this.boundingSphere && this.computeBoundingSphere(), Cg.copy(this.boundingSphere), Cg.applyMatrix4(r), !1 !== e.ray.intersectsSphere(Cg) && (Tg.copy(r).invert(), Pg.copy(e.ray).applyMatrix4(Tg), null !== this.boundingBox && !1 === Pg.intersectsBox(this.boundingBox) || this._computeIntersections(e, t, Pg)))
            }
            getVertexPosition(e, t) {
                return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t
            }
            bind(e, t) {
                this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
            }
            pose() {
                this.skeleton.pose()
            }
            normalizeSkinWeights() {
                const e = new xu,
                    t = this.geometry.attributes.skinWeight;
                for (let n = 0, r = t.count; n < r; n++) {
                    e.fromBufferAttribute(t, n);
                    const r = 1 / e.manhattanLength();
                    r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
                }
            }
            updateMatrixWorld(e) {
                super.updateMatrixWorld(e), this.bindMode === ns ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === rs ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            }
            applyBoneTransform(e, t) {
                const n = this.skeleton,
                    r = this.geometry;
                Mg.fromBufferAttribute(r.attributes.skinIndex, e), wg.fromBufferAttribute(r.attributes.skinWeight, e), _g.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
                for (let i = 0; i < 4; i++) {
                    const e = wg.getComponent(i);
                    if (0 !== e) {
                        const r = Mg.getComponent(i);
                        Sg.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), t.addScaledVector(Ag.copy(_g).applyMatrix4(Sg), e)
                    }
                }
                return t.applyMatrix4(this.bindMatrixInverse)
            }
        }
        class Ig extends Rd {
            constructor() {
                super(), this.isBone = !0, this.type = "Bone"
            }
        }
        class Og extends bu {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                super(null, arguments.length > 5 ? arguments[5] : void 0, arguments.length > 6 ? arguments[6] : void 0, arguments.length > 7 ? arguments[7] : void 0, arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : ps, arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : ps, arguments.length > 3 ? arguments[3] : void 0, arguments.length > 4 ? arguments[4] : void 0, arguments.length > 10 ? arguments[10] : void 0, arguments.length > 11 ? arguments[11] : void 0), this.isDataTexture = !0, this.image = {
                    data: e,
                    width: t,
                    height: n
                }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        }
        const Bg = new od,
            Lg = new od;
        class Dg {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                this.uuid = Hc(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init()
            }
            init() {
                const e = this.bones,
                    t = this.boneInverses;
                if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses();
                else if (e.length !== t.length) {
                    console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                    for (let e = 0, t = this.bones.length; e < t; e++) this.boneInverses.push(new od)
                }
            }
            calculateInverses() {
                this.boneInverses.length = 0;
                for (let e = 0, t = this.bones.length; e < t; e++) {
                    const t = new od;
                    this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t)
                }
            }
            pose() {
                for (let e = 0, t = this.bones.length; e < t; e++) {
                    const t = this.bones[e];
                    t && t.matrixWorld.copy(this.boneInverses[e]).invert()
                }
                for (let e = 0, t = this.bones.length; e < t; e++) {
                    const t = this.bones[e];
                    t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
                }
            }
            update() {
                const e = this.bones,
                    t = this.boneInverses,
                    n = this.boneMatrices,
                    r = this.boneTexture;
                for (let i = 0, o = e.length; i < o; i++) {
                    const r = e[i] ? e[i].matrixWorld : Lg;
                    Bg.multiplyMatrices(r, t[i]), Bg.toArray(n, 16 * i)
                }
                null !== r && (r.needsUpdate = !0)
            }
            clone() {
                return new Dg(this.bones, this.boneInverses)
            }
            computeBoneTexture() {
                let e = Math.sqrt(4 * this.bones.length);
                e = 4 * Math.ceil(e / 4), e = Math.max(e, 4);
                const t = new Float32Array(e * e * 4);
                t.set(this.boneMatrices);
                const n = new Og(t, e, e, Ds, Ps);
                return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this
            }
            getBoneByName(e) {
                for (let t = 0, n = this.bones.length; t < n; t++) {
                    const n = this.bones[t];
                    if (n.name === e) return n
                }
            }
            dispose() {
                null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
            }
            fromJSON(e, t) {
                this.uuid = e.uuid;
                for (let n = 0, r = e.bones.length; n < r; n++) {
                    const r = e.bones[n];
                    let i = t[r];
                    void 0 === i && (console.warn("THREE.Skeleton: No bone found with UUID:", r), i = new Ig), this.bones.push(i), this.boneInverses.push((new od).fromArray(e.boneInverses[n]))
                }
                return this.init(), this
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.6,
                        type: "Skeleton",
                        generator: "Skeleton.toJSON"
                    },
                    bones: [],
                    boneInverses: []
                };
                e.uuid = this.uuid;
                const t = this.bones,
                    n = this.boneInverses;
                for (let r = 0, i = t.length; r < i; r++) {
                    const i = t[r];
                    e.bones.push(i.uuid);
                    const o = n[r];
                    e.boneInverses.push(o.toArray())
                }
                return e
            }
        }
        class Ng extends ih {
            constructor(e, t, n) {
                let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r
            }
            copy(e) {
                return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
            }
            toJSON() {
                const e = super.toJSON();
                return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
            }
        }
        const kg = new od,
            Fg = new od,
            Ug = [],
            zg = new Ou,
            Hg = new od,
            jg = new zh,
            Gg = new Yu;
        class Vg extends zh {
            constructor(e, t, n) {
                super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new Ng(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
                for (let r = 0; r < n; r++) this.setMatrixAt(r, Hg)
            }
            computeBoundingBox() {
                const e = this.geometry,
                    t = this.count;
                null === this.boundingBox && (this.boundingBox = new Ou), null === e.boundingBox && e.computeBoundingBox(), this.boundingBox.makeEmpty();
                for (let n = 0; n < t; n++) this.getMatrixAt(n, kg), zg.copy(e.boundingBox).applyMatrix4(kg), this.boundingBox.union(zg)
            }
            computeBoundingSphere() {
                const e = this.geometry,
                    t = this.count;
                null === this.boundingSphere && (this.boundingSphere = new Yu), null === e.boundingSphere && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
                for (let n = 0; n < t; n++) this.getMatrixAt(n, kg), Gg.copy(e.boundingSphere).applyMatrix4(kg), this.boundingSphere.union(Gg)
            }
            copy(e, t) {
                return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
            }
            getColorAt(e, t) {
                t.fromArray(this.instanceColor.array, 3 * e)
            }
            getMatrixAt(e, t) {
                t.fromArray(this.instanceMatrix.array, 16 * e)
            }
            raycast(e, t) {
                const n = this.matrixWorld,
                    r = this.count;
                if (jg.geometry = this.geometry, jg.material = this.material, void 0 !== jg.material && (null === this.boundingSphere && this.computeBoundingSphere(), Gg.copy(this.boundingSphere), Gg.applyMatrix4(n), !1 !== e.ray.intersectsSphere(Gg)))
                    for (let i = 0; i < r; i++) {
                        this.getMatrixAt(i, kg), Fg.multiplyMatrices(n, kg), jg.matrixWorld = Fg, jg.raycast(e, Ug);
                        for (let e = 0, n = Ug.length; e < n; e++) {
                            const n = Ug[e];
                            n.instanceId = i, n.object = this, t.push(n)
                        }
                        Ug.length = 0
                    }
            }
            setColorAt(e, t) {
                null === this.instanceColor && (this.instanceColor = new Ng(new Float32Array(3 * this.instanceMatrix.count), 3)), t.toArray(this.instanceColor.array, 3 * e)
            }
            setMatrixAt(e, t) {
                t.toArray(this.instanceMatrix.array, 16 * e)
            }
            updateMorphTargets() {}
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }

        function qg(e, t) {
            return e.z - t.z
        }

        function Wg(e, t) {
            return t.z - e.z
        }
        class Xg {
            constructor() {
                this.index = 0, this.pool = [], this.list = []
            }
            push(e, t) {
                const n = this.pool,
                    r = this.list;
                this.index >= n.length && n.push({
                    start: -1,
                    count: -1,
                    z: -1
                });
                const i = n[this.index];
                r.push(i), this.index++, i.start = e.start, i.count = e.count, i.z = t
            }
            reset() {
                this.list.length = 0, this.index = 0
            }
        }
        const Kg = "batchId",
            Jg = new od,
            Yg = new od,
            Qg = new od,
            Zg = new od,
            $g = new cp,
            ev = new Ou,
            tv = new Yu,
            nv = new Pu,
            rv = new Xg,
            iv = new zh,
            ov = [];

        function av(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            const r = t.itemSize;
            if (e.isInterleavedBufferAttribute || e.array.constructor !== t.array.constructor) {
                const i = e.count;
                for (let o = 0; o < i; o++)
                    for (let i = 0; i < r; i++) t.setComponent(o + n, i, e.getComponent(o, i))
            } else t.array.set(e.array, n * r);
            t.needsUpdate = !0
        }
        class sv extends zh {
            get maxGeometryCount() {
                return this._maxGeometryCount
            }
            constructor(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2 * t,
                    r = arguments.length > 3 ? arguments[3] : void 0;
                super(new Mh, r), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._drawRanges = [], this._reservedRanges = [], this._visibility = [], this._active = [], this._bounds = [], this._maxGeometryCount = e, this._maxVertexCount = t, this._maxIndexCount = n, this._geometryInitialized = !1, this._geometryCount = 0, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._visibilityChanged = !0, this._matricesTexture = null, this._initMatricesTexture()
            }
            _initMatricesTexture() {
                let e = Math.sqrt(4 * this._maxGeometryCount);
                e = 4 * Math.ceil(e / 4), e = Math.max(e, 4);
                const t = new Float32Array(e * e * 4),
                    n = new Og(t, e, e, Ds, Ps);
                this._matricesTexture = n
            }
            _initializeGeometry(e) {
                const t = this.geometry,
                    n = this._maxVertexCount,
                    r = this._maxGeometryCount,
                    i = this._maxIndexCount;
                if (!1 === this._geometryInitialized) {
                    for (const r in e.attributes) {
                        const i = e.getAttribute(r),
                            {
                                array: o,
                                itemSize: a,
                                normalized: s
                            } = i,
                            l = new o.constructor(n * a),
                            c = new i.constructor(l, a, s);
                        c.setUsage(i.usage), t.setAttribute(r, c)
                    }
                    if (null !== e.getIndex()) {
                        const e = n > 65536 ? new Uint32Array(i) : new Uint16Array(i);
                        t.setIndex(new ih(e, 1))
                    }
                    const o = r > 65536 ? new Uint32Array(n) : new Uint16Array(n);
                    t.setAttribute(Kg, new ih(o, 1)), this._geometryInitialized = !0
                }
            }
            _validateGeometry(e) {
                if (e.getAttribute(Kg)) throw new Error('BatchedMesh: Geometry cannot use attribute "'.concat(Kg, '"'));
                const t = this.geometry;
                if (Boolean(e.getIndex()) !== Boolean(t.getIndex())) throw new Error('BatchedMesh: All geometries must consistently have "index".');
                for (const n in t.attributes) {
                    if (n === Kg) continue;
                    if (!e.hasAttribute(n)) throw new Error('BatchedMesh: Added geometry missing "'.concat(n, '". All geometries must have consistent attributes.'));
                    const r = e.getAttribute(n),
                        i = t.getAttribute(n);
                    if (r.itemSize !== i.itemSize || r.normalized !== i.normalized) throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.")
                }
            }
            setCustomSort(e) {
                return this.customSort = e, this
            }
            computeBoundingBox() {
                null === this.boundingBox && (this.boundingBox = new Ou);
                const e = this._geometryCount,
                    t = this.boundingBox,
                    n = this._active;
                t.makeEmpty();
                for (let r = 0; r < e; r++) !1 !== n[r] && (this.getMatrixAt(r, Jg), this.getBoundingBoxAt(r, ev).applyMatrix4(Jg), t.union(ev))
            }
            computeBoundingSphere() {
                null === this.boundingSphere && (this.boundingSphere = new Yu);
                const e = this._geometryCount,
                    t = this.boundingSphere,
                    n = this._active;
                t.makeEmpty();
                for (let r = 0; r < e; r++) !1 !== n[r] && (this.getMatrixAt(r, Jg), this.getBoundingSphereAt(r, tv).applyMatrix4(Jg), t.union(tv))
            }
            addGeometry(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -1;
                if (this._initializeGeometry(e), this._validateGeometry(e), this._geometryCount >= this._maxGeometryCount) throw new Error("BatchedMesh: Maximum geometry count reached.");
                const r = {
                    vertexStart: -1,
                    vertexCount: -1,
                    indexStart: -1,
                    indexCount: -1
                };
                let i = null;
                const o = this._reservedRanges,
                    a = this._drawRanges,
                    s = this._bounds;
                0 !== this._geometryCount && (i = o[o.length - 1]), r.vertexCount = -1 === t ? e.getAttribute("position").count : t, r.vertexStart = null === i ? 0 : i.vertexStart + i.vertexCount;
                const l = e.getIndex(),
                    c = null !== l;
                if (c && (r.indexCount = -1 === n ? l.count : n, r.indexStart = null === i ? 0 : i.indexStart + i.indexCount), -1 !== r.indexStart && r.indexStart + r.indexCount > this._maxIndexCount || r.vertexStart + r.vertexCount > this._maxVertexCount) throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
                const u = this._visibility,
                    d = this._active,
                    h = this._matricesTexture,
                    p = this._matricesTexture.image.data;
                u.push(!0), d.push(!0);
                const f = this._geometryCount;
                this._geometryCount++, Qg.toArray(p, 16 * f), h.needsUpdate = !0, o.push(r), a.push({
                    start: c ? r.indexStart : r.vertexStart,
                    count: -1
                }), s.push({
                    boxInitialized: !1,
                    box: new Ou,
                    sphereInitialized: !1,
                    sphere: new Yu
                });
                const m = this.geometry.getAttribute(Kg);
                for (let g = 0; g < r.vertexCount; g++) m.setX(r.vertexStart + g, f);
                return m.needsUpdate = !0, this.setGeometryAt(f, e), f
            }
            setGeometryAt(e, t) {
                if (e >= this._geometryCount) throw new Error("BatchedMesh: Maximum geometry count reached.");
                this._validateGeometry(t);
                const n = this.geometry,
                    r = null !== n.getIndex(),
                    i = n.getIndex(),
                    o = t.getIndex(),
                    a = this._reservedRanges[e];
                if (r && o.count > a.indexCount || t.attributes.position.count > a.vertexCount) throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
                const s = a.vertexStart,
                    l = a.vertexCount;
                for (const h in n.attributes) {
                    if (h === Kg) continue;
                    const e = t.getAttribute(h),
                        r = n.getAttribute(h);
                    av(e, r, s);
                    const i = e.itemSize;
                    for (let t = e.count, n = l; t < n; t++) {
                        const e = s + t;
                        for (let t = 0; t < i; t++) r.setComponent(e, t, 0)
                    }
                    r.needsUpdate = !0
                }
                if (r) {
                    const e = a.indexStart;
                    for (let t = 0; t < o.count; t++) i.setX(e + t, s + o.getX(t));
                    for (let t = o.count, n = a.indexCount; t < n; t++) i.setX(e + t, s);
                    i.needsUpdate = !0
                }
                const c = this._bounds[e];
                null !== t.boundingBox ? (c.box.copy(t.boundingBox), c.boxInitialized = !0) : c.boxInitialized = !1, null !== t.boundingSphere ? (c.sphere.copy(t.boundingSphere), c.sphereInitialized = !0) : c.sphereInitialized = !1;
                const u = this._drawRanges[e],
                    d = t.getAttribute("position");
                return u.count = r ? o.count : d.count, this._visibilityChanged = !0, e
            }
            deleteGeometry(e) {
                const t = this._active;
                return e >= t.length || !1 === t[e] || (t[e] = !1, this._visibilityChanged = !0), this
            }
            getBoundingBoxAt(e, t) {
                if (!1 === this._active[e]) return null;
                const n = this._bounds[e],
                    r = n.box,
                    i = this.geometry;
                if (!1 === n.boxInitialized) {
                    r.makeEmpty();
                    const t = i.index,
                        o = i.attributes.position,
                        a = this._drawRanges[e];
                    for (let e = a.start, n = a.start + a.count; e < n; e++) {
                        let n = e;
                        t && (n = t.getX(n)), r.expandByPoint(nv.fromBufferAttribute(o, n))
                    }
                    n.boxInitialized = !0
                }
                return t.copy(r), t
            }
            getBoundingSphereAt(e, t) {
                if (!1 === this._active[e]) return null;
                const n = this._bounds[e],
                    r = n.sphere,
                    i = this.geometry;
                if (!1 === n.sphereInitialized) {
                    r.makeEmpty(), this.getBoundingBoxAt(e, ev), ev.getCenter(r.center);
                    const t = i.index,
                        o = i.attributes.position,
                        a = this._drawRanges[e];
                    let s = 0;
                    for (let e = a.start, n = a.start + a.count; e < n; e++) {
                        let n = e;
                        t && (n = t.getX(n)), nv.fromBufferAttribute(o, n), s = Math.max(s, r.center.distanceToSquared(nv))
                    }
                    r.radius = Math.sqrt(s), n.sphereInitialized = !0
                }
                return t.copy(r), t
            }
            setMatrixAt(e, t) {
                const n = this._active,
                    r = this._matricesTexture,
                    i = this._matricesTexture.image.data;
                return e >= this._geometryCount || !1 === n[e] || (t.toArray(i, 16 * e), r.needsUpdate = !0), this
            }
            getMatrixAt(e, t) {
                const n = this._active,
                    r = this._matricesTexture.image.data;
                return e >= this._geometryCount || !1 === n[e] ? null : t.fromArray(r, 16 * e)
            }
            setVisibleAt(e, t) {
                const n = this._visibility,
                    r = this._active;
                return e >= this._geometryCount || !1 === r[e] || n[e] === t || (n[e] = t, this._visibilityChanged = !0), this
            }
            getVisibleAt(e) {
                const t = this._visibility,
                    n = this._active;
                return !(e >= this._geometryCount || !1 === n[e]) && t[e]
            }
            raycast(e, t) {
                const n = this._visibility,
                    r = this._active,
                    i = this._drawRanges,
                    o = this._geometryCount,
                    a = this.matrixWorld,
                    s = this.geometry;
                iv.material = this.material, iv.geometry.index = s.index, iv.geometry.attributes = s.attributes, null === iv.geometry.boundingBox && (iv.geometry.boundingBox = new Ou), null === iv.geometry.boundingSphere && (iv.geometry.boundingSphere = new Yu);
                for (let l = 0; l < o; l++) {
                    if (!n[l] || !r[l]) continue;
                    const o = i[l];
                    iv.geometry.setDrawRange(o.start, o.count), this.getMatrixAt(l, iv.matrixWorld).premultiply(a), this.getBoundingBoxAt(l, iv.geometry.boundingBox), this.getBoundingSphereAt(l, iv.geometry.boundingSphere), iv.raycast(e, ov);
                    for (let e = 0, n = ov.length; e < n; e++) {
                        const n = ov[e];
                        n.object = this, n.batchId = l, t.push(n)
                    }
                    ov.length = 0
                }
                iv.material = null, iv.geometry.index = null, iv.geometry.attributes = {}, iv.geometry.setDrawRange(0, 1 / 0)
            }
            copy(e) {
                return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = null !== e.boundingBox ? e.boundingBox.clone() : null, this.boundingSphere = null !== e.boundingSphere ? e.boundingSphere.clone() : null, this._drawRanges = e._drawRanges.map((e => ({ ...e
                }))), this._reservedRanges = e._reservedRanges.map((e => ({ ...e
                }))), this._visibility = e._visibility.slice(), this._active = e._active.slice(), this._bounds = e._bounds.map((e => ({
                    boxInitialized: e.boxInitialized,
                    box: e.box.clone(),
                    sphereInitialized: e.sphereInitialized,
                    sphere: e.sphere.clone()
                }))), this._maxGeometryCount = e._maxGeometryCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._geometryCount = e._geometryCount, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.slice(), this
            }
            dispose() {
                return this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this
            }
            onBeforeRender(e, t, n, r, i) {
                if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) return;
                const o = r.getIndex(),
                    a = null === o ? 1 : o.array.BYTES_PER_ELEMENT,
                    s = this._active,
                    l = this._visibility,
                    c = this._multiDrawStarts,
                    u = this._multiDrawCounts,
                    d = this._drawRanges,
                    h = this.perObjectFrustumCulled;
                h && (Zg.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld), $g.setFromProjectionMatrix(Zg, e.coordinateSystem));
                let p = 0;
                if (this.sortObjects) {
                    Yg.copy(this.matrixWorld).invert(), nv.setFromMatrixPosition(n.matrixWorld).applyMatrix4(Yg);
                    for (let n = 0, r = l.length; n < r; n++)
                        if (l[n] && s[n]) {
                            this.getMatrixAt(n, Jg), this.getBoundingSphereAt(n, tv).applyMatrix4(Jg);
                            let e = !1;
                            if (h && (e = !$g.intersectsSphere(tv)), !e) {
                                const e = nv.distanceTo(tv.center);
                                rv.push(d[n], e)
                            }
                        }
                    const e = rv.list,
                        t = this.customSort;
                    null === t ? e.sort(i.transparent ? Wg : qg) : t.call(this, e, n);
                    for (let n = 0, r = e.length; n < r; n++) {
                        const t = e[n];
                        c[p] = t.start * a, u[p] = t.count, p++
                    }
                    rv.reset()
                } else
                    for (let f = 0, m = l.length; f < m; f++)
                        if (l[f] && s[f]) {
                            let e = !1;
                            if (h && (this.getMatrixAt(f, Jg), this.getBoundingSphereAt(f, tv).applyMatrix4(Jg), e = !$g.intersectsSphere(tv)), !e) {
                                const e = d[f];
                                c[p] = e.start * a, u[p] = e.count, p++
                            }
                        }
                this._multiDrawCount = p, this._visibilityChanged = !1
            }
            onBeforeShadow(e, t, n, r, i, o) {
                this.onBeforeRender(e, null, r, i, o)
            }
        }
        class lv extends Jd {
            constructor(e) {
                super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Wd(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this
            }
        }
        const cv = new Pu,
            uv = new Pu,
            dv = new od,
            hv = new id,
            pv = new Yu;
        class fv extends Rd {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Mh,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new lv;
                super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets()
            }
            copy(e, t) {
                return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
            }
            computeLineDistances() {
                const e = this.geometry;
                if (null === e.index) {
                    const t = e.attributes.position,
                        n = [0];
                    for (let e = 1, r = t.count; e < r; e++) cv.fromBufferAttribute(t, e - 1), uv.fromBufferAttribute(t, e), n[e] = n[e - 1], n[e] += cv.distanceTo(uv);
                    e.setAttribute("lineDistance", new ph(n, 1))
                } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
            raycast(e, t) {
                const n = this.geometry,
                    r = this.matrixWorld,
                    i = e.params.Line.threshold,
                    o = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(), pv.copy(n.boundingSphere), pv.applyMatrix4(r), pv.radius += i, !1 === e.ray.intersectsSphere(pv)) return;
                dv.copy(r).invert(), hv.copy(e.ray).applyMatrix4(dv);
                const a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    s = a * a,
                    l = new Pu,
                    c = new Pu,
                    u = new Pu,
                    d = new Pu,
                    h = this.isLineSegments ? 2 : 1,
                    p = n.index,
                    f = n.attributes.position;
                if (null !== p) {
                    for (let n = Math.max(0, o.start), r = Math.min(p.count, o.start + o.count) - 1; n < r; n += h) {
                        const r = p.getX(n),
                            i = p.getX(n + 1);
                        l.fromBufferAttribute(f, r), c.fromBufferAttribute(f, i);
                        if (hv.distanceSqToSegment(l, c, d, u) > s) continue;
                        d.applyMatrix4(this.matrixWorld);
                        const o = e.ray.origin.distanceTo(d);
                        o < e.near || o > e.far || t.push({
                            distance: o,
                            point: u.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                } else {
                    for (let n = Math.max(0, o.start), r = Math.min(f.count, o.start + o.count) - 1; n < r; n += h) {
                        l.fromBufferAttribute(f, n), c.fromBufferAttribute(f, n + 1);
                        if (hv.distanceSqToSegment(l, c, d, u) > s) continue;
                        d.applyMatrix4(this.matrixWorld);
                        const r = e.ray.origin.distanceTo(d);
                        r < e.near || r > e.far || t.push({
                            distance: r,
                            point: u.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                }
            }
            updateMorphTargets() {
                const e = this.geometry.morphAttributes,
                    t = Object.keys(e);
                if (t.length > 0) {
                    const n = e[t[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let e = 0, t = n.length; e < t; e++) {
                            const t = n[e].name || String(e);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e
                        }
                    }
                }
            }
        }
        const mv = new Pu,
            gv = new Pu;
        class vv extends fv {
            constructor(e, t) {
                super(e, t), this.isLineSegments = !0, this.type = "LineSegments"
            }
            computeLineDistances() {
                const e = this.geometry;
                if (null === e.index) {
                    const t = e.attributes.position,
                        n = [];
                    for (let e = 0, r = t.count; e < r; e += 2) mv.fromBufferAttribute(t, e), gv.fromBufferAttribute(t, e + 1), n[e] = 0 === e ? 0 : n[e - 1], n[e + 1] = n[e] + mv.distanceTo(gv);
                    e.setAttribute("lineDistance", new ph(n, 1))
                } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
        }
        class yv extends fv {
            constructor(e, t) {
                super(e, t), this.isLineLoop = !0, this.type = "LineLoop"
            }
        }
        class bv extends Jd {
            constructor(e) {
                super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Wd(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
            }
        }
        const xv = new od,
            _v = new id,
            Mv = new Yu,
            wv = new Pu;
        class Av extends Rd {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Mh,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new bv;
                super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets()
            }
            copy(e, t) {
                return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
            }
            raycast(e, t) {
                const n = this.geometry,
                    r = this.matrixWorld,
                    i = e.params.Points.threshold,
                    o = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(), Mv.copy(n.boundingSphere), Mv.applyMatrix4(r), Mv.radius += i, !1 === e.ray.intersectsSphere(Mv)) return;
                xv.copy(r).invert(), _v.copy(e.ray).applyMatrix4(xv);
                const a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    s = a * a,
                    l = n.index,
                    c = n.attributes.position;
                if (null !== l) {
                    for (let n = Math.max(0, o.start), i = Math.min(l.count, o.start + o.count); n < i; n++) {
                        const i = l.getX(n);
                        wv.fromBufferAttribute(c, i), Sv(wv, i, s, r, e, t, this)
                    }
                } else {
                    for (let n = Math.max(0, o.start), i = Math.min(c.count, o.start + o.count); n < i; n++) wv.fromBufferAttribute(c, n), Sv(wv, n, s, r, e, t, this)
                }
            }
            updateMorphTargets() {
                const e = this.geometry.morphAttributes,
                    t = Object.keys(e);
                if (t.length > 0) {
                    const n = e[t[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let e = 0, t = n.length; e < t; e++) {
                            const t = n[e].name || String(e);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e
                        }
                    }
                }
            }
        }

        function Sv(e, t, n, r, i, o, a) {
            const s = _v.distanceSqToPoint(e);
            if (s < n) {
                const n = new Pu;
                _v.closestPointToPoint(e, n), n.applyMatrix4(r);
                const l = i.ray.origin.distanceTo(n);
                if (l < i.near || l > i.far) return;
                o.push({
                    distance: l,
                    distanceToRay: Math.sqrt(s),
                    point: n,
                    index: t,
                    face: null,
                    object: a
                })
            }
        }
        class Ev extends bu {
            constructor(e, t, n, r, i, o, a, s, l) {
                super(e, t, n, r, i, o, a, s, l), this.isVideoTexture = !0, this.minFilter = void 0 !== o ? o : ys, this.magFilter = void 0 !== i ? i : ys, this.generateMipmaps = !1;
                const c = this;
                "requestVideoFrameCallback" in e && e.requestVideoFrameCallback((function t() {
                    c.needsUpdate = !0, e.requestVideoFrameCallback(t)
                }))
            }
            clone() {
                return new this.constructor(this.image).copy(this)
            }
            update() {
                const e = this.image;
                !1 === "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }
        class Cv extends bu {
            constructor(e, t) {
                super({
                    width: e,
                    height: t
                }), this.isFramebufferTexture = !0, this.magFilter = ps, this.minFilter = ps, this.generateMipmaps = !1, this.needsUpdate = !0
            }
        }
        class Tv extends bu {
            constructor(e, t, n, r, i, o, a, s, l, c, u, d) {
                super(null, o, a, s, l, c, r, i, u, d), this.isCompressedTexture = !0, this.image = {
                    width: t,
                    height: n
                }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
            }
        }
        class Pv extends Tv {
            constructor(e, t, n, r, i, o) {
                super(e, t, n, i, o), this.isCompressedArrayTexture = !0, this.image.depth = r, this.wrapR = ds
            }
        }
        class Rv extends Tv {
            constructor(e, t, n) {
                super(void 0, e[0].width, e[0].height, t, n, os), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e
            }
        }
        class Iv extends bu {
            constructor(e, t, n, r, i, o, a, s, l) {
                super(e, t, n, r, i, o, a, s, l), this.isCanvasTexture = !0, this.needsUpdate = !0
            }
        }
        class Ov {
            constructor() {
                this.type = "Curve", this.arcLengthDivisions = 200
            }
            getPoint() {
                return console.warn("THREE.Curve: .getPoint() not implemented."), null
            }
            getPointAt(e, t) {
                const n = this.getUtoTmapping(e);
                return this.getPoint(n, t)
            }
            getPoints() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 5;
                const t = [];
                for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                return t
            }
            getSpacedPoints() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 5;
                const t = [];
                for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
                return t
            }
            getLength() {
                const e = this.getLengths();
                return e[e.length - 1]
            }
            getLengths() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.arcLengthDivisions;
                if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                this.needsUpdate = !1;
                const t = [];
                let n, r = this.getPoint(0),
                    i = 0;
                t.push(0);
                for (let o = 1; o <= e; o++) n = this.getPoint(o / e), i += n.distanceTo(r), t.push(i), r = n;
                return this.cacheArcLengths = t, t
            }
            updateArcLengths() {
                this.needsUpdate = !0, this.getLengths()
            }
            getUtoTmapping(e, t) {
                const n = this.getLengths();
                let r = 0;
                const i = n.length;
                let o;
                o = t || e * n[i - 1];
                let a, s = 0,
                    l = i - 1;
                for (; s <= l;)
                    if (r = Math.floor(s + (l - s) / 2), a = n[r] - o, a < 0) s = r + 1;
                    else {
                        if (!(a > 0)) {
                            l = r;
                            break
                        }
                        l = r - 1
                    }
                if (r = l, n[r] === o) return r / (i - 1);
                const c = n[r];
                return (r + (o - c) / (n[r + 1] - c)) / (i - 1)
            }
            getTangent(e, t) {
                const n = 1e-4;
                let r = e - n,
                    i = e + n;
                r < 0 && (r = 0), i > 1 && (i = 1);
                const o = this.getPoint(r),
                    a = this.getPoint(i),
                    s = t || (o.isVector2 ? new Yc : new Pu);
                return s.copy(a).sub(o).normalize(), s
            }
            getTangentAt(e, t) {
                const n = this.getUtoTmapping(e);
                return this.getTangent(n, t)
            }
            computeFrenetFrames(e, t) {
                const n = new Pu,
                    r = [],
                    i = [],
                    o = [],
                    a = new Pu,
                    s = new od;
                for (let h = 0; h <= e; h++) {
                    const t = h / e;
                    r[h] = this.getTangentAt(t, new Pu)
                }
                i[0] = new Pu, o[0] = new Pu;
                let l = Number.MAX_VALUE;
                const c = Math.abs(r[0].x),
                    u = Math.abs(r[0].y),
                    d = Math.abs(r[0].z);
                c <= l && (l = c, n.set(1, 0, 0)), u <= l && (l = u, n.set(0, 1, 0)), d <= l && n.set(0, 0, 1), a.crossVectors(r[0], n).normalize(), i[0].crossVectors(r[0], a), o[0].crossVectors(r[0], i[0]);
                for (let h = 1; h <= e; h++) {
                    if (i[h] = i[h - 1].clone(), o[h] = o[h - 1].clone(), a.crossVectors(r[h - 1], r[h]), a.length() > Number.EPSILON) {
                        a.normalize();
                        const e = Math.acos(jc(r[h - 1].dot(r[h]), -1, 1));
                        i[h].applyMatrix4(s.makeRotationAxis(a, e))
                    }
                    o[h].crossVectors(r[h], i[h])
                }
                if (!0 === t) {
                    let t = Math.acos(jc(i[0].dot(i[e]), -1, 1));
                    t /= e, r[0].dot(a.crossVectors(i[0], i[e])) > 0 && (t = -t);
                    for (let n = 1; n <= e; n++) i[n].applyMatrix4(s.makeRotationAxis(r[n], t * n)), o[n].crossVectors(r[n], i[n])
                }
                return {
                    tangents: r,
                    normals: i,
                    binormals: o
                }
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.arcLengthDivisions = e.arcLengthDivisions, this
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.6,
                        type: "Curve",
                        generator: "Curve.toJSON"
                    }
                };
                return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
            }
            fromJSON(e) {
                return this.arcLengthDivisions = e.arcLengthDivisions, this
            }
        }
        class Bv extends Ov {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
                    i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
                    o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 2 * Math.PI,
                    a = arguments.length > 6 && void 0 !== arguments[6] && arguments[6],
                    s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0;
                super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = r, this.aStartAngle = i, this.aEndAngle = o, this.aClockwise = a, this.aRotation = s
            }
            getPoint(e, t) {
                const n = t || new Yc,
                    r = 2 * Math.PI;
                let i = this.aEndAngle - this.aStartAngle;
                const o = Math.abs(i) < Number.EPSILON;
                for (; i < 0;) i += r;
                for (; i > r;) i -= r;
                i < Number.EPSILON && (i = o ? 0 : r), !0 !== this.aClockwise || o || (i === r ? i = -r : i -= r);
                const a = this.aStartAngle + e * i;
                let s = this.aX + this.xRadius * Math.cos(a),
                    l = this.aY + this.yRadius * Math.sin(a);
                if (0 !== this.aRotation) {
                    const e = Math.cos(this.aRotation),
                        t = Math.sin(this.aRotation),
                        n = s - this.aX,
                        r = l - this.aY;
                    s = n * e - r * t + this.aX, l = n * t + r * e + this.aY
                }
                return n.set(s, l)
            }
            copy(e) {
                return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
            }
            toJSON() {
                const e = super.toJSON();
                return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
            }
            fromJSON(e) {
                return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
            }
        }
        class Lv extends Bv {
            constructor(e, t, n, r, i, o) {
                super(e, t, n, n, r, i, o), this.isArcCurve = !0, this.type = "ArcCurve"
            }
        }

        function Dv() {
            let e = 0,
                t = 0,
                n = 0,
                r = 0;

            function i(i, o, a, s) {
                e = i, t = a, n = -3 * i + 3 * o - 2 * a - s, r = 2 * i - 2 * o + a + s
            }
            return {
                initCatmullRom: function(e, t, n, r, o) {
                    i(t, n, o * (n - e), o * (r - t))
                },
                initNonuniformCatmullRom: function(e, t, n, r, o, a, s) {
                    let l = (t - e) / o - (n - e) / (o + a) + (n - t) / a,
                        c = (n - t) / a - (r - t) / (a + s) + (r - n) / s;
                    l *= a, c *= a, i(t, n, l, c)
                },
                calc: function(i) {
                    const o = i * i;
                    return e + t * i + n * o + r * (o * i)
                }
            }
        }
        const Nv = new Pu,
            kv = new Dv,
            Fv = new Dv,
            Uv = new Dv;
        class zv extends Ov {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                    t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "centripetal",
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5;
                super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = r
            }
            getPoint(e) {
                const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Pu,
                    n = this.points,
                    r = n.length,
                    i = (r - (this.closed ? 0 : 1)) * e;
                let o, a, s = Math.floor(i),
                    l = i - s;
                this.closed ? s += s > 0 ? 0 : (Math.floor(Math.abs(s) / r) + 1) * r : 0 === l && s === r - 1 && (s = r - 2, l = 1), this.closed || s > 0 ? o = n[(s - 1) % r] : (Nv.subVectors(n[0], n[1]).add(n[0]), o = Nv);
                const c = n[s % r],
                    u = n[(s + 1) % r];
                if (this.closed || s + 2 < r ? a = n[(s + 2) % r] : (Nv.subVectors(n[r - 1], n[r - 2]).add(n[r - 1]), a = Nv), "centripetal" === this.curveType || "chordal" === this.curveType) {
                    const e = "chordal" === this.curveType ? .5 : .25;
                    let t = Math.pow(o.distanceToSquared(c), e),
                        n = Math.pow(c.distanceToSquared(u), e),
                        r = Math.pow(u.distanceToSquared(a), e);
                    n < 1e-4 && (n = 1), t < 1e-4 && (t = n), r < 1e-4 && (r = n), kv.initNonuniformCatmullRom(o.x, c.x, u.x, a.x, t, n, r), Fv.initNonuniformCatmullRom(o.y, c.y, u.y, a.y, t, n, r), Uv.initNonuniformCatmullRom(o.z, c.z, u.z, a.z, t, n, r)
                } else "catmullrom" === this.curveType && (kv.initCatmullRom(o.x, c.x, u.x, a.x, this.tension), Fv.initCatmullRom(o.y, c.y, u.y, a.y, this.tension), Uv.initCatmullRom(o.z, c.z, u.z, a.z, this.tension));
                return t.set(kv.calc(l), Fv.calc(l), Uv.calc(l)), t
            }
            copy(e) {
                super.copy(e), this.points = [];
                for (let t = 0, n = e.points.length; t < n; t++) {
                    const n = e.points[t];
                    this.points.push(n.clone())
                }
                return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
            }
            toJSON() {
                const e = super.toJSON();
                e.points = [];
                for (let t = 0, n = this.points.length; t < n; t++) {
                    const n = this.points[t];
                    e.points.push(n.toArray())
                }
                return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
            }
            fromJSON(e) {
                super.fromJSON(e), this.points = [];
                for (let t = 0, n = e.points.length; t < n; t++) {
                    const n = e.points[t];
                    this.points.push((new Pu).fromArray(n))
                }
                return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
            }
        }

        function Hv(e, t, n, r, i) {
            const o = .5 * (r - t),
                a = .5 * (i - n),
                s = e * e;
            return (2 * n - 2 * r + o + a) * (e * s) + (-3 * n + 3 * r - 2 * o - a) * s + o * e + n
        }

        function jv(e, t, n, r) {
            return function(e, t) {
                const n = 1 - e;
                return n * n * t
            }(e, t) + function(e, t) {
                return 2 * (1 - e) * e * t
            }(e, n) + function(e, t) {
                return e * e * t
            }(e, r)
        }

        function Gv(e, t, n, r, i) {
            return function(e, t) {
                const n = 1 - e;
                return n * n * n * t
            }(e, t) + function(e, t) {
                const n = 1 - e;
                return 3 * n * n * e * t
            }(e, n) + function(e, t) {
                return 3 * (1 - e) * e * e * t
            }(e, r) + function(e, t) {
                return e * e * e * t
            }(e, i)
        }
        class Vv extends Ov {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Yc,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Yc,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Yc,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : new Yc;
                super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r
            }
            getPoint(e) {
                const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Yc,
                    n = this.v0,
                    r = this.v1,
                    i = this.v2,
                    o = this.v3;
                return t.set(Gv(e, n.x, r.x, i.x, o.x), Gv(e, n.y, r.y, i.y, o.y)), t
            }
            copy(e) {
                return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
            }
            fromJSON(e) {
                return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
            }
        }
        class qv extends Ov {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Pu,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Pu,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Pu,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : new Pu;
                super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r
            }
            getPoint(e) {
                const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Pu,
                    n = this.v0,
                    r = this.v1,
                    i = this.v2,
                    o = this.v3;
                return t.set(Gv(e, n.x, r.x, i.x, o.x), Gv(e, n.y, r.y, i.y, o.y), Gv(e, n.z, r.z, i.z, o.z)), t
            }
            copy(e) {
                return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
            }
            fromJSON(e) {
                return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
            }
        }
        class Wv extends Ov {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Yc,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Yc;
                super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t
            }
            getPoint(e) {
                const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Yc;
                return 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)), t
            }
            getPointAt(e, t) {
                return this.getPoint(e, t)
            }
            getTangent(e) {
                return (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Yc).subVectors(this.v2, this.v1).normalize()
            }
            getTangentAt(e, t) {
                return this.getTangent(e, t)
            }
            copy(e) {
                return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }
            fromJSON(e) {
                return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }
        }
        class Xv extends Ov {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Pu,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Pu;
                super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t
            }
            getPoint(e) {
                const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Pu;
                return 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)), t
            }
            getPointAt(e, t) {
                return this.getPoint(e, t)
            }
            getTangent(e) {
                return (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Pu).subVectors(this.v2, this.v1).normalize()
            }
            getTangentAt(e, t) {
                return this.getTangent(e, t)
            }
            copy(e) {
                return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }
            fromJSON(e) {
                return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }
        }
        class Kv extends Ov {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Yc,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Yc,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Yc;
                super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n
            }
            getPoint(e) {
                const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Yc,
                    n = this.v0,
                    r = this.v1,
                    i = this.v2;
                return t.set(jv(e, n.x, r.x, i.x), jv(e, n.y, r.y, i.y)), t
            }
            copy(e) {
                return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }
            fromJSON(e) {
                return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }
        }
        class Jv extends Ov {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Pu,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Pu,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Pu;
                super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n
            }
            getPoint(e) {
                const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Pu,
                    n = this.v0,
                    r = this.v1,
                    i = this.v2;
                return t.set(jv(e, n.x, r.x, i.x), jv(e, n.y, r.y, i.y), jv(e, n.z, r.z, i.z)), t
            }
            copy(e) {
                return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }
            toJSON() {
                const e = super.toJSON();
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }
            fromJSON(e) {
                return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }
        }
        class Yv extends Ov {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e
            }
            getPoint(e) {
                const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Yc,
                    n = this.points,
                    r = (n.length - 1) * e,
                    i = Math.floor(r),
                    o = r - i,
                    a = n[0 === i ? i : i - 1],
                    s = n[i],
                    l = n[i > n.length - 2 ? n.length - 1 : i + 1],
                    c = n[i > n.length - 3 ? n.length - 1 : i + 2];
                return t.set(Hv(o, a.x, s.x, l.x, c.x), Hv(o, a.y, s.y, l.y, c.y)), t
            }
            copy(e) {
                super.copy(e), this.points = [];
                for (let t = 0, n = e.points.length; t < n; t++) {
                    const n = e.points[t];
                    this.points.push(n.clone())
                }
                return this
            }
            toJSON() {
                const e = super.toJSON();
                e.points = [];
                for (let t = 0, n = this.points.length; t < n; t++) {
                    const n = this.points[t];
                    e.points.push(n.toArray())
                }
                return e
            }
            fromJSON(e) {
                super.fromJSON(e), this.points = [];
                for (let t = 0, n = e.points.length; t < n; t++) {
                    const n = e.points[t];
                    this.points.push((new Yc).fromArray(n))
                }
                return this
            }
        }
        var Qv = Object.freeze({
            __proto__: null,
            ArcCurve: Lv,
            CatmullRomCurve3: zv,
            CubicBezierCurve: Vv,
            CubicBezierCurve3: qv,
            EllipseCurve: Bv,
            LineCurve: Wv,
            LineCurve3: Xv,
            QuadraticBezierCurve: Kv,
            QuadraticBezierCurve3: Jv,
            SplineCurve: Yv
        });
        class Zv extends Ov {
            constructor() {
                super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
            }
            add(e) {
                this.curves.push(e)
            }
            closePath() {
                const e = this.curves[0].getPoint(0),
                    t = this.curves[this.curves.length - 1].getPoint(1);
                if (!e.equals(t)) {
                    const n = !0 === e.isVector2 ? "LineCurve" : "LineCurve3";
                    this.curves.push(new Qv[n](t, e))
                }
                return this
            }
            getPoint(e, t) {
                const n = e * this.getLength(),
                    r = this.getCurveLengths();
                let i = 0;
                for (; i < r.length;) {
                    if (r[i] >= n) {
                        const e = r[i] - n,
                            o = this.curves[i],
                            a = o.getLength(),
                            s = 0 === a ? 0 : 1 - e / a;
                        return o.getPointAt(s, t)
                    }
                    i++
                }
                return null
            }
            getLength() {
                const e = this.getCurveLengths();
                return e[e.length - 1]
            }
            updateArcLengths() {
                this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
            }
            getCurveLengths() {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                const e = [];
                let t = 0;
                for (let n = 0, r = this.curves.length; n < r; n++) t += this.curves[n].getLength(), e.push(t);
                return this.cacheLengths = e, e
            }
            getSpacedPoints() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 40;
                const t = [];
                for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                return this.autoClose && t.push(t[0]), t
            }
            getPoints() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 12;
                const t = [];
                let n;
                for (let r = 0, i = this.curves; r < i.length; r++) {
                    const o = i[r],
                        a = o.isEllipseCurve ? 2 * e : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e,
                        s = o.getPoints(a);
                    for (let e = 0; e < s.length; e++) {
                        const r = s[e];
                        n && n.equals(r) || (t.push(r), n = r)
                    }
                }
                return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t
            }
            copy(e) {
                super.copy(e), this.curves = [];
                for (let t = 0, n = e.curves.length; t < n; t++) {
                    const n = e.curves[t];
                    this.curves.push(n.clone())
                }
                return this.autoClose = e.autoClose, this
            }
            toJSON() {
                const e = super.toJSON();
                e.autoClose = this.autoClose, e.curves = [];
                for (let t = 0, n = this.curves.length; t < n; t++) {
                    const n = this.curves[t];
                    e.curves.push(n.toJSON())
                }
                return e
            }
            fromJSON(e) {
                super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
                for (let t = 0, n = e.curves.length; t < n; t++) {
                    const n = e.curves[t];
                    this.curves.push((new Qv[n.type]).fromJSON(n))
                }
                return this
            }
        }
        class $v extends Zv {
            constructor(e) {
                super(), this.type = "Path", this.currentPoint = new Yc, e && this.setFromPoints(e)
            }
            setFromPoints(e) {
                this.moveTo(e[0].x, e[0].y);
                for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
                return this
            }
            moveTo(e, t) {
                return this.currentPoint.set(e, t), this
            }
            lineTo(e, t) {
                const n = new Wv(this.currentPoint.clone(), new Yc(e, t));
                return this.curves.push(n), this.currentPoint.set(e, t), this
            }
            quadraticCurveTo(e, t, n, r) {
                const i = new Kv(this.currentPoint.clone(), new Yc(e, t), new Yc(n, r));
                return this.curves.push(i), this.currentPoint.set(n, r), this
            }
            bezierCurveTo(e, t, n, r, i, o) {
                const a = new Vv(this.currentPoint.clone(), new Yc(e, t), new Yc(n, r), new Yc(i, o));
                return this.curves.push(a), this.currentPoint.set(i, o), this
            }
            splineThru(e) {
                const t = [this.currentPoint.clone()].concat(e),
                    n = new Yv(t);
                return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this
            }
            arc(e, t, n, r, i, o) {
                const a = this.currentPoint.x,
                    s = this.currentPoint.y;
                return this.absarc(e + a, t + s, n, r, i, o), this
            }
            absarc(e, t, n, r, i, o) {
                return this.absellipse(e, t, n, n, r, i, o), this
            }
            ellipse(e, t, n, r, i, o, a, s) {
                const l = this.currentPoint.x,
                    c = this.currentPoint.y;
                return this.absellipse(e + l, t + c, n, r, i, o, a, s), this
            }
            absellipse(e, t, n, r, i, o, a, s) {
                const l = new Bv(e, t, n, r, i, o, a, s);
                if (this.curves.length > 0) {
                    const e = l.getPoint(0);
                    e.equals(this.currentPoint) || this.lineTo(e.x, e.y)
                }
                this.curves.push(l);
                const c = l.getPoint(1);
                return this.currentPoint.copy(c), this
            }
            copy(e) {
                return super.copy(e), this.currentPoint.copy(e.currentPoint), this
            }
            toJSON() {
                const e = super.toJSON();
                return e.currentPoint = this.currentPoint.toArray(), e
            }
            fromJSON(e) {
                return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
            }
        }
        class ey extends Mh {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [new Yc(0, -.5), new Yc(.5, 0), new Yc(0, .5)],
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 12,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 2 * Math.PI;
                super(), this.type = "LatheGeometry", this.parameters = {
                    points: e,
                    segments: t,
                    phiStart: n,
                    phiLength: r
                }, t = Math.floor(t), r = jc(r, 0, 2 * Math.PI);
                const i = [],
                    o = [],
                    a = [],
                    s = [],
                    l = [],
                    c = 1 / t,
                    u = new Pu,
                    d = new Yc,
                    h = new Pu,
                    p = new Pu,
                    f = new Pu;
                let m = 0,
                    g = 0;
                for (let v = 0; v <= e.length - 1; v++) switch (v) {
                    case 0:
                        m = e[v + 1].x - e[v].x, g = e[v + 1].y - e[v].y, h.x = 1 * g, h.y = -m, h.z = 0 * g, f.copy(h), h.normalize(), s.push(h.x, h.y, h.z);
                        break;
                    case e.length - 1:
                        s.push(f.x, f.y, f.z);
                        break;
                    default:
                        m = e[v + 1].x - e[v].x, g = e[v + 1].y - e[v].y, h.x = 1 * g, h.y = -m, h.z = 0 * g, p.copy(h), h.x += f.x, h.y += f.y, h.z += f.z, h.normalize(), s.push(h.x, h.y, h.z), f.copy(p)
                }
                for (let v = 0; v <= t; v++) {
                    const i = n + v * c * r,
                        h = Math.sin(i),
                        p = Math.cos(i);
                    for (let n = 0; n <= e.length - 1; n++) {
                        u.x = e[n].x * h, u.y = e[n].y, u.z = e[n].x * p, o.push(u.x, u.y, u.z), d.x = v / t, d.y = n / (e.length - 1), a.push(d.x, d.y);
                        const r = s[3 * n + 0] * h,
                            i = s[3 * n + 1],
                            c = s[3 * n + 0] * p;
                        l.push(r, i, c)
                    }
                }
                for (let v = 0; v < t; v++)
                    for (let t = 0; t < e.length - 1; t++) {
                        const n = t + v * e.length,
                            r = n,
                            o = n + e.length,
                            a = n + e.length + 1,
                            s = n + 1;
                        i.push(r, o, s), i.push(a, s, o)
                    }
                this.setIndex(i), this.setAttribute("position", new ph(o, 3)), this.setAttribute("uv", new ph(a, 2)), this.setAttribute("normal", new ph(l, 3))
            }
            copy(e) {
                return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
            }
            static fromJSON(e) {
                return new ey(e.points, e.segments, e.phiStart, e.phiLength)
            }
        }
        class ty extends ey {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 4,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 8;
                const i = new $v;
                i.absarc(0, -t / 2, e, 1.5 * Math.PI, 0), i.absarc(0, t / 2, e, 0, .5 * Math.PI), super(i.getPoints(n), r), this.type = "CapsuleGeometry", this.parameters = {
                    radius: e,
                    length: t,
                    capSegments: n,
                    radialSegments: r
                }
            }
            static fromJSON(e) {
                return new ty(e.radius, e.length, e.capSegments, e.radialSegments)
            }
        }
        class ny extends Mh {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 32,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 2 * Math.PI;
                super(), this.type = "CircleGeometry", this.parameters = {
                    radius: e,
                    segments: t,
                    thetaStart: n,
                    thetaLength: r
                }, t = Math.max(3, t);
                const i = [],
                    o = [],
                    a = [],
                    s = [],
                    l = new Pu,
                    c = new Yc;
                o.push(0, 0, 0), a.push(0, 0, 1), s.push(.5, .5);
                for (let u = 0, d = 3; u <= t; u++, d += 3) {
                    const i = n + u / t * r;
                    l.x = e * Math.cos(i), l.y = e * Math.sin(i), o.push(l.x, l.y, l.z), a.push(0, 0, 1), c.x = (o[d] / e + 1) / 2, c.y = (o[d + 1] / e + 1) / 2, s.push(c.x, c.y)
                }
                for (let u = 1; u <= t; u++) i.push(u, u + 1, 0);
                this.setIndex(i), this.setAttribute("position", new ph(o, 3)), this.setAttribute("normal", new ph(a, 3)), this.setAttribute("uv", new ph(s, 2))
            }
            copy(e) {
                return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
            }
            static fromJSON(e) {
                return new ny(e.radius, e.segments, e.thetaStart, e.thetaLength)
            }
        }
        class ry extends Mh {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 32,
                    i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1,
                    o = arguments.length > 5 && void 0 !== arguments[5] && arguments[5],
                    a = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0,
                    s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 2 * Math.PI;
                super(), this.type = "CylinderGeometry", this.parameters = {
                    radiusTop: e,
                    radiusBottom: t,
                    height: n,
                    radialSegments: r,
                    heightSegments: i,
                    openEnded: o,
                    thetaStart: a,
                    thetaLength: s
                };
                const l = this;
                r = Math.floor(r), i = Math.floor(i);
                const c = [],
                    u = [],
                    d = [],
                    h = [];
                let p = 0;
                const f = [],
                    m = n / 2;
                let g = 0;

                function v(n) {
                    const i = p,
                        o = new Yc,
                        f = new Pu;
                    let v = 0;
                    const y = !0 === n ? e : t,
                        b = !0 === n ? 1 : -1;
                    for (let e = 1; e <= r; e++) u.push(0, m * b, 0), d.push(0, b, 0), h.push(.5, .5), p++;
                    const x = p;
                    for (let e = 0; e <= r; e++) {
                        const t = e / r * s + a,
                            n = Math.cos(t),
                            i = Math.sin(t);
                        f.x = y * i, f.y = m * b, f.z = y * n, u.push(f.x, f.y, f.z), d.push(0, b, 0), o.x = .5 * n + .5, o.y = .5 * i * b + .5, h.push(o.x, o.y), p++
                    }
                    for (let e = 0; e < r; e++) {
                        const t = i + e,
                            r = x + e;
                        !0 === n ? c.push(r, r + 1, t) : c.push(r + 1, r, t), v += 3
                    }
                    l.addGroup(g, v, !0 === n ? 1 : 2), g += v
                }! function() {
                    const o = new Pu,
                        v = new Pu;
                    let y = 0;
                    const b = (t - e) / n;
                    for (let l = 0; l <= i; l++) {
                        const c = [],
                            g = l / i,
                            y = g * (t - e) + e;
                        for (let e = 0; e <= r; e++) {
                            const t = e / r,
                                i = t * s + a,
                                l = Math.sin(i),
                                f = Math.cos(i);
                            v.x = y * l, v.y = -g * n + m, v.z = y * f, u.push(v.x, v.y, v.z), o.set(l, b, f).normalize(), d.push(o.x, o.y, o.z), h.push(t, 1 - g), c.push(p++)
                        }
                        f.push(c)
                    }
                    for (let e = 0; e < r; e++)
                        for (let t = 0; t < i; t++) {
                            const n = f[t][e],
                                r = f[t + 1][e],
                                i = f[t + 1][e + 1],
                                o = f[t][e + 1];
                            c.push(n, r, o), c.push(r, i, o), y += 6
                        }
                    l.addGroup(g, y, 0), g += y
                }(), !1 === o && (e > 0 && v(!0), t > 0 && v(!1)), this.setIndex(c), this.setAttribute("position", new ph(u, 3)), this.setAttribute("normal", new ph(d, 3)), this.setAttribute("uv", new ph(h, 2))
            }
            copy(e) {
                return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
            }
            static fromJSON(e) {
                return new ry(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
            }
        }
        class iy extends ry {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 32,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
                    i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
                    o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0,
                    a = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 2 * Math.PI;
                super(0, e, t, n, r, i, o, a), this.type = "ConeGeometry", this.parameters = {
                    radius: e,
                    height: t,
                    radialSegments: n,
                    heightSegments: r,
                    openEnded: i,
                    thetaStart: o,
                    thetaLength: a
                }
            }
            static fromJSON(e) {
                return new iy(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
            }
        }
        class oy extends Mh {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
                super(), this.type = "PolyhedronGeometry", this.parameters = {
                    vertices: e,
                    indices: t,
                    radius: n,
                    detail: r
                };
                const i = [],
                    o = [];

                function a(e, t, n, r) {
                    const i = r + 1,
                        o = [];
                    for (let a = 0; a <= i; a++) {
                        o[a] = [];
                        const r = e.clone().lerp(n, a / i),
                            s = t.clone().lerp(n, a / i),
                            l = i - a;
                        for (let e = 0; e <= l; e++) o[a][e] = 0 === e && a === i ? r : r.clone().lerp(s, e / l)
                    }
                    for (let a = 0; a < i; a++)
                        for (let e = 0; e < 2 * (i - a) - 1; e++) {
                            const t = Math.floor(e / 2);
                            e % 2 === 0 ? (s(o[a][t + 1]), s(o[a + 1][t]), s(o[a][t])) : (s(o[a][t + 1]), s(o[a + 1][t + 1]), s(o[a + 1][t]))
                        }
                }

                function s(e) {
                    i.push(e.x, e.y, e.z)
                }

                function l(t, n) {
                    const r = 3 * t;
                    n.x = e[r + 0], n.y = e[r + 1], n.z = e[r + 2]
                }

                function c(e, t, n, r) {
                    r < 0 && 1 === e.x && (o[t] = e.x - 1), 0 === n.x && 0 === n.z && (o[t] = r / 2 / Math.PI + .5)
                }

                function u(e) {
                    return Math.atan2(e.z, -e.x)
                }! function(e) {
                    const n = new Pu,
                        r = new Pu,
                        i = new Pu;
                    for (let o = 0; o < t.length; o += 3) l(t[o + 0], n), l(t[o + 1], r), l(t[o + 2], i), a(n, r, i, e)
                }(r),
                function(e) {
                    const t = new Pu;
                    for (let n = 0; n < i.length; n += 3) t.x = i[n + 0], t.y = i[n + 1], t.z = i[n + 2], t.normalize().multiplyScalar(e), i[n + 0] = t.x, i[n + 1] = t.y, i[n + 2] = t.z
                }(n),
                function() {
                    const e = new Pu;
                    for (let n = 0; n < i.length; n += 3) {
                        e.x = i[n + 0], e.y = i[n + 1], e.z = i[n + 2];
                        const r = u(e) / 2 / Math.PI + .5,
                            a = (t = e, Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5);
                        o.push(r, 1 - a)
                    }
                    var t;
                    (function() {
                        const e = new Pu,
                            t = new Pu,
                            n = new Pu,
                            r = new Pu,
                            a = new Yc,
                            s = new Yc,
                            l = new Yc;
                        for (let d = 0, h = 0; d < i.length; d += 9, h += 6) {
                            e.set(i[d + 0], i[d + 1], i[d + 2]), t.set(i[d + 3], i[d + 4], i[d + 5]), n.set(i[d + 6], i[d + 7], i[d + 8]), a.set(o[h + 0], o[h + 1]), s.set(o[h + 2], o[h + 3]), l.set(o[h + 4], o[h + 5]), r.copy(e).add(t).add(n).divideScalar(3);
                            const p = u(r);
                            c(a, h + 0, e, p), c(s, h + 2, t, p), c(l, h + 4, n, p)
                        }
                    })(),
                    function() {
                        for (let e = 0; e < o.length; e += 6) {
                            const t = o[e + 0],
                                n = o[e + 2],
                                r = o[e + 4],
                                i = Math.max(t, n, r),
                                a = Math.min(t, n, r);
                            i > .9 && a < .1 && (t < .2 && (o[e + 0] += 1), n < .2 && (o[e + 2] += 1), r < .2 && (o[e + 4] += 1))
                        }
                    }()
                }(), this.setAttribute("position", new ph(i, 3)), this.setAttribute("normal", new ph(i.slice(), 3)), this.setAttribute("uv", new ph(o, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals()
            }
            copy(e) {
                return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
            }
            static fromJSON(e) {
                return new oy(e.vertices, e.indices, e.radius, e.details)
            }
        }
        class ay extends oy {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                const n = (1 + Math.sqrt(5)) / 2,
                    r = 1 / n;
                super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }
            static fromJSON(e) {
                return new ay(e.radius, e.detail)
            }
        }
        const sy = new Pu,
            ly = new Pu,
            cy = new Pu,
            uy = new Hd;
        class dy extends Mh {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                if (super(), this.type = "EdgesGeometry", this.parameters = {
                        geometry: e,
                        thresholdAngle: t
                    }, null !== e) {
                    const n = 4,
                        r = Math.pow(10, n),
                        i = Math.cos(Uc * t),
                        o = e.getIndex(),
                        a = e.getAttribute("position"),
                        s = o ? o.count : a.count,
                        l = [0, 0, 0],
                        c = ["a", "b", "c"],
                        u = new Array(3),
                        d = {},
                        h = [];
                    for (let e = 0; e < s; e += 3) {
                        o ? (l[0] = o.getX(e), l[1] = o.getX(e + 1), l[2] = o.getX(e + 2)) : (l[0] = e, l[1] = e + 1, l[2] = e + 2);
                        const {
                            a: t,
                            b: n,
                            c: s
                        } = uy;
                        if (t.fromBufferAttribute(a, l[0]), n.fromBufferAttribute(a, l[1]), s.fromBufferAttribute(a, l[2]), uy.getNormal(cy), u[0] = "".concat(Math.round(t.x * r), ",").concat(Math.round(t.y * r), ",").concat(Math.round(t.z * r)), u[1] = "".concat(Math.round(n.x * r), ",").concat(Math.round(n.y * r), ",").concat(Math.round(n.z * r)), u[2] = "".concat(Math.round(s.x * r), ",").concat(Math.round(s.y * r), ",").concat(Math.round(s.z * r)), u[0] !== u[1] && u[1] !== u[2] && u[2] !== u[0])
                            for (let e = 0; e < 3; e++) {
                                const t = (e + 1) % 3,
                                    n = u[e],
                                    r = u[t],
                                    o = uy[c[e]],
                                    a = uy[c[t]],
                                    s = "".concat(n, "_").concat(r),
                                    p = "".concat(r, "_").concat(n);
                                p in d && d[p] ? (cy.dot(d[p].normal) <= i && (h.push(o.x, o.y, o.z), h.push(a.x, a.y, a.z)), d[p] = null) : s in d || (d[s] = {
                                    index0: l[e],
                                    index1: l[t],
                                    normal: cy.clone()
                                })
                            }
                    }
                    for (const e in d)
                        if (d[e]) {
                            const {
                                index0: t,
                                index1: n
                            } = d[e];
                            sy.fromBufferAttribute(a, t), ly.fromBufferAttribute(a, n), h.push(sy.x, sy.y, sy.z), h.push(ly.x, ly.y, ly.z)
                        }
                    this.setAttribute("position", new ph(h, 3))
                }
            }
            copy(e) {
                return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
            }
        }
        class hy extends $v {
            constructor(e) {
                super(e), this.uuid = Hc(), this.type = "Shape", this.holes = []
            }
            getPointsHoles(e) {
                const t = [];
                for (let n = 0, r = this.holes.length; n < r; n++) t[n] = this.holes[n].getPoints(e);
                return t
            }
            extractPoints(e) {
                return {
                    shape: this.getPoints(e),
                    holes: this.getPointsHoles(e)
                }
            }
            copy(e) {
                super.copy(e), this.holes = [];
                for (let t = 0, n = e.holes.length; t < n; t++) {
                    const n = e.holes[t];
                    this.holes.push(n.clone())
                }
                return this
            }
            toJSON() {
                const e = super.toJSON();
                e.uuid = this.uuid, e.holes = [];
                for (let t = 0, n = this.holes.length; t < n; t++) {
                    const n = this.holes[t];
                    e.holes.push(n.toJSON())
                }
                return e
            }
            fromJSON(e) {
                super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
                for (let t = 0, n = e.holes.length; t < n; t++) {
                    const n = e.holes[t];
                    this.holes.push((new $v).fromJSON(n))
                }
                return this
            }
        }
        const py = function(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2;
            const r = t && t.length,
                i = r ? t[0] * n : e.length;
            let o = fy(e, 0, i, n, !0);
            const a = [];
            if (!o || o.next === o.prev) return a;
            let s, l, c, u, d, h, p;
            if (r && (o = function(e, t, n, r) {
                    const i = [];
                    let o, a, s, l, c;
                    for (o = 0, a = t.length; o < a; o++) s = t[o] * r, l = o < a - 1 ? t[o + 1] * r : e.length, c = fy(e, s, l, r, !1), c === c.next && (c.steiner = !0), i.push(Sy(c));
                    for (i.sort(_y), o = 0; o < i.length; o++) n = My(i[o], n);
                    return n
                }(e, t, o, n)), e.length > 80 * n) {
                s = c = e[0], l = u = e[1];
                for (let t = n; t < i; t += n) d = e[t], h = e[t + 1], d < s && (s = d), h < l && (l = h), d > c && (c = d), h > u && (u = h);
                p = Math.max(c - s, u - l), p = 0 !== p ? 32767 / p : 0
            }
            return gy(o, a, n, s, l, p, 0), a
        };

        function fy(e, t, n, r, i) {
            let o, a;
            if (i === function(e, t, n, r) {
                    let i = 0;
                    for (let o = t, a = n - r; o < n; o += r) i += (e[a] - e[o]) * (e[o + 1] + e[a + 1]), a = o;
                    return i
                }(e, t, n, r) > 0)
                for (o = t; o < n; o += r) a = Dy(o, e[o], e[o + 1], a);
            else
                for (o = n - r; o >= t; o -= r) a = Dy(o, e[o], e[o + 1], a);
            return a && Py(a, a.next) && (Ny(a), a = a.next), a
        }

        function my(e, t) {
            if (!e) return e;
            t || (t = e);
            let n, r = e;
            do {
                if (n = !1, r.steiner || !Py(r, r.next) && 0 !== Ty(r.prev, r, r.next)) r = r.next;
                else {
                    if (Ny(r), r = t = r.prev, r === r.next) break;
                    n = !0
                }
            } while (n || r !== t);
            return t
        }

        function gy(e, t, n, r, i, o, a) {
            if (!e) return;
            !a && o && function(e, t, n, r) {
                let i = e;
                do {
                    0 === i.z && (i.z = Ay(i.x, i.y, t, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next
                } while (i !== e);
                i.prevZ.nextZ = null, i.prevZ = null,
                    function(e) {
                        let t, n, r, i, o, a, s, l, c = 1;
                        do {
                            for (n = e, e = null, o = null, a = 0; n;) {
                                for (a++, r = n, s = 0, t = 0; t < c && (s++, r = r.nextZ, r); t++);
                                for (l = c; s > 0 || l > 0 && r;) 0 !== s && (0 === l || !r || n.z <= r.z) ? (i = n, n = n.nextZ, s--) : (i = r, r = r.nextZ, l--), o ? o.nextZ = i : e = i, i.prevZ = o, o = i;
                                n = r
                            }
                            o.nextZ = null, c *= 2
                        } while (a > 1)
                    }(i)
            }(e, r, i, o);
            let s, l, c = e;
            for (; e.prev !== e.next;)
                if (s = e.prev, l = e.next, o ? yy(e, r, i, o) : vy(e)) t.push(s.i / n | 0), t.push(e.i / n | 0), t.push(l.i / n | 0), Ny(e), e = l.next, c = l.next;
                else if ((e = l) === c) {
                a ? 1 === a ? gy(e = by(my(e), t, n), t, n, r, i, o, 2) : 2 === a && xy(e, t, n, r, i, o) : gy(my(e), t, n, r, i, o, 1);
                break
            }
        }

        function vy(e) {
            const t = e.prev,
                n = e,
                r = e.next;
            if (Ty(t, n, r) >= 0) return !1;
            const i = t.x,
                o = n.x,
                a = r.x,
                s = t.y,
                l = n.y,
                c = r.y,
                u = i < o ? i < a ? i : a : o < a ? o : a,
                d = s < l ? s < c ? s : c : l < c ? l : c,
                h = i > o ? i > a ? i : a : o > a ? o : a,
                p = s > l ? s > c ? s : c : l > c ? l : c;
            let f = r.next;
            for (; f !== t;) {
                if (f.x >= u && f.x <= h && f.y >= d && f.y <= p && Ey(i, s, o, l, a, c, f.x, f.y) && Ty(f.prev, f, f.next) >= 0) return !1;
                f = f.next
            }
            return !0
        }

        function yy(e, t, n, r) {
            const i = e.prev,
                o = e,
                a = e.next;
            if (Ty(i, o, a) >= 0) return !1;
            const s = i.x,
                l = o.x,
                c = a.x,
                u = i.y,
                d = o.y,
                h = a.y,
                p = s < l ? s < c ? s : c : l < c ? l : c,
                f = u < d ? u < h ? u : h : d < h ? d : h,
                m = s > l ? s > c ? s : c : l > c ? l : c,
                g = u > d ? u > h ? u : h : d > h ? d : h,
                v = Ay(p, f, t, n, r),
                y = Ay(m, g, t, n, r);
            let b = e.prevZ,
                x = e.nextZ;
            for (; b && b.z >= v && x && x.z <= y;) {
                if (b.x >= p && b.x <= m && b.y >= f && b.y <= g && b !== i && b !== a && Ey(s, u, l, d, c, h, b.x, b.y) && Ty(b.prev, b, b.next) >= 0) return !1;
                if (b = b.prevZ, x.x >= p && x.x <= m && x.y >= f && x.y <= g && x !== i && x !== a && Ey(s, u, l, d, c, h, x.x, x.y) && Ty(x.prev, x, x.next) >= 0) return !1;
                x = x.nextZ
            }
            for (; b && b.z >= v;) {
                if (b.x >= p && b.x <= m && b.y >= f && b.y <= g && b !== i && b !== a && Ey(s, u, l, d, c, h, b.x, b.y) && Ty(b.prev, b, b.next) >= 0) return !1;
                b = b.prevZ
            }
            for (; x && x.z <= y;) {
                if (x.x >= p && x.x <= m && x.y >= f && x.y <= g && x !== i && x !== a && Ey(s, u, l, d, c, h, x.x, x.y) && Ty(x.prev, x, x.next) >= 0) return !1;
                x = x.nextZ
            }
            return !0
        }

        function by(e, t, n) {
            let r = e;
            do {
                const i = r.prev,
                    o = r.next.next;
                !Py(i, o) && Ry(i, r, r.next, o) && By(i, o) && By(o, i) && (t.push(i.i / n | 0), t.push(r.i / n | 0), t.push(o.i / n | 0), Ny(r), Ny(r.next), r = e = o), r = r.next
            } while (r !== e);
            return my(r)
        }

        function xy(e, t, n, r, i, o) {
            let a = e;
            do {
                let e = a.next.next;
                for (; e !== a.prev;) {
                    if (a.i !== e.i && Cy(a, e)) {
                        let s = Ly(a, e);
                        return a = my(a, a.next), s = my(s, s.next), gy(a, t, n, r, i, o, 0), void gy(s, t, n, r, i, o, 0)
                    }
                    e = e.next
                }
                a = a.next
            } while (a !== e)
        }

        function _y(e, t) {
            return e.x - t.x
        }

        function My(e, t) {
            const n = function(e, t) {
                let n, r = t,
                    i = -1 / 0;
                const o = e.x,
                    a = e.y;
                do {
                    if (a <= r.y && a >= r.next.y && r.next.y !== r.y) {
                        const e = r.x + (a - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                        if (e <= o && e > i && (i = e, n = r.x < r.next.x ? r : r.next, e === o)) return n
                    }
                    r = r.next
                } while (r !== t);
                if (!n) return null;
                const s = n,
                    l = n.x,
                    c = n.y;
                let u, d = 1 / 0;
                r = n;
                do {
                    o >= r.x && r.x >= l && o !== r.x && Ey(a < c ? o : i, a, l, c, a < c ? i : o, a, r.x, r.y) && (u = Math.abs(a - r.y) / (o - r.x), By(r, e) && (u < d || u === d && (r.x > n.x || r.x === n.x && wy(n, r))) && (n = r, d = u)), r = r.next
                } while (r !== s);
                return n
            }(e, t);
            if (!n) return t;
            const r = Ly(n, e);
            return my(r, r.next), my(n, n.next)
        }

        function wy(e, t) {
            return Ty(e.prev, e, t.prev) < 0 && Ty(t.next, e, e.next) < 0
        }

        function Ay(e, t, n, r, i) {
            return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * i | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - r) * i | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
        }

        function Sy(e) {
            let t = e,
                n = e;
            do {
                (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next
            } while (t !== e);
            return n
        }

        function Ey(e, t, n, r, i, o, a, s) {
            return (i - a) * (t - s) >= (e - a) * (o - s) && (e - a) * (r - s) >= (n - a) * (t - s) && (n - a) * (o - s) >= (i - a) * (r - s)
        }

        function Cy(e, t) {
            return e.next.i !== t.i && e.prev.i !== t.i && ! function(e, t) {
                let n = e;
                do {
                    if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && Ry(n, n.next, e, t)) return !0;
                    n = n.next
                } while (n !== e);
                return !1
            }(e, t) && (By(e, t) && By(t, e) && function(e, t) {
                let n = e,
                    r = !1;
                const i = (e.x + t.x) / 2,
                    o = (e.y + t.y) / 2;
                do {
                    n.y > o !== n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next
                } while (n !== e);
                return r
            }(e, t) && (Ty(e.prev, e, t.prev) || Ty(e, t.prev, t)) || Py(e, t) && Ty(e.prev, e, e.next) > 0 && Ty(t.prev, t, t.next) > 0)
        }

        function Ty(e, t, n) {
            return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
        }

        function Py(e, t) {
            return e.x === t.x && e.y === t.y
        }

        function Ry(e, t, n, r) {
            const i = Oy(Ty(e, t, n)),
                o = Oy(Ty(e, t, r)),
                a = Oy(Ty(n, r, e)),
                s = Oy(Ty(n, r, t));
            return i !== o && a !== s || (!(0 !== i || !Iy(e, n, t)) || (!(0 !== o || !Iy(e, r, t)) || (!(0 !== a || !Iy(n, e, r)) || !(0 !== s || !Iy(n, t, r)))))
        }

        function Iy(e, t, n) {
            return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
        }

        function Oy(e) {
            return e > 0 ? 1 : e < 0 ? -1 : 0
        }

        function By(e, t) {
            return Ty(e.prev, e, e.next) < 0 ? Ty(e, t, e.next) >= 0 && Ty(e, e.prev, t) >= 0 : Ty(e, t, e.prev) < 0 || Ty(e, e.next, t) < 0
        }

        function Ly(e, t) {
            const n = new ky(e.i, e.x, e.y),
                r = new ky(t.i, t.x, t.y),
                i = e.next,
                o = t.prev;
            return e.next = t, t.prev = e, n.next = i, i.prev = n, r.next = n, n.prev = r, o.next = r, r.prev = o, r
        }

        function Dy(e, t, n, r) {
            const i = new ky(e, t, n);
            return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
        }

        function Ny(e) {
            e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
        }

        function ky(e, t, n) {
            this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
        }
        class Fy {
            static area(e) {
                const t = e.length;
                let n = 0;
                for (let r = t - 1, i = 0; i < t; r = i++) n += e[r].x * e[i].y - e[i].x * e[r].y;
                return .5 * n
            }
            static isClockWise(e) {
                return Fy.area(e) < 0
            }
            static triangulateShape(e, t) {
                const n = [],
                    r = [],
                    i = [];
                Uy(e), zy(n, e);
                let o = e.length;
                t.forEach(Uy);
                for (let s = 0; s < t.length; s++) r.push(o), o += t[s].length, zy(n, t[s]);
                const a = py(n, r);
                for (let s = 0; s < a.length; s += 3) i.push(a.slice(s, s + 3));
                return i
            }
        }

        function Uy(e) {
            const t = e.length;
            t > 2 && e[t - 1].equals(e[0]) && e.pop()
        }

        function zy(e, t) {
            for (let n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y)
        }
        class Hy extends Mh {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new hy([new Yc(.5, .5), new Yc(-.5, .5), new Yc(-.5, -.5), new Yc(.5, -.5)]),
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                super(), this.type = "ExtrudeGeometry", this.parameters = {
                    shapes: e,
                    options: t
                }, e = Array.isArray(e) ? e : [e];
                const n = this,
                    r = [],
                    i = [];
                for (let a = 0, s = e.length; a < s; a++) {
                    o(e[a])
                }

                function o(e) {
                    const o = [],
                        a = void 0 !== t.curveSegments ? t.curveSegments : 12,
                        s = void 0 !== t.steps ? t.steps : 1,
                        l = void 0 !== t.depth ? t.depth : 1;
                    let c = void 0 === t.bevelEnabled || t.bevelEnabled,
                        u = void 0 !== t.bevelThickness ? t.bevelThickness : .2,
                        d = void 0 !== t.bevelSize ? t.bevelSize : u - .1,
                        h = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
                        p = void 0 !== t.bevelSegments ? t.bevelSegments : 3;
                    const f = t.extrudePath,
                        m = void 0 !== t.UVGenerator ? t.UVGenerator : jy;
                    let g, v, y, b, x, _ = !1;
                    f && (g = f.getSpacedPoints(s), _ = !0, c = !1, v = f.computeFrenetFrames(s, !1), y = new Pu, b = new Pu, x = new Pu), c || (p = 0, u = 0, d = 0, h = 0);
                    const M = e.extractPoints(a);
                    let w = M.shape;
                    const A = M.holes;
                    if (!Fy.isClockWise(w)) {
                        w = w.reverse();
                        for (let e = 0, t = A.length; e < t; e++) {
                            const t = A[e];
                            Fy.isClockWise(t) && (A[e] = t.reverse())
                        }
                    }
                    const S = Fy.triangulateShape(w, A),
                        E = w;
                    for (let t = 0, n = A.length; t < n; t++) {
                        const e = A[t];
                        w = w.concat(e)
                    }

                    function C(e, t, n) {
                        return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().addScaledVector(t, n)
                    }
                    const T = w.length,
                        P = S.length;

                    function R(e, t, n) {
                        let r, i, o;
                        const a = e.x - t.x,
                            s = e.y - t.y,
                            l = n.x - e.x,
                            c = n.y - e.y,
                            u = a * a + s * s,
                            d = a * c - s * l;
                        if (Math.abs(d) > Number.EPSILON) {
                            const d = Math.sqrt(u),
                                h = Math.sqrt(l * l + c * c),
                                p = t.x - s / d,
                                f = t.y + a / d,
                                m = ((n.x - c / h - p) * c - (n.y + l / h - f) * l) / (a * c - s * l);
                            r = p + a * m - e.x, i = f + s * m - e.y;
                            const g = r * r + i * i;
                            if (g <= 2) return new Yc(r, i);
                            o = Math.sqrt(g / 2)
                        } else {
                            let e = !1;
                            a > Number.EPSILON ? l > Number.EPSILON && (e = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (e = !0) : Math.sign(s) === Math.sign(c) && (e = !0), e ? (r = -s, i = a, o = Math.sqrt(u)) : (r = a, i = s, o = Math.sqrt(u / 2))
                        }
                        return new Yc(r / o, i / o)
                    }
                    const I = [];
                    for (let t = 0, n = E.length, r = n - 1, i = t + 1; t < n; t++, r++, i++) r === n && (r = 0), i === n && (i = 0), I[t] = R(E[t], E[r], E[i]);
                    const O = [];
                    let B, L = I.concat();
                    for (let t = 0, n = A.length; t < n; t++) {
                        const e = A[t];
                        B = [];
                        for (let t = 0, n = e.length, r = n - 1, i = t + 1; t < n; t++, r++, i++) r === n && (r = 0), i === n && (i = 0), B[t] = R(e[t], e[r], e[i]);
                        O.push(B), L = L.concat(B)
                    }
                    for (let t = 0; t < p; t++) {
                        const e = t / p,
                            n = u * Math.cos(e * Math.PI / 2),
                            r = d * Math.sin(e * Math.PI / 2) + h;
                        for (let t = 0, i = E.length; t < i; t++) {
                            const e = C(E[t], I[t], r);
                            k(e.x, e.y, -n)
                        }
                        for (let t = 0, i = A.length; t < i; t++) {
                            const e = A[t];
                            B = O[t];
                            for (let t = 0, i = e.length; t < i; t++) {
                                const i = C(e[t], B[t], r);
                                k(i.x, i.y, -n)
                            }
                        }
                    }
                    const D = d + h;
                    for (let t = 0; t < T; t++) {
                        const e = c ? C(w[t], L[t], D) : w[t];
                        _ ? (b.copy(v.normals[0]).multiplyScalar(e.x), y.copy(v.binormals[0]).multiplyScalar(e.y), x.copy(g[0]).add(b).add(y), k(x.x, x.y, x.z)) : k(e.x, e.y, 0)
                    }
                    for (let t = 1; t <= s; t++)
                        for (let e = 0; e < T; e++) {
                            const n = c ? C(w[e], L[e], D) : w[e];
                            _ ? (b.copy(v.normals[t]).multiplyScalar(n.x), y.copy(v.binormals[t]).multiplyScalar(n.y), x.copy(g[t]).add(b).add(y), k(x.x, x.y, x.z)) : k(n.x, n.y, l / s * t)
                        }
                    for (let t = p - 1; t >= 0; t--) {
                        const e = t / p,
                            n = u * Math.cos(e * Math.PI / 2),
                            r = d * Math.sin(e * Math.PI / 2) + h;
                        for (let t = 0, i = E.length; t < i; t++) {
                            const e = C(E[t], I[t], r);
                            k(e.x, e.y, l + n)
                        }
                        for (let t = 0, i = A.length; t < i; t++) {
                            const e = A[t];
                            B = O[t];
                            for (let t = 0, i = e.length; t < i; t++) {
                                const i = C(e[t], B[t], r);
                                _ ? k(i.x, i.y + g[s - 1].y, g[s - 1].x + n) : k(i.x, i.y, l + n)
                            }
                        }
                    }

                    function N(e, t) {
                        let n = e.length;
                        for (; --n >= 0;) {
                            const r = n;
                            let i = n - 1;
                            i < 0 && (i = e.length - 1);
                            for (let e = 0, n = s + 2 * p; e < n; e++) {
                                const n = T * e,
                                    o = T * (e + 1);
                                U(t + r + n, t + i + n, t + i + o, t + r + o)
                            }
                        }
                    }

                    function k(e, t, n) {
                        o.push(e), o.push(t), o.push(n)
                    }

                    function F(e, t, i) {
                        z(e), z(t), z(i);
                        const o = r.length / 3,
                            a = m.generateTopUV(n, r, o - 3, o - 2, o - 1);
                        H(a[0]), H(a[1]), H(a[2])
                    }

                    function U(e, t, i, o) {
                        z(e), z(t), z(o), z(t), z(i), z(o);
                        const a = r.length / 3,
                            s = m.generateSideWallUV(n, r, a - 6, a - 3, a - 2, a - 1);
                        H(s[0]), H(s[1]), H(s[3]), H(s[1]), H(s[2]), H(s[3])
                    }

                    function z(e) {
                        r.push(o[3 * e + 0]), r.push(o[3 * e + 1]), r.push(o[3 * e + 2])
                    }

                    function H(e) {
                        i.push(e.x), i.push(e.y)
                    }! function() {
                        const e = r.length / 3;
                        if (c) {
                            let e = 0,
                                t = T * e;
                            for (let n = 0; n < P; n++) {
                                const e = S[n];
                                F(e[2] + t, e[1] + t, e[0] + t)
                            }
                            e = s + 2 * p, t = T * e;
                            for (let n = 0; n < P; n++) {
                                const e = S[n];
                                F(e[0] + t, e[1] + t, e[2] + t)
                            }
                        } else {
                            for (let e = 0; e < P; e++) {
                                const t = S[e];
                                F(t[2], t[1], t[0])
                            }
                            for (let e = 0; e < P; e++) {
                                const t = S[e];
                                F(t[0] + T * s, t[1] + T * s, t[2] + T * s)
                            }
                        }
                        n.addGroup(e, r.length / 3 - e, 0)
                    }(),
                    function() {
                        const e = r.length / 3;
                        let t = 0;
                        N(E, t), t += E.length;
                        for (let n = 0, r = A.length; n < r; n++) {
                            const e = A[n];
                            N(e, t), t += e.length
                        }
                        n.addGroup(e, r.length / 3 - e, 1)
                    }()
                }
                this.setAttribute("position", new ph(r, 3)), this.setAttribute("uv", new ph(i, 2)), this.computeVertexNormals()
            }
            copy(e) {
                return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
            }
            toJSON() {
                const e = super.toJSON();
                return function(e, t, n) {
                    if (n.shapes = [], Array.isArray(e))
                        for (let r = 0, i = e.length; r < i; r++) {
                            const t = e[r];
                            n.shapes.push(t.uuid)
                        } else n.shapes.push(e.uuid);
                    n.options = Object.assign({}, t), void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON());
                    return n
                }(this.parameters.shapes, this.parameters.options, e)
            }
            static fromJSON(e, t) {
                const n = [];
                for (let i = 0, o = e.shapes.length; i < o; i++) {
                    const r = t[e.shapes[i]];
                    n.push(r)
                }
                const r = e.options.extrudePath;
                return void 0 !== r && (e.options.extrudePath = (new Qv[r.type]).fromJSON(r)), new Hy(n, e.options)
            }
        }
        const jy = {
            generateTopUV: function(e, t, n, r, i) {
                const o = t[3 * n],
                    a = t[3 * n + 1],
                    s = t[3 * r],
                    l = t[3 * r + 1],
                    c = t[3 * i],
                    u = t[3 * i + 1];
                return [new Yc(o, a), new Yc(s, l), new Yc(c, u)]
            },
            generateSideWallUV: function(e, t, n, r, i, o) {
                const a = t[3 * n],
                    s = t[3 * n + 1],
                    l = t[3 * n + 2],
                    c = t[3 * r],
                    u = t[3 * r + 1],
                    d = t[3 * r + 2],
                    h = t[3 * i],
                    p = t[3 * i + 1],
                    f = t[3 * i + 2],
                    m = t[3 * o],
                    g = t[3 * o + 1],
                    v = t[3 * o + 2];
                return Math.abs(s - u) < Math.abs(a - c) ? [new Yc(a, 1 - l), new Yc(c, 1 - d), new Yc(h, 1 - f), new Yc(m, 1 - v)] : [new Yc(s, 1 - l), new Yc(u, 1 - d), new Yc(p, 1 - f), new Yc(g, 1 - v)]
            }
        };
        class Gy extends oy {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                const n = (1 + Math.sqrt(5)) / 2;
                super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }
            static fromJSON(e) {
                return new Gy(e.radius, e.detail)
            }
        }
        class Vy extends oy {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }
            static fromJSON(e) {
                return new Vy(e.radius, e.detail)
            }
        }
        class qy extends Mh {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 32,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
                    i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
                    o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 2 * Math.PI;
                super(), this.type = "RingGeometry", this.parameters = {
                    innerRadius: e,
                    outerRadius: t,
                    thetaSegments: n,
                    phiSegments: r,
                    thetaStart: i,
                    thetaLength: o
                }, n = Math.max(3, n), r = Math.max(1, r);
                const a = [],
                    s = [],
                    l = [],
                    c = [];
                let u = e;
                const d = (t - e) / r,
                    h = new Pu,
                    p = new Yc;
                for (let f = 0; f <= r; f++) {
                    for (let e = 0; e <= n; e++) {
                        const r = i + e / n * o;
                        h.x = u * Math.cos(r), h.y = u * Math.sin(r), s.push(h.x, h.y, h.z), l.push(0, 0, 1), p.x = (h.x / t + 1) / 2, p.y = (h.y / t + 1) / 2, c.push(p.x, p.y)
                    }
                    u += d
                }
                for (let f = 0; f < r; f++) {
                    const e = f * (n + 1);
                    for (let t = 0; t < n; t++) {
                        const r = t + e,
                            i = r,
                            o = r + n + 1,
                            s = r + n + 2,
                            l = r + 1;
                        a.push(i, o, l), a.push(o, s, l)
                    }
                }
                this.setIndex(a), this.setAttribute("position", new ph(s, 3)), this.setAttribute("normal", new ph(l, 3)), this.setAttribute("uv", new ph(c, 2))
            }
            copy(e) {
                return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
            }
            static fromJSON(e) {
                return new qy(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength)
            }
        }
        class Wy extends Mh {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new hy([new Yc(0, .5), new Yc(-.5, -.5), new Yc(.5, -.5)]),
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 12;
                super(), this.type = "ShapeGeometry", this.parameters = {
                    shapes: e,
                    curveSegments: t
                };
                const n = [],
                    r = [],
                    i = [],
                    o = [];
                let a = 0,
                    s = 0;
                if (!1 === Array.isArray(e)) l(e);
                else
                    for (let c = 0; c < e.length; c++) l(e[c]), this.addGroup(a, s, c), a += s, s = 0;

                function l(e) {
                    const a = r.length / 3,
                        l = e.extractPoints(t);
                    let c = l.shape;
                    const u = l.holes;
                    !1 === Fy.isClockWise(c) && (c = c.reverse());
                    for (let t = 0, n = u.length; t < n; t++) {
                        const e = u[t];
                        !0 === Fy.isClockWise(e) && (u[t] = e.reverse())
                    }
                    const d = Fy.triangulateShape(c, u);
                    for (let t = 0, n = u.length; t < n; t++) {
                        const e = u[t];
                        c = c.concat(e)
                    }
                    for (let t = 0, n = c.length; t < n; t++) {
                        const e = c[t];
                        r.push(e.x, e.y, 0), i.push(0, 0, 1), o.push(e.x, e.y)
                    }
                    for (let t = 0, r = d.length; t < r; t++) {
                        const e = d[t],
                            r = e[0] + a,
                            i = e[1] + a,
                            o = e[2] + a;
                        n.push(r, i, o), s += 3
                    }
                }
                this.setIndex(n), this.setAttribute("position", new ph(r, 3)), this.setAttribute("normal", new ph(i, 3)), this.setAttribute("uv", new ph(o, 2))
            }
            copy(e) {
                return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
            }
            toJSON() {
                const e = super.toJSON();
                return function(e, t) {
                    if (t.shapes = [], Array.isArray(e))
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n];
                            t.shapes.push(r.uuid)
                        } else t.shapes.push(e.uuid);
                    return t
                }(this.parameters.shapes, e)
            }
            static fromJSON(e, t) {
                const n = [];
                for (let r = 0, i = e.shapes.length; r < i; r++) {
                    const i = t[e.shapes[r]];
                    n.push(i)
                }
                return new Wy(n, e.curveSegments)
            }
        }
        class Xy extends Mh {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 32,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 16,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                    i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 2 * Math.PI,
                    o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0,
                    a = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : Math.PI;
                super(), this.type = "SphereGeometry", this.parameters = {
                    radius: e,
                    widthSegments: t,
                    heightSegments: n,
                    phiStart: r,
                    phiLength: i,
                    thetaStart: o,
                    thetaLength: a
                }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
                const s = Math.min(o + a, Math.PI);
                let l = 0;
                const c = [],
                    u = new Pu,
                    d = new Pu,
                    h = [],
                    p = [],
                    f = [],
                    m = [];
                for (let g = 0; g <= n; g++) {
                    const h = [],
                        v = g / n;
                    let y = 0;
                    0 === g && 0 === o ? y = .5 / t : g === n && s === Math.PI && (y = -.5 / t);
                    for (let n = 0; n <= t; n++) {
                        const s = n / t;
                        u.x = -e * Math.cos(r + s * i) * Math.sin(o + v * a), u.y = e * Math.cos(o + v * a), u.z = e * Math.sin(r + s * i) * Math.sin(o + v * a), p.push(u.x, u.y, u.z), d.copy(u).normalize(), f.push(d.x, d.y, d.z), m.push(s + y, 1 - v), h.push(l++)
                    }
                    c.push(h)
                }
                for (let g = 0; g < n; g++)
                    for (let e = 0; e < t; e++) {
                        const t = c[g][e + 1],
                            r = c[g][e],
                            i = c[g + 1][e],
                            a = c[g + 1][e + 1];
                        (0 !== g || o > 0) && h.push(t, r, a), (g !== n - 1 || s < Math.PI) && h.push(r, i, a)
                    }
                this.setIndex(h), this.setAttribute("position", new ph(p, 3)), this.setAttribute("normal", new ph(f, 3)), this.setAttribute("uv", new ph(m, 2))
            }
            copy(e) {
                return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
            }
            static fromJSON(e) {
                return new Xy(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength)
            }
        }
        class Ky extends oy {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }
            static fromJSON(e) {
                return new Ky(e.radius, e.detail)
            }
        }
        class Jy extends Mh {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .4,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 12,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 48,
                    i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 2 * Math.PI;
                super(), this.type = "TorusGeometry", this.parameters = {
                    radius: e,
                    tube: t,
                    radialSegments: n,
                    tubularSegments: r,
                    arc: i
                }, n = Math.floor(n), r = Math.floor(r);
                const o = [],
                    a = [],
                    s = [],
                    l = [],
                    c = new Pu,
                    u = new Pu,
                    d = new Pu;
                for (let h = 0; h <= n; h++)
                    for (let o = 0; o <= r; o++) {
                        const p = o / r * i,
                            f = h / n * Math.PI * 2;
                        u.x = (e + t * Math.cos(f)) * Math.cos(p), u.y = (e + t * Math.cos(f)) * Math.sin(p), u.z = t * Math.sin(f), a.push(u.x, u.y, u.z), c.x = e * Math.cos(p), c.y = e * Math.sin(p), d.subVectors(u, c).normalize(), s.push(d.x, d.y, d.z), l.push(o / r), l.push(h / n)
                    }
                for (let h = 1; h <= n; h++)
                    for (let e = 1; e <= r; e++) {
                        const t = (r + 1) * h + e - 1,
                            n = (r + 1) * (h - 1) + e - 1,
                            i = (r + 1) * (h - 1) + e,
                            a = (r + 1) * h + e;
                        o.push(t, n, a), o.push(n, i, a)
                    }
                this.setIndex(o), this.setAttribute("position", new ph(a, 3)), this.setAttribute("normal", new ph(s, 3)), this.setAttribute("uv", new ph(l, 2))
            }
            copy(e) {
                return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
            }
            static fromJSON(e) {
                return new Jy(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc)
            }
        }
        class Yy extends Mh {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .4,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 64,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 8,
                    i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 2,
                    o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 3;
                super(), this.type = "TorusKnotGeometry", this.parameters = {
                    radius: e,
                    tube: t,
                    tubularSegments: n,
                    radialSegments: r,
                    p: i,
                    q: o
                }, n = Math.floor(n), r = Math.floor(r);
                const a = [],
                    s = [],
                    l = [],
                    c = [],
                    u = new Pu,
                    d = new Pu,
                    h = new Pu,
                    p = new Pu,
                    f = new Pu,
                    m = new Pu,
                    g = new Pu;
                for (let y = 0; y <= n; ++y) {
                    const a = y / n * i * Math.PI * 2;
                    v(a, i, o, e, h), v(a + .01, i, o, e, p), m.subVectors(p, h), g.addVectors(p, h), f.crossVectors(m, g), g.crossVectors(f, m), f.normalize(), g.normalize();
                    for (let e = 0; e <= r; ++e) {
                        const i = e / r * Math.PI * 2,
                            o = -t * Math.cos(i),
                            a = t * Math.sin(i);
                        u.x = h.x + (o * g.x + a * f.x), u.y = h.y + (o * g.y + a * f.y), u.z = h.z + (o * g.z + a * f.z), s.push(u.x, u.y, u.z), d.subVectors(u, h).normalize(), l.push(d.x, d.y, d.z), c.push(y / n), c.push(e / r)
                    }
                }
                for (let y = 1; y <= n; y++)
                    for (let e = 1; e <= r; e++) {
                        const t = (r + 1) * (y - 1) + (e - 1),
                            n = (r + 1) * y + (e - 1),
                            i = (r + 1) * y + e,
                            o = (r + 1) * (y - 1) + e;
                        a.push(t, n, o), a.push(n, i, o)
                    }

                function v(e, t, n, r, i) {
                    const o = Math.cos(e),
                        a = Math.sin(e),
                        s = n / t * e,
                        l = Math.cos(s);
                    i.x = r * (2 + l) * .5 * o, i.y = r * (2 + l) * a * .5, i.z = r * Math.sin(s) * .5
                }
                this.setIndex(a), this.setAttribute("position", new ph(s, 3)), this.setAttribute("normal", new ph(l, 3)), this.setAttribute("uv", new ph(c, 2))
            }
            copy(e) {
                return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
            }
            static fromJSON(e) {
                return new Yy(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q)
            }
        }
        class Qy extends Mh {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Jv(new Pu(-1, -1, 0), new Pu(-1, 1, 0), new Pu(1, 1, 0)),
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 64,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 8,
                    i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                super(), this.type = "TubeGeometry", this.parameters = {
                    path: e,
                    tubularSegments: t,
                    radius: n,
                    radialSegments: r,
                    closed: i
                };
                const o = e.computeFrenetFrames(t, i);
                this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
                const a = new Pu,
                    s = new Pu,
                    l = new Yc;
                let c = new Pu;
                const u = [],
                    d = [],
                    h = [],
                    p = [];

                function f(i) {
                    c = e.getPointAt(i / t, c);
                    const l = o.normals[i],
                        h = o.binormals[i];
                    for (let e = 0; e <= r; e++) {
                        const t = e / r * Math.PI * 2,
                            i = Math.sin(t),
                            o = -Math.cos(t);
                        s.x = o * l.x + i * h.x, s.y = o * l.y + i * h.y, s.z = o * l.z + i * h.z, s.normalize(), d.push(s.x, s.y, s.z), a.x = c.x + n * s.x, a.y = c.y + n * s.y, a.z = c.z + n * s.z, u.push(a.x, a.y, a.z)
                    }
                }! function() {
                    for (let e = 0; e < t; e++) f(e);
                    f(!1 === i ? t : 0),
                        function() {
                            for (let e = 0; e <= t; e++)
                                for (let n = 0; n <= r; n++) l.x = e / t, l.y = n / r, h.push(l.x, l.y)
                        }(),
                        function() {
                            for (let e = 1; e <= t; e++)
                                for (let t = 1; t <= r; t++) {
                                    const n = (r + 1) * (e - 1) + (t - 1),
                                        i = (r + 1) * e + (t - 1),
                                        o = (r + 1) * e + t,
                                        a = (r + 1) * (e - 1) + t;
                                    p.push(n, i, a), p.push(i, o, a)
                                }
                        }()
                }(), this.setIndex(p), this.setAttribute("position", new ph(u, 3)), this.setAttribute("normal", new ph(d, 3)), this.setAttribute("uv", new ph(h, 2))
            }
            copy(e) {
                return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
            }
            toJSON() {
                const e = super.toJSON();
                return e.path = this.parameters.path.toJSON(), e
            }
            static fromJSON(e) {
                return new Qy((new Qv[e.path.type]).fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed)
            }
        }
        class Zy extends Mh {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                if (super(), this.type = "WireframeGeometry", this.parameters = {
                        geometry: e
                    }, null !== e) {
                    const t = [],
                        n = new Set,
                        r = new Pu,
                        i = new Pu;
                    if (null !== e.index) {
                        const o = e.attributes.position,
                            a = e.index;
                        let s = e.groups;
                        0 === s.length && (s = [{
                            start: 0,
                            count: a.count,
                            materialIndex: 0
                        }]);
                        for (let e = 0, l = s.length; e < l; ++e) {
                            const l = s[e],
                                c = l.start;
                            for (let e = c, s = c + l.count; e < s; e += 3)
                                for (let l = 0; l < 3; l++) {
                                    const s = a.getX(e + l),
                                        c = a.getX(e + (l + 1) % 3);
                                    r.fromBufferAttribute(o, s), i.fromBufferAttribute(o, c), !0 === $y(r, i, n) && (t.push(r.x, r.y, r.z), t.push(i.x, i.y, i.z))
                                }
                        }
                    } else {
                        const o = e.attributes.position;
                        for (let e = 0, a = o.count / 3; e < a; e++)
                            for (let s = 0; s < 3; s++) {
                                const a = 3 * e + s,
                                    l = 3 * e + (s + 1) % 3;
                                r.fromBufferAttribute(o, a), i.fromBufferAttribute(o, l), !0 === $y(r, i, n) && (t.push(r.x, r.y, r.z), t.push(i.x, i.y, i.z))
                            }
                    }
                    this.setAttribute("position", new ph(t, 3))
                }
            }
            copy(e) {
                return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
            }
        }

        function $y(e, t, n) {
            const r = "".concat(e.x, ",").concat(e.y, ",").concat(e.z, "-").concat(t.x, ",").concat(t.y, ",").concat(t.z),
                i = "".concat(t.x, ",").concat(t.y, ",").concat(t.z, "-").concat(e.x, ",").concat(e.y, ",").concat(e.z);
            return !0 !== n.has(r) && !0 !== n.has(i) && (n.add(r), n.add(i), !0)
        }
        var eb = Object.freeze({
            __proto__: null,
            BoxGeometry: jh,
            CapsuleGeometry: ty,
            CircleGeometry: ny,
            ConeGeometry: iy,
            CylinderGeometry: ry,
            DodecahedronGeometry: ay,
            EdgesGeometry: dy,
            ExtrudeGeometry: Hy,
            IcosahedronGeometry: Gy,
            LatheGeometry: ey,
            OctahedronGeometry: Vy,
            PlaneGeometry: hp,
            PolyhedronGeometry: oy,
            RingGeometry: qy,
            ShapeGeometry: Wy,
            SphereGeometry: Xy,
            TetrahedronGeometry: Ky,
            TorusGeometry: Jy,
            TorusKnotGeometry: Yy,
            TubeGeometry: Qy,
            WireframeGeometry: Zy
        });
        class tb extends Jd {
            constructor(e) {
                super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Wd(0), this.transparent = !0, this.fog = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this
            }
        }
        class nb extends Xh {
            constructor(e) {
                super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial"
            }
        }
        class rb extends Jd {
            constructor(e) {
                super(), this.isMeshStandardMaterial = !0, this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new Wd(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Wd(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Hl, this.normalScale = new Yc(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.defines = {
                    STANDARD: ""
                }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
            }
        }
        class ib extends rb {
            constructor(e) {
                super(), this.isMeshPhysicalMaterial = !0, this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Yc(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                    get: function() {
                        return jc(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                    },
                    set: function(e) {
                        this.ior = (1 + .4 * e) / (1 - .4 * e)
                    }
                }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Wd(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Wd(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Wd(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e)
            }
            get anisotropy() {
                return this._anisotropy
            }
            set anisotropy(e) {
                this._anisotropy > 0 !== e > 0 && this.version++, this._anisotropy = e
            }
            get clearcoat() {
                return this._clearcoat
            }
            set clearcoat(e) {
                this._clearcoat > 0 !== e > 0 && this.version++, this._clearcoat = e
            }
            get iridescence() {
                return this._iridescence
            }
            set iridescence(e) {
                this._iridescence > 0 !== e > 0 && this.version++, this._iridescence = e
            }
            get sheen() {
                return this._sheen
            }
            set sheen(e) {
                this._sheen > 0 !== e > 0 && this.version++, this._sheen = e
            }
            get transmission() {
                return this._transmission
            }
            set transmission(e) {
                this._transmission > 0 !== e > 0 && this.version++, this._transmission = e
            }
            copy(e) {
                return super.copy(e), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
            }
        }
        class ob extends Jd {
            constructor(e) {
                super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Wd(16777215), this.specular = new Wd(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Wd(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Hl, this.normalScale = new Yc(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Wa, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
            }
        }
        class ab extends Jd {
            constructor(e) {
                super(), this.isMeshToonMaterial = !0, this.defines = {
                    TOON: ""
                }, this.type = "MeshToonMaterial", this.color = new Wd(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Wd(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Hl, this.normalScale = new Yc(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
            }
        }
        class sb extends Jd {
            constructor(e) {
                super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Hl, this.normalScale = new Yc(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this
            }
        }
        class lb extends Jd {
            constructor(e) {
                super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Wd(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Wd(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Hl, this.normalScale = new Yc(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Wa, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
            }
        }
        class cb extends Jd {
            constructor(e) {
                super(), this.isMeshMatcapMaterial = !0, this.defines = {
                    MATCAP: ""
                }, this.type = "MeshMatcapMaterial", this.color = new Wd(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Hl, this.normalScale = new Yc(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.defines = {
                    MATCAP: ""
                }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this
            }
        }
        class ub extends lv {
            constructor(e) {
                super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
            }
        }

        function db(e, t, n) {
            return !e || !n && e.constructor === t ? e : "number" === typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
        }

        function hb(e) {
            return ArrayBuffer.isView(e) && !(e instanceof DataView)
        }

        function pb(e) {
            const t = e.length,
                n = new Array(t);
            for (let r = 0; r !== t; ++r) n[r] = r;
            return n.sort((function(t, n) {
                return e[t] - e[n]
            })), n
        }

        function fb(e, t, n) {
            const r = e.length,
                i = new e.constructor(r);
            for (let o = 0, a = 0; a !== r; ++o) {
                const r = n[o] * t;
                for (let n = 0; n !== t; ++n) i[a++] = e[r + n]
            }
            return i
        }

        function mb(e, t, n, r) {
            let i = 1,
                o = e[0];
            for (; void 0 !== o && void 0 === o[r];) o = e[i++];
            if (void 0 === o) return;
            let a = o[r];
            if (void 0 !== a)
                if (Array.isArray(a))
                    do {
                        a = o[r], void 0 !== a && (t.push(o.time), n.push.apply(n, a)), o = e[i++]
                    } while (void 0 !== o);
                else if (void 0 !== a.toArray)
                do {
                    a = o[r], void 0 !== a && (t.push(o.time), a.toArray(n, n.length)), o = e[i++]
                } while (void 0 !== o);
            else
                do {
                    a = o[r], void 0 !== a && (t.push(o.time), n.push(a)), o = e[i++]
                } while (void 0 !== o)
        }
        const gb = {
            convertArray: db,
            isTypedArray: hb,
            getKeyframeOrder: pb,
            sortedArray: fb,
            flattenJSON: mb,
            subclip: function(e, t, n, r) {
                let i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 30;
                const o = e.clone();
                o.name = t;
                const a = [];
                for (let l = 0; l < o.tracks.length; ++l) {
                    const e = o.tracks[l],
                        t = e.getValueSize(),
                        s = [],
                        c = [];
                    for (let o = 0; o < e.times.length; ++o) {
                        const a = e.times[o] * i;
                        if (!(a < n || a >= r)) {
                            s.push(e.times[o]);
                            for (let n = 0; n < t; ++n) c.push(e.values[o * t + n])
                        }
                    }
                    0 !== s.length && (e.times = db(s, e.times.constructor), e.values = db(c, e.values.constructor), a.push(e))
                }
                o.tracks = a;
                let s = 1 / 0;
                for (let l = 0; l < o.tracks.length; ++l) s > o.tracks[l].times[0] && (s = o.tracks[l].times[0]);
                for (let l = 0; l < o.tracks.length; ++l) o.tracks[l].shift(-1 * s);
                return o.resetDuration(), o
            },
            makeClipAdditive: function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 30;
                r <= 0 && (r = 30);
                const i = n.tracks.length,
                    o = t / r;
                for (let a = 0; a < i; ++a) {
                    const t = n.tracks[a],
                        r = t.ValueTypeName;
                    if ("bool" === r || "string" === r) continue;
                    const i = e.tracks.find((function(e) {
                        return e.name === t.name && e.ValueTypeName === r
                    }));
                    if (void 0 === i) continue;
                    let s = 0;
                    const l = t.getValueSize();
                    t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (s = l / 3);
                    let c = 0;
                    const u = i.getValueSize();
                    i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = u / 3);
                    const d = t.times.length - 1;
                    let h;
                    if (o <= t.times[0]) {
                        const e = s,
                            n = l - s;
                        h = t.values.slice(e, n)
                    } else if (o >= t.times[d]) {
                        const e = d * l + s,
                            n = e + l - s;
                        h = t.values.slice(e, n)
                    } else {
                        const e = t.createInterpolant(),
                            n = s,
                            r = l - s;
                        e.evaluate(o), h = e.resultBuffer.slice(n, r)
                    }
                    if ("quaternion" === r) {
                        (new Tu).fromArray(h).normalize().conjugate().toArray(h)
                    }
                    const p = i.times.length;
                    for (let e = 0; e < p; ++e) {
                        const t = e * u + c;
                        if ("quaternion" === r) Tu.multiplyQuaternionsFlat(i.values, t, h, 0, i.values, t);
                        else {
                            const e = u - 2 * c;
                            for (let n = 0; n < e; ++n) i.values[t + n] -= h[n]
                        }
                    }
                }
                return e.blendMode = Bl, e
            }
        };
        class vb {
            constructor(e, t, n, r) {
                this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
            }
            evaluate(e) {
                const t = this.parameterPositions;
                let n = this._cachedIndex,
                    r = t[n],
                    i = t[n - 1];
                e: {
                    t: {
                        let o;n: {
                            r: if (!(e < r)) {
                                for (let o = n + 2;;) {
                                    if (void 0 === r) {
                                        if (e < i) break r;
                                        return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                                    }
                                    if (n === o) break;
                                    if (i = r, r = t[++n], e < r) break t
                                }
                                o = t.length;
                                break n
                            }if (e >= i) break e; {
                                const a = t[1];
                                e < a && (n = 2, i = a);
                                for (let o = n - 2;;) {
                                    if (void 0 === i) return this._cachedIndex = 0, this.copySampleValue_(0);
                                    if (n === o) break;
                                    if (r = i, i = t[--n - 1], e >= i) break t
                                }
                                o = n, n = 0
                            }
                        }
                        for (; n < o;) {
                            const r = n + o >>> 1;
                            e < t[r] ? o = r : n = r + 1
                        }
                        if (r = t[n], i = t[n - 1], void 0 === i) return this._cachedIndex = 0, this.copySampleValue_(0);
                        if (void 0 === r) return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                    }
                    this._cachedIndex = n,
                    this.intervalChanged_(n, i, r)
                }
                return this.interpolate_(n, i, e, r)
            }
            getSettings_() {
                return this.settings || this.DefaultSettings_
            }
            copySampleValue_(e) {
                const t = this.resultBuffer,
                    n = this.sampleValues,
                    r = this.valueSize,
                    i = e * r;
                for (let o = 0; o !== r; ++o) t[o] = n[i + o];
                return t
            }
            interpolate_() {
                throw new Error("call to abstract method")
            }
            intervalChanged_() {}
        }
        class yb extends vb {
            constructor(e, t, n, r) {
                super(e, t, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                    endingStart: Pl,
                    endingEnd: Pl
                }
            }
            intervalChanged_(e, t, n) {
                const r = this.parameterPositions;
                let i = e - 2,
                    o = e + 1,
                    a = r[i],
                    s = r[o];
                if (void 0 === a) switch (this.getSettings_().endingStart) {
                    case Rl:
                        i = e, a = 2 * t - n;
                        break;
                    case Il:
                        i = r.length - 2, a = t + r[i] - r[i + 1];
                        break;
                    default:
                        i = e, a = n
                }
                if (void 0 === s) switch (this.getSettings_().endingEnd) {
                    case Rl:
                        o = e, s = 2 * n - t;
                        break;
                    case Il:
                        o = 1, s = n + r[1] - r[0];
                        break;
                    default:
                        o = e - 1, s = t
                }
                const l = .5 * (n - t),
                    c = this.valueSize;
                this._weightPrev = l / (t - a), this._weightNext = l / (s - n), this._offsetPrev = i * c, this._offsetNext = o * c
            }
            interpolate_(e, t, n, r) {
                const i = this.resultBuffer,
                    o = this.sampleValues,
                    a = this.valueSize,
                    s = e * a,
                    l = s - a,
                    c = this._offsetPrev,
                    u = this._offsetNext,
                    d = this._weightPrev,
                    h = this._weightNext,
                    p = (n - t) / (r - t),
                    f = p * p,
                    m = f * p,
                    g = -d * m + 2 * d * f - d * p,
                    v = (1 + d) * m + (-1.5 - 2 * d) * f + (-.5 + d) * p + 1,
                    y = (-1 - h) * m + (1.5 + h) * f + .5 * p,
                    b = h * m - h * f;
                for (let x = 0; x !== a; ++x) i[x] = g * o[c + x] + v * o[l + x] + y * o[s + x] + b * o[u + x];
                return i
            }
        }
        class bb extends vb {
            constructor(e, t, n, r) {
                super(e, t, n, r)
            }
            interpolate_(e, t, n, r) {
                const i = this.resultBuffer,
                    o = this.sampleValues,
                    a = this.valueSize,
                    s = e * a,
                    l = s - a,
                    c = (n - t) / (r - t),
                    u = 1 - c;
                for (let d = 0; d !== a; ++d) i[d] = o[l + d] * u + o[s + d] * c;
                return i
            }
        }
        class xb extends vb {
            constructor(e, t, n, r) {
                super(e, t, n, r)
            }
            interpolate_(e) {
                return this.copySampleValue_(e - 1)
            }
        }
        class _b {
            constructor(e, t, n, r) {
                if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                this.name = e, this.times = db(t, this.TimeBufferType), this.values = db(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
            }
            static toJSON(e) {
                const t = e.constructor;
                let n;
                if (t.toJSON !== this.toJSON) n = t.toJSON(e);
                else {
                    n = {
                        name: e.name,
                        times: db(e.times, Array),
                        values: db(e.values, Array)
                    };
                    const t = e.getInterpolation();
                    t !== e.DefaultInterpolation && (n.interpolation = t)
                }
                return n.type = e.ValueTypeName, n
            }
            InterpolantFactoryMethodDiscrete(e) {
                return new xb(this.times, this.values, this.getValueSize(), e)
            }
            InterpolantFactoryMethodLinear(e) {
                return new bb(this.times, this.values, this.getValueSize(), e)
            }
            InterpolantFactoryMethodSmooth(e) {
                return new yb(this.times, this.values, this.getValueSize(), e)
            }
            setInterpolation(e) {
                let t;
                switch (e) {
                    case El:
                        t = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case Cl:
                        t = this.InterpolantFactoryMethodLinear;
                        break;
                    case Tl:
                        t = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === t) {
                    const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (e === this.DefaultInterpolation) throw new Error(t);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", t), this
                }
                return this.createInterpolant = t, this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return El;
                    case this.InterpolantFactoryMethodLinear:
                        return Cl;
                    case this.InterpolantFactoryMethodSmooth:
                        return Tl
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(e) {
                if (0 !== e) {
                    const t = this.times;
                    for (let n = 0, r = t.length; n !== r; ++n) t[n] += e
                }
                return this
            }
            scale(e) {
                if (1 !== e) {
                    const t = this.times;
                    for (let n = 0, r = t.length; n !== r; ++n) t[n] *= e
                }
                return this
            }
            trim(e, t) {
                const n = this.times,
                    r = n.length;
                let i = 0,
                    o = r - 1;
                for (; i !== r && n[i] < e;) ++i;
                for (; - 1 !== o && n[o] > t;) --o;
                if (++o, 0 !== i || o !== r) {
                    i >= o && (o = Math.max(o, 1), i = o - 1);
                    const e = this.getValueSize();
                    this.times = n.slice(i, o), this.values = this.values.slice(i * e, o * e)
                }
                return this
            }
            validate() {
                let e = !0;
                const t = this.getValueSize();
                t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
                const n = this.times,
                    r = this.values,
                    i = n.length;
                0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
                let o = null;
                for (let a = 0; a !== i; a++) {
                    const t = n[a];
                    if ("number" === typeof t && isNaN(t)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, t), e = !1;
                        break
                    }
                    if (null !== o && o > t) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, t, o), e = !1;
                        break
                    }
                    o = t
                }
                if (void 0 !== r && hb(r))
                    for (let a = 0, s = r.length; a !== s; ++a) {
                        const t = r[a];
                        if (isNaN(t)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, t), e = !1;
                            break
                        }
                    }
                return e
            }
            optimize() {
                const e = this.times.slice(),
                    t = this.values.slice(),
                    n = this.getValueSize(),
                    r = this.getInterpolation() === Tl,
                    i = e.length - 1;
                let o = 1;
                for (let a = 1; a < i; ++a) {
                    let i = !1;
                    const s = e[a];
                    if (s !== e[a + 1] && (1 !== a || s !== e[0]))
                        if (r) i = !0;
                        else {
                            const e = a * n,
                                r = e - n,
                                o = e + n;
                            for (let a = 0; a !== n; ++a) {
                                const n = t[e + a];
                                if (n !== t[r + a] || n !== t[o + a]) {
                                    i = !0;
                                    break
                                }
                            }
                        }
                    if (i) {
                        if (a !== o) {
                            e[o] = e[a];
                            const r = a * n,
                                i = o * n;
                            for (let e = 0; e !== n; ++e) t[i + e] = t[r + e]
                        }++o
                    }
                }
                if (i > 0) {
                    e[o] = e[i];
                    for (let e = i * n, r = o * n, a = 0; a !== n; ++a) t[r + a] = t[e + a];
                    ++o
                }
                return o !== e.length ? (this.times = e.slice(0, o), this.values = t.slice(0, o * n)) : (this.times = e, this.values = t), this
            }
            clone() {
                const e = this.times.slice(),
                    t = this.values.slice(),
                    n = new(0, this.constructor)(this.name, e, t);
                return n.createInterpolant = this.createInterpolant, n
            }
        }
        _b.prototype.TimeBufferType = Float32Array, _b.prototype.ValueBufferType = Float32Array, _b.prototype.DefaultInterpolation = Cl;
        class Mb extends _b {}
        Mb.prototype.ValueTypeName = "bool", Mb.prototype.ValueBufferType = Array, Mb.prototype.DefaultInterpolation = El, Mb.prototype.InterpolantFactoryMethodLinear = void 0, Mb.prototype.InterpolantFactoryMethodSmooth = void 0;
        class wb extends _b {}
        wb.prototype.ValueTypeName = "color";
        class Ab extends _b {}
        Ab.prototype.ValueTypeName = "number";
        class Sb extends vb {
            constructor(e, t, n, r) {
                super(e, t, n, r)
            }
            interpolate_(e, t, n, r) {
                const i = this.resultBuffer,
                    o = this.sampleValues,
                    a = this.valueSize,
                    s = (n - t) / (r - t);
                let l = e * a;
                for (let c = l + a; l !== c; l += 4) Tu.slerpFlat(i, 0, o, l - a, o, l, s);
                return i
            }
        }
        class Eb extends _b {
            InterpolantFactoryMethodLinear(e) {
                return new Sb(this.times, this.values, this.getValueSize(), e)
            }
        }
        Eb.prototype.ValueTypeName = "quaternion", Eb.prototype.DefaultInterpolation = Cl, Eb.prototype.InterpolantFactoryMethodSmooth = void 0;
        class Cb extends _b {}
        Cb.prototype.ValueTypeName = "string", Cb.prototype.ValueBufferType = Array, Cb.prototype.DefaultInterpolation = El, Cb.prototype.InterpolantFactoryMethodLinear = void 0, Cb.prototype.InterpolantFactoryMethodSmooth = void 0;
        class Tb extends _b {}
        Tb.prototype.ValueTypeName = "vector";
        class Pb {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1,
                    n = arguments.length > 2 ? arguments[2] : void 0,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Ol;
                this.name = e, this.tracks = n, this.duration = t, this.blendMode = r, this.uuid = Hc(), this.duration < 0 && this.resetDuration()
            }
            static parse(e) {
                const t = [],
                    n = e.tracks,
                    r = 1 / (e.fps || 1);
                for (let o = 0, a = n.length; o !== a; ++o) t.push(Rb(n[o]).scale(r));
                const i = new this(e.name, e.duration, t, e.blendMode);
                return i.uuid = e.uuid, i
            }
            static toJSON(e) {
                const t = [],
                    n = e.tracks,
                    r = {
                        name: e.name,
                        duration: e.duration,
                        tracks: t,
                        uuid: e.uuid,
                        blendMode: e.blendMode
                    };
                for (let i = 0, o = n.length; i !== o; ++i) t.push(_b.toJSON(n[i]));
                return r
            }
            static CreateFromMorphTargetSequence(e, t, n, r) {
                const i = t.length,
                    o = [];
                for (let a = 0; a < i; a++) {
                    let e = [],
                        s = [];
                    e.push((a + i - 1) % i, a, (a + 1) % i), s.push(0, 1, 0);
                    const l = pb(e);
                    e = fb(e, 1, l), s = fb(s, 1, l), r || 0 !== e[0] || (e.push(i), s.push(s[0])), o.push(new Ab(".morphTargetInfluences[" + t[a].name + "]", e, s).scale(1 / n))
                }
                return new this(e, -1, o)
            }
            static findByName(e, t) {
                let n = e;
                if (!Array.isArray(e)) {
                    const t = e;
                    n = t.geometry && t.geometry.animations || t.animations
                }
                for (let r = 0; r < n.length; r++)
                    if (n[r].name === t) return n[r];
                return null
            }
            static CreateClipsFromMorphTargetSequences(e, t, n) {
                const r = {},
                    i = /^([\w-]*?)([\d]+)$/;
                for (let a = 0, s = e.length; a < s; a++) {
                    const t = e[a],
                        n = t.name.match(i);
                    if (n && n.length > 1) {
                        const e = n[1];
                        let i = r[e];
                        i || (r[e] = i = []), i.push(t)
                    }
                }
                const o = [];
                for (const a in r) o.push(this.CreateFromMorphTargetSequence(a, r[a], t, n));
                return o
            }
            static parseAnimation(e, t) {
                if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                const n = function(e, t, n, r, i) {
                        if (0 !== n.length) {
                            const o = [],
                                a = [];
                            mb(n, o, a, r), 0 !== o.length && i.push(new e(t, o, a))
                        }
                    },
                    r = [],
                    i = e.name || "default",
                    o = e.fps || 30,
                    a = e.blendMode;
                let s = e.length || -1;
                const l = e.hierarchy || [];
                for (let c = 0; c < l.length; c++) {
                    const e = l[c].keys;
                    if (e && 0 !== e.length)
                        if (e[0].morphTargets) {
                            const t = {};
                            let n;
                            for (n = 0; n < e.length; n++)
                                if (e[n].morphTargets)
                                    for (let r = 0; r < e[n].morphTargets.length; r++) t[e[n].morphTargets[r]] = -1;
                            for (const i in t) {
                                const t = [],
                                    o = [];
                                for (let r = 0; r !== e[n].morphTargets.length; ++r) {
                                    const r = e[n];
                                    t.push(r.time), o.push(r.morphTarget === i ? 1 : 0)
                                }
                                r.push(new Ab(".morphTargetInfluence[" + i + "]", t, o))
                            }
                            s = t.length * o
                        } else {
                            const i = ".bones[" + t[c].name + "]";
                            n(Tb, i + ".position", e, "pos", r), n(Eb, i + ".quaternion", e, "rot", r), n(Tb, i + ".scale", e, "scl", r)
                        }
                }
                if (0 === r.length) return null;
                return new this(i, s, r, a)
            }
            resetDuration() {
                let e = 0;
                for (let t = 0, n = this.tracks.length; t !== n; ++t) {
                    const n = this.tracks[t];
                    e = Math.max(e, n.times[n.times.length - 1])
                }
                return this.duration = e, this
            }
            trim() {
                for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                return this
            }
            validate() {
                let e = !0;
                for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
                return e
            }
            optimize() {
                for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                return this
            }
            clone() {
                const e = [];
                for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
                return new this.constructor(this.name, this.duration, e, this.blendMode)
            }
            toJSON() {
                return this.constructor.toJSON(this)
            }
        }

        function Rb(e) {
            if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const t = function(e) {
                switch (e.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return Ab;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return Tb;
                    case "color":
                        return wb;
                    case "quaternion":
                        return Eb;
                    case "bool":
                    case "boolean":
                        return Mb;
                    case "string":
                        return Cb
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
            }(e.type);
            if (void 0 === e.times) {
                const t = [],
                    n = [];
                mb(e.keys, t, n, "value"), e.times = t, e.values = n
            }
            return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
        }
        const Ib = {
            enabled: !1,
            files: {},
            add: function(e, t) {
                !1 !== this.enabled && (this.files[e] = t)
            },
            get: function(e) {
                if (!1 !== this.enabled) return this.files[e]
            },
            remove: function(e) {
                delete this.files[e]
            },
            clear: function() {
                this.files = {}
            }
        };
        class Ob {
            constructor(e, t, n) {
                const r = this;
                let i, o = !1,
                    a = 0,
                    s = 0;
                const l = [];
                this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(e) {
                    s++, !1 === o && void 0 !== r.onStart && r.onStart(e, a, s), o = !0
                }, this.itemEnd = function(e) {
                    a++, void 0 !== r.onProgress && r.onProgress(e, a, s), a === s && (o = !1, void 0 !== r.onLoad && r.onLoad())
                }, this.itemError = function(e) {
                    void 0 !== r.onError && r.onError(e)
                }, this.resolveURL = function(e) {
                    return i ? i(e) : e
                }, this.setURLModifier = function(e) {
                    return i = e, this
                }, this.addHandler = function(e, t) {
                    return l.push(e, t), this
                }, this.removeHandler = function(e) {
                    const t = l.indexOf(e);
                    return -1 !== t && l.splice(t, 2), this
                }, this.getHandler = function(e) {
                    for (let t = 0, n = l.length; t < n; t += 2) {
                        const n = l[t],
                            r = l[t + 1];
                        if (n.global && (n.lastIndex = 0), n.test(e)) return r
                    }
                    return null
                }
            }
        }
        const Bb = new Ob;
        class Lb {
            constructor(e) {
                this.manager = void 0 !== e ? e : Bb, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
            }
            load() {}
            loadAsync(e, t) {
                const n = this;
                return new Promise((function(r, i) {
                    n.load(e, r, t, i)
                }))
            }
            parse() {}
            setCrossOrigin(e) {
                return this.crossOrigin = e, this
            }
            setWithCredentials(e) {
                return this.withCredentials = e, this
            }
            setPath(e) {
                return this.path = e, this
            }
            setResourcePath(e) {
                return this.resourcePath = e, this
            }
            setRequestHeader(e) {
                return this.requestHeader = e, this
            }
        }
        Lb.DEFAULT_MATERIAL_NAME = "__DEFAULT";
        const Db = {};
        class Nb extends Error {
            constructor(e, t) {
                super(e), this.response = t
            }
        }
        class kb extends Lb {
            constructor(e) {
                super(e)
            }
            load(e, t, n, r) {
                void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                const i = Ib.get(e);
                if (void 0 !== i) return this.manager.itemStart(e), setTimeout((() => {
                    t && t(i), this.manager.itemEnd(e)
                }), 0), i;
                if (void 0 !== Db[e]) return void Db[e].push({
                    onLoad: t,
                    onProgress: n,
                    onError: r
                });
                Db[e] = [], Db[e].push({
                    onLoad: t,
                    onProgress: n,
                    onError: r
                });
                const o = new Request(e, {
                        headers: new Headers(this.requestHeader),
                        credentials: this.withCredentials ? "include" : "same-origin"
                    }),
                    a = this.mimeType,
                    s = this.responseType;
                fetch(o).then((t => {
                    if (200 === t.status || 0 === t.status) {
                        if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" === typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader) return t;
                        const n = Db[e],
                            r = t.body.getReader(),
                            i = t.headers.get("Content-Length") || t.headers.get("X-File-Size"),
                            o = i ? parseInt(i) : 0,
                            a = 0 !== o;
                        let s = 0;
                        const l = new ReadableStream({
                            start(e) {
                                ! function t() {
                                    r.read().then((r => {
                                        let {
                                            done: i,
                                            value: l
                                        } = r;
                                        if (i) e.close();
                                        else {
                                            s += l.byteLength;
                                            const r = new ProgressEvent("progress", {
                                                lengthComputable: a,
                                                loaded: s,
                                                total: o
                                            });
                                            for (let e = 0, t = n.length; e < t; e++) {
                                                const t = n[e];
                                                t.onProgress && t.onProgress(r)
                                            }
                                            e.enqueue(l), t()
                                        }
                                    }))
                                }()
                            }
                        });
                        return new Response(l)
                    }
                    throw new Nb('fetch for "'.concat(t.url, '" responded with ').concat(t.status, ": ").concat(t.statusText), t)
                })).then((e => {
                    switch (s) {
                        case "arraybuffer":
                            return e.arrayBuffer();
                        case "blob":
                            return e.blob();
                        case "document":
                            return e.text().then((e => (new DOMParser).parseFromString(e, a)));
                        case "json":
                            return e.json();
                        default:
                            if (void 0 === a) return e.text(); {
                                const t = /charset="?([^;"\s]*)"?/i.exec(a),
                                    n = t && t[1] ? t[1].toLowerCase() : void 0,
                                    r = new TextDecoder(n);
                                return e.arrayBuffer().then((e => r.decode(e)))
                            }
                    }
                })).then((t => {
                    Ib.add(e, t);
                    const n = Db[e];
                    delete Db[e];
                    for (let e = 0, r = n.length; e < r; e++) {
                        const r = n[e];
                        r.onLoad && r.onLoad(t)
                    }
                })).catch((t => {
                    const n = Db[e];
                    if (void 0 === n) throw this.manager.itemError(e), t;
                    delete Db[e];
                    for (let e = 0, r = n.length; e < r; e++) {
                        const r = n[e];
                        r.onError && r.onError(t)
                    }
                    this.manager.itemError(e)
                })).finally((() => {
                    this.manager.itemEnd(e)
                })), this.manager.itemStart(e)
            }
            setResponseType(e) {
                return this.responseType = e, this
            }
            setMimeType(e) {
                return this.mimeType = e, this
            }
        }
        class Fb extends Lb {
            constructor(e) {
                super(e)
            }
            load(e, t, n, r) {
                const i = this,
                    o = new kb(this.manager);
                o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, (function(n) {
                    try {
                        t(i.parse(JSON.parse(n)))
                    } catch (o) {
                        r ? r(o) : console.error(o), i.manager.itemError(e)
                    }
                }), n, r)
            }
            parse(e) {
                const t = [];
                for (let n = 0; n < e.length; n++) {
                    const r = Pb.parse(e[n]);
                    t.push(r)
                }
                return t
            }
        }
        class Ub extends Lb {
            constructor(e) {
                super(e)
            }
            load(e, t, n, r) {
                const i = this,
                    o = [],
                    a = new Tv,
                    s = new kb(this.manager);
                s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(i.withCredentials);
                let l = 0;

                function c(c) {
                    s.load(e[c], (function(e) {
                        const n = i.parse(e, !0);
                        o[c] = {
                            width: n.width,
                            height: n.height,
                            format: n.format,
                            mipmaps: n.mipmaps
                        }, l += 1, 6 === l && (1 === n.mipmapCount && (a.minFilter = ys), a.image = o, a.format = n.format, a.needsUpdate = !0, t && t(a))
                    }), n, r)
                }
                if (Array.isArray(e))
                    for (let u = 0, d = e.length; u < d; ++u) c(u);
                else s.load(e, (function(e) {
                    const n = i.parse(e, !0);
                    if (n.isCubemap) {
                        const e = n.mipmaps.length / n.mipmapCount;
                        for (let t = 0; t < e; t++) {
                            o[t] = {
                                mipmaps: []
                            };
                            for (let e = 0; e < n.mipmapCount; e++) o[t].mipmaps.push(n.mipmaps[t * n.mipmapCount + e]), o[t].format = n.format, o[t].width = n.width, o[t].height = n.height
                        }
                        a.image = o
                    } else a.image.width = n.width, a.image.height = n.height, a.mipmaps = n.mipmaps;
                    1 === n.mipmapCount && (a.minFilter = ys), a.format = n.format, a.needsUpdate = !0, t && t(a)
                }), n, r);
                return a
            }
        }
        class zb extends Lb {
            constructor(e) {
                super(e)
            }
            load(e, t, n, r) {
                void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                const i = this,
                    o = Ib.get(e);
                if (void 0 !== o) return i.manager.itemStart(e), setTimeout((function() {
                    t && t(o), i.manager.itemEnd(e)
                }), 0), o;
                const a = nu("img");

                function s() {
                    c(), Ib.add(e, this), t && t(this), i.manager.itemEnd(e)
                }

                function l(t) {
                    c(), r && r(t), i.manager.itemError(e), i.manager.itemEnd(e)
                }

                function c() {
                    a.removeEventListener("load", s, !1), a.removeEventListener("error", l, !1)
                }
                return a.addEventListener("load", s, !1), a.addEventListener("error", l, !1), "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), i.manager.itemStart(e), a.src = e, a
            }
        }
        class Hb extends Lb {
            constructor(e) {
                super(e)
            }
            load(e, t, n, r) {
                const i = new tp;
                i.colorSpace = Vl;
                const o = new zb(this.manager);
                o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
                let a = 0;

                function s(n) {
                    o.load(e[n], (function(e) {
                        i.images[n] = e, a++, 6 === a && (i.needsUpdate = !0, t && t(i))
                    }), void 0, r)
                }
                for (let l = 0; l < e.length; ++l) s(l);
                return i
            }
        }
        class jb extends Lb {
            constructor(e) {
                super(e)
            }
            load(e, t, n, r) {
                const i = this,
                    o = new Og,
                    a = new kb(this.manager);
                return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(i.withCredentials), a.load(e, (function(e) {
                    let n;
                    try {
                        n = i.parse(e)
                    } catch (a) {
                        if (void 0 === r) return void console.error(a);
                        r(a)
                    }
                    void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width, o.image.height = n.height, o.image.data = n.data), o.wrapS = void 0 !== n.wrapS ? n.wrapS : ds, o.wrapT = void 0 !== n.wrapT ? n.wrapT : ds, o.magFilter = void 0 !== n.magFilter ? n.magFilter : ys, o.minFilter = void 0 !== n.minFilter ? n.minFilter : ys, o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.colorSpace ? o.colorSpace = n.colorSpace : void 0 !== n.encoding && (o.encoding = n.encoding), void 0 !== n.flipY && (o.flipY = n.flipY), void 0 !== n.format && (o.format = n.format), void 0 !== n.type && (o.type = n.type), void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps, o.minFilter = _s), 1 === n.mipmapCount && (o.minFilter = ys), void 0 !== n.generateMipmaps && (o.generateMipmaps = n.generateMipmaps), o.needsUpdate = !0, t && t(o, n)
                }), n, r), o
            }
        }
        class Gb extends Lb {
            constructor(e) {
                super(e)
            }
            load(e, t, n, r) {
                const i = new bu,
                    o = new zb(this.manager);
                return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, (function(e) {
                    i.image = e, i.needsUpdate = !0, void 0 !== t && t(i)
                }), n, r), i
            }
        }
        class Vb extends Rd {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                super(), this.isLight = !0, this.type = "Light", this.color = new Wd(e), this.intensity = t
            }
            dispose() {}
            copy(e, t) {
                return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
            }
        }
        class qb extends Vb {
            constructor(e, t, n) {
                super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Rd.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Wd(t)
            }
            copy(e, t) {
                return super.copy(e, t), this.groundColor.copy(e.groundColor), this
            }
        }
        const Wb = new od,
            Xb = new Pu,
            Kb = new Pu;
        class Jb {
            constructor(e) {
                this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Yc(512, 512), this.map = null, this.mapPass = null, this.matrix = new od, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new cp, this._frameExtents = new Yc(1, 1), this._viewportCount = 1, this._viewports = [new xu(0, 0, 1, 1)]
            }
            getViewportCount() {
                return this._viewportCount
            }
            getFrustum() {
                return this._frustum
            }
            updateMatrices(e) {
                const t = this.camera,
                    n = this.matrix;
                Xb.setFromMatrixPosition(e.matrixWorld), t.position.copy(Xb), Kb.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Kb), t.updateMatrixWorld(), Wb.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Wb), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(Wb)
            }
            getViewport(e) {
                return this._viewports[e]
            }
            getFrameExtents() {
                return this._frameExtents
            }
            dispose() {
                this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
            }
            copy(e) {
                return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            toJSON() {
                const e = {};
                return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
            }
        }
        class Yb extends Jb {
            constructor() {
                super(new Zh(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
            }
            updateMatrices(e) {
                const t = this.camera,
                    n = 2 * zc * e.angle * this.focus,
                    r = this.mapSize.width / this.mapSize.height,
                    i = e.distance || t.far;
                n === t.fov && r === t.aspect && i === t.far || (t.fov = n, t.aspect = r, t.far = i, t.updateProjectionMatrix()), super.updateMatrices(e)
            }
            copy(e) {
                return super.copy(e), this.focus = e.focus, this
            }
        }
        class Qb extends Vb {
            constructor(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Math.PI / 3,
                    i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
                    o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 2;
                super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Rd.DEFAULT_UP), this.updateMatrix(), this.target = new Rd, this.distance = n, this.angle = r, this.penumbra = i, this.decay = o, this.map = null, this.shadow = new Yb
            }
            get power() {
                return this.intensity * Math.PI
            }
            set power(e) {
                this.intensity = e / Math.PI
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e, t) {
                return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
            }
        }
        const Zb = new od,
            $b = new Pu,
            ex = new Pu;
        class tx extends Jb {
            constructor() {
                super(new Zh(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Yc(4, 2), this._viewportCount = 6, this._viewports = [new xu(2, 1, 1, 1), new xu(0, 1, 1, 1), new xu(3, 1, 1, 1), new xu(1, 1, 1, 1), new xu(3, 0, 1, 1), new xu(1, 0, 1, 1)], this._cubeDirections = [new Pu(1, 0, 0), new Pu(-1, 0, 0), new Pu(0, 0, 1), new Pu(0, 0, -1), new Pu(0, 1, 0), new Pu(0, -1, 0)], this._cubeUps = [new Pu(0, 1, 0), new Pu(0, 1, 0), new Pu(0, 1, 0), new Pu(0, 1, 0), new Pu(0, 0, 1), new Pu(0, 0, -1)]
            }
            updateMatrices(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                const n = this.camera,
                    r = this.matrix,
                    i = e.distance || n.far;
                i !== n.far && (n.far = i, n.updateProjectionMatrix()), $b.setFromMatrixPosition(e.matrixWorld), n.position.copy($b), ex.copy(n.position), ex.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(ex), n.updateMatrixWorld(), r.makeTranslation(-$b.x, -$b.y, -$b.z), Zb.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Zb)
            }
        }
        class nx extends Vb {
            constructor(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 2;
                super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new tx
            }
            get power() {
                return 4 * this.intensity * Math.PI
            }
            set power(e) {
                this.intensity = e / (4 * Math.PI)
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e, t) {
                return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
            }
        }
        class rx extends Jb {
            constructor() {
                super(new wp(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
            }
        }
        class ix extends Vb {
            constructor(e, t) {
                super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Rd.DEFAULT_UP), this.updateMatrix(), this.target = new Rd, this.shadow = new rx
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e) {
                return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
            }
        }
        class ox extends Vb {
            constructor(e, t) {
                super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight"
            }
        }
        class ax extends Vb {
            constructor(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 10;
                super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = r
            }
            get power() {
                return this.intensity * this.width * this.height * Math.PI
            }
            set power(e) {
                this.intensity = e / (this.width * this.height * Math.PI)
            }
            copy(e) {
                return super.copy(e), this.width = e.width, this.height = e.height, this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.width = this.width, t.object.height = this.height, t
            }
        }
        class sx {
            constructor() {
                this.isSphericalHarmonics3 = !0, this.coefficients = [];
                for (let e = 0; e < 9; e++) this.coefficients.push(new Pu)
            }
            set(e) {
                for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
                return this
            }
            zero() {
                for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
                return this
            }
            getAt(e, t) {
                const n = e.x,
                    r = e.y,
                    i = e.z,
                    o = this.coefficients;
                return t.copy(o[0]).multiplyScalar(.282095), t.addScaledVector(o[1], .488603 * r), t.addScaledVector(o[2], .488603 * i), t.addScaledVector(o[3], .488603 * n), t.addScaledVector(o[4], n * r * 1.092548), t.addScaledVector(o[5], r * i * 1.092548), t.addScaledVector(o[6], .315392 * (3 * i * i - 1)), t.addScaledVector(o[7], n * i * 1.092548), t.addScaledVector(o[8], .546274 * (n * n - r * r)), t
            }
            getIrradianceAt(e, t) {
                const n = e.x,
                    r = e.y,
                    i = e.z,
                    o = this.coefficients;
                return t.copy(o[0]).multiplyScalar(.886227), t.addScaledVector(o[1], 1.023328 * r), t.addScaledVector(o[2], 1.023328 * i), t.addScaledVector(o[3], 1.023328 * n), t.addScaledVector(o[4], .858086 * n * r), t.addScaledVector(o[5], .858086 * r * i), t.addScaledVector(o[6], .743125 * i * i - .247708), t.addScaledVector(o[7], .858086 * n * i), t.addScaledVector(o[8], .429043 * (n * n - r * r)), t
            }
            add(e) {
                for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
                return this
            }
            addScaledSH(e, t) {
                for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(e.coefficients[n], t);
                return this
            }
            scale(e) {
                for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
                return this
            }
            lerp(e, t) {
                for (let n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
                return this
            }
            equals(e) {
                for (let t = 0; t < 9; t++)
                    if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
                return !0
            }
            copy(e) {
                return this.set(e.coefficients)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            fromArray(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                const n = this.coefficients;
                for (let r = 0; r < 9; r++) n[r].fromArray(e, t + 3 * r);
                return this
            }
            toArray() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                const n = this.coefficients;
                for (let r = 0; r < 9; r++) n[r].toArray(e, t + 3 * r);
                return e
            }
            static getBasisAt(e, t) {
                const n = e.x,
                    r = e.y,
                    i = e.z;
                t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * i, t[3] = .488603 * n, t[4] = 1.092548 * n * r, t[5] = 1.092548 * r * i, t[6] = .315392 * (3 * i * i - 1), t[7] = 1.092548 * n * i, t[8] = .546274 * (n * n - r * r)
            }
        }
        class lx extends Vb {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new sx;
                super(void 0, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1), this.isLightProbe = !0, this.sh = e
            }
            copy(e) {
                return super.copy(e), this.sh.copy(e.sh), this
            }
            fromJSON(e) {
                return this.intensity = e.intensity, this.sh.fromArray(e.sh), this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.sh = this.sh.toArray(), t
            }
        }
        class cx extends Lb {
            constructor(e) {
                super(e), this.textures = {}
            }
            load(e, t, n, r) {
                const i = this,
                    o = new kb(i.manager);
                o.setPath(i.path), o.setRequestHeader(i.requestHeader), o.setWithCredentials(i.withCredentials), o.load(e, (function(n) {
                    try {
                        t(i.parse(JSON.parse(n)))
                    } catch (o) {
                        r ? r(o) : console.error(o), i.manager.itemError(e)
                    }
                }), n, r)
            }
            parse(e) {
                const t = this.textures;

                function n(e) {
                    return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), t[e]
                }
                const r = cx.createMaterialFromType(e.type);
                if (void 0 !== e.uuid && (r.uuid = e.uuid), void 0 !== e.name && (r.name = e.name), void 0 !== e.color && void 0 !== r.color && r.color.setHex(e.color), void 0 !== e.roughness && (r.roughness = e.roughness), void 0 !== e.metalness && (r.metalness = e.metalness), void 0 !== e.sheen && (r.sheen = e.sheen), void 0 !== e.sheenColor && (r.sheenColor = (new Wd).setHex(e.sheenColor)), void 0 !== e.sheenRoughness && (r.sheenRoughness = e.sheenRoughness), void 0 !== e.emissive && void 0 !== r.emissive && r.emissive.setHex(e.emissive), void 0 !== e.specular && void 0 !== r.specular && r.specular.setHex(e.specular), void 0 !== e.specularIntensity && (r.specularIntensity = e.specularIntensity), void 0 !== e.specularColor && void 0 !== r.specularColor && r.specularColor.setHex(e.specularColor), void 0 !== e.shininess && (r.shininess = e.shininess), void 0 !== e.clearcoat && (r.clearcoat = e.clearcoat), void 0 !== e.clearcoatRoughness && (r.clearcoatRoughness = e.clearcoatRoughness), void 0 !== e.iridescence && (r.iridescence = e.iridescence), void 0 !== e.iridescenceIOR && (r.iridescenceIOR = e.iridescenceIOR), void 0 !== e.iridescenceThicknessRange && (r.iridescenceThicknessRange = e.iridescenceThicknessRange), void 0 !== e.transmission && (r.transmission = e.transmission), void 0 !== e.thickness && (r.thickness = e.thickness), void 0 !== e.attenuationDistance && (r.attenuationDistance = e.attenuationDistance), void 0 !== e.attenuationColor && void 0 !== r.attenuationColor && r.attenuationColor.setHex(e.attenuationColor), void 0 !== e.anisotropy && (r.anisotropy = e.anisotropy), void 0 !== e.anisotropyRotation && (r.anisotropyRotation = e.anisotropyRotation), void 0 !== e.fog && (r.fog = e.fog), void 0 !== e.flatShading && (r.flatShading = e.flatShading), void 0 !== e.blending && (r.blending = e.blending), void 0 !== e.combine && (r.combine = e.combine), void 0 !== e.side && (r.side = e.side), void 0 !== e.shadowSide && (r.shadowSide = e.shadowSide), void 0 !== e.opacity && (r.opacity = e.opacity), void 0 !== e.transparent && (r.transparent = e.transparent), void 0 !== e.alphaTest && (r.alphaTest = e.alphaTest), void 0 !== e.alphaHash && (r.alphaHash = e.alphaHash), void 0 !== e.depthFunc && (r.depthFunc = e.depthFunc), void 0 !== e.depthTest && (r.depthTest = e.depthTest), void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (r.colorWrite = e.colorWrite), void 0 !== e.blendSrc && (r.blendSrc = e.blendSrc), void 0 !== e.blendDst && (r.blendDst = e.blendDst), void 0 !== e.blendEquation && (r.blendEquation = e.blendEquation), void 0 !== e.blendSrcAlpha && (r.blendSrcAlpha = e.blendSrcAlpha), void 0 !== e.blendDstAlpha && (r.blendDstAlpha = e.blendDstAlpha), void 0 !== e.blendEquationAlpha && (r.blendEquationAlpha = e.blendEquationAlpha), void 0 !== e.blendColor && void 0 !== r.blendColor && r.blendColor.setHex(e.blendColor), void 0 !== e.blendAlpha && (r.blendAlpha = e.blendAlpha), void 0 !== e.stencilWriteMask && (r.stencilWriteMask = e.stencilWriteMask), void 0 !== e.stencilFunc && (r.stencilFunc = e.stencilFunc), void 0 !== e.stencilRef && (r.stencilRef = e.stencilRef), void 0 !== e.stencilFuncMask && (r.stencilFuncMask = e.stencilFuncMask), void 0 !== e.stencilFail && (r.stencilFail = e.stencilFail), void 0 !== e.stencilZFail && (r.stencilZFail = e.stencilZFail), void 0 !== e.stencilZPass && (r.stencilZPass = e.stencilZPass), void 0 !== e.stencilWrite && (r.stencilWrite = e.stencilWrite), void 0 !== e.wireframe && (r.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (r.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (r.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (r.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (r.rotation = e.rotation), void 0 !== e.linewidth && (r.linewidth = e.linewidth), void 0 !== e.dashSize && (r.dashSize = e.dashSize), void 0 !== e.gapSize && (r.gapSize = e.gapSize), void 0 !== e.scale && (r.scale = e.scale), void 0 !== e.polygonOffset && (r.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (r.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (r.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.dithering && (r.dithering = e.dithering), void 0 !== e.alphaToCoverage && (r.alphaToCoverage = e.alphaToCoverage), void 0 !== e.premultipliedAlpha && (r.premultipliedAlpha = e.premultipliedAlpha), void 0 !== e.forceSinglePass && (r.forceSinglePass = e.forceSinglePass), void 0 !== e.visible && (r.visible = e.visible), void 0 !== e.toneMapped && (r.toneMapped = e.toneMapped), void 0 !== e.userData && (r.userData = e.userData), void 0 !== e.vertexColors && ("number" === typeof e.vertexColors ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), void 0 !== e.uniforms)
                    for (const i in e.uniforms) {
                        const t = e.uniforms[i];
                        switch (r.uniforms[i] = {}, t.type) {
                            case "t":
                                r.uniforms[i].value = n(t.value);
                                break;
                            case "c":
                                r.uniforms[i].value = (new Wd).setHex(t.value);
                                break;
                            case "v2":
                                r.uniforms[i].value = (new Yc).fromArray(t.value);
                                break;
                            case "v3":
                                r.uniforms[i].value = (new Pu).fromArray(t.value);
                                break;
                            case "v4":
                                r.uniforms[i].value = (new xu).fromArray(t.value);
                                break;
                            case "m3":
                                r.uniforms[i].value = (new Qc).fromArray(t.value);
                                break;
                            case "m4":
                                r.uniforms[i].value = (new od).fromArray(t.value);
                                break;
                            default:
                                r.uniforms[i].value = t.value
                        }
                    }
                if (void 0 !== e.defines && (r.defines = e.defines), void 0 !== e.vertexShader && (r.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (r.fragmentShader = e.fragmentShader), void 0 !== e.glslVersion && (r.glslVersion = e.glslVersion), void 0 !== e.extensions)
                    for (const i in e.extensions) r.extensions[i] = e.extensions[i];
                if (void 0 !== e.lights && (r.lights = e.lights), void 0 !== e.clipping && (r.clipping = e.clipping), void 0 !== e.size && (r.size = e.size), void 0 !== e.sizeAttenuation && (r.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (r.map = n(e.map)), void 0 !== e.matcap && (r.matcap = n(e.matcap)), void 0 !== e.alphaMap && (r.alphaMap = n(e.alphaMap)), void 0 !== e.bumpMap && (r.bumpMap = n(e.bumpMap)), void 0 !== e.bumpScale && (r.bumpScale = e.bumpScale), void 0 !== e.normalMap && (r.normalMap = n(e.normalMap)), void 0 !== e.normalMapType && (r.normalMapType = e.normalMapType), void 0 !== e.normalScale) {
                    let t = e.normalScale;
                    !1 === Array.isArray(t) && (t = [t, t]), r.normalScale = (new Yc).fromArray(t)
                }
                return void 0 !== e.displacementMap && (r.displacementMap = n(e.displacementMap)), void 0 !== e.displacementScale && (r.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (r.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (r.roughnessMap = n(e.roughnessMap)), void 0 !== e.metalnessMap && (r.metalnessMap = n(e.metalnessMap)), void 0 !== e.emissiveMap && (r.emissiveMap = n(e.emissiveMap)), void 0 !== e.emissiveIntensity && (r.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (r.specularMap = n(e.specularMap)), void 0 !== e.specularIntensityMap && (r.specularIntensityMap = n(e.specularIntensityMap)), void 0 !== e.specularColorMap && (r.specularColorMap = n(e.specularColorMap)), void 0 !== e.envMap && (r.envMap = n(e.envMap)), void 0 !== e.envMapIntensity && (r.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (r.reflectivity = e.reflectivity), void 0 !== e.refractionRatio && (r.refractionRatio = e.refractionRatio), void 0 !== e.lightMap && (r.lightMap = n(e.lightMap)), void 0 !== e.lightMapIntensity && (r.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (r.aoMap = n(e.aoMap)), void 0 !== e.aoMapIntensity && (r.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (r.gradientMap = n(e.gradientMap)), void 0 !== e.clearcoatMap && (r.clearcoatMap = n(e.clearcoatMap)), void 0 !== e.clearcoatRoughnessMap && (r.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), void 0 !== e.clearcoatNormalMap && (r.clearcoatNormalMap = n(e.clearcoatNormalMap)), void 0 !== e.clearcoatNormalScale && (r.clearcoatNormalScale = (new Yc).fromArray(e.clearcoatNormalScale)), void 0 !== e.iridescenceMap && (r.iridescenceMap = n(e.iridescenceMap)), void 0 !== e.iridescenceThicknessMap && (r.iridescenceThicknessMap = n(e.iridescenceThicknessMap)), void 0 !== e.transmissionMap && (r.transmissionMap = n(e.transmissionMap)), void 0 !== e.thicknessMap && (r.thicknessMap = n(e.thicknessMap)), void 0 !== e.anisotropyMap && (r.anisotropyMap = n(e.anisotropyMap)), void 0 !== e.sheenColorMap && (r.sheenColorMap = n(e.sheenColorMap)), void 0 !== e.sheenRoughnessMap && (r.sheenRoughnessMap = n(e.sheenRoughnessMap)), r
            }
            setTextures(e) {
                return this.textures = e, this
            }
            static createMaterialFromType(e) {
                return new {
                    ShadowMaterial: tb,
                    SpriteMaterial: ng,
                    RawShaderMaterial: nb,
                    ShaderMaterial: Xh,
                    PointsMaterial: bv,
                    MeshPhysicalMaterial: ib,
                    MeshStandardMaterial: rb,
                    MeshPhongMaterial: ob,
                    MeshToonMaterial: ab,
                    MeshNormalMaterial: sb,
                    MeshLambertMaterial: lb,
                    MeshDepthMaterial: Lm,
                    MeshDistanceMaterial: Dm,
                    MeshBasicMaterial: Yd,
                    MeshMatcapMaterial: cb,
                    LineDashedMaterial: ub,
                    LineBasicMaterial: lv,
                    Material: Jd
                }[e]
            }
        }
        class ux {
            static decodeText(e) {
                if ("undefined" !== typeof TextDecoder) return (new TextDecoder).decode(e);
                let t = "";
                for (let r = 0, i = e.length; r < i; r++) t += String.fromCharCode(e[r]);
                try {
                    return decodeURIComponent(escape(t))
                } catch (n) {
                    return t
                }
            }
            static extractUrlBase(e) {
                const t = e.lastIndexOf("/");
                return -1 === t ? "./" : e.slice(0, t + 1)
            }
            static resolveURL(e, t) {
                return "string" !== typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
            }
        }
        class dx extends Mh {
            constructor() {
                super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
            }
            copy(e) {
                return super.copy(e), this.instanceCount = e.instanceCount, this
            }
            toJSON() {
                const e = super.toJSON();
                return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e
            }
        }
        class hx extends Lb {
            constructor(e) {
                super(e)
            }
            load(e, t, n, r) {
                const i = this,
                    o = new kb(i.manager);
                o.setPath(i.path), o.setRequestHeader(i.requestHeader), o.setWithCredentials(i.withCredentials), o.load(e, (function(n) {
                    try {
                        t(i.parse(JSON.parse(n)))
                    } catch (o) {
                        r ? r(o) : console.error(o), i.manager.itemError(e)
                    }
                }), n, r)
            }
            parse(e) {
                const t = {},
                    n = {};

                function r(e, r) {
                    if (void 0 !== t[r]) return t[r];
                    const i = e.interleavedBuffers[r],
                        o = function(e, t) {
                            if (void 0 !== n[t]) return n[t];
                            const r = e.arrayBuffers,
                                i = r[t],
                                o = new Uint32Array(i).buffer;
                            return n[t] = o, o
                        }(e, i.buffer),
                        a = tu(i.type, o),
                        s = new $m(a, i.stride);
                    return s.uuid = i.uuid, t[r] = s, s
                }
                const i = e.isInstancedBufferGeometry ? new dx : new Mh,
                    o = e.data.index;
                if (void 0 !== o) {
                    const e = tu(o.type, o.array);
                    i.setIndex(new ih(e, 1))
                }
                const a = e.data.attributes;
                for (const u in a) {
                    const t = a[u];
                    let n;
                    if (t.isInterleavedBufferAttribute) {
                        const i = r(e.data, t.data);
                        n = new tg(i, t.itemSize, t.offset, t.normalized)
                    } else {
                        const e = tu(t.type, t.array);
                        n = new(t.isInstancedBufferAttribute ? Ng : ih)(e, t.itemSize, t.normalized)
                    }
                    void 0 !== t.name && (n.name = t.name), void 0 !== t.usage && n.setUsage(t.usage), i.setAttribute(u, n)
                }
                const s = e.data.morphAttributes;
                if (s)
                    for (const u in s) {
                        const t = s[u],
                            n = [];
                        for (let i = 0, o = t.length; i < o; i++) {
                            const o = t[i];
                            let a;
                            if (o.isInterleavedBufferAttribute) {
                                const t = r(e.data, o.data);
                                a = new tg(t, o.itemSize, o.offset, o.normalized)
                            } else {
                                const e = tu(o.type, o.array);
                                a = new ih(e, o.itemSize, o.normalized)
                            }
                            void 0 !== o.name && (a.name = o.name), n.push(a)
                        }
                        i.morphAttributes[u] = n
                    }
                e.data.morphTargetsRelative && (i.morphTargetsRelative = !0);
                const l = e.data.groups || e.data.drawcalls || e.data.offsets;
                if (void 0 !== l)
                    for (let u = 0, d = l.length; u !== d; ++u) {
                        const e = l[u];
                        i.addGroup(e.start, e.count, e.materialIndex)
                    }
                const c = e.data.boundingSphere;
                if (void 0 !== c) {
                    const e = new Pu;
                    void 0 !== c.center && e.fromArray(c.center), i.boundingSphere = new Yu(e, c.radius)
                }
                return e.name && (i.name = e.name), e.userData && (i.userData = e.userData), i
            }
        }
        class px extends Lb {
            constructor(e) {
                super(e)
            }
            load(e, t, n, r) {
                const i = this,
                    o = "" === this.path ? ux.extractUrlBase(e) : this.path;
                this.resourcePath = this.resourcePath || o;
                const a = new kb(this.manager);
                a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, (function(n) {
                    let o = null;
                    try {
                        o = JSON.parse(n)
                    } catch (s) {
                        return void 0 !== r && r(s), void console.error("THREE:ObjectLoader: Can't parse " + e + ".", s.message)
                    }
                    const a = o.metadata;
                    if (void 0 === a || void 0 === a.type || "geometry" === a.type.toLowerCase()) return void 0 !== r && r(new Error("THREE.ObjectLoader: Can't load " + e)), void console.error("THREE.ObjectLoader: Can't load " + e);
                    i.parse(o, t)
                }), n, r)
            }
            async loadAsync(e, t) {
                const n = "" === this.path ? ux.extractUrlBase(e) : this.path;
                this.resourcePath = this.resourcePath || n;
                const r = new kb(this.manager);
                r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials);
                const i = await r.loadAsync(e, t),
                    o = JSON.parse(i),
                    a = o.metadata;
                if (void 0 === a || void 0 === a.type || "geometry" === a.type.toLowerCase()) throw new Error("THREE.ObjectLoader: Can't load " + e);
                return await this.parseAsync(o)
            }
            parse(e, t) {
                const n = this.parseAnimations(e.animations),
                    r = this.parseShapes(e.shapes),
                    i = this.parseGeometries(e.geometries, r),
                    o = this.parseImages(e.images, (function() {
                        void 0 !== t && t(l)
                    })),
                    a = this.parseTextures(e.textures, o),
                    s = this.parseMaterials(e.materials, a),
                    l = this.parseObject(e.object, i, s, a, n),
                    c = this.parseSkeletons(e.skeletons, l);
                if (this.bindSkeletons(l, c), void 0 !== t) {
                    let e = !1;
                    for (const t in o)
                        if (o[t].data instanceof HTMLImageElement) {
                            e = !0;
                            break
                        }!1 === e && t(l)
                }
                return l
            }
            async parseAsync(e) {
                const t = this.parseAnimations(e.animations),
                    n = this.parseShapes(e.shapes),
                    r = this.parseGeometries(e.geometries, n),
                    i = await this.parseImagesAsync(e.images),
                    o = this.parseTextures(e.textures, i),
                    a = this.parseMaterials(e.materials, o),
                    s = this.parseObject(e.object, r, a, o, t),
                    l = this.parseSkeletons(e.skeletons, s);
                return this.bindSkeletons(s, l), s
            }
            parseShapes(e) {
                const t = {};
                if (void 0 !== e)
                    for (let n = 0, r = e.length; n < r; n++) {
                        const r = (new hy).fromJSON(e[n]);
                        t[r.uuid] = r
                    }
                return t
            }
            parseSkeletons(e, t) {
                const n = {},
                    r = {};
                if (t.traverse((function(e) {
                        e.isBone && (r[e.uuid] = e)
                    })), void 0 !== e)
                    for (let i = 0, o = e.length; i < o; i++) {
                        const t = (new Dg).fromJSON(e[i], r);
                        n[t.uuid] = t
                    }
                return n
            }
            parseGeometries(e, t) {
                const n = {};
                if (void 0 !== e) {
                    const r = new hx;
                    for (let i = 0, o = e.length; i < o; i++) {
                        let o;
                        const a = e[i];
                        switch (a.type) {
                            case "BufferGeometry":
                            case "InstancedBufferGeometry":
                                o = r.parse(a);
                                break;
                            default:
                                a.type in eb ? o = eb[a.type].fromJSON(a, t) : console.warn('THREE.ObjectLoader: Unsupported geometry type "'.concat(a.type, '"'))
                        }
                        o.uuid = a.uuid, void 0 !== a.name && (o.name = a.name), void 0 !== a.userData && (o.userData = a.userData), n[a.uuid] = o
                    }
                }
                return n
            }
            parseMaterials(e, t) {
                const n = {},
                    r = {};
                if (void 0 !== e) {
                    const i = new cx;
                    i.setTextures(t);
                    for (let t = 0, o = e.length; t < o; t++) {
                        const o = e[t];
                        void 0 === n[o.uuid] && (n[o.uuid] = i.parse(o)), r[o.uuid] = n[o.uuid]
                    }
                }
                return r
            }
            parseAnimations(e) {
                const t = {};
                if (void 0 !== e)
                    for (let n = 0; n < e.length; n++) {
                        const r = e[n],
                            i = Pb.parse(r);
                        t[i.uuid] = i
                    }
                return t
            }
            parseImages(e, t) {
                const n = this,
                    r = {};
                let i;

                function o(e) {
                    if ("string" === typeof e) {
                        const t = e;
                        return function(e) {
                            return n.manager.itemStart(e), i.load(e, (function() {
                                n.manager.itemEnd(e)
                            }), void 0, (function() {
                                n.manager.itemError(e), n.manager.itemEnd(e)
                            }))
                        }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(t) ? t : n.resourcePath + t)
                    }
                    return e.data ? {
                        data: tu(e.type, e.data),
                        width: e.width,
                        height: e.height
                    } : null
                }
                if (void 0 !== e && e.length > 0) {
                    const n = new Ob(t);
                    i = new zb(n), i.setCrossOrigin(this.crossOrigin);
                    for (let t = 0, i = e.length; t < i; t++) {
                        const n = e[t],
                            i = n.url;
                        if (Array.isArray(i)) {
                            const e = [];
                            for (let t = 0, n = i.length; t < n; t++) {
                                const n = o(i[t]);
                                null !== n && (n instanceof HTMLImageElement ? e.push(n) : e.push(new Og(n.data, n.width, n.height)))
                            }
                            r[n.uuid] = new gu(e)
                        } else {
                            const e = o(n.url);
                            r[n.uuid] = new gu(e)
                        }
                    }
                }
                return r
            }
            async parseImagesAsync(e) {
                const t = this,
                    n = {};
                let r;
                async function i(e) {
                    if ("string" === typeof e) {
                        const n = e,
                            i = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(n) ? n : t.resourcePath + n;
                        return await r.loadAsync(i)
                    }
                    return e.data ? {
                        data: tu(e.type, e.data),
                        width: e.width,
                        height: e.height
                    } : null
                }
                if (void 0 !== e && e.length > 0) {
                    r = new zb(this.manager), r.setCrossOrigin(this.crossOrigin);
                    for (let t = 0, r = e.length; t < r; t++) {
                        const r = e[t],
                            o = r.url;
                        if (Array.isArray(o)) {
                            const e = [];
                            for (let t = 0, n = o.length; t < n; t++) {
                                const n = o[t],
                                    r = await i(n);
                                null !== r && (r instanceof HTMLImageElement ? e.push(r) : e.push(new Og(r.data, r.width, r.height)))
                            }
                            n[r.uuid] = new gu(e)
                        } else {
                            const e = await i(r.url);
                            n[r.uuid] = new gu(e)
                        }
                    }
                }
                return n
            }
            parseTextures(e, t) {
                function n(e, t) {
                    return "number" === typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e])
                }
                const r = {};
                if (void 0 !== e)
                    for (let i = 0, o = e.length; i < o; i++) {
                        const o = e[i];
                        void 0 === o.image && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid), void 0 === t[o.image] && console.warn("THREE.ObjectLoader: Undefined image", o.image);
                        const a = t[o.image],
                            s = a.data;
                        let l;
                        Array.isArray(s) ? (l = new tp, 6 === s.length && (l.needsUpdate = !0)) : (l = s && s.data ? new Og : new bu, s && (l.needsUpdate = !0)), l.source = a, l.uuid = o.uuid, void 0 !== o.name && (l.name = o.name), void 0 !== o.mapping && (l.mapping = n(o.mapping, fx)), void 0 !== o.channel && (l.channel = o.channel), void 0 !== o.offset && l.offset.fromArray(o.offset), void 0 !== o.repeat && l.repeat.fromArray(o.repeat), void 0 !== o.center && l.center.fromArray(o.center), void 0 !== o.rotation && (l.rotation = o.rotation), void 0 !== o.wrap && (l.wrapS = n(o.wrap[0], mx), l.wrapT = n(o.wrap[1], mx)), void 0 !== o.format && (l.format = o.format), void 0 !== o.internalFormat && (l.internalFormat = o.internalFormat), void 0 !== o.type && (l.type = o.type), void 0 !== o.colorSpace && (l.colorSpace = o.colorSpace), void 0 !== o.encoding && (l.encoding = o.encoding), void 0 !== o.minFilter && (l.minFilter = n(o.minFilter, gx)), void 0 !== o.magFilter && (l.magFilter = n(o.magFilter, gx)), void 0 !== o.anisotropy && (l.anisotropy = o.anisotropy), void 0 !== o.flipY && (l.flipY = o.flipY), void 0 !== o.generateMipmaps && (l.generateMipmaps = o.generateMipmaps), void 0 !== o.premultiplyAlpha && (l.premultiplyAlpha = o.premultiplyAlpha), void 0 !== o.unpackAlignment && (l.unpackAlignment = o.unpackAlignment), void 0 !== o.compareFunction && (l.compareFunction = o.compareFunction), void 0 !== o.userData && (l.userData = o.userData), r[o.uuid] = l
                    }
                return r
            }
            parseObject(e, t, n, r, i) {
                let o, a, s;

                function l(e) {
                    return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e]
                }

                function c(e) {
                    if (void 0 !== e) {
                        if (Array.isArray(e)) {
                            const t = [];
                            for (let r = 0, i = e.length; r < i; r++) {
                                const i = e[r];
                                void 0 === n[i] && console.warn("THREE.ObjectLoader: Undefined material", i), t.push(n[i])
                            }
                            return t
                        }
                        return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined material", e), n[e]
                    }
                }

                function u(e) {
                    return void 0 === r[e] && console.warn("THREE.ObjectLoader: Undefined texture", e), r[e]
                }
                switch (e.type) {
                    case "Scene":
                        o = new Zm, void 0 !== e.background && (Number.isInteger(e.background) ? o.background = new Wd(e.background) : o.background = u(e.background)), void 0 !== e.environment && (o.environment = u(e.environment)), void 0 !== e.fog && ("Fog" === e.fog.type ? o.fog = new Qm(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (o.fog = new Ym(e.fog.color, e.fog.density)), "" !== e.fog.name && (o.fog.name = e.fog.name)), void 0 !== e.backgroundBlurriness && (o.backgroundBlurriness = e.backgroundBlurriness), void 0 !== e.backgroundIntensity && (o.backgroundIntensity = e.backgroundIntensity);
                        break;
                    case "PerspectiveCamera":
                        o = new Zh(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (o.focus = e.focus), void 0 !== e.zoom && (o.zoom = e.zoom), void 0 !== e.filmGauge && (o.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (o.filmOffset = e.filmOffset), void 0 !== e.view && (o.view = Object.assign({}, e.view));
                        break;
                    case "OrthographicCamera":
                        o = new wp(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (o.zoom = e.zoom), void 0 !== e.view && (o.view = Object.assign({}, e.view));
                        break;
                    case "AmbientLight":
                        o = new ox(e.color, e.intensity);
                        break;
                    case "DirectionalLight":
                        o = new ix(e.color, e.intensity);
                        break;
                    case "PointLight":
                        o = new nx(e.color, e.intensity, e.distance, e.decay);
                        break;
                    case "RectAreaLight":
                        o = new ax(e.color, e.intensity, e.width, e.height);
                        break;
                    case "SpotLight":
                        o = new Qb(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                        break;
                    case "HemisphereLight":
                        o = new qb(e.color, e.groundColor, e.intensity);
                        break;
                    case "LightProbe":
                        o = (new lx).fromJSON(e);
                        break;
                    case "SkinnedMesh":
                        a = l(e.geometry), s = c(e.material), o = new Rg(a, s), void 0 !== e.bindMode && (o.bindMode = e.bindMode), void 0 !== e.bindMatrix && o.bindMatrix.fromArray(e.bindMatrix), void 0 !== e.skeleton && (o.skeleton = e.skeleton);
                        break;
                    case "Mesh":
                        a = l(e.geometry), s = c(e.material), o = new zh(a, s);
                        break;
                    case "InstancedMesh":
                        a = l(e.geometry), s = c(e.material);
                        const t = e.count,
                            n = e.instanceMatrix,
                            r = e.instanceColor;
                        o = new Vg(a, s, t), o.instanceMatrix = new Ng(new Float32Array(n.array), 16), void 0 !== r && (o.instanceColor = new Ng(new Float32Array(r.array), r.itemSize));
                        break;
                    case "BatchedMesh":
                        a = l(e.geometry), s = c(e.material), o = new sv(e.maxGeometryCount, e.maxVertexCount, e.maxIndexCount, s), o.geometry = a, o.perObjectFrustumCulled = e.perObjectFrustumCulled, o.sortObjects = e.sortObjects, o._drawRanges = e.drawRanges, o._reservedRanges = e.reservedRanges, o._visibility = e.visibility, o._active = e.active, o._bounds = e.bounds.map((e => {
                            const t = new Ou;
                            t.min.fromArray(e.boxMin), t.max.fromArray(e.boxMax);
                            const n = new Yu;
                            return n.radius = e.sphereRadius, n.center.fromArray(e.sphereCenter), {
                                boxInitialized: e.boxInitialized,
                                box: t,
                                sphereInitialized: e.sphereInitialized,
                                sphere: n
                            }
                        })), o._maxGeometryCount = e.maxGeometryCount, o._maxVertexCount = e.maxVertexCount, o._maxIndexCount = e.maxIndexCount, o._geometryInitialized = e.geometryInitialized, o._geometryCount = e.geometryCount, o._matricesTexture = u(e.matricesTexture.uuid);
                        break;
                    case "LOD":
                        o = new xg;
                        break;
                    case "Line":
                        o = new fv(l(e.geometry), c(e.material));
                        break;
                    case "LineLoop":
                        o = new yv(l(e.geometry), c(e.material));
                        break;
                    case "LineSegments":
                        o = new vv(l(e.geometry), c(e.material));
                        break;
                    case "PointCloud":
                    case "Points":
                        o = new Av(l(e.geometry), c(e.material));
                        break;
                    case "Sprite":
                        o = new gg(c(e.material));
                        break;
                    case "Group":
                        o = new Hm;
                        break;
                    case "Bone":
                        o = new Ig;
                        break;
                    default:
                        o = new Rd
                }
                if (o.uuid = e.uuid, void 0 !== e.name && (o.name = e.name), void 0 !== e.matrix ? (o.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (o.matrixAutoUpdate = e.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (void 0 !== e.position && o.position.fromArray(e.position), void 0 !== e.rotation && o.rotation.fromArray(e.rotation), void 0 !== e.quaternion && o.quaternion.fromArray(e.quaternion), void 0 !== e.scale && o.scale.fromArray(e.scale)), void 0 !== e.up && o.up.fromArray(e.up), void 0 !== e.castShadow && (o.castShadow = e.castShadow), void 0 !== e.receiveShadow && (o.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (o.shadow.bias = e.shadow.bias), void 0 !== e.shadow.normalBias && (o.shadow.normalBias = e.shadow.normalBias), void 0 !== e.shadow.radius && (o.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && o.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (o.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (o.visible = e.visible), void 0 !== e.frustumCulled && (o.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (o.renderOrder = e.renderOrder), void 0 !== e.userData && (o.userData = e.userData), void 0 !== e.layers && (o.layers.mask = e.layers), void 0 !== e.children) {
                    const a = e.children;
                    for (let e = 0; e < a.length; e++) o.add(this.parseObject(a[e], t, n, r, i))
                }
                if (void 0 !== e.animations) {
                    const t = e.animations;
                    for (let e = 0; e < t.length; e++) {
                        const n = t[e];
                        o.animations.push(i[n])
                    }
                }
                if ("LOD" === e.type) {
                    void 0 !== e.autoUpdate && (o.autoUpdate = e.autoUpdate);
                    const t = e.levels;
                    for (let e = 0; e < t.length; e++) {
                        const n = t[e],
                            r = o.getObjectByProperty("uuid", n.object);
                        void 0 !== r && o.addLevel(r, n.distance, n.hysteresis)
                    }
                }
                return o
            }
            bindSkeletons(e, t) {
                0 !== Object.keys(t).length && e.traverse((function(e) {
                    if (!0 === e.isSkinnedMesh && void 0 !== e.skeleton) {
                        const n = t[e.skeleton];
                        void 0 === n ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", e.skeleton) : e.bind(n, e.bindMatrix)
                    }
                }))
            }
        }
        const fx = {
                UVMapping: is,
                CubeReflectionMapping: os,
                CubeRefractionMapping: as,
                EquirectangularReflectionMapping: ss,
                EquirectangularRefractionMapping: ls,
                CubeUVReflectionMapping: cs
            },
            mx = {
                RepeatWrapping: us,
                ClampToEdgeWrapping: ds,
                MirroredRepeatWrapping: hs
            },
            gx = {
                NearestFilter: ps,
                NearestMipmapNearestFilter: fs,
                NearestMipmapLinearFilter: gs,
                LinearFilter: ys,
                LinearMipmapNearestFilter: bs,
                LinearMipmapLinearFilter: _s
            };
        class vx extends Lb {
            constructor(e) {
                super(e), this.isImageBitmapLoader = !0, "undefined" === typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" === typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                    premultiplyAlpha: "none"
                }
            }
            setOptions(e) {
                return this.options = e, this
            }
            load(e, t, n, r) {
                void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                const i = this,
                    o = Ib.get(e);
                if (void 0 !== o) return i.manager.itemStart(e), o.then ? void o.then((n => {
                    t && t(n), i.manager.itemEnd(e)
                })).catch((e => {
                    r && r(e)
                })) : (setTimeout((function() {
                    t && t(o), i.manager.itemEnd(e)
                }), 0), o);
                const a = {};
                a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a.headers = this.requestHeader;
                const s = fetch(e, a).then((function(e) {
                    return e.blob()
                })).then((function(e) {
                    return createImageBitmap(e, Object.assign(i.options, {
                        colorSpaceConversion: "none"
                    }))
                })).then((function(n) {
                    return Ib.add(e, n), t && t(n), i.manager.itemEnd(e), n
                })).catch((function(t) {
                    r && r(t), Ib.remove(e), i.manager.itemError(e), i.manager.itemEnd(e)
                }));
                Ib.add(e, s), i.manager.itemStart(e)
            }
        }
        let yx;
        class bx {
            static getContext() {
                return void 0 === yx && (yx = new(window.AudioContext || window.webkitAudioContext)), yx
            }
            static setContext(e) {
                yx = e
            }
        }
        class xx extends Lb {
            constructor(e) {
                super(e)
            }
            load(e, t, n, r) {
                const i = this,
                    o = new kb(this.manager);

                function a(t) {
                    r ? r(t) : console.error(t), i.manager.itemError(e)
                }
                o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, (function(e) {
                    try {
                        const n = e.slice(0);
                        bx.getContext().decodeAudioData(n, (function(e) {
                            t(e)
                        })).catch(a)
                    } catch (n) {
                        a(n)
                    }
                }), n, r)
            }
        }
        const _x = new od,
            Mx = new od,
            wx = new od;
        class Ax {
            constructor() {
                this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Zh, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Zh, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
                    focus: null,
                    fov: null,
                    aspect: null,
                    near: null,
                    far: null,
                    zoom: null,
                    eyeSep: null
                }
            }
            update(e) {
                const t = this._cache;
                if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
                    t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, wx.copy(e.projectionMatrix);
                    const n = t.eyeSep / 2,
                        r = n * t.near / t.focus,
                        i = t.near * Math.tan(Uc * t.fov * .5) / t.zoom;
                    let o, a;
                    Mx.elements[12] = -n, _x.elements[12] = n, o = -i * t.aspect + r, a = i * t.aspect + r, wx.elements[0] = 2 * t.near / (a - o), wx.elements[8] = (a + o) / (a - o), this.cameraL.projectionMatrix.copy(wx), o = -i * t.aspect - r, a = i * t.aspect - r, wx.elements[0] = 2 * t.near / (a - o), wx.elements[8] = (a + o) / (a - o), this.cameraR.projectionMatrix.copy(wx)
                }
                this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Mx), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(_x)
            }
        }
        class Sx {
            constructor() {
                let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }
            start() {
                this.startTime = Ex(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
            }
            stop() {
                this.getElapsedTime(), this.running = !1, this.autoStart = !1
            }
            getElapsedTime() {
                return this.getDelta(), this.elapsedTime
            }
            getDelta() {
                let e = 0;
                if (this.autoStart && !this.running) return this.start(), 0;
                if (this.running) {
                    const t = Ex();
                    e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
                }
                return e
            }
        }

        function Ex() {
            return ("undefined" === typeof performance ? Date : performance).now()
        }
        const Cx = new Pu,
            Tx = new Tu,
            Px = new Pu,
            Rx = new Pu;
        class Ix extends Rd {
            constructor() {
                super(), this.type = "AudioListener", this.context = bx.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Sx
            }
            getInput() {
                return this.gain
            }
            removeFilter() {
                return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
            }
            getFilter() {
                return this.filter
            }
            setFilter(e) {
                return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
            }
            getMasterVolume() {
                return this.gain.gain.value
            }
            setMasterVolume(e) {
                return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
            }
            updateMatrixWorld(e) {
                super.updateMatrixWorld(e);
                const t = this.context.listener,
                    n = this.up;
                if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Cx, Tx, Px), Rx.set(0, 0, -1).applyQuaternion(Tx), t.positionX) {
                    const e = this.context.currentTime + this.timeDelta;
                    t.positionX.linearRampToValueAtTime(Cx.x, e), t.positionY.linearRampToValueAtTime(Cx.y, e), t.positionZ.linearRampToValueAtTime(Cx.z, e), t.forwardX.linearRampToValueAtTime(Rx.x, e), t.forwardY.linearRampToValueAtTime(Rx.y, e), t.forwardZ.linearRampToValueAtTime(Rx.z, e), t.upX.linearRampToValueAtTime(n.x, e), t.upY.linearRampToValueAtTime(n.y, e), t.upZ.linearRampToValueAtTime(n.z, e)
                } else t.setPosition(Cx.x, Cx.y, Cx.z), t.setOrientation(Rx.x, Rx.y, Rx.z, n.x, n.y, n.z)
            }
        }
        class Ox extends Rd {
            constructor(e) {
                super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
            }
            getOutput() {
                return this.gain
            }
            setNodeSource(e) {
                return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
            }
            setMediaElementSource(e) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
            }
            setMediaStreamSource(e) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
            }
            setBuffer(e) {
                return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
            }
            play() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
                if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
                this._startedAt = this.context.currentTime + e;
                const t = this.context.createBufferSource();
                return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
            }
            pause() {
                if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            stop() {
                if (!1 !== this.hasPlaybackControl) return this._progress = 0, null !== this.source && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            connect() {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else this.source.connect(this.getOutput());
                return this._connected = !0, this
            }
            disconnect() {
                if (!1 !== this._connected) {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this._connected = !1, this
                }
            }
            getFilters() {
                return this.filters
            }
            setFilters(e) {
                return e || (e = []), !0 === this._connected ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this
            }
            setDetune(e) {
                return this.detune = e, !0 === this.isPlaying && void 0 !== this.source.detune && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
            }
            getDetune() {
                return this.detune
            }
            getFilter() {
                return this.getFilters()[0]
            }
            setFilter(e) {
                return this.setFilters(e ? [e] : [])
            }
            setPlaybackRate(e) {
                if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            getPlaybackRate() {
                return this.playbackRate
            }
            onEnded() {
                this.isPlaying = !1
            }
            getLoop() {
                return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
            }
            setLoop(e) {
                if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            setLoopStart(e) {
                return this.loopStart = e, this
            }
            setLoopEnd(e) {
                return this.loopEnd = e, this
            }
            getVolume() {
                return this.gain.gain.value
            }
            setVolume(e) {
                return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
            }
        }
        const Bx = new Pu,
            Lx = new Tu,
            Dx = new Pu,
            Nx = new Pu;
        class kx extends Ox {
            constructor(e) {
                super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
            }
            connect() {
                super.connect(), this.panner.connect(this.gain)
            }
            disconnect() {
                super.disconnect(), this.panner.disconnect(this.gain)
            }
            getOutput() {
                return this.panner
            }
            getRefDistance() {
                return this.panner.refDistance
            }
            setRefDistance(e) {
                return this.panner.refDistance = e, this
            }
            getRolloffFactor() {
                return this.panner.rolloffFactor
            }
            setRolloffFactor(e) {
                return this.panner.rolloffFactor = e, this
            }
            getDistanceModel() {
                return this.panner.distanceModel
            }
            setDistanceModel(e) {
                return this.panner.distanceModel = e, this
            }
            getMaxDistance() {
                return this.panner.maxDistance
            }
            setMaxDistance(e) {
                return this.panner.maxDistance = e, this
            }
            setDirectionalCone(e, t, n) {
                return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this
            }
            updateMatrixWorld(e) {
                if (super.updateMatrixWorld(e), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return;
                this.matrixWorld.decompose(Bx, Lx, Dx), Nx.set(0, 0, 1).applyQuaternion(Lx);
                const t = this.panner;
                if (t.positionX) {
                    const e = this.context.currentTime + this.listener.timeDelta;
                    t.positionX.linearRampToValueAtTime(Bx.x, e), t.positionY.linearRampToValueAtTime(Bx.y, e), t.positionZ.linearRampToValueAtTime(Bx.z, e), t.orientationX.linearRampToValueAtTime(Nx.x, e), t.orientationY.linearRampToValueAtTime(Nx.y, e), t.orientationZ.linearRampToValueAtTime(Nx.z, e)
                } else t.setPosition(Bx.x, Bx.y, Bx.z), t.setOrientation(Nx.x, Nx.y, Nx.z)
            }
        }
        class Fx {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2048;
                this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
            }
            getFrequencyData() {
                return this.analyser.getByteFrequencyData(this.data), this.data
            }
            getAverageFrequency() {
                let e = 0;
                const t = this.getFrequencyData();
                for (let n = 0; n < t.length; n++) e += t[n];
                return e / t.length
            }
        }
        class Ux {
            constructor(e, t, n) {
                let r, i, o;
                switch (this.binding = e, this.valueSize = n, t) {
                    case "quaternion":
                        r = this._slerp, i = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                        break;
                    case "string":
                    case "bool":
                        r = this._select, i = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
                        break;
                    default:
                        r = this._lerp, i = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
                }
                this._mixBufferRegion = r, this._mixBufferRegionAdditive = i, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
            }
            accumulate(e, t) {
                const n = this.buffer,
                    r = this.valueSize,
                    i = e * r + r;
                let o = this.cumulativeWeight;
                if (0 === o) {
                    for (let e = 0; e !== r; ++e) n[i + e] = n[e];
                    o = t
                } else {
                    o += t;
                    const e = t / o;
                    this._mixBufferRegion(n, i, 0, e, r)
                }
                this.cumulativeWeight = o
            }
            accumulateAdditive(e) {
                const t = this.buffer,
                    n = this.valueSize,
                    r = n * this._addIndex;
                0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, n), this.cumulativeWeightAdditive += e
            }
            apply(e) {
                const t = this.valueSize,
                    n = this.buffer,
                    r = e * t + t,
                    i = this.cumulativeWeight,
                    o = this.cumulativeWeightAdditive,
                    a = this.binding;
                if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i < 1) {
                    const e = t * this._origIndex;
                    this._mixBufferRegion(n, r, e, 1 - i, t)
                }
                o > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * t, 1, t);
                for (let s = t, l = t + t; s !== l; ++s)
                    if (n[s] !== n[s + t]) {
                        a.setValue(n, r);
                        break
                    }
            }
            saveOriginalState() {
                const e = this.binding,
                    t = this.buffer,
                    n = this.valueSize,
                    r = n * this._origIndex;
                e.getValue(t, r);
                for (let i = n, o = r; i !== o; ++i) t[i] = t[r + i % n];
                this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
            }
            restoreOriginalState() {
                const e = 3 * this.valueSize;
                this.binding.setValue(this.buffer, e)
            }
            _setAdditiveIdentityNumeric() {
                const e = this._addIndex * this.valueSize,
                    t = e + this.valueSize;
                for (let n = e; n < t; n++) this.buffer[n] = 0
            }
            _setAdditiveIdentityQuaternion() {
                this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
            }
            _setAdditiveIdentityOther() {
                const e = this._origIndex * this.valueSize,
                    t = this._addIndex * this.valueSize;
                for (let n = 0; n < this.valueSize; n++) this.buffer[t + n] = this.buffer[e + n]
            }
            _select(e, t, n, r, i) {
                if (r >= .5)
                    for (let o = 0; o !== i; ++o) e[t + o] = e[n + o]
            }
            _slerp(e, t, n, r) {
                Tu.slerpFlat(e, t, e, t, e, n, r)
            }
            _slerpAdditive(e, t, n, r, i) {
                const o = this._workIndex * i;
                Tu.multiplyQuaternionsFlat(e, o, e, t, e, n), Tu.slerpFlat(e, t, e, t, e, o, r)
            }
            _lerp(e, t, n, r, i) {
                const o = 1 - r;
                for (let a = 0; a !== i; ++a) {
                    const i = t + a;
                    e[i] = e[i] * o + e[n + a] * r
                }
            }
            _lerpAdditive(e, t, n, r, i) {
                for (let o = 0; o !== i; ++o) {
                    const i = t + o;
                    e[i] = e[i] + e[n + o] * r
                }
            }
        }
        const zx = "\\[\\]\\.:\\/",
            Hx = new RegExp("[" + zx + "]", "g"),
            jx = "[^" + zx + "]",
            Gx = "[^" + zx.replace("\\.", "") + "]",
            Vx = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", jx) + /(WCOD+)?/.source.replace("WCOD", Gx) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", jx) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", jx) + "$"),
            qx = ["material", "materials", "bones", "map"];
        class Wx {
            constructor(e, t, n) {
                this.path = t, this.parsedPath = n || Wx.parseTrackName(t), this.node = Wx.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
            static create(e, t, n) {
                return e && e.isAnimationObjectGroup ? new Wx.Composite(e, t, n) : new Wx(e, t, n)
            }
            static sanitizeNodeName(e) {
                return e.replace(/\s/g, "_").replace(Hx, "")
            }
            static parseTrackName(e) {
                const t = Vx.exec(e);
                if (null === t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                const n = {
                        nodeName: t[2],
                        objectName: t[3],
                        objectIndex: t[4],
                        propertyName: t[5],
                        propertyIndex: t[6]
                    },
                    r = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== r && -1 !== r) {
                    const e = n.nodeName.substring(r + 1); - 1 !== qx.indexOf(e) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = e)
                }
                if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                return n
            }
            static findNode(e, t) {
                if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
                if (e.skeleton) {
                    const n = e.skeleton.getBoneByName(t);
                    if (void 0 !== n) return n
                }
                if (e.children) {
                    const n = function(e) {
                            for (let r = 0; r < e.length; r++) {
                                const i = e[r];
                                if (i.name === t || i.uuid === t) return i;
                                const o = n(i.children);
                                if (o) return o
                            }
                            return null
                        },
                        r = n(e.children);
                    if (r) return r
                }
                return null
            }
            _getValue_unavailable() {}
            _setValue_unavailable() {}
            _getValue_direct(e, t) {
                e[t] = this.targetObject[this.propertyName]
            }
            _getValue_array(e, t) {
                const n = this.resolvedProperty;
                for (let r = 0, i = n.length; r !== i; ++r) e[t++] = n[r]
            }
            _getValue_arrayElement(e, t) {
                e[t] = this.resolvedProperty[this.propertyIndex]
            }
            _getValue_toArray(e, t) {
                this.resolvedProperty.toArray(e, t)
            }
            _setValue_direct(e, t) {
                this.targetObject[this.propertyName] = e[t]
            }
            _setValue_direct_setNeedsUpdate(e, t) {
                this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
            }
            _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
                this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_array(e, t) {
                const n = this.resolvedProperty;
                for (let r = 0, i = n.length; r !== i; ++r) n[r] = e[t++]
            }
            _setValue_array_setNeedsUpdate(e, t) {
                const n = this.resolvedProperty;
                for (let r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                this.targetObject.needsUpdate = !0
            }
            _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
                const n = this.resolvedProperty;
                for (let r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_arrayElement(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t]
            }
            _setValue_arrayElement_setNeedsUpdate(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
            }
            _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_fromArray(e, t) {
                this.resolvedProperty.fromArray(e, t)
            }
            _setValue_fromArray_setNeedsUpdate(e, t) {
                this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
            }
            _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
                this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _getValue_unbound(e, t) {
                this.bind(), this.getValue(e, t)
            }
            _setValue_unbound(e, t) {
                this.bind(), this.setValue(e, t)
            }
            bind() {
                let e = this.node;
                const t = this.parsedPath,
                    n = t.objectName,
                    r = t.propertyName;
                let i = t.propertyIndex;
                if (e || (e = Wx.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return void console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                if (n) {
                    let r = t.objectIndex;
                    switch (n) {
                        case "materials":
                            if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            e = e.material.materials;
                            break;
                        case "bones":
                            if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            e = e.skeleton.bones;
                            for (let t = 0; t < e.length; t++)
                                if (e[t].name === r) {
                                    r = t;
                                    break
                                }
                            break;
                        case "map":
                            if ("map" in e) {
                                e = e.map;
                                break
                            }
                            if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!e.material.map) return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                            e = e.material.map;
                            break;
                        default:
                            if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            e = e[n]
                    }
                    if (void 0 !== r) {
                        if (void 0 === e[r]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                        e = e[r]
                    }
                }
                const o = e[r];
                if (void 0 === o) {
                    const n = t.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + r + " but it wasn't found.", e)
                }
                let a = this.Versioning.None;
                this.targetObject = e, void 0 !== e.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
                let s = this.BindingType.Direct;
                if (void 0 !== i) {
                    if ("morphTargetInfluences" === r) {
                        if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        void 0 !== e.morphTargetDictionary[i] && (i = e.morphTargetDictionary[i])
                    }
                    s = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = i
                } else void 0 !== o.fromArray && void 0 !== o.toArray ? (s = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (s = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = r;
                this.getValue = this.GetterByBindingType[s], this.setValue = this.SetterByBindingTypeAndVersioning[s][a]
            }
            unbind() {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }
        Wx.Composite = class {
            constructor(e, t, n) {
                const r = n || Wx.parseTrackName(t);
                this._targetGroup = e, this._bindings = e.subscribe_(t, r)
            }
            getValue(e, t) {
                this.bind();
                const n = this._targetGroup.nCachedObjects_,
                    r = this._bindings[n];
                void 0 !== r && r.getValue(e, t)
            }
            setValue(e, t) {
                const n = this._bindings;
                for (let r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(e, t)
            }
            bind() {
                const e = this._bindings;
                for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
            }
            unbind() {
                const e = this._bindings;
                for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
            }
        }, Wx.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        }, Wx.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        }, Wx.prototype.GetterByBindingType = [Wx.prototype._getValue_direct, Wx.prototype._getValue_array, Wx.prototype._getValue_arrayElement, Wx.prototype._getValue_toArray], Wx.prototype.SetterByBindingTypeAndVersioning = [
            [Wx.prototype._setValue_direct, Wx.prototype._setValue_direct_setNeedsUpdate, Wx.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
            [Wx.prototype._setValue_array, Wx.prototype._setValue_array_setNeedsUpdate, Wx.prototype._setValue_array_setMatrixWorldNeedsUpdate],
            [Wx.prototype._setValue_arrayElement, Wx.prototype._setValue_arrayElement_setNeedsUpdate, Wx.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
            [Wx.prototype._setValue_fromArray, Wx.prototype._setValue_fromArray_setNeedsUpdate, Wx.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
        ];
        class Xx {
            constructor() {
                this.isAnimationObjectGroup = !0, this.uuid = Hc(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                const e = {};
                this._indicesByUUID = e;
                for (let n = 0, r = arguments.length; n !== r; ++n) e[arguments[n].uuid] = n;
                this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                const t = this;
                this.stats = {
                    objects: {
                        get total() {
                            return t._objects.length
                        },
                        get inUse() {
                            return this.total - t.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return t._bindings.length
                    }
                }
            }
            add() {
                const e = this._objects,
                    t = this._indicesByUUID,
                    n = this._paths,
                    r = this._parsedPaths,
                    i = this._bindings,
                    o = i.length;
                let a, s = e.length,
                    l = this.nCachedObjects_;
                for (let c = 0, u = arguments.length; c !== u; ++c) {
                    const u = arguments[c],
                        d = u.uuid;
                    let h = t[d];
                    if (void 0 === h) {
                        h = s++, t[d] = h, e.push(u);
                        for (let e = 0, t = o; e !== t; ++e) i[e].push(new Wx(u, n[e], r[e]))
                    } else if (h < l) {
                        a = e[h];
                        const s = --l,
                            c = e[s];
                        t[c.uuid] = h, e[h] = c, t[d] = s, e[s] = u;
                        for (let e = 0, t = o; e !== t; ++e) {
                            const t = i[e],
                                o = t[s];
                            let a = t[h];
                            t[h] = o, void 0 === a && (a = new Wx(u, n[e], r[e])), t[s] = a
                        }
                    } else e[h] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                }
                this.nCachedObjects_ = l
            }
            remove() {
                const e = this._objects,
                    t = this._indicesByUUID,
                    n = this._bindings,
                    r = n.length;
                let i = this.nCachedObjects_;
                for (let o = 0, a = arguments.length; o !== a; ++o) {
                    const a = arguments[o],
                        s = a.uuid,
                        l = t[s];
                    if (void 0 !== l && l >= i) {
                        const o = i++,
                            c = e[o];
                        t[c.uuid] = l, e[l] = c, t[s] = o, e[o] = a;
                        for (let e = 0, t = r; e !== t; ++e) {
                            const t = n[e],
                                r = t[o],
                                i = t[l];
                            t[l] = r, t[o] = i
                        }
                    }
                }
                this.nCachedObjects_ = i
            }
            uncache() {
                const e = this._objects,
                    t = this._indicesByUUID,
                    n = this._bindings,
                    r = n.length;
                let i = this.nCachedObjects_,
                    o = e.length;
                for (let a = 0, s = arguments.length; a !== s; ++a) {
                    const s = arguments[a].uuid,
                        l = t[s];
                    if (void 0 !== l)
                        if (delete t[s], l < i) {
                            const a = --i,
                                s = e[a],
                                c = --o,
                                u = e[c];
                            t[s.uuid] = l, e[l] = s, t[u.uuid] = a, e[a] = u, e.pop();
                            for (let e = 0, t = r; e !== t; ++e) {
                                const t = n[e],
                                    r = t[a],
                                    i = t[c];
                                t[l] = r, t[a] = i, t.pop()
                            }
                        } else {
                            const i = --o,
                                a = e[i];
                            i > 0 && (t[a.uuid] = l), e[l] = a, e.pop();
                            for (let e = 0, t = r; e !== t; ++e) {
                                const t = n[e];
                                t[l] = t[i], t.pop()
                            }
                        }
                }
                this.nCachedObjects_ = i
            }
            subscribe_(e, t) {
                const n = this._bindingsIndicesByPath;
                let r = n[e];
                const i = this._bindings;
                if (void 0 !== r) return i[r];
                const o = this._paths,
                    a = this._parsedPaths,
                    s = this._objects,
                    l = s.length,
                    c = this.nCachedObjects_,
                    u = new Array(l);
                r = i.length, n[e] = r, o.push(e), a.push(t), i.push(u);
                for (let d = c, h = s.length; d !== h; ++d) {
                    const n = s[d];
                    u[d] = new Wx(n, e, t)
                }
                return u
            }
            unsubscribe_(e) {
                const t = this._bindingsIndicesByPath,
                    n = t[e];
                if (void 0 !== n) {
                    const r = this._paths,
                        i = this._parsedPaths,
                        o = this._bindings,
                        a = o.length - 1,
                        s = o[a];
                    t[e[a]] = n, o[n] = s, o.pop(), i[n] = i[a], i.pop(), r[n] = r[a], r.pop()
                }
            }
        }
        class Kx {
            constructor(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : t.blendMode;
                this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = r;
                const i = t.tracks,
                    o = i.length,
                    a = new Array(o),
                    s = {
                        endingStart: Pl,
                        endingEnd: Pl
                    };
                for (let l = 0; l !== o; ++l) {
                    const e = i[l].createInterpolant(null);
                    a[l] = e, e.settings = s
                }
                this._interpolantSettings = s, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Al, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
            }
            play() {
                return this._mixer._activateAction(this), this
            }
            stop() {
                return this._mixer._deactivateAction(this), this.reset()
            }
            reset() {
                return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
            }
            isRunning() {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            }
            isScheduled() {
                return this._mixer._isActiveAction(this)
            }
            startAt(e) {
                return this._startTime = e, this
            }
            setLoop(e, t) {
                return this.loop = e, this.repetitions = t, this
            }
            setEffectiveWeight(e) {
                return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
            }
            getEffectiveWeight() {
                return this._effectiveWeight
            }
            fadeIn(e) {
                return this._scheduleFading(e, 0, 1)
            }
            fadeOut(e) {
                return this._scheduleFading(e, 1, 0)
            }
            crossFadeFrom(e, t, n) {
                if (e.fadeOut(t), this.fadeIn(t), n) {
                    const n = this._clip.duration,
                        r = e._clip.duration,
                        i = r / n,
                        o = n / r;
                    e.warp(1, i, t), this.warp(o, 1, t)
                }
                return this
            }
            crossFadeTo(e, t, n) {
                return e.crossFadeFrom(this, t, n)
            }
            stopFading() {
                const e = this._weightInterpolant;
                return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
            }
            setEffectiveTimeScale(e) {
                return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
            }
            getEffectiveTimeScale() {
                return this._effectiveTimeScale
            }
            setDuration(e) {
                return this.timeScale = this._clip.duration / e, this.stopWarping()
            }
            syncWith(e) {
                return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
            }
            halt(e) {
                return this.warp(this._effectiveTimeScale, 0, e)
            }
            warp(e, t, n) {
                const r = this._mixer,
                    i = r.time,
                    o = this.timeScale;
                let a = this._timeScaleInterpolant;
                null === a && (a = r._lendControlInterpolant(), this._timeScaleInterpolant = a);
                const s = a.parameterPositions,
                    l = a.sampleValues;
                return s[0] = i, s[1] = i + n, l[0] = e / o, l[1] = t / o, this
            }
            stopWarping() {
                const e = this._timeScaleInterpolant;
                return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
            }
            getMixer() {
                return this._mixer
            }
            getClip() {
                return this._clip
            }
            getRoot() {
                return this._localRoot || this._mixer._root
            }
            _update(e, t, n, r) {
                if (!this.enabled) return void this._updateWeight(e);
                const i = this._startTime;
                if (null !== i) {
                    const r = (e - i) * n;
                    r < 0 || 0 === n ? t = 0 : (this._startTime = null, t = n * r)
                }
                t *= this._updateTimeScale(e);
                const o = this._updateTime(t),
                    a = this._updateWeight(e);
                if (a > 0) {
                    const e = this._interpolants,
                        t = this._propertyBindings;
                    if (this.blendMode === Bl)
                        for (let n = 0, r = e.length; n !== r; ++n) e[n].evaluate(o), t[n].accumulateAdditive(a);
                    else
                        for (let n = 0, i = e.length; n !== i; ++n) e[n].evaluate(o), t[n].accumulate(r, a)
                }
            }
            _updateWeight(e) {
                let t = 0;
                if (this.enabled) {
                    t = this.weight;
                    const n = this._weightInterpolant;
                    if (null !== n) {
                        const r = n.evaluate(e)[0];
                        t *= r, e > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = t, t
            }
            _updateTimeScale(e) {
                let t = 0;
                if (!this.paused) {
                    t = this.timeScale;
                    const n = this._timeScaleInterpolant;
                    if (null !== n) {
                        t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)
                    }
                }
                return this._effectiveTimeScale = t, t
            }
            _updateTime(e) {
                const t = this._clip.duration,
                    n = this.loop;
                let r = this.time + e,
                    i = this._loopCount;
                const o = n === Sl;
                if (0 === e) return -1 === i ? r : o && 1 === (1 & i) ? t - r : r;
                if (n === wl) {
                    -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                    e: {
                        if (r >= t) r = t;
                        else {
                            if (!(r < 0)) {
                                this.time = r;
                                break e
                            }
                            r = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        this.time = r,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: e < 0 ? -1 : 1
                        })
                    }
                } else {
                    if (-1 === i && (e >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), r >= t || r < 0) {
                        const n = Math.floor(r / t);
                        r -= t * n, i += Math.abs(n);
                        const a = this.repetitions - i;
                        if (a <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: e > 0 ? 1 : -1
                        });
                        else {
                            if (1 === a) {
                                const t = e < 0;
                                this._setEndings(t, !t, o)
                            } else this._setEndings(!1, !1, o);
                            this._loopCount = i, this.time = r, this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: n
                            })
                        }
                    } else this.time = r;
                    if (o && 1 === (1 & i)) return t - r
                }
                return r
            }
            _setEndings(e, t, n) {
                const r = this._interpolantSettings;
                n ? (r.endingStart = Rl, r.endingEnd = Rl) : (r.endingStart = e ? this.zeroSlopeAtStart ? Rl : Pl : Il, r.endingEnd = t ? this.zeroSlopeAtEnd ? Rl : Pl : Il)
            }
            _scheduleFading(e, t, n) {
                const r = this._mixer,
                    i = r.time;
                let o = this._weightInterpolant;
                null === o && (o = r._lendControlInterpolant(), this._weightInterpolant = o);
                const a = o.parameterPositions,
                    s = o.sampleValues;
                return a[0] = i, s[0] = t, a[1] = i + e, s[1] = n, this
            }
        }
        const Jx = new Float32Array(1);
        class Yx extends Nc {
            constructor(e) {
                super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
            }
            _bindAction(e, t) {
                const n = e._localRoot || this._root,
                    r = e._clip.tracks,
                    i = r.length,
                    o = e._propertyBindings,
                    a = e._interpolants,
                    s = n.uuid,
                    l = this._bindingsByRootAndName;
                let c = l[s];
                void 0 === c && (c = {}, l[s] = c);
                for (let u = 0; u !== i; ++u) {
                    const e = r[u],
                        i = e.name;
                    let l = c[i];
                    if (void 0 !== l) ++l.referenceCount, o[u] = l;
                    else {
                        if (l = o[u], void 0 !== l) {
                            null === l._cacheIndex && (++l.referenceCount, this._addInactiveBinding(l, s, i));
                            continue
                        }
                        const r = t && t._propertyBindings[u].binding.parsedPath;
                        l = new Ux(Wx.create(n, i, r), e.ValueTypeName, e.getValueSize()), ++l.referenceCount, this._addInactiveBinding(l, s, i), o[u] = l
                    }
                    a[u].resultBuffer = l.buffer
                }
            }
            _activateAction(e) {
                if (!this._isActiveAction(e)) {
                    if (null === e._cacheIndex) {
                        const t = (e._localRoot || this._root).uuid,
                            n = e._clip.uuid,
                            r = this._actionsByClip[n];
                        this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, n, t)
                    }
                    const t = e._propertyBindings;
                    for (let e = 0, n = t.length; e !== n; ++e) {
                        const n = t[e];
                        0 === n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
                    }
                    this._lendAction(e)
                }
            }
            _deactivateAction(e) {
                if (this._isActiveAction(e)) {
                    const t = e._propertyBindings;
                    for (let e = 0, n = t.length; e !== n; ++e) {
                        const n = t[e];
                        0 === --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
                    }
                    this._takeBackAction(e)
                }
            }
            _initMemoryManager() {
                this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                const e = this;
                this.stats = {
                    actions: {
                        get total() {
                            return e._actions.length
                        },
                        get inUse() {
                            return e._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return e._bindings.length
                        },
                        get inUse() {
                            return e._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return e._controlInterpolants.length
                        },
                        get inUse() {
                            return e._nActiveControlInterpolants
                        }
                    }
                }
            }
            _isActiveAction(e) {
                const t = e._cacheIndex;
                return null !== t && t < this._nActiveActions
            }
            _addInactiveAction(e, t, n) {
                const r = this._actions,
                    i = this._actionsByClip;
                let o = i[t];
                if (void 0 === o) o = {
                    knownActions: [e],
                    actionByRoot: {}
                }, e._byClipCacheIndex = 0, i[t] = o;
                else {
                    const t = o.knownActions;
                    e._byClipCacheIndex = t.length, t.push(e)
                }
                e._cacheIndex = r.length, r.push(e), o.actionByRoot[n] = e
            }
            _removeInactiveAction(e) {
                const t = this._actions,
                    n = t[t.length - 1],
                    r = e._cacheIndex;
                n._cacheIndex = r, t[r] = n, t.pop(), e._cacheIndex = null;
                const i = e._clip.uuid,
                    o = this._actionsByClip,
                    a = o[i],
                    s = a.knownActions,
                    l = s[s.length - 1],
                    c = e._byClipCacheIndex;
                l._byClipCacheIndex = c, s[c] = l, s.pop(), e._byClipCacheIndex = null;
                delete a.actionByRoot[(e._localRoot || this._root).uuid], 0 === s.length && delete o[i], this._removeInactiveBindingsForAction(e)
            }
            _removeInactiveBindingsForAction(e) {
                const t = e._propertyBindings;
                for (let n = 0, r = t.length; n !== r; ++n) {
                    const e = t[n];
                    0 === --e.referenceCount && this._removeInactiveBinding(e)
                }
            }
            _lendAction(e) {
                const t = this._actions,
                    n = e._cacheIndex,
                    r = this._nActiveActions++,
                    i = t[r];
                e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
            }
            _takeBackAction(e) {
                const t = this._actions,
                    n = e._cacheIndex,
                    r = --this._nActiveActions,
                    i = t[r];
                e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
            }
            _addInactiveBinding(e, t, n) {
                const r = this._bindingsByRootAndName,
                    i = this._bindings;
                let o = r[t];
                void 0 === o && (o = {}, r[t] = o), o[n] = e, e._cacheIndex = i.length, i.push(e)
            }
            _removeInactiveBinding(e) {
                const t = this._bindings,
                    n = e.binding,
                    r = n.rootNode.uuid,
                    i = n.path,
                    o = this._bindingsByRootAndName,
                    a = o[r],
                    s = t[t.length - 1],
                    l = e._cacheIndex;
                s._cacheIndex = l, t[l] = s, t.pop(), delete a[i], 0 === Object.keys(a).length && delete o[r]
            }
            _lendBinding(e) {
                const t = this._bindings,
                    n = e._cacheIndex,
                    r = this._nActiveBindings++,
                    i = t[r];
                e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
            }
            _takeBackBinding(e) {
                const t = this._bindings,
                    n = e._cacheIndex,
                    r = --this._nActiveBindings,
                    i = t[r];
                e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
            }
            _lendControlInterpolant() {
                const e = this._controlInterpolants,
                    t = this._nActiveControlInterpolants++;
                let n = e[t];
                return void 0 === n && (n = new bb(new Float32Array(2), new Float32Array(2), 1, Jx), n.__cacheIndex = t, e[t] = n), n
            }
            _takeBackControlInterpolant(e) {
                const t = this._controlInterpolants,
                    n = e.__cacheIndex,
                    r = --this._nActiveControlInterpolants,
                    i = t[r];
                e.__cacheIndex = r, t[r] = e, i.__cacheIndex = n, t[n] = i
            }
            clipAction(e, t, n) {
                const r = t || this._root,
                    i = r.uuid;
                let o = "string" === typeof e ? Pb.findByName(r, e) : e;
                const a = null !== o ? o.uuid : e,
                    s = this._actionsByClip[a];
                let l = null;
                if (void 0 === n && (n = null !== o ? o.blendMode : Ol), void 0 !== s) {
                    const e = s.actionByRoot[i];
                    if (void 0 !== e && e.blendMode === n) return e;
                    l = s.knownActions[0], null === o && (o = l._clip)
                }
                if (null === o) return null;
                const c = new Kx(this, o, t, n);
                return this._bindAction(c, l), this._addInactiveAction(c, a, i), c
            }
            existingAction(e, t) {
                const n = t || this._root,
                    r = n.uuid,
                    i = "string" === typeof e ? Pb.findByName(n, e) : e,
                    o = i ? i.uuid : e,
                    a = this._actionsByClip[o];
                return void 0 !== a && a.actionByRoot[r] || null
            }
            stopAllAction() {
                const e = this._actions;
                for (let t = this._nActiveActions - 1; t >= 0; --t) e[t].stop();
                return this
            }
            update(e) {
                e *= this.timeScale;
                const t = this._actions,
                    n = this._nActiveActions,
                    r = this.time += e,
                    i = Math.sign(e),
                    o = this._accuIndex ^= 1;
                for (let l = 0; l !== n; ++l) {
                    t[l]._update(r, e, i, o)
                }
                const a = this._bindings,
                    s = this._nActiveBindings;
                for (let l = 0; l !== s; ++l) a[l].apply(o);
                return this
            }
            setTime(e) {
                this.time = 0;
                for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
                return this.update(e)
            }
            getRoot() {
                return this._root
            }
            uncacheClip(e) {
                const t = this._actions,
                    n = e.uuid,
                    r = this._actionsByClip,
                    i = r[n];
                if (void 0 !== i) {
                    const e = i.knownActions;
                    for (let n = 0, r = e.length; n !== r; ++n) {
                        const r = e[n];
                        this._deactivateAction(r);
                        const i = r._cacheIndex,
                            o = t[t.length - 1];
                        r._cacheIndex = null, r._byClipCacheIndex = null, o._cacheIndex = i, t[i] = o, t.pop(), this._removeInactiveBindingsForAction(r)
                    }
                    delete r[n]
                }
            }
            uncacheRoot(e) {
                const t = e.uuid,
                    n = this._actionsByClip;
                for (const i in n) {
                    const e = n[i].actionByRoot[t];
                    void 0 !== e && (this._deactivateAction(e), this._removeInactiveAction(e))
                }
                const r = this._bindingsByRootAndName[t];
                if (void 0 !== r)
                    for (const i in r) {
                        const e = r[i];
                        e.restoreOriginalState(), this._removeInactiveBinding(e)
                    }
            }
            uncacheAction(e, t) {
                const n = this.existingAction(e, t);
                null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
            }
        }
        class Qx {
            constructor(e) {
                this.value = e
            }
            clone() {
                return new Qx(void 0 === this.value.clone ? this.value : this.value.clone())
            }
        }
        let Zx = 0;
        class $x extends Nc {
            constructor() {
                super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", {
                    value: Zx++
                }), this.name = "", this.usage = Mc, this.uniforms = []
            }
            add(e) {
                return this.uniforms.push(e), this
            }
            remove(e) {
                const t = this.uniforms.indexOf(e);
                return -1 !== t && this.uniforms.splice(t, 1), this
            }
            setName(e) {
                return this.name = e, this
            }
            setUsage(e) {
                return this.usage = e, this
            }
            dispose() {
                return this.dispatchEvent({
                    type: "dispose"
                }), this
            }
            copy(e) {
                this.name = e.name, this.usage = e.usage;
                const t = e.uniforms;
                this.uniforms.length = 0;
                for (let n = 0, r = t.length; n < r; n++) {
                    const e = Array.isArray(t[n]) ? t[n] : [t[n]];
                    for (let t = 0; t < e.length; t++) this.uniforms.push(e[t].clone())
                }
                return this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class e_ extends $m {
            constructor(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n
            }
            copy(e) {
                return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
            }
            clone(e) {
                const t = super.clone(e);
                return t.meshPerAttribute = this.meshPerAttribute, t
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t
            }
        }
        class t_ {
            constructor(e, t, n, r, i) {
                this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = r, this.count = i, this.version = 0
            }
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            setBuffer(e) {
                return this.buffer = e, this
            }
            setType(e, t) {
                return this.type = e, this.elementSize = t, this
            }
            setItemSize(e) {
                return this.itemSize = e, this
            }
            setCount(e) {
                return this.count = e, this
            }
        }
        class n_ {
            constructor(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1 / 0;
                this.ray = new id(e, t), this.near = n, this.far = r, this.camera = null, this.layers = new gd, this.params = {
                    Mesh: {},
                    Line: {
                        threshold: 1
                    },
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }
            }
            set(e, t) {
                this.ray.set(e, t)
            }
            setFromCamera(e, t) {
                t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
            }
            intersectObject(e) {
                let t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
                return i_(e, this, t, !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]), t.sort(r_), t
            }
            intersectObjects(e) {
                let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
                for (let r = 0, i = e.length; r < i; r++) i_(e[r], this, n, t);
                return n.sort(r_), n
            }
        }

        function r_(e, t) {
            return e.distance - t.distance
        }

        function i_(e, t, n, r) {
            if (e.layers.test(t.layers) && e.raycast(t, n), !0 === r) {
                const r = e.children;
                for (let e = 0, i = r.length; e < i; e++) i_(r[e], t, n, !0)
            }
        }
        class o_ {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                return this.radius = e, this.phi = t, this.theta = n, this
            }
            set(e, t, n) {
                return this.radius = e, this.phi = t, this.theta = n, this
            }
            copy(e) {
                return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
            }
            makeSafe() {
                const e = 1e-6;
                return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)), this
            }
            setFromVector3(e) {
                return this.setFromCartesianCoords(e.x, e.y, e.z)
            }
            setFromCartesianCoords(e, t, n) {
                return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(jc(t / this.radius, -1, 1))), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class a_ {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                return this.radius = e, this.theta = t, this.y = n, this
            }
            set(e, t, n) {
                return this.radius = e, this.theta = t, this.y = n, this
            }
            copy(e) {
                return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
            }
            setFromVector3(e) {
                return this.setFromCartesianCoords(e.x, e.y, e.z)
            }
            setFromCartesianCoords(e, t, n) {
                return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const s_ = new Yc;
        class l_ {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Yc(1 / 0, 1 / 0),
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Yc(-1 / 0, -1 / 0);
                this.isBox2 = !0, this.min = e, this.max = t
            }
            set(e, t) {
                return this.min.copy(e), this.max.copy(t), this
            }
            setFromPoints(e) {
                this.makeEmpty();
                for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                return this
            }
            setFromCenterAndSize(e, t) {
                const n = s_.copy(t).multiplyScalar(.5);
                return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.min.copy(e.min), this.max.copy(e.max), this
            }
            makeEmpty() {
                return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y
            }
            getCenter(e) {
                return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(e) {
                return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
            }
            expandByPoint(e) {
                return this.min.min(e), this.max.max(e), this
            }
            expandByVector(e) {
                return this.min.sub(e), this.max.add(e), this
            }
            expandByScalar(e) {
                return this.min.addScalar(-e), this.max.addScalar(e), this
            }
            containsPoint(e) {
                return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
            }
            containsBox(e) {
                return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
            }
            getParameter(e, t) {
                return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
            }
            intersectsBox(e) {
                return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
            }
            clampPoint(e, t) {
                return t.copy(e).clamp(this.min, this.max)
            }
            distanceToPoint(e) {
                return this.clampPoint(e, s_).distanceTo(e)
            }
            intersect(e) {
                return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
            }
            union(e) {
                return this.min.min(e.min), this.max.max(e.max), this
            }
            translate(e) {
                return this.min.add(e), this.max.add(e), this
            }
            equals(e) {
                return e.min.equals(this.min) && e.max.equals(this.max)
            }
        }
        const c_ = new Pu,
            u_ = new Pu;
        class d_ {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Pu,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Pu;
                this.start = e, this.end = t
            }
            set(e, t) {
                return this.start.copy(e), this.end.copy(t), this
            }
            copy(e) {
                return this.start.copy(e.start), this.end.copy(e.end), this
            }
            getCenter(e) {
                return e.addVectors(this.start, this.end).multiplyScalar(.5)
            }
            delta(e) {
                return e.subVectors(this.end, this.start)
            }
            distanceSq() {
                return this.start.distanceToSquared(this.end)
            }
            distance() {
                return this.start.distanceTo(this.end)
            }
            at(e, t) {
                return this.delta(t).multiplyScalar(e).add(this.start)
            }
            closestPointToPointParameter(e, t) {
                c_.subVectors(e, this.start), u_.subVectors(this.end, this.start);
                const n = u_.dot(u_);
                let r = u_.dot(c_) / n;
                return t && (r = jc(r, 0, 1)), r
            }
            closestPointToPoint(e, t, n) {
                const r = this.closestPointToPointParameter(e, t);
                return this.delta(n).multiplyScalar(r).add(this.start)
            }
            applyMatrix4(e) {
                return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
            }
            equals(e) {
                return e.start.equals(this.start) && e.end.equals(this.end)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const h_ = new Pu;
        class p_ extends Rd {
            constructor(e, t) {
                super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper";
                const n = new Mh,
                    r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                for (let o = 0, a = 1, s = 32; o < s; o++, a++) {
                    const e = o / s * Math.PI * 2,
                        t = a / s * Math.PI * 2;
                    r.push(Math.cos(e), Math.sin(e), 1, Math.cos(t), Math.sin(t), 1)
                }
                n.setAttribute("position", new ph(r, 3));
                const i = new lv({
                    fog: !1,
                    toneMapped: !1
                });
                this.cone = new vv(n, i), this.add(this.cone), this.update()
            }
            dispose() {
                this.cone.geometry.dispose(), this.cone.material.dispose()
            }
            update() {
                this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1);
                const e = this.light.distance ? this.light.distance : 1e3,
                    t = e * Math.tan(this.light.angle);
                this.cone.scale.set(t, t, e), h_.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(h_), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
            }
        }
        const f_ = new Pu,
            m_ = new od,
            g_ = new od;
        class v_ extends vv {
            constructor(e) {
                const t = y_(e),
                    n = new Mh,
                    r = [],
                    i = [],
                    o = new Wd(0, 0, 1),
                    a = new Wd(0, 1, 0);
                for (let s = 0; s < t.length; s++) {
                    const e = t[s];
                    e.parent && e.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(o.r, o.g, o.b), i.push(a.r, a.g, a.b))
                }
                n.setAttribute("position", new ph(r, 3)), n.setAttribute("color", new ph(i, 3));
                super(n, new lv({
                    vertexColors: !0,
                    depthTest: !1,
                    depthWrite: !1,
                    toneMapped: !1,
                    transparent: !0
                })), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
            }
            updateMatrixWorld(e) {
                const t = this.bones,
                    n = this.geometry,
                    r = n.getAttribute("position");
                g_.copy(this.root.matrixWorld).invert();
                for (let i = 0, o = 0; i < t.length; i++) {
                    const e = t[i];
                    e.parent && e.parent.isBone && (m_.multiplyMatrices(g_, e.matrixWorld), f_.setFromMatrixPosition(m_), r.setXYZ(o, f_.x, f_.y, f_.z), m_.multiplyMatrices(g_, e.parent.matrixWorld), f_.setFromMatrixPosition(m_), r.setXYZ(o + 1, f_.x, f_.y, f_.z), o += 2)
                }
                n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e)
            }
            dispose() {
                this.geometry.dispose(), this.material.dispose()
            }
        }

        function y_(e) {
            const t = [];
            !0 === e.isBone && t.push(e);
            for (let n = 0; n < e.children.length; n++) t.push.apply(t, y_(e.children[n]));
            return t
        }
        class b_ extends zh {
            constructor(e, t, n) {
                super(new Xy(t, 4, 2), new Yd({
                    wireframe: !0,
                    fog: !1,
                    toneMapped: !1
                })), this.light = e, this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
            }
            dispose() {
                this.geometry.dispose(), this.material.dispose()
            }
            update() {
                this.light.updateWorldMatrix(!0, !1), void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
            }
        }
        const x_ = new Pu,
            __ = new Wd,
            M_ = new Wd;
        class w_ extends Rd {
            constructor(e, t, n) {
                super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "HemisphereLightHelper";
                const r = new Vy(t);
                r.rotateY(.5 * Math.PI), this.material = new Yd({
                    wireframe: !0,
                    fog: !1,
                    toneMapped: !1
                }), void 0 === this.color && (this.material.vertexColors = !0);
                const i = r.getAttribute("position"),
                    o = new Float32Array(3 * i.count);
                r.setAttribute("color", new ih(o, 3)), this.add(new zh(r, this.material)), this.update()
            }
            dispose() {
                this.children[0].geometry.dispose(), this.children[0].material.dispose()
            }
            update() {
                const e = this.children[0];
                if (void 0 !== this.color) this.material.color.set(this.color);
                else {
                    const t = e.geometry.getAttribute("color");
                    __.copy(this.light.color), M_.copy(this.light.groundColor);
                    for (let e = 0, n = t.count; e < n; e++) {
                        const r = e < n / 2 ? __ : M_;
                        t.setXYZ(e, r.r, r.g, r.b)
                    }
                    t.needsUpdate = !0
                }
                this.light.updateWorldMatrix(!0, !1), e.lookAt(x_.setFromMatrixPosition(this.light.matrixWorld).negate())
            }
        }
        class A_ extends vv {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 4473924,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 8947848;
                n = new Wd(n), r = new Wd(r);
                const i = t / 2,
                    o = e / t,
                    a = e / 2,
                    s = [],
                    l = [];
                for (let u = 0, d = 0, h = -a; u <= t; u++, h += o) {
                    s.push(-a, 0, h, a, 0, h), s.push(h, 0, -a, h, 0, a);
                    const e = u === i ? n : r;
                    e.toArray(l, d), d += 3, e.toArray(l, d), d += 3, e.toArray(l, d), d += 3, e.toArray(l, d), d += 3
                }
                const c = new Mh;
                c.setAttribute("position", new ph(s, 3)), c.setAttribute("color", new ph(l, 3));
                super(c, new lv({
                    vertexColors: !0,
                    toneMapped: !1
                })), this.type = "GridHelper"
            }
            dispose() {
                this.geometry.dispose(), this.material.dispose()
            }
        }
        class S_ extends vv {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 16,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 8,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 64,
                    i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 4473924,
                    o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 8947848;
                i = new Wd(i), o = new Wd(o);
                const a = [],
                    s = [];
                if (t > 1)
                    for (let c = 0; c < t; c++) {
                        const n = c / t * (2 * Math.PI),
                            r = Math.sin(n) * e,
                            l = Math.cos(n) * e;
                        a.push(0, 0, 0), a.push(r, 0, l);
                        const u = 1 & c ? i : o;
                        s.push(u.r, u.g, u.b), s.push(u.r, u.g, u.b)
                    }
                for (let c = 0; c < n; c++) {
                    const t = 1 & c ? i : o,
                        l = e - e / n * c;
                    for (let e = 0; e < r; e++) {
                        let n = e / r * (2 * Math.PI),
                            i = Math.sin(n) * l,
                            o = Math.cos(n) * l;
                        a.push(i, 0, o), s.push(t.r, t.g, t.b), n = (e + 1) / r * (2 * Math.PI), i = Math.sin(n) * l, o = Math.cos(n) * l, a.push(i, 0, o), s.push(t.r, t.g, t.b)
                    }
                }
                const l = new Mh;
                l.setAttribute("position", new ph(a, 3)), l.setAttribute("color", new ph(s, 3));
                super(l, new lv({
                    vertexColors: !0,
                    toneMapped: !1
                })), this.type = "PolarGridHelper"
            }
            dispose() {
                this.geometry.dispose(), this.material.dispose()
            }
        }
        const E_ = new Pu,
            C_ = new Pu,
            T_ = new Pu;
        class P_ extends Rd {
            constructor(e, t, n) {
                super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "DirectionalLightHelper", void 0 === t && (t = 1);
                let r = new Mh;
                r.setAttribute("position", new ph([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
                const i = new lv({
                    fog: !1,
                    toneMapped: !1
                });
                this.lightPlane = new fv(r, i), this.add(this.lightPlane), r = new Mh, r.setAttribute("position", new ph([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new fv(r, i), this.add(this.targetLine), this.update()
            }
            dispose() {
                this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
            }
            update() {
                this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), E_.setFromMatrixPosition(this.light.matrixWorld), C_.setFromMatrixPosition(this.light.target.matrixWorld), T_.subVectors(C_, E_), this.lightPlane.lookAt(C_), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(C_), this.targetLine.scale.z = T_.length()
            }
        }
        const R_ = new Pu,
            I_ = new Kh;
        class O_ extends vv {
            constructor(e) {
                const t = new Mh,
                    n = new lv({
                        color: 16777215,
                        vertexColors: !0,
                        toneMapped: !1
                    }),
                    r = [],
                    i = [],
                    o = {};

                function a(e, t) {
                    s(e), s(t)
                }

                function s(e) {
                    r.push(0, 0, 0), i.push(0, 0, 0), void 0 === o[e] && (o[e] = []), o[e].push(r.length / 3 - 1)
                }
                a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4"), t.setAttribute("position", new ph(r, 3)), t.setAttribute("color", new ph(i, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update();
                const l = new Wd(16755200),
                    c = new Wd(16711680),
                    u = new Wd(43775),
                    d = new Wd(16777215),
                    h = new Wd(3355443);
                this.setColors(l, c, u, d, h)
            }
            setColors(e, t, n, r, i) {
                const o = this.geometry.getAttribute("color");
                o.setXYZ(0, e.r, e.g, e.b), o.setXYZ(1, e.r, e.g, e.b), o.setXYZ(2, e.r, e.g, e.b), o.setXYZ(3, e.r, e.g, e.b), o.setXYZ(4, e.r, e.g, e.b), o.setXYZ(5, e.r, e.g, e.b), o.setXYZ(6, e.r, e.g, e.b), o.setXYZ(7, e.r, e.g, e.b), o.setXYZ(8, e.r, e.g, e.b), o.setXYZ(9, e.r, e.g, e.b), o.setXYZ(10, e.r, e.g, e.b), o.setXYZ(11, e.r, e.g, e.b), o.setXYZ(12, e.r, e.g, e.b), o.setXYZ(13, e.r, e.g, e.b), o.setXYZ(14, e.r, e.g, e.b), o.setXYZ(15, e.r, e.g, e.b), o.setXYZ(16, e.r, e.g, e.b), o.setXYZ(17, e.r, e.g, e.b), o.setXYZ(18, e.r, e.g, e.b), o.setXYZ(19, e.r, e.g, e.b), o.setXYZ(20, e.r, e.g, e.b), o.setXYZ(21, e.r, e.g, e.b), o.setXYZ(22, e.r, e.g, e.b), o.setXYZ(23, e.r, e.g, e.b), o.setXYZ(24, t.r, t.g, t.b), o.setXYZ(25, t.r, t.g, t.b), o.setXYZ(26, t.r, t.g, t.b), o.setXYZ(27, t.r, t.g, t.b), o.setXYZ(28, t.r, t.g, t.b), o.setXYZ(29, t.r, t.g, t.b), o.setXYZ(30, t.r, t.g, t.b), o.setXYZ(31, t.r, t.g, t.b), o.setXYZ(32, n.r, n.g, n.b), o.setXYZ(33, n.r, n.g, n.b), o.setXYZ(34, n.r, n.g, n.b), o.setXYZ(35, n.r, n.g, n.b), o.setXYZ(36, n.r, n.g, n.b), o.setXYZ(37, n.r, n.g, n.b), o.setXYZ(38, r.r, r.g, r.b), o.setXYZ(39, r.r, r.g, r.b), o.setXYZ(40, i.r, i.g, i.b), o.setXYZ(41, i.r, i.g, i.b), o.setXYZ(42, i.r, i.g, i.b), o.setXYZ(43, i.r, i.g, i.b), o.setXYZ(44, i.r, i.g, i.b), o.setXYZ(45, i.r, i.g, i.b), o.setXYZ(46, i.r, i.g, i.b), o.setXYZ(47, i.r, i.g, i.b), o.setXYZ(48, i.r, i.g, i.b), o.setXYZ(49, i.r, i.g, i.b), o.needsUpdate = !0
            }
            update() {
                const e = this.geometry,
                    t = this.pointMap;
                I_.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), B_("c", t, e, I_, 0, 0, -1), B_("t", t, e, I_, 0, 0, 1), B_("n1", t, e, I_, -1, -1, -1), B_("n2", t, e, I_, 1, -1, -1), B_("n3", t, e, I_, -1, 1, -1), B_("n4", t, e, I_, 1, 1, -1), B_("f1", t, e, I_, -1, -1, 1), B_("f2", t, e, I_, 1, -1, 1), B_("f3", t, e, I_, -1, 1, 1), B_("f4", t, e, I_, 1, 1, 1), B_("u1", t, e, I_, .7, 1.1, -1), B_("u2", t, e, I_, -.7, 1.1, -1), B_("u3", t, e, I_, 0, 2, -1), B_("cf1", t, e, I_, -1, 0, 1), B_("cf2", t, e, I_, 1, 0, 1), B_("cf3", t, e, I_, 0, -1, 1), B_("cf4", t, e, I_, 0, 1, 1), B_("cn1", t, e, I_, -1, 0, -1), B_("cn2", t, e, I_, 1, 0, -1), B_("cn3", t, e, I_, 0, -1, -1), B_("cn4", t, e, I_, 0, 1, -1), e.getAttribute("position").needsUpdate = !0
            }
            dispose() {
                this.geometry.dispose(), this.material.dispose()
            }
        }

        function B_(e, t, n, r, i, o, a) {
            R_.set(i, o, a).unproject(r);
            const s = t[e];
            if (void 0 !== s) {
                const e = n.getAttribute("position");
                for (let t = 0, n = s.length; t < n; t++) e.setXYZ(s[t], R_.x, R_.y, R_.z)
            }
        }
        const L_ = new Ou;
        class D_ extends vv {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 16776960;
                const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    r = new Float32Array(24),
                    i = new Mh;
                i.setIndex(new ih(n, 1)), i.setAttribute("position", new ih(r, 3)), super(i, new lv({
                    color: t,
                    toneMapped: !1
                })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
            }
            update(e) {
                if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && L_.setFromObject(this.object), L_.isEmpty()) return;
                const t = L_.min,
                    n = L_.max,
                    r = this.geometry.attributes.position,
                    i = r.array;
                i[0] = n.x, i[1] = n.y, i[2] = n.z, i[3] = t.x, i[4] = n.y, i[5] = n.z, i[6] = t.x, i[7] = t.y, i[8] = n.z, i[9] = n.x, i[10] = t.y, i[11] = n.z, i[12] = n.x, i[13] = n.y, i[14] = t.z, i[15] = t.x, i[16] = n.y, i[17] = t.z, i[18] = t.x, i[19] = t.y, i[20] = t.z, i[21] = n.x, i[22] = t.y, i[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
            }
            setFromObject(e) {
                return this.object = e, this.update(), this
            }
            copy(e, t) {
                return super.copy(e, t), this.object = e.object, this
            }
            dispose() {
                this.geometry.dispose(), this.material.dispose()
            }
        }
        class N_ extends vv {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 16776960;
                const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    r = new Mh;
                r.setIndex(new ih(n, 1)), r.setAttribute("position", new ph([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(r, new lv({
                    color: t,
                    toneMapped: !1
                })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
            }
            updateMatrixWorld(e) {
                const t = this.box;
                t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e))
            }
            dispose() {
                this.geometry.dispose(), this.material.dispose()
            }
        }
        class k_ extends fv {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 16776960,
                    r = new Mh;
                r.setAttribute("position", new ph([1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), r.computeBoundingSphere(), super(r, new lv({
                    color: n,
                    toneMapped: !1
                })), this.type = "PlaneHelper", this.plane = e, this.size = t;
                const i = new Mh;
                i.setAttribute("position", new ph([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), i.computeBoundingSphere(), this.add(new zh(i, new Yd({
                    color: n,
                    opacity: .2,
                    transparent: !0,
                    depthWrite: !1,
                    toneMapped: !1
                })))
            }
            updateMatrixWorld(e) {
                this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e)
            }
            dispose() {
                this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
            }
        }
        const F_ = new Pu;
        let U_, z_;
        class H_ extends Rd {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Pu(0, 0, 1),
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Pu(0, 0, 0),
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 16776960,
                    i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : .2 * n,
                    o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : .2 * i;
                super(), this.type = "ArrowHelper", void 0 === U_ && (U_ = new Mh, U_.setAttribute("position", new ph([0, 0, 0, 0, 1, 0], 3)), z_ = new ry(0, .5, 1, 5, 1), z_.translate(0, -.5, 0)), this.position.copy(t), this.line = new fv(U_, new lv({
                    color: r,
                    toneMapped: !1
                })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new zh(z_, new Yd({
                    color: r,
                    toneMapped: !1
                })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, i, o)
            }
            setDirection(e) {
                if (e.y > .99999) this.quaternion.set(0, 0, 0, 1);
                else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0);
                else {
                    F_.set(e.z, 0, -e.x).normalize();
                    const t = Math.acos(e.y);
                    this.quaternion.setFromAxisAngle(F_, t)
                }
            }
            setLength(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .2 * e,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .2 * t;
                this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix()
            }
            setColor(e) {
                this.line.material.color.set(e), this.cone.material.color.set(e)
            }
            copy(e) {
                return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
            }
            dispose() {
                this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose()
            }
        }
        class j_ extends vv {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
                const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
                    n = new Mh;
                n.setAttribute("position", new ph(t, 3)), n.setAttribute("color", new ph([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
                super(n, new lv({
                    vertexColors: !0,
                    toneMapped: !1
                })), this.type = "AxesHelper"
            }
            setColors(e, t, n) {
                const r = new Wd,
                    i = this.geometry.attributes.color.array;
                return r.set(e), r.toArray(i, 0), r.toArray(i, 3), r.set(t), r.toArray(i, 6), r.toArray(i, 9), r.set(n), r.toArray(i, 12), r.toArray(i, 15), this.geometry.attributes.color.needsUpdate = !0, this
            }
            dispose() {
                this.geometry.dispose(), this.material.dispose()
            }
        }
        class G_ {
            constructor() {
                this.type = "ShapePath", this.color = new Wd, this.subPaths = [], this.currentPath = null
            }
            moveTo(e, t) {
                return this.currentPath = new $v, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this
            }
            lineTo(e, t) {
                return this.currentPath.lineTo(e, t), this
            }
            quadraticCurveTo(e, t, n, r) {
                return this.currentPath.quadraticCurveTo(e, t, n, r), this
            }
            bezierCurveTo(e, t, n, r, i, o) {
                return this.currentPath.bezierCurveTo(e, t, n, r, i, o), this
            }
            splineThru(e) {
                return this.currentPath.splineThru(e), this
            }
            toShapes(e) {
                function t(e, t) {
                    const n = t.length;
                    let r = !1;
                    for (let i = n - 1, o = 0; o < n; i = o++) {
                        let n = t[i],
                            a = t[o],
                            s = a.x - n.x,
                            l = a.y - n.y;
                        if (Math.abs(l) > Number.EPSILON) {
                            if (l < 0 && (n = t[o], s = -s, a = t[i], l = -l), e.y < n.y || e.y > a.y) continue;
                            if (e.y === n.y) {
                                if (e.x === n.x) return !0
                            } else {
                                const t = l * (e.x - n.x) - s * (e.y - n.y);
                                if (0 === t) return !0;
                                if (t < 0) continue;
                                r = !r
                            }
                        } else {
                            if (e.y !== n.y) continue;
                            if (a.x <= e.x && e.x <= n.x || n.x <= e.x && e.x <= a.x) return !0
                        }
                    }
                    return r
                }
                const n = Fy.isClockWise,
                    r = this.subPaths;
                if (0 === r.length) return [];
                let i, o, a;
                const s = [];
                if (1 === r.length) return o = r[0], a = new hy, a.curves = o.curves, s.push(a), s;
                let l = !n(r[0].getPoints());
                l = e ? !l : l;
                const c = [],
                    u = [];
                let d, h, p = [],
                    f = 0;
                u[f] = void 0, p[f] = [];
                for (let m = 0, g = r.length; m < g; m++) o = r[m], d = o.getPoints(), i = n(d), i = e ? !i : i, i ? (!l && u[f] && f++, u[f] = {
                    s: new hy,
                    p: d
                }, u[f].s.curves = o.curves, l && f++, p[f] = []) : p[f].push({
                    h: o,
                    p: d[0]
                });
                if (!u[0]) return function(e) {
                    const t = [];
                    for (let n = 0, r = e.length; n < r; n++) {
                        const r = e[n],
                            i = new hy;
                        i.curves = r.curves, t.push(i)
                    }
                    return t
                }(r);
                if (u.length > 1) {
                    let e = !1,
                        n = 0;
                    for (let t = 0, r = u.length; t < r; t++) c[t] = [];
                    for (let r = 0, i = u.length; r < i; r++) {
                        const i = p[r];
                        for (let o = 0; o < i.length; o++) {
                            const a = i[o];
                            let s = !0;
                            for (let i = 0; i < u.length; i++) t(a.p, u[i].p) && (r !== i && n++, s ? (s = !1, c[i].push(a)) : e = !0);
                            s && c[r].push(a)
                        }
                    }
                    n > 0 && !1 === e && (p = c)
                }
                for (let m = 0, g = u.length; m < g; m++) {
                    a = u[m].s, s.push(a), h = p[m];
                    for (let e = 0, t = h.length; e < t; e++) a.holes.push(h[e].h)
                }
                return s
            }
        }
        "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
            detail: {
                revision: Zo
            }
        })), "undefined" !== typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Zo);
        var V_ = n(1920);

        function q_(e) {
            let t;
            const n = new Set,
                r = (e, r) => {
                    const i = "function" === typeof e ? e(t) : e;
                    if (i !== t) {
                        const e = t;
                        t = r ? i : Object.assign({}, t, i), n.forEach((n => n(t, e)))
                    }
                },
                i = () => t,
                o = {
                    setState: r,
                    getState: i,
                    subscribe: (e, r, o) => r || o ? function(e) {
                        let r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : i,
                            o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Object.is;
                        console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
                        let a = r(t);

                        function s() {
                            const n = r(t);
                            if (!o(a, n)) {
                                const t = a;
                                e(a = n, t)
                            }
                        }
                        return n.add(s), () => n.delete(s)
                    }(e, r, o) : (n.add(e), () => n.delete(e)),
                    destroy: () => n.clear()
                };
            return t = e(r, i, o), o
        }
        const W_ = "undefined" === typeof window || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent) ? r.useEffect : r.useLayoutEffect;

        function X_(e) {
            const t = "function" === typeof e ? q_(e) : e,
                n = function() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : t.getState,
                        n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Object.is;
                    const [, i] = (0, r.useReducer)((e => e + 1), 0), o = t.getState(), a = (0, r.useRef)(o), s = (0, r.useRef)(e), l = (0, r.useRef)(n), c = (0, r.useRef)(!1), u = (0, r.useRef)();
                    let d;
                    void 0 === u.current && (u.current = e(o));
                    let h = !1;
                    (a.current !== o || s.current !== e || l.current !== n || c.current) && (d = e(o), h = !n(u.current, d)), W_((() => {
                        h && (u.current = d), a.current = o, s.current = e, l.current = n, c.current = !1
                    }));
                    const p = (0, r.useRef)(o);
                    W_((() => {
                        const e = () => {
                                try {
                                    const e = t.getState(),
                                        n = s.current(e);
                                    l.current(u.current, n) || (a.current = e, u.current = n, i())
                                } catch (e) {
                                    c.current = !0, i()
                                }
                            },
                            n = t.subscribe(e);
                        return t.getState() !== p.current && e(), n
                    }), []);
                    const f = h ? d : u.current;
                    return (0, r.useDebugValue)(f), f
                };
            return Object.assign(n, t), n[Symbol.iterator] = function() {
                console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
                const e = [n, t];
                return {
                    next() {
                        const t = e.length <= 0;
                        return {
                            value: e.shift(),
                            done: t
                        }
                    }
                }
            }, n
        }
        var K_ = n(4384),
            J_ = n.n(K_),
            Y_ = n(2712);
        const Q_ = [];

        function Z_(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : (e, t) => e === t;
            if (e === t) return !0;
            if (!e || !t) return !1;
            const r = e.length;
            if (t.length !== r) return !1;
            for (let i = 0; i < r; i++)
                if (!n(e[i], t[i])) return !1;
            return !0
        }

        function $_(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
            null === t && (t = [e]);
            for (const a of Q_)
                if (Z_(t, a.keys, a.equal)) {
                    if (n) return;
                    if (Object.prototype.hasOwnProperty.call(a, "error")) throw a.error;
                    if (Object.prototype.hasOwnProperty.call(a, "response")) return r.lifespan && r.lifespan > 0 && (a.timeout && clearTimeout(a.timeout), a.timeout = setTimeout(a.remove, r.lifespan)), a.response;
                    if (!n) throw a.promise
                }
            const i = {
                keys: t,
                equal: r.equal,
                remove: () => {
                    const e = Q_.indexOf(i); - 1 !== e && Q_.splice(e, 1)
                },
                promise: (o = e, "object" === typeof o && "function" === typeof o.then ? e : e(...t)).then((e => {
                    i.response = e, r.lifespan && r.lifespan > 0 && (i.timeout = setTimeout(i.remove, r.lifespan))
                })).catch((e => i.error = e))
            };
            var o;
            if (Q_.push(i), !n) throw i.promise
        }
        const eM = (e, t, n) => $_(e, t, !1, n);
        const tM = {},
            nM = e => {
                Object.assign(tM, e)
            };
        var rM, iM;
        const oM = e => "colorSpace" in e || "outputColorSpace" in e,
            aM = () => {
                var e;
                return null != (e = tM.ColorManagement) ? e : null
            },
            sM = e => e && e.isOrthographicCamera,
            lM = "undefined" !== typeof window && (null != (rM = window.document) && rM.createElement || "ReactNative" === (null == (iM = window.navigator) ? void 0 : iM.product)) ? r.useLayoutEffect : r.useEffect;

        function cM(e) {
            const t = r.useRef(e);
            return lM((() => {
                t.current = e
            }), [e]), t
        }

        function uM(e) {
            let {
                set: t
            } = e;
            return lM((() => (t(new Promise((() => null))), () => t(!1))), [t]), null
        }
        class dM extends r.Component {
            constructor() {
                super(...arguments), this.state = {
                    error: !1
                }
            }
            componentDidCatch(e) {
                this.props.set(e)
            }
            render() {
                return this.state.error ? null : this.props.children
            }
        }
        dM.getDerivedStateFromError = () => ({
            error: !0
        });
        const hM = "__default",
            pM = new Map,
            fM = e => e && !!e.memoized && !!e.changes;

        function mM(e) {
            var t;
            const n = "undefined" !== typeof window ? null != (t = window.devicePixelRatio) ? t : 2 : 1;
            return Array.isArray(e) ? Math.min(Math.max(e[0], n), e[1]) : e
        }
        const gM = e => {
            var t;
            return null == (t = e.__r3f) ? void 0 : t.root.getState()
        };

        function vM(e) {
            let t = e.__r3f.root;
            for (; t.getState().previousRoot;) t = t.getState().previousRoot;
            return t
        }
        const yM = {
            obj: e => e === Object(e) && !yM.arr(e) && "function" !== typeof e,
            fun: e => "function" === typeof e,
            str: e => "string" === typeof e,
            num: e => "number" === typeof e,
            boo: e => "boolean" === typeof e,
            und: e => void 0 === e,
            arr: e => Array.isArray(e),
            equ(e, t) {
                let {
                    arrays: n = "shallow",
                    objects: r = "reference",
                    strict: i = !0
                } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                if (typeof e !== typeof t || !!e !== !!t) return !1;
                if (yM.str(e) || yM.num(e)) return e === t;
                const o = yM.obj(e);
                if (o && "reference" === r) return e === t;
                const a = yM.arr(e);
                if (a && "reference" === n) return e === t;
                if ((a || o) && e === t) return !0;
                let s;
                for (s in e)
                    if (!(s in t)) return !1;
                if (o && "shallow" === n && "shallow" === r) {
                    for (s in i ? t : e)
                        if (!yM.equ(e[s], t[s], {
                                strict: i,
                                objects: "reference"
                            })) return !1
                } else
                    for (s in i ? t : e)
                        if (e[s] !== t[s]) return !1;
                if (yM.und(s)) {
                    if (a && 0 === e.length && 0 === t.length) return !0;
                    if (o && 0 === Object.keys(e).length && 0 === Object.keys(t).length) return !0;
                    if (e !== t) return !1
                }
                return !0
            }
        };

        function bM(e) {
            const t = {
                nodes: {},
                materials: {}
            };
            return e && e.traverse((e => {
                e.name && (t.nodes[e.name] = e), e.material && !t.materials[e.material.name] && (t.materials[e.material.name] = e.material)
            })), t
        }

        function xM(e, t) {
            return e.__r3f = {
                type: "",
                root: null,
                previousAttach: null,
                memoizedProps: {},
                eventCount: 0,
                handlers: {},
                objects: [],
                parent: null,
                ...t
            }, e
        }

        function _M(e, t) {
            let n = e;
            if (t.includes("-")) {
                const r = t.split("-"),
                    i = r.pop();
                return n = r.reduce(((e, t) => e[t]), e), {
                    target: n,
                    key: i
                }
            }
            return {
                target: n,
                key: t
            }
        }
        const MM = /-\d+$/;

        function wM(e, t, n) {
            if (yM.str(n)) {
                if (MM.test(n)) {
                    const t = n.replace(MM, ""),
                        {
                            target: r,
                            key: i
                        } = _M(e, t);
                    Array.isArray(r[i]) || (r[i] = [])
                }
                const {
                    target: r,
                    key: i
                } = _M(e, n);
                t.__r3f.previousAttach = r[i], r[i] = t
            } else t.__r3f.previousAttach = n(e, t)
        }

        function AM(e, t, n) {
            var r, i;
            if (yM.str(n)) {
                const {
                    target: r,
                    key: i
                } = _M(e, n), o = t.__r3f.previousAttach;
                void 0 === o ? delete r[i] : r[i] = o
            } else null == (r = t.__r3f) || null == r.previousAttach || r.previousAttach(e, t);
            null == (i = t.__r3f) || delete i.previousAttach
        }

        function SM(e, t) {
            let {
                children: n,
                key: r,
                ref: i,
                ...o
            } = t, {
                children: a,
                key: s,
                ref: l,
                ...c
            } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, u = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            var d;
            const h = null != (d = null == e ? void 0 : e.__r3f) ? d : {},
                p = Object.entries(o),
                f = [];
            if (u) {
                const e = Object.keys(c);
                for (let t = 0; t < e.length; t++) o.hasOwnProperty(e[t]) || p.unshift([e[t], hM + "remove"])
            }
            p.forEach((t => {
                let [n, r] = t;
                var i;
                if (null != (i = e.__r3f) && i.primitive && "object" === n) return;
                if (yM.equ(r, c[n])) return;
                if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(n)) return f.push([n, r, !0, []]);
                let a = [];
                n.includes("-") && (a = n.split("-")), f.push([n, r, !1, a]);
                for (const e in o) {
                    const t = o[e];
                    e.startsWith("".concat(n, "-")) && f.push([e, t, !1, e.split("-")])
                }
            }));
            const m = { ...o
            };
            return h.memoizedProps && h.memoizedProps.args && (m.args = h.memoizedProps.args), h.memoizedProps && h.memoizedProps.attach && (m.attach = h.memoizedProps.attach), {
                memoized: m,
                changes: f
            }
        }
        const EM = "undefined" !== typeof process && !1;

        function CM(e, t) {
            var n, r, i;
            const o = null != (n = e.__r3f) ? n : {},
                a = o.root,
                s = null != (r = null == a || null == a.getState ? void 0 : a.getState()) ? r : {},
                {
                    memoized: l,
                    changes: c
                } = fM(t) ? t : SM(e, t),
                u = o.eventCount;
            e.__r3f && (e.__r3f.memoizedProps = l);
            for (let d = 0; d < c.length; d++) {
                let [t, n, r, i] = c[d];
                if (oM(e)) {
                    const e = 3001,
                        r = "srgb",
                        i = "srgb-linear";
                    "encoding" === t ? (t = "colorSpace", n = n === e ? r : i) : "outputEncoding" === t && (t = "outputColorSpace", n = n === e ? r : i)
                }
                let a = e,
                    l = a[t];
                if (i.length && (l = i.reduce(((e, t) => e[t]), e), !l || !l.set)) {
                    const [n, ...r] = i.reverse();
                    a = r.reverse().reduce(((e, t) => e[t]), e), t = n
                }
                if (n === hM + "remove")
                    if (a.constructor) {
                        let e = pM.get(a.constructor);
                        e || (e = new a.constructor, pM.set(a.constructor, e)), n = e[t]
                    } else n = 0;
                if (r) n ? o.handlers[t] = n : delete o.handlers[t], o.eventCount = Object.keys(o.handlers).length;
                else if (l && l.set && (l.copy || l instanceof gd)) {
                    if (Array.isArray(n)) l.fromArray ? l.fromArray(n) : l.set(...n);
                    else if (l.copy && n && n.constructor && (EM ? l.constructor.name === n.constructor.name : l.constructor === n.constructor)) l.copy(n);
                    else if (void 0 !== n) {
                        const e = l instanceof Wd;
                        !e && l.setScalar ? l.setScalar(n) : l instanceof gd && n instanceof gd ? l.mask = n.mask : l.set(n), aM() || s.linear || !e || l.convertSRGBToLinear()
                    }
                } else if (a[t] = n, a[t] instanceof bu && a[t].format === Ds && a[t].type === ws) {
                    const e = a[t];
                    oM(e) && oM(s.gl) ? e.colorSpace = s.gl.outputColorSpace : e.encoding = s.gl.outputEncoding
                }
                TM(e)
            }
            if (o.parent && e.raycast && u !== o.eventCount) {
                const t = vM(e).getState().internal,
                    n = t.interaction.indexOf(e);
                n > -1 && t.interaction.splice(n, 1), o.eventCount && t.interaction.push(e)
            }
            return !(1 === c.length && "onUpdate" === c[0][0]) && c.length && null != (i = e.__r3f) && i.parent && PM(e), e
        }

        function TM(e) {
            var t, n;
            const r = null == (t = e.__r3f) || null == (n = t.root) || null == n.getState ? void 0 : n.getState();
            r && 0 === r.internal.frames && r.invalidate()
        }

        function PM(e) {
            null == e.onUpdate || e.onUpdate(e)
        }

        function RM(e, t) {
            e.manual || (sM(e) ? (e.left = t.width / -2, e.right = t.width / 2, e.top = t.height / 2, e.bottom = t.height / -2) : e.aspect = t.width / t.height, e.updateProjectionMatrix(), e.updateMatrixWorld())
        }

        function IM(e) {
            return (e.eventObject || e.object).uuid + "/" + e.index + e.instanceId
        }

        function OM(e, t, n, r) {
            const i = n.get(t);
            i && (n.delete(t), 0 === n.size && (e.delete(r), i.target.releasePointerCapture(r)))
        }

        function BM(e) {
            function t(e) {
                return e.filter((e => ["Move", "Over", "Enter", "Out", "Leave"].some((t => {
                    var n;
                    return null == (n = e.__r3f) ? void 0 : n.handlers["onPointer" + t]
                }))))
            }

            function n(t) {
                const {
                    internal: n
                } = e.getState();
                for (const e of n.hovered.values())
                    if (!t.length || !t.find((t => t.object === e.object && t.index === e.index && t.instanceId === e.instanceId))) {
                        const r = e.eventObject.__r3f,
                            i = null == r ? void 0 : r.handlers;
                        if (n.hovered.delete(IM(e)), null != r && r.eventCount) {
                            const n = { ...e,
                                intersections: t
                            };
                            null == i.onPointerOut || i.onPointerOut(n), null == i.onPointerLeave || i.onPointerLeave(n)
                        }
                    }
            }

            function r(e, t) {
                for (let n = 0; n < t.length; n++) {
                    const r = t[n].__r3f;
                    null == r || null == r.handlers.onPointerMissed || r.handlers.onPointerMissed(e)
                }
            }
            return {
                handlePointer: function(i) {
                    switch (i) {
                        case "onPointerLeave":
                        case "onPointerCancel":
                            return () => n([]);
                        case "onLostPointerCapture":
                            return t => {
                                const {
                                    internal: r
                                } = e.getState();
                                "pointerId" in t && r.capturedMap.has(t.pointerId) && requestAnimationFrame((() => {
                                    r.capturedMap.has(t.pointerId) && (r.capturedMap.delete(t.pointerId), n([]))
                                }))
                            }
                    }
                    return function(o) {
                        const {
                            onPointerMissed: a,
                            internal: s
                        } = e.getState();
                        s.lastEvent.current = o;
                        const l = "onPointerMove" === i,
                            c = "onClick" === i || "onContextMenu" === i || "onDoubleClick" === i,
                            u = function(t, n) {
                                const r = e.getState(),
                                    i = new Set,
                                    o = [],
                                    a = n ? n(r.internal.interaction) : r.internal.interaction;
                                for (let e = 0; e < a.length; e++) {
                                    const t = gM(a[e]);
                                    t && (t.raycaster.camera = void 0)
                                }
                                r.previousRoot || null == r.events.compute || r.events.compute(t, r);
                                let s = a.flatMap((function(e) {
                                    const n = gM(e);
                                    return n && n.events.enabled && null !== n.raycaster.camera ? (void 0 === n.raycaster.camera && (null == n.events.compute || n.events.compute(t, n, null == (r = n.previousRoot) ? void 0 : r.getState()), void 0 === n.raycaster.camera && (n.raycaster.camera = null)), n.raycaster.camera ? n.raycaster.intersectObject(e, !0) : []) : [];
                                    var r
                                })).sort(((e, t) => {
                                    const n = gM(e.object),
                                        r = gM(t.object);
                                    return n && r && r.events.priority - n.events.priority || e.distance - t.distance
                                })).filter((e => {
                                    const t = IM(e);
                                    return !i.has(t) && (i.add(t), !0)
                                }));
                                r.events.filter && (s = r.events.filter(s, r));
                                for (const e of s) {
                                    let t = e.object;
                                    for (; t;) {
                                        var l;
                                        null != (l = t.__r3f) && l.eventCount && o.push({ ...e,
                                            eventObject: t
                                        }), t = t.parent
                                    }
                                }
                                if ("pointerId" in t && r.internal.capturedMap.has(t.pointerId))
                                    for (let e of r.internal.capturedMap.get(t.pointerId).values()) i.has(IM(e.intersection)) || o.push(e.intersection);
                                return o
                            }(o, l ? t : void 0),
                            d = c ? function(t) {
                                const {
                                    internal: n
                                } = e.getState(), r = t.offsetX - n.initialClick[0], i = t.offsetY - n.initialClick[1];
                                return Math.round(Math.sqrt(r * r + i * i))
                            }(o) : 0;
                        "onPointerDown" === i && (s.initialClick = [o.offsetX, o.offsetY], s.initialHits = u.map((e => e.eventObject))), c && !u.length && d <= 2 && (r(o, s.interaction), a && a(o)), l && n(u),
                            function(t, r, i, o) {
                                const a = e.getState();
                                if (t.length) {
                                    const e = {
                                        stopped: !1
                                    };
                                    for (const s of t) {
                                        const l = gM(s.object) || a,
                                            {
                                                raycaster: c,
                                                pointer: u,
                                                camera: d,
                                                internal: h
                                            } = l,
                                            p = new Pu(u.x, u.y, 0).unproject(d),
                                            f = e => {
                                                var t, n;
                                                return null != (t = null == (n = h.capturedMap.get(e)) ? void 0 : n.has(s.eventObject)) && t
                                            },
                                            m = e => {
                                                const t = {
                                                    intersection: s,
                                                    target: r.target
                                                };
                                                h.capturedMap.has(e) ? h.capturedMap.get(e).set(s.eventObject, t) : h.capturedMap.set(e, new Map([
                                                    [s.eventObject, t]
                                                ])), r.target.setPointerCapture(e)
                                            },
                                            g = e => {
                                                const t = h.capturedMap.get(e);
                                                t && OM(h.capturedMap, s.eventObject, t, e)
                                            };
                                        let v = {};
                                        for (let e in r) {
                                            let t = r[e];
                                            "function" !== typeof t && (v[e] = t)
                                        }
                                        let y = { ...s,
                                            ...v,
                                            pointer: u,
                                            intersections: t,
                                            stopped: e.stopped,
                                            delta: i,
                                            unprojectedPoint: p,
                                            ray: c.ray,
                                            camera: d,
                                            stopPropagation() {
                                                const i = "pointerId" in r && h.capturedMap.get(r.pointerId);
                                                (!i || i.has(s.eventObject)) && (y.stopped = e.stopped = !0, h.hovered.size && Array.from(h.hovered.values()).find((e => e.eventObject === s.eventObject))) && n([...t.slice(0, t.indexOf(s)), s])
                                            },
                                            target: {
                                                hasPointerCapture: f,
                                                setPointerCapture: m,
                                                releasePointerCapture: g
                                            },
                                            currentTarget: {
                                                hasPointerCapture: f,
                                                setPointerCapture: m,
                                                releasePointerCapture: g
                                            },
                                            nativeEvent: r
                                        };
                                        if (o(y), !0 === e.stopped) break
                                    }
                                }
                            }(u, o, d, (function(e) {
                                const t = e.eventObject,
                                    n = t.__r3f,
                                    a = null == n ? void 0 : n.handlers;
                                if (null != n && n.eventCount)
                                    if (l) {
                                        if (a.onPointerOver || a.onPointerEnter || a.onPointerOut || a.onPointerLeave) {
                                            const t = IM(e),
                                                n = s.hovered.get(t);
                                            n ? n.stopped && e.stopPropagation() : (s.hovered.set(t, e), null == a.onPointerOver || a.onPointerOver(e), null == a.onPointerEnter || a.onPointerEnter(e))
                                        }
                                        null == a.onPointerMove || a.onPointerMove(e)
                                    } else {
                                        const n = a[i];
                                        n ? c && !s.initialHits.includes(t) || (r(o, s.interaction.filter((e => !s.initialHits.includes(e)))), n(e)) : c && s.initialHits.includes(t) && r(o, s.interaction.filter((e => !s.initialHits.includes(e))))
                                    }
                            }))
                    }
                }
            }
        }
        const LM = ["set", "get", "setSize", "setFrameloop", "setDpr", "events", "invalidate", "advance", "size", "viewport"],
            DM = e => !(null == e || !e.render),
            NM = r.createContext(null),
            kM = (e, t) => {
                const n = X_(((n, i) => {
                        const o = new Pu,
                            a = new Pu,
                            s = new Pu;

                        function l() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : i().camera,
                                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : a,
                                n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : i().size;
                            const {
                                width: r,
                                height: l,
                                top: c,
                                left: u
                            } = n, d = r / l;
                            t instanceof Pu ? s.copy(t) : s.set(...t);
                            const h = e.getWorldPosition(o).distanceTo(s);
                            if (sM(e)) return {
                                width: r / e.zoom,
                                height: l / e.zoom,
                                top: c,
                                left: u,
                                factor: 1,
                                distance: h,
                                aspect: d
                            }; {
                                const t = e.fov * Math.PI / 180,
                                    n = 2 * Math.tan(t / 2) * h,
                                    i = n * (r / l);
                                return {
                                    width: i,
                                    height: n,
                                    top: c,
                                    left: u,
                                    factor: r / i,
                                    distance: h,
                                    aspect: d
                                }
                            }
                        }
                        let c;
                        const u = e => n((t => ({
                                performance: { ...t.performance,
                                    current: e
                                }
                            }))),
                            d = new Yc,
                            h = {
                                set: n,
                                get: i,
                                gl: null,
                                camera: null,
                                raycaster: null,
                                events: {
                                    priority: 1,
                                    enabled: !0,
                                    connected: !1
                                },
                                xr: null,
                                scene: null,
                                invalidate: function() {
                                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
                                    return e(i(), t)
                                },
                                advance: (e, n) => t(e, n, i()),
                                legacy: !1,
                                linear: !1,
                                flat: !1,
                                controls: null,
                                clock: new Sx,
                                pointer: d,
                                mouse: d,
                                frameloop: "always",
                                onPointerMissed: void 0,
                                performance: {
                                    current: 1,
                                    min: .5,
                                    max: 1,
                                    debounce: 200,
                                    regress: () => {
                                        const e = i();
                                        c && clearTimeout(c), e.performance.current !== e.performance.min && u(e.performance.min), c = setTimeout((() => u(i().performance.max)), e.performance.debounce)
                                    }
                                },
                                size: {
                                    width: 0,
                                    height: 0,
                                    top: 0,
                                    left: 0,
                                    updateStyle: !1
                                },
                                viewport: {
                                    initialDpr: 0,
                                    dpr: 0,
                                    width: 0,
                                    height: 0,
                                    top: 0,
                                    left: 0,
                                    aspect: 0,
                                    distance: 0,
                                    factor: 0,
                                    getCurrentViewport: l
                                },
                                setEvents: e => n((t => ({ ...t,
                                    events: { ...t.events,
                                        ...e
                                    }
                                }))),
                                setSize: (e, t, r, o, s) => {
                                    const c = i().camera,
                                        u = {
                                            width: e,
                                            height: t,
                                            top: o || 0,
                                            left: s || 0,
                                            updateStyle: r
                                        };
                                    n((e => ({
                                        size: u,
                                        viewport: { ...e.viewport,
                                            ...l(c, a, u)
                                        }
                                    })))
                                },
                                setDpr: e => n((t => {
                                    const n = mM(e);
                                    return {
                                        viewport: { ...t.viewport,
                                            dpr: n,
                                            initialDpr: t.viewport.initialDpr || n
                                        }
                                    }
                                })),
                                setFrameloop: function() {
                                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "always";
                                    const t = i().clock;
                                    t.stop(), t.elapsedTime = 0, "never" !== e && (t.start(), t.elapsedTime = 0), n((() => ({
                                        frameloop: e
                                    })))
                                },
                                previousRoot: void 0,
                                internal: {
                                    active: !1,
                                    priority: 0,
                                    frames: 0,
                                    lastEvent: r.createRef(),
                                    interaction: [],
                                    hovered: new Map,
                                    subscribers: [],
                                    initialClick: [0, 0],
                                    initialHits: [],
                                    capturedMap: new Map,
                                    subscribe: (e, t, n) => {
                                        const r = i().internal;
                                        return r.priority = r.priority + (t > 0 ? 1 : 0), r.subscribers.push({
                                            ref: e,
                                            priority: t,
                                            store: n
                                        }), r.subscribers = r.subscribers.sort(((e, t) => e.priority - t.priority)), () => {
                                            const n = i().internal;
                                            null != n && n.subscribers && (n.priority = n.priority - (t > 0 ? 1 : 0), n.subscribers = n.subscribers.filter((t => t.ref !== e)))
                                        }
                                    }
                                }
                            };
                        return h
                    })),
                    i = n.getState();
                let o = i.size,
                    a = i.viewport.dpr,
                    s = i.camera;
                return n.subscribe((() => {
                    const {
                        camera: e,
                        size: t,
                        viewport: r,
                        gl: i,
                        set: l
                    } = n.getState();
                    if (t.width !== o.width || t.height !== o.height || r.dpr !== a) {
                        var c;
                        o = t, a = r.dpr, RM(e, t), i.setPixelRatio(r.dpr);
                        const n = null != (c = t.updateStyle) ? c : "undefined" !== typeof HTMLCanvasElement && i.domElement instanceof HTMLCanvasElement;
                        i.setSize(t.width, t.height, n)
                    }
                    e !== s && (s = e, l((t => ({
                        viewport: { ...t.viewport,
                            ...t.viewport.getCurrentViewport(e)
                        }
                    }))))
                })), n.subscribe((t => e(t))), n
            };
        let FM, UM = new Set,
            zM = new Set,
            HM = new Set;

        function jM(e, t) {
            if (e.size)
                for (const {
                        callback: n
                    } of e.values()) n(t)
        }

        function GM(e, t) {
            switch (e) {
                case "before":
                    return jM(UM, t);
                case "after":
                    return jM(zM, t);
                case "tail":
                    return jM(HM, t)
            }
        }
        let VM, qM;

        function WM(e, t, n) {
            let r = t.clock.getDelta();
            for ("never" === t.frameloop && "number" === typeof e && (r = e - t.clock.elapsedTime, t.clock.oldTime = t.clock.elapsedTime, t.clock.elapsedTime = e), VM = t.internal.subscribers, FM = 0; FM < VM.length; FM++) qM = VM[FM], qM.ref.current(qM.store.getState(), r, n);
            return !t.internal.priority && t.gl.render && t.gl.render(t.scene, t.camera), t.internal.frames = Math.max(0, t.internal.frames - 1), "always" === t.frameloop ? 1 : t.internal.frames
        }

        function XM() {
            const e = r.useContext(NM);
            if (!e) throw new Error("R3F: Hooks can only be used within the Canvas component!");
            return e
        }

        function KM() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : e => e,
                t = arguments.length > 1 ? arguments[1] : void 0;
            return XM()(e, t)
        }

        function JM(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            const n = XM(),
                r = n.getState().internal.subscribe,
                i = cM(e);
            return lM((() => r(i, t, n)), [t, r, n]), null
        }
        const YM = new WeakMap;

        function QM(e, t) {
            return function(n) {
                let r = YM.get(n);
                r || (r = new n, YM.set(n, r)), e && e(r);
                for (var i = arguments.length, o = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++) o[a - 1] = arguments[a];
                return Promise.all(o.map((e => new Promise(((n, i) => r.load(e, (e => {
                    e.scene && Object.assign(e, bM(e.scene)), n(e)
                }), t, (t => i(new Error("Could not load ".concat(e, ": ").concat(null == t ? void 0 : t.message)))))))))).finally((() => null == r.dispose ? void 0 : r.dispose()))
            }
        }

        function ZM(e, t, n, r) {
            const i = Array.isArray(t) ? t : [t],
                o = eM(QM(n, r), [e, ...i], {
                    equal: yM.equ
                });
            return Array.isArray(t) ? o : o[0]
        }
        ZM.preload = function(e, t, n) {
            const r = Array.isArray(t) ? t : [t];
            return ((e, t, n) => {
                $_(e, t, !0, n)
            })(QM(n), [e, ...r])
        }, ZM.clear = function(e, t) {
            return (e => {
                if (void 0 === e || 0 === e.length) Q_.splice(0, Q_.length);
                else {
                    const t = Q_.find((t => Z_(e, t.keys, t.equal)));
                    t && t.remove()
                }
            })([e, ...Array.isArray(t) ? t : [t]])
        };
        const $M = new Map,
            {
                invalidate: ew,
                advance: tw
            } = function(e) {
                let t, n, r, i = !1;

                function o(a) {
                    n = requestAnimationFrame(o), i = !0, t = 0, GM("before", a);
                    for (const n of e.values()) {
                        var s;
                        r = n.store.getState(), !r.internal.active || !("always" === r.frameloop || r.internal.frames > 0) || null != (s = r.gl.xr) && s.isPresenting || (t += WM(a, r))
                    }
                    if (GM("after", a), 0 === t) return GM("tail", a), i = !1, cancelAnimationFrame(n)
                }
                return {
                    loop: o,
                    invalidate: function t(n) {
                        let r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                        var a;
                        if (!n) return e.forEach((e => t(e.store.getState())), r);
                        null != (a = n.gl.xr) && a.isPresenting || !n.internal.active || "never" === n.frameloop || (n.internal.frames = Math.min(60, n.internal.frames + r), i || (i = !0, requestAnimationFrame(o)))
                    },
                    advance: function(t) {
                        let n = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                            r = arguments.length > 2 ? arguments[2] : void 0,
                            i = arguments.length > 3 ? arguments[3] : void 0;
                        if (n && GM("before", t), r) WM(t, r, i);
                        else
                            for (const o of e.values()) WM(t, o.store.getState());
                        n && GM("after", t)
                    }
                }
            }($M),
            {
                reconciler: nw,
                applyProps: rw
            } = function(e, t) {
                function n(e, t, n) {
                    let r, {
                            args: i = [],
                            attach: o,
                            ...a
                        } = t,
                        s = "".concat(e[0].toUpperCase()).concat(e.slice(1));
                    if ("primitive" === e) {
                        if (void 0 === a.object) throw new Error("R3F: Primitives without 'object' are invalid!");
                        r = xM(a.object, {
                            type: e,
                            root: n,
                            attach: o,
                            primitive: !0
                        })
                    } else {
                        const t = tM[s];
                        if (!t) throw new Error("R3F: ".concat(s, " is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively"));
                        if (!Array.isArray(i)) throw new Error("R3F: The args prop must be an array!");
                        r = xM(new t(...i), {
                            type: e,
                            root: n,
                            attach: o,
                            memoizedProps: {
                                args: i
                            }
                        })
                    }
                    return void 0 === r.__r3f.attach && (r instanceof Mh ? r.__r3f.attach = "geometry" : r instanceof Jd && (r.__r3f.attach = "material")), "inject" !== s && CM(r, a), r
                }

                function r(e, t) {
                    let n = !1;
                    var r, i;
                    t && (null != (r = t.__r3f) && r.attach ? wM(e, t, t.__r3f.attach) : t.isObject3D && e.isObject3D && (e.add(t), n = !0), n || null == (i = e.__r3f) || i.objects.push(t), t.__r3f || xM(t, {}), t.__r3f.parent = e, PM(t), TM(t))
                }

                function i(e, t, n) {
                    let r = !1;
                    if (t) {
                        var i, o;
                        if (null != (i = t.__r3f) && i.attach) wM(e, t, t.__r3f.attach);
                        else if (t.isObject3D && e.isObject3D) {
                            t.parent = e, t.dispatchEvent({
                                type: "added"
                            });
                            const i = e.children.filter((e => e !== t)),
                                o = i.indexOf(n);
                            e.children = [...i.slice(0, o), t, ...i.slice(o)], r = !0
                        }
                        r || null == (o = e.__r3f) || o.objects.push(t), t.__r3f || xM(t, {}), t.__r3f.parent = e, PM(t), TM(t)
                    }
                }

                function o(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                    e && [...e].forEach((e => a(t, e, n)))
                }

                function a(e, t, n) {
                    if (t) {
                        var r, i, a;
                        if (t.__r3f && (t.__r3f.parent = null), null != (r = e.__r3f) && r.objects && (e.__r3f.objects = e.__r3f.objects.filter((e => e !== t))), null != (i = t.__r3f) && i.attach) AM(e, t, t.__r3f.attach);
                        else if (t.isObject3D && e.isObject3D) {
                            var s;
                            e.remove(t), null != (s = t.__r3f) && s.root && function(e, t) {
                                const {
                                    internal: n
                                } = e.getState();
                                n.interaction = n.interaction.filter((e => e !== t)), n.initialHits = n.initialHits.filter((e => e !== t)), n.hovered.forEach(((e, r) => {
                                    e.eventObject !== t && e.object !== t || n.hovered.delete(r)
                                })), n.capturedMap.forEach(((e, r) => {
                                    OM(n.capturedMap, t, e, r)
                                }))
                            }(vM(t), t)
                        }
                        const c = null == (a = t.__r3f) ? void 0 : a.primitive,
                            u = !c && (void 0 === n ? null !== t.dispose : n);
                        var l;
                        if (!c) o(null == (l = t.__r3f) ? void 0 : l.objects, t, u), o(t.children, t, u);
                        if (delete t.__r3f, u && t.dispose && "Scene" !== t.type) {
                            const e = () => {
                                try {
                                    t.dispose()
                                } catch (e) {}
                            };
                            "undefined" === typeof IS_REACT_ACT_ENVIRONMENT ? (0, Y_.unstable_scheduleCallback)(Y_.unstable_IdlePriority, e) : e()
                        }
                        TM(e)
                    }
                }
                const s = () => console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters."),
                    l = J_()({
                        createInstance: n,
                        removeChild: a,
                        appendChild: r,
                        appendInitialChild: r,
                        insertBefore: i,
                        supportsMutation: !0,
                        isPrimaryRenderer: !1,
                        supportsPersistence: !1,
                        supportsHydration: !1,
                        noTimeout: -1,
                        appendChildToContainer: (e, t) => {
                            if (!t) return;
                            const n = e.getState().scene;
                            n.__r3f && (n.__r3f.root = e, r(n, t))
                        },
                        removeChildFromContainer: (e, t) => {
                            t && a(e.getState().scene, t)
                        },
                        insertInContainerBefore: (e, t, n) => {
                            if (!t || !n) return;
                            const r = e.getState().scene;
                            r.__r3f && i(r, t, n)
                        },
                        getRootHostContext: () => null,
                        getChildHostContext: e => e,
                        finalizeInitialChildren(e) {
                            var t;
                            const n = null != (t = null == e ? void 0 : e.__r3f) ? t : {};
                            return Boolean(n.handlers)
                        },
                        prepareUpdate(e, t, n, r) {
                            var i;
                            if ((null != (i = null == e ? void 0 : e.__r3f) ? i : {}).primitive && r.object && r.object !== e) return [!0]; {
                                const {
                                    args: t = [],
                                    children: i,
                                    ...o
                                } = r, {
                                    args: a = [],
                                    children: s,
                                    ...l
                                } = n;
                                if (!Array.isArray(t)) throw new Error("R3F: the args prop must be an array!");
                                if (t.some(((e, t) => e !== a[t]))) return [!0];
                                const c = SM(e, o, l, !0);
                                return c.changes.length ? [!1, c] : null
                            }
                        },
                        commitUpdate(e, t, i, o, s, l) {
                            let [c, u] = t;
                            c ? function(e, t, i, o) {
                                var s;
                                const l = null == (s = e.__r3f) ? void 0 : s.parent;
                                if (!l) return;
                                const c = n(t, i, e.__r3f.root);
                                if (e.children) {
                                    for (const t of e.children) t.__r3f && r(c, t);
                                    e.children = e.children.filter((e => !e.__r3f))
                                }
                                e.__r3f.objects.forEach((e => r(c, e))), e.__r3f.objects = [], e.__r3f.autoRemovedBeforeAppend || a(l, e), c.parent && (c.__r3f.autoRemovedBeforeAppend = !0), r(l, c), c.raycast && c.__r3f.eventCount && vM(c).getState().internal.interaction.push(c);
                                [o, o.alternate].forEach((e => {
                                    null !== e && (e.stateNode = c, e.ref && ("function" === typeof e.ref ? e.ref(c) : e.ref.current = c))
                                }))
                            }(e, i, s, l) : CM(e, u)
                        },
                        commitMount(e, t, n, r) {
                            var i;
                            const o = null != (i = e.__r3f) ? i : {};
                            e.raycast && o.handlers && o.eventCount && vM(e).getState().internal.interaction.push(e)
                        },
                        getPublicInstance: e => e,
                        prepareForCommit: () => null,
                        preparePortalMount: e => xM(e.getState().scene),
                        resetAfterCommit: () => {},
                        shouldSetTextContent: () => !1,
                        clearContainer: () => !1,
                        hideInstance(e) {
                            var t;
                            const {
                                attach: n,
                                parent: r
                            } = null != (t = e.__r3f) ? t : {};
                            n && r && AM(r, e, n), e.isObject3D && (e.visible = !1), TM(e)
                        },
                        unhideInstance(e, t) {
                            var n;
                            const {
                                attach: r,
                                parent: i
                            } = null != (n = e.__r3f) ? n : {};
                            r && i && wM(i, e, r), (e.isObject3D && null == t.visible || t.visible) && (e.visible = !0), TM(e)
                        },
                        createTextInstance: s,
                        hideTextInstance: s,
                        unhideTextInstance: s,
                        getCurrentEventPriority: () => t ? t() : V_.DefaultEventPriority,
                        beforeActiveInstanceBlur: () => {},
                        afterActiveInstanceBlur: () => {},
                        detachDeletedInstance: () => {},
                        now: "undefined" !== typeof performance && yM.fun(performance.now) ? performance.now : yM.fun(Date.now) ? Date.now : () => 0,
                        scheduleTimeout: yM.fun(setTimeout) ? setTimeout : void 0,
                        cancelTimeout: yM.fun(clearTimeout) ? clearTimeout : void 0
                    });
                return {
                    reconciler: l,
                    applyProps: CM
                }
            }(0, (function() {
                var e;
                const t = "undefined" !== typeof self && self || "undefined" !== typeof window && window;
                if (!t) return V_.DefaultEventPriority;
                switch (null == (e = t.event) ? void 0 : e.type) {
                    case "click":
                    case "contextmenu":
                    case "dblclick":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointerup":
                        return V_.DiscreteEventPriority;
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerenter":
                    case "pointerleave":
                    case "wheel":
                        return V_.ContinuousEventPriority;
                    default:
                        return V_.DefaultEventPriority
                }
            })),
            iw = {
                objects: "shallow",
                strict: !1
            },
            ow = (e, t) => {
                const n = "function" === typeof e ? e(t) : e;
                return DM(n) ? n : new Km({
                    powerPreference: "high-performance",
                    canvas: t,
                    antialias: !0,
                    alpha: !0,
                    ...e
                })
            };

        function aw(e) {
            const t = $M.get(e),
                n = null == t ? void 0 : t.fiber,
                i = null == t ? void 0 : t.store;
            t && console.warn("R3F.createRoot should only be called once!");
            const o = "function" === typeof reportError ? reportError : console.error,
                a = i || kM(ew, tw),
                s = n || nw.createContainer(a, V_.ConcurrentRoot, null, !1, null, "", o, null);
            let l;
            t || $M.set(e, {
                fiber: s,
                store: a
            });
            let c, u = !1;
            return {
                configure() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                        {
                            gl: n,
                            size: r,
                            scene: i,
                            events: o,
                            onCreated: s,
                            shadows: d = !1,
                            linear: h = !1,
                            flat: p = !1,
                            legacy: f = !1,
                            orthographic: m = !1,
                            frameloop: g = "always",
                            dpr: v = [1, 2],
                            performance: y,
                            raycaster: b,
                            camera: x,
                            onPointerMissed: _
                        } = t,
                        M = a.getState(),
                        w = M.gl;
                    M.gl || M.set({
                        gl: w = ow(n, e)
                    });
                    let A = M.raycaster;
                    A || M.set({
                        raycaster: A = new n_
                    });
                    const {
                        params: S,
                        ...E
                    } = b || {};
                    if (yM.equ(E, A, iw) || rw(A, { ...E
                        }), yM.equ(S, A.params, iw) || rw(A, {
                            params: { ...A.params,
                                ...S
                            }
                        }), !M.camera || M.camera === c && !yM.equ(c, x, iw)) {
                        c = x;
                        const e = x instanceof Kh,
                            t = e ? x : m ? new wp(0, 0, 0, 0, .1, 1e3) : new Zh(75, 0, .1, 1e3);
                        e || (t.position.z = 5, x && rw(t, x), M.camera || null != x && x.rotation || t.lookAt(0, 0, 0)), M.set({
                            camera: t
                        }), A.camera = t
                    }
                    if (!M.scene) {
                        let e;
                        i instanceof Zm ? e = i : (e = new Zm, i && rw(e, i)), M.set({
                            scene: xM(e)
                        })
                    }
                    if (!M.xr) {
                        var C;
                        const e = (e, t) => {
                                const n = a.getState();
                                "never" !== n.frameloop && tw(e, !0, n, t)
                            },
                            t = () => {
                                const t = a.getState();
                                t.gl.xr.enabled = t.gl.xr.isPresenting, t.gl.xr.setAnimationLoop(t.gl.xr.isPresenting ? e : null), t.gl.xr.isPresenting || ew(t)
                            },
                            n = {
                                connect() {
                                    const e = a.getState().gl;
                                    e.xr.addEventListener("sessionstart", t), e.xr.addEventListener("sessionend", t)
                                },
                                disconnect() {
                                    const e = a.getState().gl;
                                    e.xr.removeEventListener("sessionstart", t), e.xr.removeEventListener("sessionend", t)
                                }
                            };
                        "function" === typeof(null == (C = w.xr) ? void 0 : C.addEventListener) && n.connect(), M.set({
                            xr: n
                        })
                    }
                    if (w.shadowMap) {
                        const e = w.shadowMap.enabled,
                            t = w.shadowMap.type;
                        if (w.shadowMap.enabled = !!d, yM.boo(d)) w.shadowMap.type = sa;
                        else if (yM.str(d)) {
                            var T;
                            const e = {
                                basic: oa,
                                percentage: aa,
                                soft: sa,
                                variance: la
                            };
                            w.shadowMap.type = null != (T = e[d]) ? T : sa
                        } else yM.obj(d) && Object.assign(w.shadowMap, d);
                        e === w.shadowMap.enabled && t === w.shadowMap.type || (w.shadowMap.needsUpdate = !0)
                    }
                    const P = aM();
                    P && ("enabled" in P ? P.enabled = !f : "legacyMode" in P && (P.legacyMode = f));
                    rw(w, {
                        outputEncoding: h ? 3e3 : 3001,
                        toneMapping: p ? Ja : $a
                    }), M.legacy !== f && M.set((() => ({
                        legacy: f
                    }))), M.linear !== h && M.set((() => ({
                        linear: h
                    }))), M.flat !== p && M.set((() => ({
                        flat: p
                    }))), !n || yM.fun(n) || DM(n) || yM.equ(n, w, iw) || rw(w, n), o && !M.events.handlers && M.set({
                        events: o(a)
                    });
                    const R = function(e, t) {
                        const n = "undefined" !== typeof HTMLCanvasElement && e instanceof HTMLCanvasElement;
                        if (t) {
                            const {
                                width: e,
                                height: r,
                                top: i,
                                left: o,
                                updateStyle: a = n
                            } = t;
                            return {
                                width: e,
                                height: r,
                                top: i,
                                left: o,
                                updateStyle: a
                            }
                        }
                        if ("undefined" !== typeof HTMLCanvasElement && e instanceof HTMLCanvasElement && e.parentElement) {
                            const {
                                width: t,
                                height: r,
                                top: i,
                                left: o
                            } = e.parentElement.getBoundingClientRect();
                            return {
                                width: t,
                                height: r,
                                top: i,
                                left: o,
                                updateStyle: n
                            }
                        }
                        return "undefined" !== typeof OffscreenCanvas && e instanceof OffscreenCanvas ? {
                            width: e.width,
                            height: e.height,
                            top: 0,
                            left: 0,
                            updateStyle: n
                        } : {
                            width: 0,
                            height: 0,
                            top: 0,
                            left: 0
                        }
                    }(e, r);
                    return yM.equ(R, M.size, iw) || M.setSize(R.width, R.height, R.updateStyle, R.top, R.left), v && M.viewport.dpr !== mM(v) && M.setDpr(v), M.frameloop !== g && M.setFrameloop(g), M.onPointerMissed || M.set({
                        onPointerMissed: _
                    }), y && !yM.equ(y, M.performance, iw) && M.set((e => ({
                        performance: { ...e.performance,
                            ...y
                        }
                    }))), l = s, u = !0, this
                },
                render(t) {
                    return u || this.configure(), nw.updateContainer(r.createElement(sw, {
                        store: a,
                        children: t,
                        onCreated: l,
                        rootElement: e
                    }), s, null, (() => {})), a
                },
                unmount() {
                    lw(e)
                }
            }
        }

        function sw(e) {
            let {
                store: t,
                children: n,
                onCreated: i,
                rootElement: o
            } = e;
            return lM((() => {
                const e = t.getState();
                e.set((e => ({
                    internal: { ...e.internal,
                        active: !0
                    }
                }))), i && i(e), t.getState().events.connected || null == e.events.connect || e.events.connect(o)
            }), []), r.createElement(NM.Provider, {
                value: t
            }, n)
        }

        function lw(e, t) {
            const n = $M.get(e),
                r = null == n ? void 0 : n.fiber;
            if (r) {
                const i = null == n ? void 0 : n.store.getState();
                i && (i.internal.active = !1), nw.updateContainer(null, r, null, (() => {
                    i && setTimeout((() => {
                        try {
                            var n, r, o, a;
                            null == i.events.disconnect || i.events.disconnect(), null == (n = i.gl) || null == (r = n.renderLists) || null == r.dispose || r.dispose(), null == (o = i.gl) || null == o.forceContextLoss || o.forceContextLoss(), null != (a = i.gl) && a.xr && i.xr.disconnect(),
                                function(e) {
                                    e.dispose && "Scene" !== e.type && e.dispose();
                                    for (const t in e) null == t.dispose || t.dispose(), delete e[t]
                                }(i), $M.delete(e), t && t(e)
                        } catch (s) {}
                    }), 500)
                }))
            }
        }

        function cw(e) {
            let {
                state: t = {},
                children: n,
                container: i
            } = e;
            const {
                events: o,
                size: a,
                ...s
            } = t, l = XM(), [c] = r.useState((() => new n_)), [u] = r.useState((() => new Yc)), d = r.useCallback(((e, t) => {
                const n = { ...e
                };
                let r;
                if (Object.keys(e).forEach((r => {
                        (LM.includes(r) || e[r] !== t[r] && t[r]) && delete n[r]
                    })), t && a) {
                    const n = t.camera;
                    r = e.viewport.getCurrentViewport(n, new Pu, a), n !== e.camera && RM(n, a)
                }
                return { ...n,
                    scene: i,
                    raycaster: c,
                    pointer: u,
                    mouse: u,
                    previousRoot: l,
                    events: { ...e.events,
                        ...null == t ? void 0 : t.events,
                        ...o
                    },
                    size: { ...e.size,
                        ...a
                    },
                    viewport: { ...e.viewport,
                        ...r
                    },
                    ...s
                }
            }), [t]), [h] = r.useState((() => {
                const e = l.getState(),
                    t = X_(((t, n) => ({ ...e,
                        scene: i,
                        raycaster: c,
                        pointer: u,
                        mouse: u,
                        previousRoot: l,
                        events: { ...e.events,
                            ...o
                        },
                        size: { ...e.size,
                            ...a
                        },
                        ...s,
                        set: t,
                        get: n,
                        setEvents: e => t((t => ({ ...t,
                            events: { ...t.events,
                                ...e
                            }
                        })))
                    })));
                return t
            }));
            return r.useEffect((() => {
                const e = l.subscribe((e => h.setState((t => d(e, t)))));
                return () => {
                    e(), h.destroy()
                }
            }), []), r.useEffect((() => {
                h.setState((e => d(l.getState(), e)))
            }), [d]), r.createElement(r.Fragment, null, nw.createPortal(r.createElement(NM.Provider, {
                value: h
            }, n), h, null))
        }
        nw.injectIntoDevTools({
            bundleType: 0,
            rendererPackageName: "@react-three/fiber",
            version: r.version
        });
        r.unstable_act;
        var uw = n(5072),
            dw = n(6776),
            hw = n.n(dw);

        function pw(e) {
            let {
                debounce: t,
                scroll: n,
                polyfill: i,
                offsetSize: o
            } = void 0 === e ? {
                debounce: 0,
                scroll: !1,
                offsetSize: !1
            } : e;
            const a = i || ("undefined" === typeof window ? class {} : window.ResizeObserver);
            if (!a) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
            const [s, l] = (0, r.useState)({
                left: 0,
                top: 0,
                width: 0,
                height: 0,
                bottom: 0,
                right: 0,
                x: 0,
                y: 0
            }), c = (0, r.useRef)({
                element: null,
                scrollContainers: null,
                resizeObserver: null,
                lastBounds: s
            }), u = t ? "number" === typeof t ? t : t.scroll : null, d = t ? "number" === typeof t ? t : t.resize : null, h = (0, r.useRef)(!1);
            (0, r.useEffect)((() => (h.current = !0, () => {
                h.current = !1
            })));
            const [p, f, m] = (0, r.useMemo)((() => {
                const e = () => {
                    if (!c.current.element) return;
                    const {
                        left: e,
                        top: t,
                        width: n,
                        height: r,
                        bottom: i,
                        right: a,
                        x: s,
                        y: u
                    } = c.current.element.getBoundingClientRect(), d = {
                        left: e,
                        top: t,
                        width: n,
                        height: r,
                        bottom: i,
                        right: a,
                        x: s,
                        y: u
                    };
                    c.current.element instanceof HTMLElement && o && (d.height = c.current.element.offsetHeight, d.width = c.current.element.offsetWidth), Object.freeze(d), h.current && !gw(c.current.lastBounds, d) && l(c.current.lastBounds = d)
                };
                return [e, d ? hw()(e, d) : e, u ? hw()(e, u) : e]
            }), [l, o, u, d]);

            function g() {
                c.current.scrollContainers && (c.current.scrollContainers.forEach((e => e.removeEventListener("scroll", m, !0))), c.current.scrollContainers = null), c.current.resizeObserver && (c.current.resizeObserver.disconnect(), c.current.resizeObserver = null)
            }

            function v() {
                c.current.element && (c.current.resizeObserver = new a(m), c.current.resizeObserver.observe(c.current.element), n && c.current.scrollContainers && c.current.scrollContainers.forEach((e => e.addEventListener("scroll", m, {
                    capture: !0,
                    passive: !0
                }))))
            }
            var y, b, x;
            return y = m, b = Boolean(n), (0, r.useEffect)((() => {
                if (b) {
                    const e = y;
                    return window.addEventListener("scroll", e, {
                        capture: !0,
                        passive: !0
                    }), () => {
                        window.removeEventListener("scroll", e, !0)
                    }
                }
            }), [y, b]), x = f, (0, r.useEffect)((() => {
                const e = x;
                return window.addEventListener("resize", e), () => {
                    window.removeEventListener("resize", e)
                }
            }), [x]), (0, r.useEffect)((() => {
                g(), v()
            }), [n, m, f]), (0, r.useEffect)((() => g), []), [e => {
                e && e !== c.current.element && (g(), c.current.element = e, c.current.scrollContainers = fw(e), v())
            }, s, p]
        }

        function fw(e) {
            const t = [];
            if (!e || e === document.body) return t;
            const {
                overflow: n,
                overflowX: r,
                overflowY: i
            } = window.getComputedStyle(e);
            return [n, r, i].some((e => "auto" === e || "scroll" === e)) && t.push(e), [...t, ...fw(e.parentElement)]
        }
        const mw = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
            gw = (e, t) => mw.every((n => e[n] === t[n]));
        var vw = Object.defineProperty,
            yw = Object.defineProperties,
            bw = Object.getOwnPropertyDescriptors,
            xw = Object.getOwnPropertySymbols,
            _w = Object.prototype.hasOwnProperty,
            Mw = Object.prototype.propertyIsEnumerable,
            ww = (e, t, n) => t in e ? vw(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : e[t] = n,
            Aw = (e, t) => {
                for (var n in t || (t = {})) _w.call(t, n) && ww(e, n, t[n]);
                if (xw)
                    for (var n of xw(t)) Mw.call(t, n) && ww(e, n, t[n]);
                return e
            };

        function Sw(e, t, n) {
            if (!e) return;
            if (!0 === n(e)) return e;
            let r = t ? e.return : e.child;
            for (; r;) {
                const e = Sw(r, t, n);
                if (e) return e;
                r = t ? null : r.sibling
            }
        }

        function Ew(e) {
            try {
                return Object.defineProperties(e, {
                    _currentRenderer: {
                        get: () => null,
                        set() {}
                    },
                    _currentRenderer2: {
                        get: () => null,
                        set() {}
                    }
                })
            } catch (t) {
                return e
            }
        }
        const Cw = Ew(r.createContext(null));
        class Tw extends r.Component {
            render() {
                return r.createElement(Cw.Provider, {
                    value: this._reactInternals
                }, this.props.children)
            }
        }
        const {
            ReactCurrentOwner: Pw,
            ReactCurrentDispatcher: Rw
        } = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

        function Iw() {
            const e = r.useContext(Cw);
            if (null === e) throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
            const t = r.useId();
            return r.useMemo((() => {
                for (const n of [null == Pw ? void 0 : Pw.current, e, null == e ? void 0 : e.alternate]) {
                    if (!n) continue;
                    const e = Sw(n, !1, (e => {
                        let n = e.memoizedState;
                        for (; n;) {
                            if (n.memoizedState === t) return !0;
                            n = n.next
                        }
                    }));
                    if (e) return e
                }
            }), [e, t])
        }

        function Ow() {
            const e = function() {
                var e, t;
                const n = Iw(),
                    [i] = r.useState((() => new Map));
                i.clear();
                let o = n;
                for (; o;) {
                    const n = null == (e = o.type) ? void 0 : e._context;
                    n && n !== Cw && !i.has(n) && i.set(n, null == (t = null == Rw ? void 0 : Rw.current) ? void 0 : t.readContext(Ew(n))), o = o.return
                }
                return i
            }();
            return r.useMemo((() => Array.from(e.keys()).reduce(((t, n) => i => {
                return r.createElement(t, null, r.createElement(n.Provider, (o = Aw({}, i), a = {
                    value: e.get(n)
                }, yw(o, bw(a)))));
                var o, a
            }), (e => r.createElement(Tw, Aw({}, e))))), [e])
        }
        const Bw = {
            onClick: ["click", !1],
            onContextMenu: ["contextmenu", !1],
            onDoubleClick: ["dblclick", !1],
            onWheel: ["wheel", !0],
            onPointerDown: ["pointerdown", !0],
            onPointerUp: ["pointerup", !0],
            onPointerLeave: ["pointerleave", !0],
            onPointerMove: ["pointermove", !0],
            onPointerCancel: ["pointercancel", !0],
            onLostPointerCapture: ["lostpointercapture", !0]
        };

        function Lw(e) {
            const {
                handlePointer: t
            } = BM(e);
            return {
                priority: 1,
                enabled: !0,
                compute(e, t, n) {
                    t.pointer.set(e.offsetX / t.size.width * 2 - 1, -e.offsetY / t.size.height * 2 + 1), t.raycaster.setFromCamera(t.pointer, t.camera)
                },
                connected: void 0,
                handlers: Object.keys(Bw).reduce(((e, n) => ({ ...e,
                    [n]: t(n)
                })), {}),
                update: () => {
                    var t;
                    const {
                        events: n,
                        internal: r
                    } = e.getState();
                    null != (t = r.lastEvent) && t.current && n.handlers && n.handlers.onPointerMove(r.lastEvent.current)
                },
                connect: t => {
                    var n;
                    const {
                        set: r,
                        events: i
                    } = e.getState();
                    null == i.disconnect || i.disconnect(), r((e => ({
                        events: { ...e.events,
                            connected: t
                        }
                    }))), Object.entries(null != (n = i.handlers) ? n : []).forEach((e => {
                        let [n, r] = e;
                        const [i, o] = Bw[n];
                        t.addEventListener(i, r, {
                            passive: o
                        })
                    }))
                },
                disconnect: () => {
                    const {
                        set: t,
                        events: n
                    } = e.getState();
                    var r;
                    n.connected && (Object.entries(null != (r = n.handlers) ? r : []).forEach((e => {
                        let [t, r] = e;
                        if (n && n.connected instanceof HTMLElement) {
                            const [e] = Bw[t];
                            n.connected.removeEventListener(e, r)
                        }
                    })), t((e => ({
                        events: { ...e.events,
                            connected: void 0
                        }
                    }))))
                }
            }
        }
        const Dw = r.forwardRef((function(e, n) {
                let {
                    children: i,
                    fallback: o,
                    resize: a,
                    style: s,
                    gl: l,
                    events: c = Lw,
                    eventSource: u,
                    eventPrefix: d,
                    shadows: h,
                    linear: p,
                    flat: f,
                    legacy: m,
                    orthographic: g,
                    frameloop: v,
                    dpr: y,
                    performance: b,
                    raycaster: x,
                    camera: _,
                    scene: M,
                    onPointerMissed: w,
                    onCreated: A,
                    ...S
                } = e;
                r.useMemo((() => nM(t)), []);
                const E = Ow(),
                    [C, T] = pw({
                        scroll: !0,
                        debounce: {
                            scroll: 50,
                            resize: 0
                        },
                        ...a
                    }),
                    P = r.useRef(null),
                    R = r.useRef(null);
                r.useImperativeHandle(n, (() => P.current));
                const I = cM(w),
                    [O, B] = r.useState(!1),
                    [L, D] = r.useState(!1);
                if (O) throw O;
                if (L) throw L;
                const N = r.useRef(null);
                lM((() => {
                    const e = P.current;
                    T.width > 0 && T.height > 0 && e && (N.current || (N.current = aw(e)), N.current.configure({
                        gl: l,
                        events: c,
                        shadows: h,
                        linear: p,
                        flat: f,
                        legacy: m,
                        orthographic: g,
                        frameloop: v,
                        dpr: y,
                        performance: b,
                        raycaster: x,
                        camera: _,
                        scene: M,
                        size: T,
                        onPointerMissed: function() {
                            return null == I.current ? void 0 : I.current(...arguments)
                        },
                        onCreated: e => {
                            var t;
                            null == e.events.connect || e.events.connect(u ? (t = u) && t.hasOwnProperty("current") ? u.current : u : R.current), d && e.setEvents({
                                compute: (e, t) => {
                                    const n = e[d + "X"],
                                        r = e[d + "Y"];
                                    t.pointer.set(n / t.size.width * 2 - 1, -r / t.size.height * 2 + 1), t.raycaster.setFromCamera(t.pointer, t.camera)
                                }
                            }), null == A || A(e)
                        }
                    }), N.current.render(r.createElement(E, null, r.createElement(dM, {
                        set: D
                    }, r.createElement(r.Suspense, {
                        fallback: r.createElement(uM, {
                            set: B
                        })
                    }, i)))))
                })), r.useEffect((() => {
                    const e = P.current;
                    if (e) return () => lw(e)
                }), []);
                const k = u ? "none" : "auto";
                return r.createElement("div", (0, uw.c)({
                    ref: R,
                    style: {
                        position: "relative",
                        width: "100%",
                        height: "100%",
                        overflow: "hidden",
                        pointerEvents: k,
                        ...s
                    }
                }, S), r.createElement("div", {
                    ref: C,
                    style: {
                        width: "100%",
                        height: "100%"
                    }
                }, r.createElement("canvas", {
                    ref: P,
                    style: {
                        display: "block"
                    }
                }, o)))
            })),
            Nw = r.forwardRef((function(e, t) {
                return r.createElement(Tw, null, r.createElement(Dw, (0, uw.c)({}, e, {
                    ref: t
                })))
            }));
        class kw extends zh {
            constructor(e, t) {
                var n, r;
                const i = (o = e) && o.isCubeTexture;
                var o;
                const a = (null != (r = i ? null == (n = e.image[0]) ? void 0 : n.width : e.image.width) ? r : 1024) / 4,
                    s = Math.floor(Math.log2(a)),
                    l = Math.pow(2, s),
                    c = 3 * Math.max(l, 112),
                    u = 4 * l,
                    d = [i ? "#define ENVMAP_TYPE_CUBE" : "", "#define CUBEUV_TEXEL_WIDTH ".concat(1 / c), "#define CUBEUV_TEXEL_HEIGHT ".concat(1 / u), "#define CUBEUV_MAX_MIP ".concat(s, ".0")].join("\n") + "\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <".concat(parseInt(Zo.replace(/\D+/g, "")) >= 154 ? "colorspace_fragment" : "encodings_fragment", ">\n        }\n        "),
                    h = {
                        map: {
                            value: e
                        },
                        height: {
                            value: (null == t ? void 0 : t.height) || 15
                        },
                        radius: {
                            value: (null == t ? void 0 : t.radius) || 100
                        }
                    };
                super(new Gy(1, 16), new Xh({
                    uniforms: h,
                    fragmentShader: d,
                    vertexShader: "\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        ",
                    side: da
                }))
            }
            set radius(e) {
                this.material.uniforms.radius.value = e
            }
            get radius() {
                return this.material.uniforms.radius.value
            }
            set height(e) {
                this.material.uniforms.height.value = e
            }
            get height() {
                return this.material.uniforms.height.value
            }
        }
        class Fw extends jb {
            constructor(e) {
                super(e), this.type = Rs
            }
            parse(e) {
                const t = function(e, t) {
                        switch (e) {
                            case 1:
                                console.error("THREE.RGBELoader Read Error: " + (t || ""));
                                break;
                            case 2:
                                console.error("THREE.RGBELoader Write Error: " + (t || ""));
                                break;
                            case 3:
                                console.error("THREE.RGBELoader Bad File Format: " + (t || ""));
                                break;
                            default:
                                console.error("THREE.RGBELoader: Error: " + (t || ""))
                        }
                        return -1
                    },
                    n = function(e, t, n) {
                        t = t || 1024;
                        let r = e.pos,
                            i = -1,
                            o = 0,
                            a = "",
                            s = String.fromCharCode.apply(null, new Uint16Array(e.subarray(r, r + 128)));
                        for (; 0 > (i = s.indexOf("\n")) && o < t && r < e.byteLength;) a += s, o += s.length, r += 128, s += String.fromCharCode.apply(null, new Uint16Array(e.subarray(r, r + 128)));
                        return -1 < i && (!1 !== n && (e.pos += o + i + 1), a + s.slice(0, i))
                    },
                    r = function(e, t, n, r) {
                        const i = e[t + 3],
                            o = Math.pow(2, i - 128) / 255;
                        n[r + 0] = e[t + 0] * o, n[r + 1] = e[t + 1] * o, n[r + 2] = e[t + 2] * o, n[r + 3] = 1
                    },
                    i = function(e, t, n, r) {
                        const i = e[t + 3],
                            o = Math.pow(2, i - 128) / 255;
                        n[r + 0] = th.toHalfFloat(Math.min(e[t + 0] * o, 65504)), n[r + 1] = th.toHalfFloat(Math.min(e[t + 1] * o, 65504)), n[r + 2] = th.toHalfFloat(Math.min(e[t + 2] * o, 65504)), n[r + 3] = th.toHalfFloat(1)
                    },
                    o = new Uint8Array(e);
                o.pos = 0;
                const a = function(e) {
                    const r = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
                        i = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
                        o = /^\s*FORMAT=(\S+)\s*$/,
                        a = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
                        s = {
                            valid: 0,
                            string: "",
                            comments: "",
                            programtype: "RGBE",
                            format: "",
                            gamma: 1,
                            exposure: 1,
                            width: 0,
                            height: 0
                        };
                    let l, c;
                    if (e.pos >= e.byteLength || !(l = n(e))) return t(1, "no header found");
                    if (!(c = l.match(/^#\?(\S+)/))) return t(3, "bad initial token");
                    for (s.valid |= 1, s.programtype = c[1], s.string += l + "\n"; l = n(e), !1 !== l;)
                        if (s.string += l + "\n", "#" !== l.charAt(0)) {
                            if ((c = l.match(r)) && (s.gamma = parseFloat(c[1])), (c = l.match(i)) && (s.exposure = parseFloat(c[1])), (c = l.match(o)) && (s.valid |= 2, s.format = c[1]), (c = l.match(a)) && (s.valid |= 4, s.height = parseInt(c[1], 10), s.width = parseInt(c[2], 10)), 2 & s.valid && 4 & s.valid) break
                        } else s.comments += l + "\n";
                    return 2 & s.valid ? 4 & s.valid ? s : t(3, "missing image size specifier") : t(3, "missing format specifier")
                }(o);
                if (-1 !== a) {
                    const e = a.width,
                        n = a.height,
                        s = function(e, n, r) {
                            const i = n;
                            if (i < 8 || i > 32767 || 2 !== e[0] || 2 !== e[1] || 128 & e[2]) return new Uint8Array(e);
                            if (i !== (e[2] << 8 | e[3])) return t(3, "wrong scanline width");
                            const o = new Uint8Array(4 * n * r);
                            if (!o.length) return t(4, "unable to allocate buffer space");
                            let a = 0,
                                s = 0;
                            const l = 4 * i,
                                c = new Uint8Array(4),
                                u = new Uint8Array(l);
                            let d = r;
                            for (; d > 0 && s < e.byteLength;) {
                                if (s + 4 > e.byteLength) return t(1);
                                if (c[0] = e[s++], c[1] = e[s++], c[2] = e[s++], c[3] = e[s++], 2 != c[0] || 2 != c[1] || (c[2] << 8 | c[3]) != i) return t(3, "bad rgbe scanline format");
                                let n, r = 0;
                                for (; r < l && s < e.byteLength;) {
                                    n = e[s++];
                                    const i = n > 128;
                                    if (i && (n -= 128), 0 === n || r + n > l) return t(3, "bad scanline data");
                                    if (i) {
                                        const t = e[s++];
                                        for (let e = 0; e < n; e++) u[r++] = t
                                    } else u.set(e.subarray(s, s + n), r), r += n, s += n
                                }
                                const h = i;
                                for (let e = 0; e < h; e++) {
                                    let t = 0;
                                    o[a] = u[e + t], t += i, o[a + 1] = u[e + t], t += i, o[a + 2] = u[e + t], t += i, o[a + 3] = u[e + t], a += 4
                                }
                                d--
                            }
                            return o
                        }(o.subarray(o.pos), e, n);
                    if (-1 !== s) {
                        let t, o, l;
                        switch (this.type) {
                            case Ps:
                                l = s.length / 4;
                                const e = new Float32Array(4 * l);
                                for (let t = 0; t < l; t++) r(s, 4 * t, e, 4 * t);
                                t = e, o = Ps;
                                break;
                            case Rs:
                                l = s.length / 4;
                                const n = new Uint16Array(4 * l);
                                for (let t = 0; t < l; t++) i(s, 4 * t, n, 4 * t);
                                t = n, o = Rs;
                                break;
                            default:
                                console.error("THREE.RGBELoader: unsupported type: ", this.type)
                        }
                        return {
                            width: e,
                            height: n,
                            data: t,
                            header: a.string,
                            gamma: a.gamma,
                            exposure: a.exposure,
                            type: o
                        }
                    }
                }
                return null
            }
            setDataType(e) {
                return this.type = e, this
            }
            load(e, t, n, r) {
                return super.load(e, (function(e, n) {
                    switch (e.type) {
                        case Ps:
                        case Rs:
                            "colorSpace" in e ? e.colorSpace = "srgb-linear" : e.encoding = 3e3, e.minFilter = ys, e.magFilter = ys, e.generateMipmaps = !1, e.flipY = !0
                    }
                    t && t(e, n)
                }), n, r)
            }
        }
        var Uw = Uint8Array,
            zw = Uint16Array,
            Hw = Uint32Array,
            jw = new Uw([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
            Gw = new Uw([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
            Vw = new Uw([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
            qw = function(e, t) {
                for (var n = new zw(31), r = 0; r < 31; ++r) n[r] = t += 1 << e[r - 1];
                var i = new Hw(n[30]);
                for (r = 1; r < 30; ++r)
                    for (var o = n[r]; o < n[r + 1]; ++o) i[o] = o - n[r] << 5 | r;
                return [n, i]
            },
            Ww = qw(jw, 2),
            Xw = Ww[0],
            Kw = Ww[1];
        Xw[28] = 258, Kw[258] = 28;
        for (var Jw = qw(Gw, 0), Yw = Jw[0], Qw = (Jw[1], new zw(32768)), Zw = 0; Zw < 32768; ++Zw) {
            var $w = (43690 & Zw) >>> 1 | (21845 & Zw) << 1;
            $w = (61680 & ($w = (52428 & $w) >>> 2 | (13107 & $w) << 2)) >>> 4 | (3855 & $w) << 4, Qw[Zw] = ((65280 & $w) >>> 8 | (255 & $w) << 8) >>> 1
        }
        var eA = function(e, t, n) {
                for (var r = e.length, i = 0, o = new zw(t); i < r; ++i) ++o[e[i] - 1];
                var a, s = new zw(t);
                for (i = 0; i < t; ++i) s[i] = s[i - 1] + o[i - 1] << 1;
                if (n) {
                    a = new zw(1 << t);
                    var l = 15 - t;
                    for (i = 0; i < r; ++i)
                        if (e[i])
                            for (var c = i << 4 | e[i], u = t - e[i], d = s[e[i] - 1]++ << u, h = d | (1 << u) - 1; d <= h; ++d) a[Qw[d] >>> l] = c
                } else
                    for (a = new zw(r), i = 0; i < r; ++i) e[i] && (a[i] = Qw[s[e[i] - 1]++] >>> 15 - e[i]);
                return a
            },
            tA = new Uw(288);
        for (Zw = 0; Zw < 144; ++Zw) tA[Zw] = 8;
        for (Zw = 144; Zw < 256; ++Zw) tA[Zw] = 9;
        for (Zw = 256; Zw < 280; ++Zw) tA[Zw] = 7;
        for (Zw = 280; Zw < 288; ++Zw) tA[Zw] = 8;
        var nA = new Uw(32);
        for (Zw = 0; Zw < 32; ++Zw) nA[Zw] = 5;
        var rA = eA(tA, 9, 1),
            iA = eA(nA, 5, 1),
            oA = function(e) {
                for (var t = e[0], n = 1; n < e.length; ++n) e[n] > t && (t = e[n]);
                return t
            },
            aA = function(e, t, n) {
                var r = t / 8 | 0;
                return (e[r] | e[r + 1] << 8) >> (7 & t) & n
            },
            sA = function(e, t) {
                var n = t / 8 | 0;
                return (e[n] | e[n + 1] << 8 | e[n + 2] << 16) >> (7 & t)
            },
            lA = function(e) {
                return (e / 8 | 0) + (7 & e && 1)
            },
            cA = function(e, t, n) {
                (null == t || t < 0) && (t = 0), (null == n || n > e.length) && (n = e.length);
                var r = new(e instanceof zw ? zw : e instanceof Hw ? Hw : Uw)(n - t);
                return r.set(e.subarray(t, n)), r
            },
            uA = function(e, t, n) {
                var r = e.length;
                if (!r || n && !n.l && r < 5) return t || new Uw(0);
                var i = !t || n,
                    o = !n || n.i;
                n || (n = {}), t || (t = new Uw(3 * r));
                var a = function(e) {
                        var n = t.length;
                        if (e > n) {
                            var r = new Uw(Math.max(2 * n, e));
                            r.set(t), t = r
                        }
                    },
                    s = n.f || 0,
                    l = n.p || 0,
                    c = n.b || 0,
                    u = n.l,
                    d = n.d,
                    h = n.m,
                    p = n.n,
                    f = 8 * r;
                do {
                    if (!u) {
                        n.f = s = aA(e, l, 1);
                        var m = aA(e, l + 1, 3);
                        if (l += 3, !m) {
                            var g = e[(C = lA(l) + 4) - 4] | e[C - 3] << 8,
                                v = C + g;
                            if (v > r) {
                                if (o) throw "unexpected EOF";
                                break
                            }
                            i && a(c + g), t.set(e.subarray(C, v), c), n.b = c += g, n.p = l = 8 * v;
                            continue
                        }
                        if (1 == m) u = rA, d = iA, h = 9, p = 5;
                        else {
                            if (2 != m) throw "invalid block type";
                            var y = aA(e, l, 31) + 257,
                                b = aA(e, l + 10, 15) + 4,
                                x = y + aA(e, l + 5, 31) + 1;
                            l += 14;
                            for (var _ = new Uw(x), M = new Uw(19), w = 0; w < b; ++w) M[Vw[w]] = aA(e, l + 3 * w, 7);
                            l += 3 * b;
                            var A = oA(M),
                                S = (1 << A) - 1,
                                E = eA(M, A, 1);
                            for (w = 0; w < x;) {
                                var C, T = E[aA(e, l, S)];
                                if (l += 15 & T, (C = T >>> 4) < 16) _[w++] = C;
                                else {
                                    var P = 0,
                                        R = 0;
                                    for (16 == C ? (R = 3 + aA(e, l, 3), l += 2, P = _[w - 1]) : 17 == C ? (R = 3 + aA(e, l, 7), l += 3) : 18 == C && (R = 11 + aA(e, l, 127), l += 7); R--;) _[w++] = P
                                }
                            }
                            var I = _.subarray(0, y),
                                O = _.subarray(y);
                            h = oA(I), p = oA(O), u = eA(I, h, 1), d = eA(O, p, 1)
                        }
                        if (l > f) {
                            if (o) throw "unexpected EOF";
                            break
                        }
                    }
                    i && a(c + 131072);
                    for (var B = (1 << h) - 1, L = (1 << p) - 1, D = l;; D = l) {
                        var N = (P = u[sA(e, l) & B]) >>> 4;
                        if ((l += 15 & P) > f) {
                            if (o) throw "unexpected EOF";
                            break
                        }
                        if (!P) throw "invalid length/literal";
                        if (N < 256) t[c++] = N;
                        else {
                            if (256 == N) {
                                D = l, u = null;
                                break
                            }
                            var k = N - 254;
                            if (N > 264) {
                                var F = jw[w = N - 257];
                                k = aA(e, l, (1 << F) - 1) + Xw[w], l += F
                            }
                            var U = d[sA(e, l) & L],
                                z = U >>> 4;
                            if (!U) throw "invalid distance";
                            l += 15 & U;
                            O = Yw[z];
                            if (z > 3) {
                                F = Gw[z];
                                O += sA(e, l) & (1 << F) - 1, l += F
                            }
                            if (l > f) {
                                if (o) throw "unexpected EOF";
                                break
                            }
                            i && a(c + 131072);
                            for (var H = c + k; c < H; c += 4) t[c] = t[c - O], t[c + 1] = t[c + 1 - O], t[c + 2] = t[c + 2 - O], t[c + 3] = t[c + 3 - O];
                            c = H
                        }
                    }
                    n.l = u, n.p = D, n.b = c, u && (s = 1, n.m = h, n.d = d, n.n = p)
                } while (!s);
                return c == t.length ? t : cA(t, 0, c)
            },
            dA = new Uw(0),
            hA = function(e) {
                if (8 != (15 & e[0]) || e[0] >>> 4 > 7 || (e[0] << 8 | e[1]) % 31) throw "invalid zlib data";
                if (32 & e[1]) throw "invalid zlib data: preset dictionaries not supported"
            };

        function pA(e, t) {
            return uA((hA(e), e.subarray(2, -4)), t)
        }
        var fA = "undefined" != typeof TextDecoder && new TextDecoder;
        try {
            fA.decode(dA, {
                stream: !0
            }), 1
        } catch (ER) {}
        const mA = "colorSpace" in new bu;
        class gA extends jb {
            constructor(e) {
                super(e), this.type = Rs
            }
            parse(e) {
                const t = 65536,
                    n = 14,
                    r = 65537,
                    i = 16384,
                    o = Math.pow(2.7182818, 2.2);
                const a = {
                    l: 0,
                    c: 0,
                    lc: 0
                };

                function s(e, t, n, r, i) {
                    for (; n < e;) t = t << 8 | H(r, i), n += 8;
                    n -= e, a.l = t >> n & (1 << e) - 1, a.c = t, a.lc = n
                }
                const l = new Array(59);

                function c(e, t, n, i, o, c, u) {
                    for (var d = n, h = 0, p = 0; o <= c; o++) {
                        if (d.value - n.value > i) return !1;
                        s(6, h, p, e, d);
                        var f = a.l;
                        if (h = a.c, p = a.lc, u[o] = f, 63 == f) {
                            if (d.value - n.value > i) throw "Something wrong with hufUnpackEncTable";
                            s(8, h, p, e, d);
                            var m = a.l + 6;
                            if (h = a.c, p = a.lc, o + m > c + 1) throw "Something wrong with hufUnpackEncTable";
                            for (; m--;) u[o++] = 0;
                            o--
                        } else if (f >= 59) {
                            if (o + (m = f - 59 + 2) > c + 1) throw "Something wrong with hufUnpackEncTable";
                            for (; m--;) u[o++] = 0;
                            o--
                        }
                    }! function(e) {
                        for (var t = 0; t <= 58; ++t) l[t] = 0;
                        for (t = 0; t < r; ++t) l[e[t]] += 1;
                        var n = 0;
                        for (t = 58; t > 0; --t) {
                            var i = n + l[t] >> 1;
                            l[t] = n, n = i
                        }
                        for (t = 0; t < r; ++t) {
                            var o = e[t];
                            o > 0 && (e[t] = o | l[o]++ << 6)
                        }
                    }(u)
                }

                function u(e) {
                    return 63 & e
                }

                function d(e) {
                    return e >> 6
                }
                const h = {
                    c: 0,
                    lc: 0
                };

                function p(e, t, n, r) {
                    e = e << 8 | H(n, r), t += 8, h.c = e, h.lc = t
                }
                const f = {
                    c: 0,
                    lc: 0
                };

                function m(e, t, n, r, i, o, a, s, l, c) {
                    if (e == t) {
                        r < 8 && (p(n, r, i, a), n = h.c, r = h.lc);
                        var u = n >> (r -= 8);
                        u = new Uint8Array([u])[0];
                        if (l.value + u > c) return !1;
                        for (var d = s[l.value - 1]; u-- > 0;) s[l.value++] = d
                    } else {
                        if (!(l.value < c)) return !1;
                        s[l.value++] = e
                    }
                    f.c = n, f.lc = r
                }

                function g(e) {
                    return 65535 & e
                }

                function v(e) {
                    var t = g(e);
                    return t > 32767 ? t - 65536 : t
                }
                const y = {
                    a: 0,
                    b: 0
                };

                function b(e, t) {
                    var n = v(e),
                        r = v(t),
                        i = n + (1 & r) + (r >> 1),
                        o = i,
                        a = i - r;
                    y.a = o, y.b = a
                }

                function x(e, t) {
                    var n = g(e),
                        r = g(t),
                        i = n - (r >> 1) & 65535,
                        o = r + i - 32768 & 65535;
                    y.a = o, y.b = i
                }

                function _(e, t, n, r, i, o, a) {
                    for (var s, l = a < 16384, c = n > i ? i : n, u = 1; u <= c;) u <<= 1;
                    for (s = u >>= 1, u >>= 1; u >= 1;) {
                        for (var d, h, p, f, m = 0, g = m + o * (i - s), v = o * u, _ = o * s, M = r * u, w = r * s; m <= g; m += _) {
                            for (var A = m, S = m + r * (n - s); A <= S; A += w) {
                                var E = A + M,
                                    C = (T = A + v) + M;
                                l ? (b(e[A + t], e[T + t]), d = y.a, p = y.b, b(e[E + t], e[C + t]), h = y.a, f = y.b, b(d, h), e[A + t] = y.a, e[E + t] = y.b, b(p, f), e[T + t] = y.a, e[C + t] = y.b) : (x(e[A + t], e[T + t]), d = y.a, p = y.b, x(e[E + t], e[C + t]), h = y.a, f = y.b, x(d, h), e[A + t] = y.a, e[E + t] = y.b, x(p, f), e[T + t] = y.a, e[C + t] = y.b)
                            }
                            if (n & u) {
                                var T = A + v;
                                l ? b(e[A + t], e[T + t]) : x(e[A + t], e[T + t]), d = y.a, e[T + t] = y.b, e[A + t] = d
                            }
                        }
                        if (i & u)
                            for (A = m, S = m + r * (n - s); A <= S; A += w) {
                                E = A + M;
                                l ? b(e[A + t], e[E + t]) : x(e[A + t], e[E + t]), d = y.a, e[E + t] = y.b, e[A + t] = d
                            }
                        s = u, u >>= 1
                    }
                    return m
                }

                function M(e, t, o, a, s, l) {
                    var g = o.value,
                        v = z(t, o),
                        y = z(t, o);
                    o.value += 4;
                    var b = z(t, o);
                    if (o.value += 4, v < 0 || v >= r || y < 0 || y >= r) throw "Something wrong with HUF_ENCSIZE";
                    var x = new Array(r),
                        _ = new Array(i);
                    if (function(e) {
                            for (var t = 0; t < i; t++) e[t] = {}, e[t].len = 0, e[t].lit = 0, e[t].p = null
                        }(_), c(e, 0, o, a - (o.value - g), v, y, x), b > 8 * (a - (o.value - g))) throw "Something wrong with hufUncompress";
                    ! function(e, t, r, i) {
                        for (; t <= r; t++) {
                            var o = d(e[t]),
                                a = u(e[t]);
                            if (o >> a) throw "Invalid table entry";
                            if (a > n) {
                                if ((h = i[o >> a - n]).len) throw "Invalid table entry";
                                if (h.lit++, h.p) {
                                    var s = h.p;
                                    h.p = new Array(h.lit);
                                    for (var l = 0; l < h.lit - 1; ++l) h.p[l] = s[l]
                                } else h.p = new Array(1);
                                h.p[h.lit - 1] = t
                            } else if (a) {
                                var c = 0;
                                for (l = 1 << n - a; l > 0; l--) {
                                    var h;
                                    if ((h = i[(o << n - a) + c]).len || h.p) throw "Invalid table entry";
                                    h.len = a, h.lit = t, c++
                                }
                            }
                        }
                    }(x, v, y, _),
                    function(e, t, r, i, o, a, s, l, c, g) {
                        for (var v = 0, y = 0, b = l, x = Math.trunc(o.value + (a + 7) / 8); o.value < x;)
                            for (p(v, y, r, o), v = h.c, y = h.lc; y >= n;)
                                if ((A = t[v >> y - n & 16383]).len) y -= A.len, m(A.lit, s, v, y, r, 0, o, c, g, b), v = f.c, y = f.lc;
                                else {
                                    if (!A.p) throw "hufDecode issues";
                                    var _;
                                    for (_ = 0; _ < A.lit; _++) {
                                        for (var M = u(e[A.p[_]]); y < M && o.value < x;) p(v, y, r, o), v = h.c, y = h.lc;
                                        if (y >= M && d(e[A.p[_]]) == (v >> y - M & (1 << M) - 1)) {
                                            y -= M, m(A.p[_], s, v, y, r, 0, o, c, g, b), v = f.c, y = f.lc;
                                            break
                                        }
                                    }
                                    if (_ == A.lit) throw "hufDecode issues"
                                }
                        var w = 8 - a & 7;
                        for (v >>= w, y -= w; y > 0;) {
                            var A;
                            if (!(A = t[v << n - y & 16383]).len) throw "hufDecode issues";
                            y -= A.len, m(A.lit, s, v, y, r, 0, o, c, g, b), v = f.c, y = f.lc
                        }
                    }(x, _, e, 0, o, b, y, l, s, {
                        value: 0
                    })
                }

                function w(e) {
                    for (var t = 1; t < e.length; t++) {
                        var n = e[t - 1] + e[t] - 128;
                        e[t] = n
                    }
                }

                function A(e, t) {
                    for (var n = 0, r = Math.floor((e.length + 1) / 2), i = 0, o = e.length - 1; !(i > o) && (t[i++] = e[n++], !(i > o));) t[i++] = e[r++]
                }

                function S(e) {
                    for (var t = e.byteLength, n = new Array, r = 0, i = new DataView(e); t > 0;) {
                        var o = i.getInt8(r++);
                        if (o < 0) {
                            t -= (s = -o) + 1;
                            for (var a = 0; a < s; a++) n.push(i.getUint8(r++))
                        } else {
                            var s = o;
                            t -= 2;
                            var l = i.getUint8(r++);
                            for (a = 0; a < s + 1; a++) n.push(l)
                        }
                    }
                    return n
                }

                function E(e, t, n) {
                    for (var r, i = 1; i < 64;) 65280 == (r = t[e.value]) ? i = 64 : r >> 8 == 255 ? i += 255 & r : (n[i] = r, i++), e.value++
                }

                function C(e, t) {
                    t[0] = W(e[0]), t[1] = W(e[1]), t[2] = W(e[5]), t[3] = W(e[6]), t[4] = W(e[14]), t[5] = W(e[15]), t[6] = W(e[27]), t[7] = W(e[28]), t[8] = W(e[2]), t[9] = W(e[4]), t[10] = W(e[7]), t[11] = W(e[13]), t[12] = W(e[16]), t[13] = W(e[26]), t[14] = W(e[29]), t[15] = W(e[42]), t[16] = W(e[3]), t[17] = W(e[8]), t[18] = W(e[12]), t[19] = W(e[17]), t[20] = W(e[25]), t[21] = W(e[30]), t[22] = W(e[41]), t[23] = W(e[43]), t[24] = W(e[9]), t[25] = W(e[11]), t[26] = W(e[18]), t[27] = W(e[24]), t[28] = W(e[31]), t[29] = W(e[40]), t[30] = W(e[44]), t[31] = W(e[53]), t[32] = W(e[10]), t[33] = W(e[19]), t[34] = W(e[23]), t[35] = W(e[32]), t[36] = W(e[39]), t[37] = W(e[45]), t[38] = W(e[52]), t[39] = W(e[54]), t[40] = W(e[20]), t[41] = W(e[22]), t[42] = W(e[33]), t[43] = W(e[38]), t[44] = W(e[46]), t[45] = W(e[51]), t[46] = W(e[55]), t[47] = W(e[60]), t[48] = W(e[21]), t[49] = W(e[34]), t[50] = W(e[37]), t[51] = W(e[47]), t[52] = W(e[50]), t[53] = W(e[56]), t[54] = W(e[59]), t[55] = W(e[61]), t[56] = W(e[35]), t[57] = W(e[36]), t[58] = W(e[48]), t[59] = W(e[49]), t[60] = W(e[57]), t[61] = W(e[58]), t[62] = W(e[62]), t[63] = W(e[63])
                }

                function T(e) {
                    const t = .5 * Math.cos(.7853975),
                        n = .5 * Math.cos(3.14159 / 16),
                        r = .5 * Math.cos(3.14159 / 8),
                        i = .5 * Math.cos(3 * 3.14159 / 16),
                        o = .5 * Math.cos(.981746875),
                        a = .5 * Math.cos(3 * 3.14159 / 8),
                        s = .5 * Math.cos(1.374445625);
                    for (var l = new Array(4), c = new Array(4), u = new Array(4), d = new Array(4), h = 0; h < 8; ++h) {
                        var p = 8 * h;
                        l[0] = r * e[p + 2], l[1] = a * e[p + 2], l[2] = r * e[p + 6], l[3] = a * e[p + 6], c[0] = n * e[p + 1] + i * e[p + 3] + o * e[p + 5] + s * e[p + 7], c[1] = i * e[p + 1] - s * e[p + 3] - n * e[p + 5] - o * e[p + 7], c[2] = o * e[p + 1] - n * e[p + 3] + s * e[p + 5] + i * e[p + 7], c[3] = s * e[p + 1] - o * e[p + 3] + i * e[p + 5] - n * e[p + 7], u[0] = t * (e[p + 0] + e[p + 4]), u[3] = t * (e[p + 0] - e[p + 4]), u[1] = l[0] + l[3], u[2] = l[1] - l[2], d[0] = u[0] + u[1], d[1] = u[3] + u[2], d[2] = u[3] - u[2], d[3] = u[0] - u[1], e[p + 0] = d[0] + c[0], e[p + 1] = d[1] + c[1], e[p + 2] = d[2] + c[2], e[p + 3] = d[3] + c[3], e[p + 4] = d[3] - c[3], e[p + 5] = d[2] - c[2], e[p + 6] = d[1] - c[1], e[p + 7] = d[0] - c[0]
                    }
                    for (var f = 0; f < 8; ++f) l[0] = r * e[16 + f], l[1] = a * e[16 + f], l[2] = r * e[48 + f], l[3] = a * e[48 + f], c[0] = n * e[8 + f] + i * e[24 + f] + o * e[40 + f] + s * e[56 + f], c[1] = i * e[8 + f] - s * e[24 + f] - n * e[40 + f] - o * e[56 + f], c[2] = o * e[8 + f] - n * e[24 + f] + s * e[40 + f] + i * e[56 + f], c[3] = s * e[8 + f] - o * e[24 + f] + i * e[40 + f] - n * e[56 + f], u[0] = t * (e[f] + e[32 + f]), u[3] = t * (e[f] - e[32 + f]), u[1] = l[0] + l[3], u[2] = l[1] - l[2], d[0] = u[0] + u[1], d[1] = u[3] + u[2], d[2] = u[3] - u[2], d[3] = u[0] - u[1], e[0 + f] = d[0] + c[0], e[8 + f] = d[1] + c[1], e[16 + f] = d[2] + c[2], e[24 + f] = d[3] + c[3], e[32 + f] = d[3] - c[3], e[40 + f] = d[2] - c[2], e[48 + f] = d[1] - c[1], e[56 + f] = d[0] - c[0]
                }

                function P(e) {
                    for (var t = 0; t < 64; ++t) {
                        var n = e[0][t],
                            r = e[1][t],
                            i = e[2][t];
                        e[0][t] = n + 1.5747 * i, e[1][t] = n - .1873 * r - .4682 * i, e[2][t] = n + 1.8556 * r
                    }
                }

                function R(e, t, n) {
                    for (var r = 0; r < 64; ++r) t[n + r] = th.toHalfFloat(I(e[r]))
                }

                function I(e) {
                    return e <= 1 ? Math.sign(e) * Math.pow(Math.abs(e), 2.2) : Math.sign(e) * Math.pow(o, Math.abs(e) - 1)
                }

                function O(e) {
                    return new DataView(e.array.buffer, e.offset.value, e.size)
                }

                function B(e) {
                    var t = e.viewer.buffer.slice(e.offset.value, e.offset.value + e.size),
                        n = new Uint8Array(S(t)),
                        r = new Uint8Array(n.length);
                    return w(n), A(n, r), new DataView(r.buffer)
                }

                function L(e) {
                    var t = pA(e.array.slice(e.offset.value, e.offset.value + e.size)),
                        n = new Uint8Array(t.length);
                    return w(t), A(t, n), new DataView(n.buffer)
                }

                function D(e) {
                    for (var n = e.viewer, r = {
                            value: e.offset.value
                        }, i = new Uint16Array(e.width * e.scanlineBlockSize * (e.channels * e.type)), o = new Uint8Array(8192), a = 0, s = new Array(e.channels), l = 0; l < e.channels; l++) s[l] = {}, s[l].start = a, s[l].end = s[l].start, s[l].nx = e.width, s[l].ny = e.lines, s[l].size = e.type, a += s[l].nx * s[l].ny * s[l].size;
                    var c = X(n, r),
                        u = X(n, r);
                    if (u >= 8192) throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";
                    if (c <= u)
                        for (l = 0; l < u - c + 1; l++) o[l + c] = j(n, r);
                    var d = new Uint16Array(t),
                        h = function(e, n) {
                            for (var r = 0, i = 0; i < t; ++i)(0 == i || e[i >> 3] & 1 << (7 & i)) && (n[r++] = i);
                            for (var o = r - 1; r < t;) n[r++] = 0;
                            return o
                        }(o, d),
                        p = z(n, r);
                    M(e.array, n, r, p, i, a);
                    for (l = 0; l < e.channels; ++l)
                        for (var f = s[l], m = 0; m < s[l].size; ++m) _(i, f.start + m, f.nx, f.size, f.ny, f.nx * f.size, h);
                    ! function(e, t, n) {
                        for (var r = 0; r < n; ++r) t[r] = e[t[r]]
                    }(d, i, a);
                    for (var g = 0, v = new Uint8Array(i.buffer.byteLength), y = 0; y < e.lines; y++)
                        for (var b = 0; b < e.channels; b++) {
                            var x = (f = s[b]).nx * f.size,
                                w = new Uint8Array(i.buffer, 2 * f.end, 2 * x);
                            v.set(w, g), g += 2 * x, f.end += x
                        }
                    return new DataView(v.buffer)
                }

                function N(e) {
                    var t = pA(e.array.slice(e.offset.value, e.offset.value + e.size));
                    const n = e.lines * e.channels * e.width,
                        r = 1 == e.type ? new Uint16Array(n) : new Uint32Array(n);
                    let i = 0,
                        o = 0;
                    const a = new Array(4);
                    for (let s = 0; s < e.lines; s++)
                        for (let n = 0; n < e.channels; n++) {
                            let n = 0;
                            switch (e.type) {
                                case 1:
                                    a[0] = i, a[1] = a[0] + e.width, i = a[1] + e.width;
                                    for (let i = 0; i < e.width; ++i) {
                                        n += t[a[0]++] << 8 | t[a[1]++], r[o] = n, o++
                                    }
                                    break;
                                case 2:
                                    a[0] = i, a[1] = a[0] + e.width, a[2] = a[1] + e.width, i = a[2] + e.width;
                                    for (let i = 0; i < e.width; ++i) {
                                        n += t[a[0]++] << 24 | t[a[1]++] << 16 | t[a[2]++] << 8, r[o] = n, o++
                                    }
                            }
                        }
                    return new DataView(r.buffer)
                }

                function k(e) {
                    var t = e.viewer,
                        n = {
                            value: e.offset.value
                        },
                        r = new Uint8Array(e.width * e.lines * (e.channels * e.type * 2)),
                        i = {
                            version: G(t, n),
                            unknownUncompressedSize: G(t, n),
                            unknownCompressedSize: G(t, n),
                            acCompressedSize: G(t, n),
                            dcCompressedSize: G(t, n),
                            rleCompressedSize: G(t, n),
                            rleUncompressedSize: G(t, n),
                            rleRawSize: G(t, n),
                            totalAcUncompressedCount: G(t, n),
                            totalDcUncompressedCount: G(t, n),
                            acCompression: G(t, n)
                        };
                    if (i.version < 2) throw "EXRLoader.parse: " + $.compression + " version " + i.version + " is unsupported";
                    for (var o = new Array, a = X(t, n) - 2; a > 0;) {
                        var s = F(t.buffer, n),
                            l = j(t, n),
                            c = l >> 2 & 3,
                            u = new Int8Array([(l >> 4) - 1])[0],
                            d = j(t, n);
                        o.push({
                            name: s,
                            index: u,
                            type: d,
                            compression: c
                        }), a -= s.length + 3
                    }
                    for (var h = $.channels, p = new Array(e.channels), f = 0; f < e.channels; ++f) {
                        var m = p[f] = {},
                            g = h[f];
                        m.name = g.name, m.compression = 0, m.decoded = !1, m.type = g.pixelType, m.pLinear = g.pLinear, m.width = e.width, m.height = e.lines
                    }
                    for (var v = {
                            idx: new Array(3)
                        }, y = 0; y < e.channels; ++y)
                        for (m = p[y], f = 0; f < o.length; ++f) {
                            var b = o[f];
                            m.name == b.name && (m.compression = b.compression, b.index >= 0 && (v.idx[b.index] = y), m.offset = y)
                        }
                    if (i.acCompressedSize > 0) switch (i.acCompression) {
                        case 0:
                            var x = new Uint16Array(i.totalAcUncompressedCount);
                            M(e.array, t, n, i.acCompressedSize, x, i.totalAcUncompressedCount);
                            break;
                        case 1:
                            var _ = pA(e.array.slice(n.value, n.value + i.totalAcUncompressedCount));
                            x = new Uint16Array(_.buffer);
                            n.value += i.totalAcUncompressedCount
                    }
                    if (i.dcCompressedSize > 0) {
                        var w = {
                                array: e.array,
                                offset: n,
                                size: i.dcCompressedSize
                            },
                            A = new Uint16Array(L(w).buffer);
                        n.value += i.dcCompressedSize
                    }
                    if (i.rleRawSize > 0) {
                        var I = S((_ = pA(e.array.slice(n.value, n.value + i.rleCompressedSize))).buffer);
                        n.value += i.rleCompressedSize
                    }
                    var O = 0,
                        B = new Array(p.length);
                    for (f = 0; f < B.length; ++f) B[f] = new Array;
                    for (var D = 0; D < e.lines; ++D)
                        for (var N = 0; N < p.length; ++N) B[N].push(O), O += p[N].width * e.type * 2;
                    ! function(e, t, n, r, i, o) {
                        var a = new DataView(o.buffer),
                            s = n[e.idx[0]].width,
                            l = n[e.idx[0]].height,
                            c = Math.floor(s / 8),
                            u = Math.ceil(s / 8),
                            d = Math.ceil(l / 8),
                            h = s - 8 * (u - 1),
                            p = l - 8 * (d - 1),
                            f = {
                                value: 0
                            },
                            m = new Array(3),
                            g = new Array(3),
                            v = new Array(3),
                            y = new Array(3),
                            b = new Array(3);
                        for (let E = 0; E < 3; ++E) b[E] = t[e.idx[E]], m[E] = E < 1 ? 0 : m[E - 1] + u * d, g[E] = new Float32Array(64), v[E] = new Uint16Array(64), y[E] = new Uint16Array(64 * u);
                        for (let O = 0; O < d; ++O) {
                            var x = 8;
                            O == d - 1 && (x = p);
                            var _ = 8;
                            for (let e = 0; e < u; ++e) {
                                e == u - 1 && (_ = h);
                                for (let e = 0; e < 3; ++e) v[e].fill(0), v[e][0] = i[m[e]++], E(f, r, v[e]), C(v[e], g[e]), T(g[e]);
                                P(g);
                                for (let t = 0; t < 3; ++t) R(g[t], y[t], 64 * e)
                            }
                            let t = 0;
                            for (let r = 0; r < 3; ++r) {
                                const i = n[e.idx[r]].type;
                                for (let e = 8 * O; e < 8 * O + x; ++e) {
                                    t = b[r][e];
                                    for (let n = 0; n < c; ++n) {
                                        const o = 64 * n + 8 * (7 & e);
                                        a.setUint16(t + 0 * i, y[r][o + 0], !0), a.setUint16(t + 2 * i, y[r][o + 1], !0), a.setUint16(t + 4 * i, y[r][o + 2], !0), a.setUint16(t + 6 * i, y[r][o + 3], !0), a.setUint16(t + 8 * i, y[r][o + 4], !0), a.setUint16(t + 10 * i, y[r][o + 5], !0), a.setUint16(t + 12 * i, y[r][o + 6], !0), a.setUint16(t + 14 * i, y[r][o + 7], !0), t += 16 * i
                                    }
                                }
                                if (c != u)
                                    for (let e = 8 * O; e < 8 * O + x; ++e) {
                                        const t = b[r][e] + 8 * c * 2 * i,
                                            n = 64 * c + 8 * (7 & e);
                                        for (let e = 0; e < _; ++e) a.setUint16(t + 2 * e * i, y[r][n + e], !0)
                                    }
                            }
                        }
                        for (var M = new Uint16Array(s), w = (a = new DataView(o.buffer), 0); w < 3; ++w) {
                            n[e.idx[w]].decoded = !0;
                            var A = n[e.idx[w]].type;
                            if (2 == n[w].type)
                                for (var S = 0; S < l; ++S) {
                                    const e = b[w][S];
                                    for (var I = 0; I < s; ++I) M[I] = a.getUint16(e + 2 * I * A, !0);
                                    for (I = 0; I < s; ++I) a.setFloat32(e + 2 * I * A, W(M[I]), !0)
                                }
                        }
                    }(v, B, p, x, A, r);
                    for (f = 0; f < p.length; ++f) {
                        if (!(m = p[f]).decoded) {
                            if (2 !== m.compression) throw "EXRLoader.parse: unsupported channel compression";
                            var k = 0,
                                U = 0;
                            for (D = 0; D < e.lines; ++D) {
                                for (var z = B[f][k], H = 0; H < m.width; ++H) {
                                    for (var V = 0; V < 2 * m.type; ++V) r[z++] = I[U + V * m.width * m.height];
                                    U++
                                }
                                k++
                            }
                        }
                    }
                    return new DataView(r.buffer)
                }

                function F(e, t) {
                    for (var n = new Uint8Array(e), r = 0; 0 != n[t.value + r];) r += 1;
                    var i = (new TextDecoder).decode(n.slice(t.value, t.value + r));
                    return t.value = t.value + r + 1, i
                }

                function U(e, t) {
                    var n = e.getInt32(t.value, !0);
                    return t.value = t.value + 4, n
                }

                function z(e, t) {
                    var n = e.getUint32(t.value, !0);
                    return t.value = t.value + 4, n
                }

                function H(e, t) {
                    var n = e[t.value];
                    return t.value = t.value + 1, n
                }

                function j(e, t) {
                    var n = e.getUint8(t.value);
                    return t.value = t.value + 1, n
                }
                const G = function(e, t) {
                    let n;
                    return n = "getBigInt64" in DataView.prototype ? Number(e.getBigInt64(t.value, !0)) : e.getUint32(t.value + 4, !0) + Number(e.getUint32(t.value, !0) << 32), t.value += 8, n
                };

                function V(e, t) {
                    var n = e.getFloat32(t.value, !0);
                    return t.value += 4, n
                }

                function q(e, t) {
                    return th.toHalfFloat(V(e, t))
                }

                function W(e) {
                    var t = (31744 & e) >> 10,
                        n = 1023 & e;
                    return (e >> 15 ? -1 : 1) * (t ? 31 === t ? n ? NaN : 1 / 0 : Math.pow(2, t - 15) * (1 + n / 1024) : n / 1024 * 6103515625e-14)
                }

                function X(e, t) {
                    var n = e.getUint16(t.value, !0);
                    return t.value += 2, n
                }

                function K(e, t) {
                    return W(X(e, t))
                }

                function J(e, t, n, r, i) {
                    return "string" === r || "stringvector" === r || "iccProfile" === r ? function(e, t, n) {
                        var r = (new TextDecoder).decode(new Uint8Array(e).slice(t.value, t.value + n));
                        return t.value = t.value + n, r
                    }(t, n, i) : "chlist" === r ? function(e, t, n, r) {
                        for (var i = n.value, o = []; n.value < i + r - 1;) {
                            var a = F(t, n),
                                s = U(e, n),
                                l = j(e, n);
                            n.value += 3;
                            var c = U(e, n),
                                u = U(e, n);
                            o.push({
                                name: a,
                                pixelType: s,
                                pLinear: l,
                                xSampling: c,
                                ySampling: u
                            })
                        }
                        return n.value += 1, o
                    }(e, t, n, i) : "chromaticities" === r ? function(e, t) {
                        return {
                            redX: V(e, t),
                            redY: V(e, t),
                            greenX: V(e, t),
                            greenY: V(e, t),
                            blueX: V(e, t),
                            blueY: V(e, t),
                            whiteX: V(e, t),
                            whiteY: V(e, t)
                        }
                    }(e, n) : "compression" === r ? function(e, t) {
                        return ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"][j(e, t)]
                    }(e, n) : "box2i" === r ? function(e, t) {
                        return {
                            xMin: z(e, t),
                            yMin: z(e, t),
                            xMax: z(e, t),
                            yMax: z(e, t)
                        }
                    }(e, n) : "lineOrder" === r ? function(e, t) {
                        return ["INCREASING_Y"][j(e, t)]
                    }(e, n) : "float" === r ? V(e, n) : "v2f" === r ? function(e, t) {
                        return [V(e, t), V(e, t)]
                    }(e, n) : "v3f" === r ? function(e, t) {
                        return [V(e, t), V(e, t), V(e, t)]
                    }(e, n) : "int" === r ? U(e, n) : "rational" === r ? function(e, t) {
                        return [U(e, t), z(e, t)]
                    }(e, n) : "timecode" === r ? function(e, t) {
                        return [z(e, t), z(e, t)]
                    }(e, n) : "preview" === r ? (n.value += i, "skipped") : void(n.value += i)
                }
                const Y = new DataView(e),
                    Q = new Uint8Array(e),
                    Z = {
                        value: 0
                    },
                    $ = function(e, t, n) {
                        const r = {};
                        if (20000630 != e.getUint32(0, !0)) throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";
                        r.version = e.getUint8(4);
                        const i = e.getUint8(5);
                        r.spec = {
                            singleTile: !!(2 & i),
                            longName: !!(4 & i),
                            deepFormat: !!(8 & i),
                            multiPart: !!(16 & i)
                        }, n.value = 8;
                        for (var o = !0; o;) {
                            var a = F(t, n);
                            if (0 == a) o = !1;
                            else {
                                var s = F(t, n),
                                    l = J(e, t, n, s, z(e, n));
                                void 0 === l ? console.warn("EXRLoader.parse: skipped unknown header attribute type '".concat(s, "'.")) : r[a] = l
                            }
                        }
                        if (0 != (-5 & i)) throw console.error("EXRHeader:", r), "THREE.EXRLoader: provided file is currently unsupported.";
                        return r
                    }(Y, e, Z),
                    ee = function(e, t, n, r, i) {
                        const o = {
                            size: 0,
                            viewer: t,
                            array: n,
                            offset: r,
                            width: e.dataWindow.xMax - e.dataWindow.xMin + 1,
                            height: e.dataWindow.yMax - e.dataWindow.yMin + 1,
                            channels: e.channels.length,
                            bytesPerLine: null,
                            lines: null,
                            inputSize: null,
                            type: e.channels[0].pixelType,
                            uncompress: null,
                            getter: null,
                            format: null,
                            [mA ? "colorSpace" : "encoding"]: null
                        };
                        switch (e.compression) {
                            case "NO_COMPRESSION":
                                o.lines = 1, o.uncompress = O;
                                break;
                            case "RLE_COMPRESSION":
                                o.lines = 1, o.uncompress = B;
                                break;
                            case "ZIPS_COMPRESSION":
                                o.lines = 1, o.uncompress = L;
                                break;
                            case "ZIP_COMPRESSION":
                                o.lines = 16, o.uncompress = L;
                                break;
                            case "PIZ_COMPRESSION":
                                o.lines = 32, o.uncompress = D;
                                break;
                            case "PXR24_COMPRESSION":
                                o.lines = 16, o.uncompress = N;
                                break;
                            case "DWAA_COMPRESSION":
                                o.lines = 32, o.uncompress = k;
                                break;
                            case "DWAB_COMPRESSION":
                                o.lines = 256, o.uncompress = k;
                                break;
                            default:
                                throw "EXRLoader.parse: " + e.compression + " is unsupported"
                        }
                        if (o.scanlineBlockSize = o.lines, 1 == o.type) switch (i) {
                            case Ps:
                                o.getter = K, o.inputSize = 2;
                                break;
                            case Rs:
                                o.getter = X, o.inputSize = 2
                        } else {
                            if (2 != o.type) throw "EXRLoader.parse: unsupported pixelType " + o.type + " for " + e.compression + ".";
                            switch (i) {
                                case Ps:
                                    o.getter = V, o.inputSize = 4;
                                    break;
                                case Rs:
                                    o.getter = q, o.inputSize = 4
                            }
                        }
                        o.blockCount = (e.dataWindow.yMax + 1) / o.scanlineBlockSize;
                        for (var a = 0; a < o.blockCount; a++) G(t, r);
                        o.outputChannels = 3 == o.channels ? 4 : o.channels;
                        const s = o.width * o.height * o.outputChannels;
                        switch (i) {
                            case Ps:
                                o.byteArray = new Float32Array(s), o.channels < o.outputChannels && o.byteArray.fill(1, 0, s);
                                break;
                            case Rs:
                                o.byteArray = new Uint16Array(s), o.channels < o.outputChannels && o.byteArray.fill(15360, 0, s);
                                break;
                            default:
                                console.error("THREE.EXRLoader: unsupported type: ", i)
                        }
                        return o.bytesPerLine = o.width * o.inputSize * o.channels, 4 == o.outputChannels ? o.format = Ds : o.format = zs, mA ? o.colorSpace = "srgb-linear" : o.encoding = 3e3, o
                    }($, Y, Q, Z, this.type),
                    te = {
                        value: 0
                    },
                    ne = {
                        R: 0,
                        G: 1,
                        B: 2,
                        A: 3,
                        Y: 0
                    };
                for (let re = 0; re < ee.height / ee.scanlineBlockSize; re++) {
                    const e = z(Y, Z);
                    ee.size = z(Y, Z), ee.lines = e + ee.scanlineBlockSize > ee.height ? ee.height - e : ee.scanlineBlockSize;
                    const t = ee.size < ee.lines * ee.bytesPerLine ? ee.uncompress(ee) : O(ee);
                    Z.value += ee.size;
                    for (let n = 0; n < ee.scanlineBlockSize; n++) {
                        const e = n + re * ee.scanlineBlockSize;
                        if (e >= ee.height) break;
                        for (let r = 0; r < ee.channels; r++) {
                            const i = ne[$.channels[r].name];
                            for (let o = 0; o < ee.width; o++) {
                                te.value = (n * (ee.channels * ee.width) + r * ee.width + o) * ee.inputSize;
                                const a = (ee.height - 1 - e) * (ee.width * ee.outputChannels) + o * ee.outputChannels + i;
                                ee.byteArray[a] = ee.getter(t, te)
                            }
                        }
                    }
                }
                return {
                    header: $,
                    width: ee.width,
                    height: ee.height,
                    data: ee.byteArray,
                    format: ee.format,
                    [mA ? "colorSpace" : "encoding"]: ee[mA ? "colorSpace" : "encoding"],
                    type: this.type
                }
            }
            setDataType(e) {
                return this.type = e, this
            }
            load(e, t, n, r) {
                return super.load(e, (function(e, n) {
                    mA ? e.colorSpace = n.colorSpace : e.encoding = n.encoding, e.minFilter = ys, e.magFilter = ys, e.generateMipmaps = !1, e.flipY = !1, t && t(e, n)
                }), n, r)
            }
        }
        const vA = {
                apartment: "lebombo_1k.hdr",
                city: "potsdamer_platz_1k.hdr",
                dawn: "kiara_1_dawn_1k.hdr",
                forest: "forest_slope_1k.hdr",
                lobby: "st_fagans_interior_1k.hdr",
                night: "dikhololo_night_1k.hdr",
                park: "rooitou_park_1k.hdr",
                studio: "studio_small_03_1k.hdr",
                sunset: "venice_sunset_1k.hdr",
                warehouse: "empty_warehouse_01_1k.hdr"
            },
            yA = "https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/",
            bA = e => Array.isArray(e);

        function xA() {
            let {
                files: e = ["/px.png", "/nx.png", "/py.png", "/ny.png", "/pz.png", "/nz.png"],
                path: t = "",
                preset: n,
                encoding: r,
                extensions: i
            } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            var o;
            let a, s = null,
                l = !1;
            if (n) {
                if (!(n in vA)) throw new Error("Preset must be one of: " + Object.keys(vA).join(", "));
                e = vA[n], t = yA
            }
            if (l = bA(e), a = bA(e) ? "cube" : e.startsWith("data:application/exr") ? "exr" : e.startsWith("data:application/hdr") ? "hdr" : null == (o = e.split(".").pop()) || null == (o = o.split("?")) || null == (o = o.shift()) ? void 0 : o.toLowerCase(), s = l ? Hb : "hdr" === a ? Fw : "exr" === a ? gA : null, !s) throw new Error("useEnvironment: Unrecognized file extension: " + e);
            const c = ZM(s, l ? [e] : e, (e => {
                    null == e.setPath || e.setPath(t), i && i(e)
                })),
                u = l ? c[0] : c;
            u.mapping = l ? os : ss;
            return "colorSpace" in u ? u.colorSpace = (null !== r && void 0 !== r ? r : l) ? "srgb" : "srgb-linear" : u.encoding = (null !== r && void 0 !== r ? r : l) ? 3001 : 3e3, u
        }
        const _A = e => {
            return (t = e).current && t.current.isScene ? e.current : e;
            var t
        };

        function MA(e, t, n, r) {
            let i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
            const o = _A(t || n),
                a = o.background,
                s = o.environment,
                l = o.backgroundBlurriness || 0;
            return "only" !== e && (o.environment = r), e && (o.background = r), e && void 0 !== o.backgroundBlurriness && (o.backgroundBlurriness = i), () => {
                "only" !== e && (o.environment = s), e && (o.background = a), e && void 0 !== o.backgroundBlurriness && (o.backgroundBlurriness = l)
            }
        }

        function wA(e) {
            let {
                scene: t,
                background: n = !1,
                blur: i,
                map: o
            } = e;
            const a = KM((e => e.scene));
            return r.useLayoutEffect((() => {
                if (o) return MA(n, t, a, o, i)
            }), [a, t, o, n, i]), null
        }

        function AA(e) {
            let {
                background: t = !1,
                scene: n,
                blur: i,
                ...o
            } = e;
            const a = xA(o),
                s = KM((e => e.scene));
            return r.useLayoutEffect((() => MA(t, n, s, a, i)), [a, t, n, s, i]), null
        }

        function SA(e) {
            let {
                children: t,
                near: n = 1,
                far: i = 1e3,
                resolution: o = 256,
                frames: a = 1,
                map: s,
                background: l = !1,
                blur: c,
                scene: u,
                files: d,
                path: h,
                preset: p,
                extensions: f
            } = e;
            const m = KM((e => e.gl)),
                g = KM((e => e.scene)),
                v = r.useRef(null),
                [y] = r.useState((() => new Zm)),
                b = r.useMemo((() => {
                    const e = new np(o);
                    return e.texture.type = Rs, e
                }), [o]);
            r.useLayoutEffect((() => (1 === a && v.current.update(m, y), MA(l, u, g, b.texture, c))), [t, y, b.texture, u, g, l, a, m]);
            let x = 1;
            return JM((() => {
                (a === 1 / 0 || x < a) && (v.current.update(m, y), x++)
            })), r.createElement(r.Fragment, null, function(e, t, n) {
                return r.createElement(cw, {
                    key: t.uuid,
                    children: e,
                    container: t,
                    state: n
                })
            }(r.createElement(r.Fragment, null, t, r.createElement("cubeCamera", {
                ref: v,
                args: [n, i, b]
            }), d || p ? r.createElement(AA, {
                background: !0,
                files: d,
                preset: p,
                path: h,
                extensions: f
            }) : s ? r.createElement(wA, {
                background: !0,
                map: s,
                extensions: f
            }) : null), y))
        }

        function EA(e) {
            var t, n, i, o;
            const a = xA(e),
                s = e.map || a;
            r.useMemo((() => nM({
                GroundProjectedEnvImpl: kw
            })), []);
            const l = r.useMemo((() => [s]), [s]),
                c = null == (t = e.ground) ? void 0 : t.height,
                u = null == (n = e.ground) ? void 0 : n.radius,
                d = null !== (i = null == (o = e.ground) ? void 0 : o.scale) && void 0 !== i ? i : 1e3;
            return r.createElement(r.Fragment, null, r.createElement(wA, (0, uw.c)({}, e, {
                map: s
            })), r.createElement("groundProjectedEnvImpl", {
                args: l,
                scale: d,
                height: c,
                radius: u
            }))
        }

        function CA(e) {
            return e.ground ? r.createElement(EA, e) : e.map ? r.createElement(wA, e) : e.children ? r.createElement(SA, e) : r.createElement(AA, e)
        }
        var TA = Object.defineProperty,
            PA = (e, t, n) => (((e, t, n) => {
                t in e ? TA(e, t, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n
                }) : e[t] = n
            })(e, "symbol" !== typeof t ? t + "" : t, n), n);
        const RA = new id,
            IA = new ap,
            OA = Math.cos(Math.PI / 180 * 70),
            BA = (e, t) => (e % t + t) % t;
        class LA extends Nc {
            constructor(e, t) {
                super(), PA(this, "object"), PA(this, "domElement"), PA(this, "enabled", !0), PA(this, "target", new Pu), PA(this, "minDistance", 0), PA(this, "maxDistance", 1 / 0), PA(this, "minZoom", 0), PA(this, "maxZoom", 1 / 0), PA(this, "minPolarAngle", 0), PA(this, "maxPolarAngle", Math.PI), PA(this, "minAzimuthAngle", -1 / 0), PA(this, "maxAzimuthAngle", 1 / 0), PA(this, "enableDamping", !1), PA(this, "dampingFactor", .05), PA(this, "enableZoom", !0), PA(this, "zoomSpeed", 1), PA(this, "enableRotate", !0), PA(this, "rotateSpeed", 1), PA(this, "enablePan", !0), PA(this, "panSpeed", 1), PA(this, "screenSpacePanning", !0), PA(this, "keyPanSpeed", 7), PA(this, "zoomToCursor", !1), PA(this, "autoRotate", !1), PA(this, "autoRotateSpeed", 2), PA(this, "reverseOrbit", !1), PA(this, "reverseHorizontalOrbit", !1), PA(this, "reverseVerticalOrbit", !1), PA(this, "keys", {
                    LEFT: "ArrowLeft",
                    UP: "ArrowUp",
                    RIGHT: "ArrowRight",
                    BOTTOM: "ArrowDown"
                }), PA(this, "mouseButtons", {
                    LEFT: $o.ROTATE,
                    MIDDLE: $o.DOLLY,
                    RIGHT: $o.PAN
                }), PA(this, "touches", {
                    ONE: ea.ROTATE,
                    TWO: ea.DOLLY_PAN
                }), PA(this, "target0"), PA(this, "position0"), PA(this, "zoom0"), PA(this, "_domElementKeyEvents", null), PA(this, "getPolarAngle"), PA(this, "getAzimuthalAngle"), PA(this, "setPolarAngle"), PA(this, "setAzimuthalAngle"), PA(this, "getDistance"), PA(this, "listenToKeyEvents"), PA(this, "stopListenToKeyEvents"), PA(this, "saveState"), PA(this, "reset"), PA(this, "update"), PA(this, "connect"), PA(this, "dispose"), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => c.phi, this.getAzimuthalAngle = () => c.theta, this.setPolarAngle = e => {
                    let t = BA(e, 2 * Math.PI),
                        r = c.phi;
                    r < 0 && (r += 2 * Math.PI), t < 0 && (t += 2 * Math.PI);
                    let i = Math.abs(t - r);
                    2 * Math.PI - i < i && (t < r ? t += 2 * Math.PI : r += 2 * Math.PI), u.phi = t - r, n.update()
                }, this.setAzimuthalAngle = e => {
                    let t = BA(e, 2 * Math.PI),
                        r = c.theta;
                    r < 0 && (r += 2 * Math.PI), t < 0 && (t += 2 * Math.PI);
                    let i = Math.abs(t - r);
                    2 * Math.PI - i < i && (t < r ? t += 2 * Math.PI : r += 2 * Math.PI), u.theta = t - r, n.update()
                }, this.getDistance = () => n.object.position.distanceTo(n.target), this.listenToKeyEvents = e => {
                    e.addEventListener("keydown", Y), this._domElementKeyEvents = e
                }, this.stopListenToKeyEvents = () => {
                    this._domElementKeyEvents.removeEventListener("keydown", Y), this._domElementKeyEvents = null
                }, this.saveState = () => {
                    n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom
                }, this.reset = () => {
                    n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(r), n.update(), s = a.NONE
                }, this.update = (() => {
                    const t = new Pu,
                        i = new Pu(0, 1, 0),
                        o = (new Tu).setFromUnitVectors(e.up, i),
                        p = o.clone().invert(),
                        f = new Pu,
                        m = new Tu,
                        g = 2 * Math.PI;
                    return function() {
                        const v = n.object.position;
                        o.setFromUnitVectors(e.up, i), p.copy(o).invert(), t.copy(v).sub(n.target), t.applyQuaternion(o), c.setFromVector3(t), n.autoRotate && s === a.NONE && T(2 * Math.PI / 60 / 60 * n.autoRotateSpeed), n.enableDamping ? (c.theta += u.theta * n.dampingFactor, c.phi += u.phi * n.dampingFactor) : (c.theta += u.theta, c.phi += u.phi);
                        let y = n.minAzimuthAngle,
                            b = n.maxAzimuthAngle;
                        isFinite(y) && isFinite(b) && (y < -Math.PI ? y += g : y > Math.PI && (y -= g), b < -Math.PI ? b += g : b > Math.PI && (b -= g), c.theta = y <= b ? Math.max(y, Math.min(b, c.theta)) : c.theta > (y + b) / 2 ? Math.max(y, c.theta) : Math.min(b, c.theta)), c.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, c.phi)), c.makeSafe(), !0 === n.enableDamping ? n.target.addScaledVector(h, n.dampingFactor) : n.target.add(h), n.zoomToCursor && A || n.object.isOrthographicCamera ? c.radius = N(c.radius) : c.radius = N(c.radius * d), t.setFromSpherical(c), t.applyQuaternion(p), v.copy(n.target).add(t), n.object.matrixAutoUpdate || n.object.updateMatrix(), n.object.lookAt(n.target), !0 === n.enableDamping ? (u.theta *= 1 - n.dampingFactor, u.phi *= 1 - n.dampingFactor, h.multiplyScalar(1 - n.dampingFactor)) : (u.set(0, 0, 0), h.set(0, 0, 0));
                        let x = !1;
                        if (n.zoomToCursor && A) {
                            let r = null;
                            if (n.object instanceof Zh && n.object.isPerspectiveCamera) {
                                const e = t.length();
                                r = N(e * d);
                                const i = e - r;
                                n.object.position.addScaledVector(M, i), n.object.updateMatrixWorld()
                            } else if (n.object.isOrthographicCamera) {
                                const e = new Pu(w.x, w.y, 0);
                                e.unproject(n.object), n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / d)), n.object.updateProjectionMatrix(), x = !0;
                                const i = new Pu(w.x, w.y, 0);
                                i.unproject(n.object), n.object.position.sub(i).add(e), n.object.updateMatrixWorld(), r = t.length()
                            } else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), n.zoomToCursor = !1;
                            null !== r && (n.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(r).add(n.object.position) : (RA.origin.copy(n.object.position), RA.direction.set(0, 0, -1).transformDirection(n.object.matrix), Math.abs(n.object.up.dot(RA.direction)) < OA ? e.lookAt(n.target) : (IA.setFromNormalAndCoplanarPoint(n.object.up, n.target), RA.intersectPlane(IA, n.target))))
                        } else n.object instanceof wp && n.object.isOrthographicCamera && (x = 1 !== d, x && (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / d)), n.object.updateProjectionMatrix()));
                        return d = 1, A = !1, !!(x || f.distanceToSquared(n.object.position) > l || 8 * (1 - m.dot(n.object.quaternion)) > l) && (n.dispatchEvent(r), f.copy(n.object.position), m.copy(n.object.quaternion), x = !1, !0)
                    }
                })(), this.connect = e => {
                    e === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), n.domElement = e, n.domElement.style.touchAction = "none", n.domElement.addEventListener("contextmenu", Q), n.domElement.addEventListener("pointerdown", q), n.domElement.addEventListener("pointercancel", K), n.domElement.addEventListener("wheel", J)
                }, this.dispose = () => {
                    var e, t, r, i, o, a;
                    null == (e = n.domElement) || e.removeEventListener("contextmenu", Q), null == (t = n.domElement) || t.removeEventListener("pointerdown", q), null == (r = n.domElement) || r.removeEventListener("pointercancel", K), null == (i = n.domElement) || i.removeEventListener("wheel", J), null == (o = n.domElement) || o.ownerDocument.removeEventListener("pointermove", W), null == (a = n.domElement) || a.ownerDocument.removeEventListener("pointerup", X), null !== n._domElementKeyEvents && n._domElementKeyEvents.removeEventListener("keydown", Y)
                };
                const n = this,
                    r = {
                        type: "change"
                    },
                    i = {
                        type: "start"
                    },
                    o = {
                        type: "end"
                    },
                    a = {
                        NONE: -1,
                        ROTATE: 0,
                        DOLLY: 1,
                        PAN: 2,
                        TOUCH_ROTATE: 3,
                        TOUCH_PAN: 4,
                        TOUCH_DOLLY_PAN: 5,
                        TOUCH_DOLLY_ROTATE: 6
                    };
                let s = a.NONE;
                const l = 1e-6,
                    c = new o_,
                    u = new o_;
                let d = 1;
                const h = new Pu,
                    p = new Yc,
                    f = new Yc,
                    m = new Yc,
                    g = new Yc,
                    v = new Yc,
                    y = new Yc,
                    b = new Yc,
                    x = new Yc,
                    _ = new Yc,
                    M = new Pu,
                    w = new Yc;
                let A = !1;
                const S = [],
                    E = {};

                function C() {
                    return Math.pow(.95, n.zoomSpeed)
                }

                function T(e) {
                    n.reverseOrbit || n.reverseHorizontalOrbit ? u.theta += e : u.theta -= e
                }

                function P(e) {
                    n.reverseOrbit || n.reverseVerticalOrbit ? u.phi += e : u.phi -= e
                }
                const R = (() => {
                        const e = new Pu;
                        return function(t, n) {
                            e.setFromMatrixColumn(n, 0), e.multiplyScalar(-t), h.add(e)
                        }
                    })(),
                    I = (() => {
                        const e = new Pu;
                        return function(t, r) {
                            !0 === n.screenSpacePanning ? e.setFromMatrixColumn(r, 1) : (e.setFromMatrixColumn(r, 0), e.crossVectors(n.object.up, e)), e.multiplyScalar(t), h.add(e)
                        }
                    })(),
                    O = (() => {
                        const e = new Pu;
                        return function(t, r) {
                            const i = n.domElement;
                            if (i && n.object instanceof Zh && n.object.isPerspectiveCamera) {
                                const o = n.object.position;
                                e.copy(o).sub(n.target);
                                let a = e.length();
                                a *= Math.tan(n.object.fov / 2 * Math.PI / 180), R(2 * t * a / i.clientHeight, n.object.matrix), I(2 * r * a / i.clientHeight, n.object.matrix)
                            } else i && n.object instanceof wp && n.object.isOrthographicCamera ? (R(t * (n.object.right - n.object.left) / n.object.zoom / i.clientWidth, n.object.matrix), I(r * (n.object.top - n.object.bottom) / n.object.zoom / i.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1)
                        }
                    })();

                function B(e) {
                    n.object instanceof Zh && n.object.isPerspectiveCamera || n.object instanceof wp && n.object.isOrthographicCamera ? d /= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
                }

                function L(e) {
                    n.object instanceof Zh && n.object.isPerspectiveCamera || n.object instanceof wp && n.object.isOrthographicCamera ? d *= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
                }

                function D(e) {
                    if (!n.zoomToCursor || !n.domElement) return;
                    A = !0;
                    const t = n.domElement.getBoundingClientRect(),
                        r = e.clientX - t.left,
                        i = e.clientY - t.top,
                        o = t.width,
                        a = t.height;
                    w.x = r / o * 2 - 1, w.y = -i / a * 2 + 1, M.set(w.x, w.y, 1).unproject(n.object).sub(n.object.position).normalize()
                }

                function N(e) {
                    return Math.max(n.minDistance, Math.min(n.maxDistance, e))
                }

                function k(e) {
                    p.set(e.clientX, e.clientY)
                }

                function F(e) {
                    g.set(e.clientX, e.clientY)
                }

                function U() {
                    if (1 == S.length) p.set(S[0].pageX, S[0].pageY);
                    else {
                        const e = .5 * (S[0].pageX + S[1].pageX),
                            t = .5 * (S[0].pageY + S[1].pageY);
                        p.set(e, t)
                    }
                }

                function z() {
                    if (1 == S.length) g.set(S[0].pageX, S[0].pageY);
                    else {
                        const e = .5 * (S[0].pageX + S[1].pageX),
                            t = .5 * (S[0].pageY + S[1].pageY);
                        g.set(e, t)
                    }
                }

                function H() {
                    const e = S[0].pageX - S[1].pageX,
                        t = S[0].pageY - S[1].pageY,
                        n = Math.sqrt(e * e + t * t);
                    b.set(0, n)
                }

                function j(e) {
                    if (1 == S.length) f.set(e.pageX, e.pageY);
                    else {
                        const t = ee(e),
                            n = .5 * (e.pageX + t.x),
                            r = .5 * (e.pageY + t.y);
                        f.set(n, r)
                    }
                    m.subVectors(f, p).multiplyScalar(n.rotateSpeed);
                    const t = n.domElement;
                    t && (T(2 * Math.PI * m.x / t.clientHeight), P(2 * Math.PI * m.y / t.clientHeight)), p.copy(f)
                }

                function G(e) {
                    if (1 == S.length) v.set(e.pageX, e.pageY);
                    else {
                        const t = ee(e),
                            n = .5 * (e.pageX + t.x),
                            r = .5 * (e.pageY + t.y);
                        v.set(n, r)
                    }
                    y.subVectors(v, g).multiplyScalar(n.panSpeed), O(y.x, y.y), g.copy(v)
                }

                function V(e) {
                    const t = ee(e),
                        r = e.pageX - t.x,
                        i = e.pageY - t.y,
                        o = Math.sqrt(r * r + i * i);
                    x.set(0, o), _.set(0, Math.pow(x.y / b.y, n.zoomSpeed)), B(_.y), b.copy(x)
                }

                function q(e) {
                    var t, r;
                    !1 !== n.enabled && (0 === S.length && (null == (t = n.domElement) || t.ownerDocument.addEventListener("pointermove", W), null == (r = n.domElement) || r.ownerDocument.addEventListener("pointerup", X)), function(e) {
                        S.push(e)
                    }(e), "touch" === e.pointerType ? function(e) {
                        switch ($(e), S.length) {
                            case 1:
                                switch (n.touches.ONE) {
                                    case ea.ROTATE:
                                        if (!1 === n.enableRotate) return;
                                        U(), s = a.TOUCH_ROTATE;
                                        break;
                                    case ea.PAN:
                                        if (!1 === n.enablePan) return;
                                        z(), s = a.TOUCH_PAN;
                                        break;
                                    default:
                                        s = a.NONE
                                }
                                break;
                            case 2:
                                switch (n.touches.TWO) {
                                    case ea.DOLLY_PAN:
                                        if (!1 === n.enableZoom && !1 === n.enablePan) return;
                                        n.enableZoom && H(), n.enablePan && z(), s = a.TOUCH_DOLLY_PAN;
                                        break;
                                    case ea.DOLLY_ROTATE:
                                        if (!1 === n.enableZoom && !1 === n.enableRotate) return;
                                        n.enableZoom && H(), n.enableRotate && U(), s = a.TOUCH_DOLLY_ROTATE;
                                        break;
                                    default:
                                        s = a.NONE
                                }
                                break;
                            default:
                                s = a.NONE
                        }
                        s !== a.NONE && n.dispatchEvent(i)
                    }(e) : function(e) {
                        let t;
                        switch (e.button) {
                            case 0:
                                t = n.mouseButtons.LEFT;
                                break;
                            case 1:
                                t = n.mouseButtons.MIDDLE;
                                break;
                            case 2:
                                t = n.mouseButtons.RIGHT;
                                break;
                            default:
                                t = -1
                        }
                        switch (t) {
                            case $o.DOLLY:
                                if (!1 === n.enableZoom) return;
                                ! function(e) {
                                    D(e), b.set(e.clientX, e.clientY)
                                }(e), s = a.DOLLY;
                                break;
                            case $o.ROTATE:
                                if (e.ctrlKey || e.metaKey || e.shiftKey) {
                                    if (!1 === n.enablePan) return;
                                    F(e), s = a.PAN
                                } else {
                                    if (!1 === n.enableRotate) return;
                                    k(e), s = a.ROTATE
                                }
                                break;
                            case $o.PAN:
                                if (e.ctrlKey || e.metaKey || e.shiftKey) {
                                    if (!1 === n.enableRotate) return;
                                    k(e), s = a.ROTATE
                                } else {
                                    if (!1 === n.enablePan) return;
                                    F(e), s = a.PAN
                                }
                                break;
                            default:
                                s = a.NONE
                        }
                        s !== a.NONE && n.dispatchEvent(i)
                    }(e))
                }

                function W(e) {
                    !1 !== n.enabled && ("touch" === e.pointerType ? function(e) {
                        switch ($(e), s) {
                            case a.TOUCH_ROTATE:
                                if (!1 === n.enableRotate) return;
                                j(e), n.update();
                                break;
                            case a.TOUCH_PAN:
                                if (!1 === n.enablePan) return;
                                G(e), n.update();
                                break;
                            case a.TOUCH_DOLLY_PAN:
                                if (!1 === n.enableZoom && !1 === n.enablePan) return;
                                ! function(e) {
                                    n.enableZoom && V(e), n.enablePan && G(e)
                                }(e), n.update();
                                break;
                            case a.TOUCH_DOLLY_ROTATE:
                                if (!1 === n.enableZoom && !1 === n.enableRotate) return;
                                ! function(e) {
                                    n.enableZoom && V(e), n.enableRotate && j(e)
                                }(e), n.update();
                                break;
                            default:
                                s = a.NONE
                        }
                    }(e) : function(e) {
                        if (!1 === n.enabled) return;
                        switch (s) {
                            case a.ROTATE:
                                if (!1 === n.enableRotate) return;
                                ! function(e) {
                                    f.set(e.clientX, e.clientY), m.subVectors(f, p).multiplyScalar(n.rotateSpeed);
                                    const t = n.domElement;
                                    t && (T(2 * Math.PI * m.x / t.clientHeight), P(2 * Math.PI * m.y / t.clientHeight)), p.copy(f), n.update()
                                }(e);
                                break;
                            case a.DOLLY:
                                if (!1 === n.enableZoom) return;
                                ! function(e) {
                                    x.set(e.clientX, e.clientY), _.subVectors(x, b), _.y > 0 ? B(C()) : _.y < 0 && L(C()), b.copy(x), n.update()
                                }(e);
                                break;
                            case a.PAN:
                                if (!1 === n.enablePan) return;
                                ! function(e) {
                                    v.set(e.clientX, e.clientY), y.subVectors(v, g).multiplyScalar(n.panSpeed), O(y.x, y.y), g.copy(v), n.update()
                                }(e)
                        }
                    }(e))
                }

                function X(e) {
                    var t, r, i;
                    Z(e), 0 === S.length && (null == (t = n.domElement) || t.releasePointerCapture(e.pointerId), null == (r = n.domElement) || r.ownerDocument.removeEventListener("pointermove", W), null == (i = n.domElement) || i.ownerDocument.removeEventListener("pointerup", X)), n.dispatchEvent(o), s = a.NONE
                }

                function K(e) {
                    Z(e)
                }

                function J(e) {
                    !1 === n.enabled || !1 === n.enableZoom || s !== a.NONE && s !== a.ROTATE || (e.preventDefault(), n.dispatchEvent(i), function(e) {
                        D(e), e.deltaY < 0 ? L(C()) : e.deltaY > 0 && B(C()), n.update()
                    }(e), n.dispatchEvent(o))
                }

                function Y(e) {
                    !1 !== n.enabled && !1 !== n.enablePan && function(e) {
                        let t = !1;
                        switch (e.code) {
                            case n.keys.UP:
                                O(0, n.keyPanSpeed), t = !0;
                                break;
                            case n.keys.BOTTOM:
                                O(0, -n.keyPanSpeed), t = !0;
                                break;
                            case n.keys.LEFT:
                                O(n.keyPanSpeed, 0), t = !0;
                                break;
                            case n.keys.RIGHT:
                                O(-n.keyPanSpeed, 0), t = !0
                        }
                        t && (e.preventDefault(), n.update())
                    }(e)
                }

                function Q(e) {
                    !1 !== n.enabled && e.preventDefault()
                }

                function Z(e) {
                    delete E[e.pointerId];
                    for (let t = 0; t < S.length; t++)
                        if (S[t].pointerId == e.pointerId) return void S.splice(t, 1)
                }

                function $(e) {
                    let t = E[e.pointerId];
                    void 0 === t && (t = new Yc, E[e.pointerId] = t), t.set(e.pageX, e.pageY)
                }

                function ee(e) {
                    const t = e.pointerId === S[0].pointerId ? S[1] : S[0];
                    return E[t.pointerId]
                }
                void 0 !== t && this.connect(t), this.update()
            }
        }
        const DA = r.forwardRef(((e, t) => {
                let {
                    makeDefault: n,
                    camera: i,
                    regress: o,
                    domElement: a,
                    enableDamping: s = !0,
                    keyEvents: l = !1,
                    onChange: c,
                    onStart: u,
                    onEnd: d,
                    ...h
                } = e;
                const p = KM((e => e.invalidate)),
                    f = KM((e => e.camera)),
                    m = KM((e => e.gl)),
                    g = KM((e => e.events)),
                    v = KM((e => e.setEvents)),
                    y = KM((e => e.set)),
                    b = KM((e => e.get)),
                    x = KM((e => e.performance)),
                    _ = i || f,
                    M = a || g.connected || m.domElement,
                    w = r.useMemo((() => new LA(_)), [_]);
                return JM((() => {
                    w.enabled && w.update()
                }), -1), r.useEffect((() => (l && w.connect(!0 === l ? M : l), w.connect(M), () => {
                    w.dispose()
                })), [l, M, o, w, p]), r.useEffect((() => {
                    const e = e => {
                            p(), o && x.regress(), c && c(e)
                        },
                        t = e => {
                            u && u(e)
                        },
                        n = e => {
                            d && d(e)
                        };
                    return w.addEventListener("change", e), w.addEventListener("start", t), w.addEventListener("end", n), () => {
                        w.removeEventListener("start", t), w.removeEventListener("end", n), w.removeEventListener("change", e)
                    }
                }), [c, u, d, w, p, v]), r.useEffect((() => {
                    if (n) {
                        const e = b().controls;
                        return y({
                            controls: w
                        }), () => y({
                            controls: e
                        })
                    }
                }), [n, w]), r.createElement("primitive", (0, uw.c)({
                    ref: t,
                    object: w,
                    enableDamping: s
                }, h))
            })),
            NA = 0,
            kA = 1,
            FA = 2,
            UA = 2,
            zA = 1.25,
            HA = 1,
            jA = 32,
            GA = 65535,
            VA = Math.pow(2, -24),
            qA = Symbol("SKIP_GENERATION");

        function WA(e) {
            return e.index ? e.index.count : e.attributes.position.count
        }

        function XA(e) {
            return WA(e) / 3
        }

        function KA(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ArrayBuffer;
            return e > 65535 ? new Uint32Array(new t(4 * e)) : new Uint16Array(new t(2 * e))
        }

        function JA(e) {
            const t = XA(e),
                n = e.drawRange,
                r = n.start / 3,
                i = (n.start + n.count) / 3,
                o = Math.max(0, r),
                a = Math.min(t, i) - o;
            return [{
                offset: Math.floor(o),
                count: Math.floor(a)
            }]
        }

        function YA(e) {
            if (!e.groups || !e.groups.length) return JA(e);
            const t = [],
                n = new Set,
                r = e.drawRange,
                i = r.start / 3,
                o = (r.start + r.count) / 3;
            for (const s of e.groups) {
                const e = s.start / 3,
                    t = (s.start + s.count) / 3;
                n.add(Math.max(i, e)), n.add(Math.min(o, t))
            }
            const a = Array.from(n.values()).sort(((e, t) => e - t));
            for (let s = 0; s < a.length - 1; s++) {
                const e = a[s],
                    n = a[s + 1];
                t.push({
                    offset: Math.floor(e),
                    count: Math.floor(n - e)
                })
            }
            return t
        }

        function QA(e, t, n, r, i) {
            let o = 1 / 0,
                a = 1 / 0,
                s = 1 / 0,
                l = -1 / 0,
                c = -1 / 0,
                u = -1 / 0,
                d = 1 / 0,
                h = 1 / 0,
                p = 1 / 0,
                f = -1 / 0,
                m = -1 / 0,
                g = -1 / 0;
            for (let v = 6 * t, y = 6 * (t + n); v < y; v += 6) {
                const t = e[v + 0],
                    n = e[v + 1],
                    r = t - n,
                    i = t + n;
                r < o && (o = r), i > l && (l = i), t < d && (d = t), t > f && (f = t);
                const y = e[v + 2],
                    b = e[v + 3],
                    x = y - b,
                    _ = y + b;
                x < a && (a = x), _ > c && (c = _), y < h && (h = y), y > m && (m = y);
                const M = e[v + 4],
                    w = e[v + 5],
                    A = M - w,
                    S = M + w;
                A < s && (s = A), S > u && (u = S), M < p && (p = M), M > g && (g = M)
            }
            r[0] = o, r[1] = a, r[2] = s, r[3] = l, r[4] = c, r[5] = u, i[0] = d, i[1] = h, i[2] = p, i[3] = f, i[4] = m, i[5] = g
        }

        function ZA(e, t, n) {
            return n.min.x = t[e], n.min.y = t[e + 1], n.min.z = t[e + 2], n.max.x = t[e + 3], n.max.y = t[e + 4], n.max.z = t[e + 5], n
        }

        function $A(e) {
            let t = -1,
                n = -1 / 0;
            for (let r = 0; r < 3; r++) {
                const i = e[r + 3] - e[r];
                i > n && (n = i, t = r)
            }
            return t
        }

        function eS(e, t) {
            t.set(e)
        }

        function tS(e, t, n) {
            let r, i;
            for (let o = 0; o < 3; o++) {
                const a = o + 3;
                r = e[o], i = t[o], n[o] = r < i ? r : i, r = e[a], i = t[a], n[a] = r > i ? r : i
            }
        }

        function nS(e, t, n) {
            for (let r = 0; r < 3; r++) {
                const i = t[e + 2 * r],
                    o = t[e + 2 * r + 1],
                    a = i - o,
                    s = i + o;
                a < n[r] && (n[r] = a), s > n[r + 3] && (n[r + 3] = s)
            }
        }

        function rS(e) {
            const t = e[3] - e[0],
                n = e[4] - e[1],
                r = e[5] - e[2];
            return 2 * (t * n + n * r + r * t)
        }
        const iS = 32,
            oS = (e, t) => e.candidate - t.candidate,
            aS = new Array(iS).fill().map((() => ({
                count: 0,
                bounds: new Float32Array(6),
                rightCacheBounds: new Float32Array(6),
                leftCacheBounds: new Float32Array(6),
                candidate: 0
            }))),
            sS = new Float32Array(6);
        class lS {
            constructor() {
                this.boundingData = new Float32Array(6)
            }
        }

        function cS(e, t, n, r, i, o) {
            let a = r,
                s = r + i - 1;
            const l = o.pos,
                c = 2 * o.axis;
            for (;;) {
                for (; a <= s && n[6 * a + c] < l;) a++;
                for (; a <= s && n[6 * s + c] >= l;) s--;
                if (!(a < s)) return a;
                for (let e = 0; e < 3; e++) {
                    let n = t[3 * a + e];
                    t[3 * a + e] = t[3 * s + e], t[3 * s + e] = n
                }
                for (let e = 0; e < 6; e++) {
                    let t = n[6 * a + e];
                    n[6 * a + e] = n[6 * s + e], n[6 * s + e] = t
                }
                a++, s--
            }
        }

        function uS(e, t, n, r, i, o) {
            let a = r,
                s = r + i - 1;
            const l = o.pos,
                c = 2 * o.axis;
            for (;;) {
                for (; a <= s && n[6 * a + c] < l;) a++;
                for (; a <= s && n[6 * s + c] >= l;) s--;
                if (!(a < s)) return a; {
                    let t = e[a];
                    e[a] = e[s], e[s] = t;
                    for (let e = 0; e < 6; e++) {
                        let t = n[6 * a + e];
                        n[6 * a + e] = n[6 * s + e], n[6 * s + e] = t
                    }
                    a++, s--
                }
            }
        }

        function dS(e, t) {
            return 65535 === t[e + 15]
        }

        function hS(e, t) {
            return t[e + 6]
        }

        function pS(e, t) {
            return t[e + 14]
        }

        function fS(e) {
            return e + 8
        }

        function mS(e, t) {
            return t[e + 6]
        }

        function gS(e, t) {
            return t[e + 7]
        }
        let vS, yS, bS, xS;
        const _S = Math.pow(2, 32);

        function MS(e) {
            return e.count ? 1 : 1 + MS(e.left) + MS(e.right)
        }

        function wS(e, t, n) {
            return vS = new Float32Array(n), yS = new Uint32Array(n), bS = new Uint16Array(n), xS = new Uint8Array(n), AS(e, t)
        }

        function AS(e, t) {
            const n = e / 4,
                r = e / 2,
                i = !!t.count,
                o = t.boundingData;
            for (let a = 0; a < 6; a++) vS[n + a] = o[a];
            if (i) {
                if (t.buffer) {
                    const r = t.buffer;
                    xS.set(new Uint8Array(r), e);
                    for (let t = e, i = e + r.byteLength; t < i; t += jA) {
                        dS(t / 2, bS) || (yS[t / 4 + 6] += n)
                    }
                    return e + r.byteLength
                } {
                    const i = t.offset,
                        o = t.count;
                    return yS[n + 6] = i, bS[r + 14] = o, bS[r + 15] = GA, e + jA
                }
            } {
                const r = t.left,
                    i = t.right,
                    o = t.splitAxis;
                let a;
                if (a = AS(e + jA, r), a / 4 > _S) throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
                return yS[n + 6] = a / 4, a = AS(a, i), yS[n + 7] = o, a
            }
        }

        function SS(e, t, n, r, i) {
            const {
                maxDepth: o,
                verbose: a,
                maxLeafTris: s,
                strategy: l,
                onProgress: c,
                indirect: u
            } = i, d = e._indirectBuffer, h = e.geometry, p = h.index ? h.index.array : null, f = u ? uS : cS, m = XA(h), g = new Float32Array(6);
            let v = !1;
            const y = new lS;
            return QA(t, n, r, y.boundingData, g),
                function e(n, r, i) {
                    let c = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                        u = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
                    !v && u >= o && (v = !0, a && (console.warn("MeshBVH: Max depth of ".concat(o, " reached when generating BVH. Consider increasing maxDepth.")), console.warn(h)));
                    if (i <= s || u >= o) return b(r + i), n.offset = r, n.count = i, n;
                    const m = function(e, t, n, r, i, o) {
                        let a = -1,
                            s = 0;
                        if (o === NA) a = $A(t), -1 !== a && (s = (t[a] + t[a + 3]) / 2);
                        else if (o === kA) a = $A(e), -1 !== a && (s = function(e, t, n, r) {
                            let i = 0;
                            for (let o = t, a = t + n; o < a; o++) i += e[6 * o + 2 * r];
                            return i / n
                        }(n, r, i, a));
                        else if (o === FA) {
                            const o = rS(e);
                            let l = zA * i;
                            const c = 6 * r,
                                u = 6 * (r + i);
                            for (let e = 0; e < 3; e++) {
                                const r = t[e],
                                    d = (t[e + 3] - r) / iS;
                                if (i < iS / 4) {
                                    const t = [...aS];
                                    t.length = i;
                                    let r = 0;
                                    for (let i = c; i < u; i += 6, r++) {
                                        const o = t[r];
                                        o.candidate = n[i + 2 * e], o.count = 0;
                                        const {
                                            bounds: a,
                                            leftCacheBounds: s,
                                            rightCacheBounds: l
                                        } = o;
                                        for (let e = 0; e < 3; e++) l[e] = 1 / 0, l[e + 3] = -1 / 0, s[e] = 1 / 0, s[e + 3] = -1 / 0, a[e] = 1 / 0, a[e + 3] = -1 / 0;
                                        nS(i, n, a)
                                    }
                                    t.sort(oS);
                                    let d = i;
                                    for (let e = 0; e < d; e++) {
                                        const n = t[e];
                                        for (; e + 1 < d && t[e + 1].candidate === n.candidate;) t.splice(e + 1, 1), d--
                                    }
                                    for (let i = c; i < u; i += 6) {
                                        const r = n[i + 2 * e];
                                        for (let e = 0; e < d; e++) {
                                            const o = t[e];
                                            r >= o.candidate ? nS(i, n, o.rightCacheBounds) : (nS(i, n, o.leftCacheBounds), o.count++)
                                        }
                                    }
                                    for (let n = 0; n < d; n++) {
                                        const r = t[n],
                                            c = r.count,
                                            u = i - r.count,
                                            d = r.leftCacheBounds,
                                            h = r.rightCacheBounds;
                                        let p = 0;
                                        0 !== c && (p = rS(d) / o);
                                        let f = 0;
                                        0 !== u && (f = rS(h) / o);
                                        const m = HA + zA * (p * c + f * u);
                                        m < l && (a = e, l = m, s = r.candidate)
                                    }
                                } else {
                                    for (let e = 0; e < iS; e++) {
                                        const t = aS[e];
                                        t.count = 0, t.candidate = r + d + e * d;
                                        const n = t.bounds;
                                        for (let e = 0; e < 3; e++) n[e] = 1 / 0, n[e + 3] = -1 / 0
                                    }
                                    for (let i = c; i < u; i += 6) {
                                        let t = ~~((n[i + 2 * e] - r) / d);
                                        t >= iS && (t = iS - 1);
                                        const o = aS[t];
                                        o.count++, nS(i, n, o.bounds)
                                    }
                                    const t = aS[iS - 1];
                                    eS(t.bounds, t.rightCacheBounds);
                                    for (let e = iS - 2; e >= 0; e--) {
                                        const t = aS[e],
                                            n = aS[e + 1];
                                        tS(t.bounds, n.rightCacheBounds, t.rightCacheBounds)
                                    }
                                    let h = 0;
                                    for (let n = 0; n < iS - 1; n++) {
                                        const t = aS[n],
                                            r = t.count,
                                            c = t.bounds,
                                            u = aS[n + 1].rightCacheBounds;
                                        0 !== r && (0 === h ? eS(c, sS) : tS(c, sS, sS)), h += r;
                                        let d = 0,
                                            p = 0;
                                        0 !== h && (d = rS(sS) / o);
                                        const f = i - h;
                                        0 !== f && (p = rS(u) / o);
                                        const m = HA + zA * (d * h + p * f);
                                        m < l && (a = e, l = m, s = t.candidate)
                                    }
                                }
                            }
                        } else console.warn("MeshBVH: Invalid build strategy value ".concat(o, " used."));
                        return {
                            axis: a,
                            pos: s
                        }
                    }(n.boundingData, c, t, r, i, l);
                    if (-1 === m.axis) return b(r + i), n.offset = r, n.count = i, n;
                    const y = f(d, p, t, r, i, m);
                    if (y === r || y === r + i) b(r + i), n.offset = r, n.count = i;
                    else {
                        n.splitAxis = m.axis;
                        const o = new lS,
                            a = r,
                            s = y - r;
                        n.left = o, QA(t, a, s, o.boundingData, g), e(o, a, s, g, u + 1);
                        const l = new lS,
                            c = y,
                            d = i - s;
                        n.right = l, QA(t, c, d, l.boundingData, g), e(l, c, d, g, u + 1)
                    }
                    return n
                }(y, n, r, g), y;

            function b(e) {
                c && c(e / m)
            }
        }

        function ES(e, t) {
            const n = e.geometry;
            t.indirect && (e._indirectBuffer = function(e, t) {
                const n = (e.index ? e.index.count : e.attributes.position.count) / 3,
                    r = n > 65536,
                    i = r ? 4 : 2,
                    o = t ? new SharedArrayBuffer(n * i) : new ArrayBuffer(n * i),
                    a = r ? new Uint32Array(o) : new Uint16Array(o);
                for (let s = 0, l = a.length; s < l; s++) a[s] = s;
                return a
            }(n, t.useSharedArrayBuffer), function(e) {
                if (0 === e.groups.length) return !1;
                const t = XA(e),
                    n = YA(e).sort(((e, t) => e.offset - t.offset)),
                    r = n[n.length - 1];
                r.count = Math.min(t - r.offset, r.count);
                let i = 0;
                return n.forEach((e => {
                    let {
                        count: t
                    } = e;
                    return i += t
                })), t !== i
            }(n) && !t.verbose && console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')), e._indirectBuffer || function(e, t) {
                if (!e.index) {
                    const n = e.attributes.position.count,
                        r = KA(n, t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer);
                    e.setIndex(new ih(r, 1));
                    for (let e = 0; e < n; e++) r[e] = e
                }
            }(n, t);
            const r = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer,
                i = function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                        r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                    const i = e.attributes.position,
                        o = e.index ? e.index.array : null,
                        a = XA(e),
                        s = i.normalized;
                    let l;
                    null === t ? (l = new Float32Array(6 * a * 4), n = 0, r = a) : (l = t, n = n || 0, r = r || a);
                    const c = i.array,
                        u = i.offset || 0;
                    let d = 3;
                    i.isInterleavedBufferAttribute && (d = i.data.stride);
                    const h = ["getX", "getY", "getZ"];
                    for (let p = n; p < n + r; p++) {
                        const e = 3 * p,
                            t = 6 * p;
                        let n = e + 0,
                            r = e + 1,
                            a = e + 2;
                        o && (n = o[n], r = o[r], a = o[a]), s || (n = n * d + u, r = r * d + u, a = a * d + u);
                        for (let o = 0; o < 3; o++) {
                            let e, u, d;
                            s ? (e = i[h[o]](n), u = i[h[o]](r), d = i[h[o]](a)) : (e = c[n + o], u = c[r + o], d = c[a + o]);
                            let p = e;
                            u < p && (p = u), d < p && (p = d);
                            let f = e;
                            u > f && (f = u), d > f && (f = d);
                            const m = (f - p) / 2,
                                g = 2 * o;
                            l[t + g + 0] = p + m, l[t + g + 1] = m + (Math.abs(p) + m) * VA
                        }
                    }
                    return l
                }(n),
                o = t.indirect ? JA(n) : YA(n);
            e._roots = o.map((n => {
                const o = SS(e, i, n.offset, n.count, t),
                    a = MS(o),
                    s = new r(jA * a);
                return wS(0, o, s), s
            }))
        }
        class CS {
            constructor() {
                this.min = 1 / 0, this.max = -1 / 0
            }
            setFromPointsField(e, t) {
                let n = 1 / 0,
                    r = -1 / 0;
                for (let i = 0, o = e.length; i < o; i++) {
                    const o = e[i][t];
                    n = o < n ? o : n, r = o > r ? o : r
                }
                this.min = n, this.max = r
            }
            setFromPoints(e, t) {
                let n = 1 / 0,
                    r = -1 / 0;
                for (let i = 0, o = t.length; i < o; i++) {
                    const o = t[i],
                        a = e.dot(o);
                    n = a < n ? a : n, r = a > r ? a : r
                }
                this.min = n, this.max = r
            }
            isSeparated(e) {
                return this.min > e.max || e.min > this.max
            }
        }
        CS.prototype.setFromBox = function() {
            const e = new Pu;
            return function(t, n) {
                const r = n.min,
                    i = n.max;
                let o = 1 / 0,
                    a = -1 / 0;
                for (let s = 0; s <= 1; s++)
                    for (let n = 0; n <= 1; n++)
                        for (let l = 0; l <= 1; l++) {
                            e.x = r.x * s + i.x * (1 - s), e.y = r.y * n + i.y * (1 - n), e.z = r.z * l + i.z * (1 - l);
                            const c = t.dot(e);
                            o = Math.min(c, o), a = Math.max(c, a)
                        }
                this.min = o, this.max = a
            }
        }();
        ! function() {
            const e = new CS
        }();
        const TS = function() {
                const e = new Pu,
                    t = new Pu,
                    n = new Pu;
                return function(r, i, o) {
                    const a = r.start,
                        s = e,
                        l = i.start,
                        c = t;
                    n.subVectors(a, l), e.subVectors(r.end, r.start), t.subVectors(i.end, i.start);
                    const u = n.dot(c),
                        d = c.dot(s),
                        h = c.dot(c),
                        p = n.dot(s),
                        f = s.dot(s) * h - d * d;
                    let m, g;
                    m = 0 !== f ? (u * d - p * h) / f : 0, g = (u + m * d) / h, o.x = m, o.y = g
                }
            }(),
            PS = function() {
                const e = new Yc,
                    t = new Pu,
                    n = new Pu;
                return function(r, i, o, a) {
                    TS(r, i, e);
                    let s = e.x,
                        l = e.y;
                    if (s >= 0 && s <= 1 && l >= 0 && l <= 1) return r.at(s, o), void i.at(l, a);
                    if (s >= 0 && s <= 1) return l < 0 ? i.at(0, a) : i.at(1, a), void r.closestPointToPoint(a, !0, o);
                    if (l >= 0 && l <= 1) return s < 0 ? r.at(0, o) : r.at(1, o), void i.closestPointToPoint(o, !0, a); {
                        let e, c;
                        e = s < 0 ? r.start : r.end, c = l < 0 ? i.start : i.end;
                        const u = t,
                            d = n;
                        return r.closestPointToPoint(c, !0, t), i.closestPointToPoint(e, !0, n), u.distanceToSquared(c) <= d.distanceToSquared(e) ? (o.copy(u), void a.copy(c)) : (o.copy(e), void a.copy(d))
                    }
                }
            }(),
            RS = function() {
                const e = new Pu,
                    t = new Pu,
                    n = new ap,
                    r = new d_;
                return function(i, o) {
                    const {
                        radius: a,
                        center: s
                    } = i, {
                        a: l,
                        b: c,
                        c: u
                    } = o;
                    r.start = l, r.end = c;
                    if (r.closestPointToPoint(s, !0, e).distanceTo(s) <= a) return !0;
                    r.start = l, r.end = u;
                    if (r.closestPointToPoint(s, !0, e).distanceTo(s) <= a) return !0;
                    r.start = c, r.end = u;
                    if (r.closestPointToPoint(s, !0, e).distanceTo(s) <= a) return !0;
                    const d = o.getPlane(n);
                    if (Math.abs(d.distanceToPoint(s)) <= a) {
                        const e = d.projectPoint(s, t);
                        if (o.containsPoint(e)) return !0
                    }
                    return !1
                }
            }();

        function IS(e) {
            return Math.abs(e) < 1e-15
        }
        class OS extends Hd {
            constructor() {
                super(...arguments), this.isExtendedTriangle = !0, this.satAxes = new Array(4).fill().map((() => new Pu)), this.satBounds = new Array(4).fill().map((() => new CS)), this.points = [this.a, this.b, this.c], this.sphere = new Yu, this.plane = new ap, this.needsUpdate = !0
            }
            intersectsSphere(e) {
                return RS(e, this)
            }
            update() {
                const e = this.a,
                    t = this.b,
                    n = this.c,
                    r = this.points,
                    i = this.satAxes,
                    o = this.satBounds,
                    a = i[0],
                    s = o[0];
                this.getNormal(a), s.setFromPoints(a, r);
                const l = i[1],
                    c = o[1];
                l.subVectors(e, t), c.setFromPoints(l, r);
                const u = i[2],
                    d = o[2];
                u.subVectors(t, n), d.setFromPoints(u, r);
                const h = i[3],
                    p = o[3];
                h.subVectors(n, e), p.setFromPoints(h, r), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(a, e), this.needsUpdate = !1
            }
        }
        OS.prototype.closestPointToSegment = function() {
            const e = new Pu,
                t = new Pu,
                n = new d_;
            return function(r) {
                let i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                    o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                const {
                    start: a,
                    end: s
                } = r, l = this.points;
                let c, u = 1 / 0;
                for (let d = 0; d < 3; d++) {
                    const a = (d + 1) % 3;
                    n.start.copy(l[d]), n.end.copy(l[a]), PS(n, r, e, t), c = e.distanceToSquared(t), c < u && (u = c, i && i.copy(e), o && o.copy(t))
                }
                return this.closestPointToPoint(a, e), c = a.distanceToSquared(e), c < u && (u = c, i && i.copy(e), o && o.copy(a)), this.closestPointToPoint(s, e), c = s.distanceToSquared(e), c < u && (u = c, i && i.copy(e), o && o.copy(s)), Math.sqrt(u)
            }
        }(), OS.prototype.intersectsTriangle = function() {
            const e = new OS,
                t = new Array(3),
                n = new Array(3),
                r = new CS,
                i = new CS,
                o = new Pu,
                a = new Pu,
                s = new Pu,
                l = new Pu,
                c = new Pu,
                u = new d_,
                d = new d_,
                h = new d_,
                p = new Pu;

            function f(e, t, n) {
                const r = e.points;
                let i = 0,
                    o = -1;
                for (let s = 0; s < 3; s++) {
                    const {
                        start: e,
                        end: l
                    } = u;
                    e.copy(r[s]), l.copy(r[(s + 1) % 3]), u.delta(a);
                    const c = IS(t.distanceToPoint(e));
                    if (IS(t.normal.dot(a)) && c) {
                        n.copy(u), i = 2;
                        break
                    }
                    const d = t.intersectLine(u, p);
                    if (!d && c && p.copy(e), (d || c) && !IS(p.distanceTo(l))) {
                        if (i <= 1) {
                            (1 === i ? n.start : n.end).copy(p), c && (o = i)
                        } else if (i >= 2) {
                            (1 === o ? n.start : n.end).copy(p), i = 2;
                            break
                        }
                        if (i++, 2 === i && -1 === o) break
                    }
                }
                return i
            }
            return function(a) {
                let u = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                    p = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                this.needsUpdate && this.update(), a.isExtendedTriangle ? a.needsUpdate && a.update() : (e.copy(a), e.update(), a = e);
                const m = this.plane,
                    g = a.plane;
                if (Math.abs(m.normal.dot(g.normal)) > 1 - 1e-10) {
                    const e = this.satBounds,
                        s = this.satAxes;
                    n[0] = a.a, n[1] = a.b, n[2] = a.c;
                    for (let t = 0; t < 4; t++) {
                        const i = e[t],
                            o = s[t];
                        if (r.setFromPoints(o, n), i.isSeparated(r)) return !1
                    }
                    const l = a.satBounds,
                        c = a.satAxes;
                    t[0] = this.a, t[1] = this.b, t[2] = this.c;
                    for (let n = 0; n < 4; n++) {
                        const e = l[n],
                            i = c[n];
                        if (r.setFromPoints(i, t), e.isSeparated(r)) return !1
                    }
                    for (let a = 0; a < 4; a++) {
                        const e = s[a];
                        for (let a = 0; a < 4; a++) {
                            const s = c[a];
                            if (o.crossVectors(e, s), r.setFromPoints(o, t), i.setFromPoints(o, n), r.isSeparated(i)) return !1
                        }
                    }
                    return u && (p || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), u.start.set(0, 0, 0), u.end.set(0, 0, 0)), !0
                } {
                    const e = f(this, g, d);
                    if (1 === e && a.containsPoint(d.end)) return u && (u.start.copy(d.end), u.end.copy(d.end)), !0;
                    if (2 !== e) return !1;
                    const t = f(a, m, h);
                    if (1 === t && this.containsPoint(h.end)) return u && (u.start.copy(h.end), u.end.copy(h.end)), !0;
                    if (2 !== t) return !1;
                    if (d.delta(s), h.delta(l), s.dot(l) < 0) {
                        let e = h.start;
                        h.start = h.end, h.end = e
                    }
                    const n = d.start.dot(s),
                        r = d.end.dot(s),
                        i = h.start.dot(s),
                        o = h.end.dot(s);
                    return (n === o || i === r || r < i !== n < o) && (u && (c.subVectors(d.start, h.start), c.dot(s) > 0 ? u.start.copy(d.start) : u.start.copy(h.start), c.subVectors(d.end, h.end), c.dot(s) < 0 ? u.end.copy(d.end) : u.end.copy(h.end)), !0)
                }
            }
        }(), OS.prototype.distanceToPoint = function() {
            const e = new Pu;
            return function(t) {
                return this.closestPointToPoint(t, e), t.distanceTo(e)
            }
        }(), OS.prototype.distanceToTriangle = function() {
            const e = new Pu,
                t = new Pu,
                n = ["a", "b", "c"],
                r = new d_,
                i = new d_;
            return function(o) {
                let a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                    s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                const l = a || s ? r : null;
                if (this.intersectsTriangle(o, l)) return (a || s) && (a && l.getCenter(a), s && l.getCenter(s)), 0;
                let c = 1 / 0;
                for (let t = 0; t < 3; t++) {
                    let r;
                    const i = n[t],
                        l = o[i];
                    this.closestPointToPoint(l, e), r = l.distanceToSquared(e), r < c && (c = r, a && a.copy(e), s && s.copy(l));
                    const u = this[i];
                    o.closestPointToPoint(u, e), r = u.distanceToSquared(e), r < c && (c = r, a && a.copy(u), s && s.copy(e))
                }
                for (let u = 0; u < 3; u++) {
                    const l = n[u],
                        d = n[(u + 1) % 3];
                    r.set(this[l], this[d]);
                    for (let u = 0; u < 3; u++) {
                        const l = n[u],
                            d = n[(u + 1) % 3];
                        i.set(o[l], o[d]), PS(r, i, e, t);
                        const h = e.distanceToSquared(t);
                        h < c && (c = h, a && a.copy(e), s && s.copy(t))
                    }
                }
                return Math.sqrt(c)
            }
        }();
        class BS {
            constructor(e, t, n) {
                this.isOrientedBox = !0, this.min = new Pu, this.max = new Pu, this.matrix = new od, this.invMatrix = new od, this.points = new Array(8).fill().map((() => new Pu)), this.satAxes = new Array(3).fill().map((() => new Pu)), this.satBounds = new Array(3).fill().map((() => new CS)), this.alignedSatBounds = new Array(3).fill().map((() => new CS)), this.needsUpdate = !1, e && this.min.copy(e), t && this.max.copy(t), n && this.matrix.copy(n)
            }
            set(e, t, n) {
                this.min.copy(e), this.max.copy(t), this.matrix.copy(n), this.needsUpdate = !0
            }
            copy(e) {
                this.min.copy(e.min), this.max.copy(e.max), this.matrix.copy(e.matrix), this.needsUpdate = !0
            }
        }
        BS.prototype.update = function() {
            const e = this.matrix,
                t = this.min,
                n = this.max,
                r = this.points;
            for (let l = 0; l <= 1; l++)
                for (let i = 0; i <= 1; i++)
                    for (let o = 0; o <= 1; o++) {
                        const a = r[1 * l | 2 * i | 4 * o];
                        a.x = l ? n.x : t.x, a.y = i ? n.y : t.y, a.z = o ? n.z : t.z, a.applyMatrix4(e)
                    }
            const i = this.satBounds,
                o = this.satAxes,
                a = r[0];
            for (let l = 0; l < 3; l++) {
                const e = o[l],
                    t = i[l],
                    n = r[1 << l];
                e.subVectors(a, n), t.setFromPoints(e, r)
            }
            const s = this.alignedSatBounds;
            s[0].setFromPointsField(r, "x"), s[1].setFromPointsField(r, "y"), s[2].setFromPointsField(r, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = !1
        }, BS.prototype.intersectsBox = function() {
            const e = new CS;
            return function(t) {
                this.needsUpdate && this.update();
                const n = t.min,
                    r = t.max,
                    i = this.satBounds,
                    o = this.satAxes,
                    a = this.alignedSatBounds;
                if (e.min = n.x, e.max = r.x, a[0].isSeparated(e)) return !1;
                if (e.min = n.y, e.max = r.y, a[1].isSeparated(e)) return !1;
                if (e.min = n.z, e.max = r.z, a[2].isSeparated(e)) return !1;
                for (let s = 0; s < 3; s++) {
                    const n = o[s],
                        r = i[s];
                    if (e.setFromBox(n, t), r.isSeparated(e)) return !1
                }
                return !0
            }
        }(), BS.prototype.intersectsTriangle = function() {
            const e = new OS,
                t = new Array(3),
                n = new CS,
                r = new CS,
                i = new Pu;
            return function(o) {
                this.needsUpdate && this.update(), o.isExtendedTriangle ? o.needsUpdate && o.update() : (e.copy(o), e.update(), o = e);
                const a = this.satBounds,
                    s = this.satAxes;
                t[0] = o.a, t[1] = o.b, t[2] = o.c;
                for (let e = 0; e < 3; e++) {
                    const r = a[e],
                        i = s[e];
                    if (n.setFromPoints(i, t), r.isSeparated(n)) return !1
                }
                const l = o.satBounds,
                    c = o.satAxes,
                    u = this.points;
                for (let e = 0; e < 3; e++) {
                    const t = l[e],
                        r = c[e];
                    if (n.setFromPoints(r, u), t.isSeparated(n)) return !1
                }
                for (let e = 0; e < 3; e++) {
                    const o = s[e];
                    for (let e = 0; e < 4; e++) {
                        const a = c[e];
                        if (i.crossVectors(o, a), n.setFromPoints(i, t), r.setFromPoints(i, u), n.isSeparated(r)) return !1
                    }
                }
                return !0
            }
        }(), BS.prototype.closestPointToPoint = function(e, t) {
            return this.needsUpdate && this.update(), t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), t
        }, BS.prototype.distanceToPoint = function() {
            const e = new Pu;
            return function(t) {
                return this.closestPointToPoint(t, e), t.distanceTo(e)
            }
        }(), BS.prototype.distanceToBox = function() {
            const e = ["x", "y", "z"],
                t = new Array(12).fill().map((() => new d_)),
                n = new Array(12).fill().map((() => new d_)),
                r = new Pu,
                i = new Pu;
            return function(o) {
                let a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                    s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                    l = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                if (this.needsUpdate && this.update(), this.intersectsBox(o)) return (s || l) && (o.getCenter(i), this.closestPointToPoint(i, r), o.closestPointToPoint(r, i), s && s.copy(r), l && l.copy(i)), 0;
                const c = a * a,
                    u = o.min,
                    d = o.max,
                    h = this.points;
                let p = 1 / 0;
                for (let e = 0; e < 8; e++) {
                    const t = h[e];
                    i.copy(t).clamp(u, d);
                    const n = t.distanceToSquared(i);
                    if (n < p && (p = n, s && s.copy(t), l && l.copy(i), n < c)) return Math.sqrt(n)
                }
                let f = 0;
                for (let r = 0; r < 3; r++)
                    for (let i = 0; i <= 1; i++)
                        for (let o = 0; o <= 1; o++) {
                            const a = (r + 1) % 3,
                                s = (r + 2) % 3,
                                l = 1 << r | i << a | o << s,
                                c = h[i << a | o << s],
                                p = h[l];
                            t[f].set(c, p);
                            const m = e[r],
                                g = e[a],
                                v = e[s],
                                y = n[f],
                                b = y.start,
                                x = y.end;
                            b[m] = u[m], b[g] = i ? u[g] : d[g], b[v] = o ? u[v] : d[g], x[m] = d[m], x[g] = i ? u[g] : d[g], x[v] = o ? u[v] : d[g], f++
                        }
                for (let e = 0; e <= 1; e++)
                    for (let t = 0; t <= 1; t++)
                        for (let n = 0; n <= 1; n++) {
                            i.x = e ? d.x : u.x, i.y = t ? d.y : u.y, i.z = n ? d.z : u.z, this.closestPointToPoint(i, r);
                            const o = i.distanceToSquared(r);
                            if (o < p && (p = o, s && s.copy(r), l && l.copy(i), o < c)) return Math.sqrt(o)
                        }
                for (let e = 0; e < 12; e++) {
                    const o = t[e];
                    for (let e = 0; e < 12; e++) {
                        const t = n[e];
                        PS(o, t, r, i);
                        const a = r.distanceToSquared(i);
                        if (a < p && (p = a, s && s.copy(r), l && l.copy(i), a < c)) return Math.sqrt(a)
                    }
                }
                return Math.sqrt(p)
            }
        }();
        class LS {
            constructor(e) {
                this._getNewPrimitive = e, this._primitives = []
            }
            getPrimitive() {
                const e = this._primitives;
                return 0 === e.length ? this._getNewPrimitive() : e.pop()
            }
            releasePrimitive(e) {
                this._primitives.push(e)
            }
        }
        class DS extends LS {
            constructor() {
                super((() => new OS))
            }
        }
        const NS = new DS;
        const kS = new class {
            constructor() {
                this.float32Array = null, this.uint16Array = null, this.uint32Array = null;
                const e = [];
                let t = null;
                this.setBuffer = n => {
                    t && e.push(t), t = n, this.float32Array = new Float32Array(n), this.uint16Array = new Uint16Array(n), this.uint32Array = new Uint32Array(n)
                }, this.clearBuffer = () => {
                    t = null, this.float32Array = null, this.uint16Array = null, this.uint32Array = null, 0 !== e.length && this.setBuffer(e.pop())
                }
            }
        };
        let FS, US;
        const zS = [],
            HS = new LS((() => new Ou));

        function jS(e, t, n, r, i, o) {
            FS = HS.getPrimitive(), US = HS.getPrimitive(), zS.push(FS, US), kS.setBuffer(e._roots[t]);
            const a = GS(0, e.geometry, n, r, i, o);
            kS.clearBuffer(), HS.releasePrimitive(FS), HS.releasePrimitive(US), zS.pop(), zS.pop();
            const s = zS.length;
            return s > 0 && (US = zS[s - 1], FS = zS[s - 2]), a
        }

        function GS(e, t, n, r) {
            let i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null,
                o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0,
                a = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0;
            const {
                float32Array: s,
                uint16Array: l,
                uint32Array: c
            } = kS;
            let u = 2 * e;
            if (dS(u, l)) {
                const d = hS(e, c),
                    h = pS(u, l);
                return ZA(e, s, FS), r(d, h, !1, a, o + e, FS)
            } {
                const p = fS(e),
                    f = mS(e, c);
                let m, g, v, y, b = p,
                    x = f;
                if (i && (v = FS, y = US, ZA(b, s, v), ZA(x, s, y), m = i(v), g = i(y), g < m)) {
                    b = f, x = p;
                    const C = m;
                    m = g, g = C, v = y
                }
                v || (v = FS, ZA(b, s, v));
                const _ = n(v, dS(2 * b, l), m, a + 1, o + b);
                let M;
                if (_ === UA) {
                    const T = S(b);
                    M = r(T, E(b) - T, !0, a + 1, o + b, v)
                } else M = _ && GS(b, t, n, r, i, o, a + 1);
                if (M) return !0;
                y = US, ZA(x, s, y);
                const w = n(y, dS(2 * x, l), g, a + 1, o + x);
                let A;
                if (w === UA) {
                    const P = S(x);
                    A = r(P, E(x) - P, !0, a + 1, o + x, y)
                } else A = w && GS(x, t, n, r, i, o, a + 1);
                return !!A;

                function S(e) {
                    const {
                        uint16Array: t,
                        uint32Array: n
                    } = kS;
                    let r = 2 * e;
                    for (; !dS(r, t);) r = 2 * (e = fS(e));
                    return hS(e, n)
                }

                function E(e) {
                    const {
                        uint16Array: t,
                        uint32Array: n
                    } = kS;
                    let r = 2 * e;
                    for (; !dS(r, t);) r = 2 * (e = mS(e, n));
                    return hS(e, n) + pS(r, t)
                }
            }
        }
        const VS = new Pu,
            qS = new Pu;
        const WS = new Pu,
            XS = new Pu,
            KS = new Pu,
            JS = new Yc,
            YS = new Yc,
            QS = new Yc,
            ZS = new Pu,
            $S = new Pu,
            eE = new Pu,
            tE = new Pu;

        function nE(e, t, n, r, i, o, a, s, l) {
            WS.fromBufferAttribute(t, o), XS.fromBufferAttribute(t, a), KS.fromBufferAttribute(t, s);
            const c = function(e, t, n, r, i, o) {
                let a;
                return a = o === ua ? e.intersectTriangle(r, n, t, !0, i) : e.intersectTriangle(t, n, r, o !== da, i), null === a ? null : {
                    distance: e.origin.distanceTo(i),
                    point: i.clone()
                }
            }(e, WS, XS, KS, tE, l);
            if (c) {
                r && (JS.fromBufferAttribute(r, o), YS.fromBufferAttribute(r, a), QS.fromBufferAttribute(r, s), c.uv = Hd.getInterpolation(tE, WS, XS, KS, JS, YS, QS, new Yc)), i && (JS.fromBufferAttribute(i, o), YS.fromBufferAttribute(i, a), QS.fromBufferAttribute(i, s), c.uv1 = Hd.getInterpolation(tE, WS, XS, KS, JS, YS, QS, new Yc)), n && (ZS.fromBufferAttribute(n, o), $S.fromBufferAttribute(n, a), eE.fromBufferAttribute(n, s), c.normal = Hd.getInterpolation(tE, WS, XS, KS, ZS, $S, eE, new Pu), c.normal.dot(e.direction) > 0 && c.normal.multiplyScalar(-1));
                const t = {
                    a: o,
                    b: a,
                    c: s,
                    normal: new Pu,
                    materialIndex: 0
                };
                Hd.getNormal(WS, XS, KS, t.normal), c.face = t, c.faceIndex = o
            }
            return c
        }

        function rE(e, t, n, r, i) {
            const o = 3 * r;
            let a = o + 0,
                s = o + 1,
                l = o + 2;
            const c = e.index;
            e.index && (a = c.getX(a), s = c.getX(s), l = c.getX(l));
            const {
                position: u,
                normal: d,
                uv: h,
                uv1: p
            } = e.attributes, f = nE(n, u, d, h, p, a, s, l, t);
            return f ? (f.faceIndex = r, i && i.push(f), f) : null
        }

        function iE(e, t, n, r) {
            const i = e.a,
                o = e.b,
                a = e.c;
            let s = t,
                l = t + 1,
                c = t + 2;
            n && (s = n.getX(s), l = n.getX(l), c = n.getX(c)), i.x = r.getX(s), i.y = r.getY(s), i.z = r.getZ(s), o.x = r.getX(l), o.y = r.getY(l), o.z = r.getZ(l), a.x = r.getX(c), a.y = r.getY(c), a.z = r.getZ(c)
        }

        function oE(e, t, n, r, i, o, a) {
            const {
                geometry: s
            } = n, {
                index: l
            } = s, c = s.attributes.position;
            for (let u = e, d = t + e; u < d; u++) {
                let e;
                if (e = u, iE(a, 3 * e, l, c), a.needsUpdate = !0, r(a, e, i, o)) return !0
            }
            return !1
        }

        function aE(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
            t && Array.isArray(t) && (t = new Set(t));
            const n = e.geometry,
                r = n.index ? n.index.array : null,
                i = n.attributes.position;
            let o, a, s, l, c = 0;
            const u = e._roots;
            for (let h = 0, p = u.length; h < p; h++) o = u[h], a = new Uint32Array(o), s = new Uint16Array(o), l = new Float32Array(o), d(0, c), c += o.byteLength;

            function d(e, n) {
                let o = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                const c = 2 * e;
                if (s[c + 15] === GA) {
                    const t = a[e + 6];
                    let n = 1 / 0,
                        o = 1 / 0,
                        u = 1 / 0,
                        d = -1 / 0,
                        h = -1 / 0,
                        p = -1 / 0;
                    for (let e = 3 * t, a = 3 * (t + s[c + 14]); e < a; e++) {
                        let t = r[e];
                        const a = i.getX(t),
                            s = i.getY(t),
                            l = i.getZ(t);
                        a < n && (n = a), a > d && (d = a), s < o && (o = s), s > h && (h = s), l < u && (u = l), l > p && (p = l)
                    }
                    return (l[e + 0] !== n || l[e + 1] !== o || l[e + 2] !== u || l[e + 3] !== d || l[e + 4] !== h || l[e + 5] !== p) && (l[e + 0] = n, l[e + 1] = o, l[e + 2] = u, l[e + 3] = d, l[e + 4] = h, l[e + 5] = p, !0)
                } {
                    const r = e + 8,
                        i = a[e + 6],
                        s = r + n,
                        c = i + n;
                    let u = o,
                        h = !1,
                        p = !1;
                    t ? u || (h = t.has(s), p = t.has(c), u = !h && !p) : (h = !0, p = !0);
                    const f = u || p;
                    let m = !1;
                    (u || h) && (m = d(r, n, u));
                    let g = !1;
                    f && (g = d(i, n, u));
                    const v = m || g;
                    if (v)
                        for (let t = 0; t < 3; t++) {
                            const n = r + t,
                                o = i + t,
                                a = l[n],
                                s = l[n + 3],
                                c = l[o],
                                u = l[o + 3];
                            l[e + t] = a < c ? a : c, l[e + t + 3] = s > u ? s : u
                        }
                    return v
                }
            }
        }
        const sE = new Ou;

        function lE(e, t, n, r) {
            return ZA(e, t, sE), n.intersectBox(sE, r)
        }
        const cE = new Pu;

        function uE(e, t, n, r, i) {
            kS.setBuffer(e._roots[t]), dE(0, e, n, r, i), kS.clearBuffer()
        }

        function dE(e, t, n, r, i) {
            const {
                float32Array: o,
                uint16Array: a,
                uint32Array: s
            } = kS, l = 2 * e;
            if (dS(l, a)) {
                ! function(e, t, n, r, i, o) {
                    const {
                        geometry: a,
                        _indirectBuffer: s
                    } = e;
                    for (let l = r, c = r + i; l < c; l++) rE(a, t, n, l, o)
                }(t, n, r, hS(e, s), pS(l, a), i)
            } else {
                const a = fS(e);
                lE(a, o, r, cE) && dE(a, t, n, r, i);
                const l = mS(e, s);
                lE(l, o, r, cE) && dE(l, t, n, r, i)
            }
        }
        const hE = new Pu,
            pE = ["x", "y", "z"];

        function fE(e, t, n, r) {
            kS.setBuffer(e._roots[t]);
            const i = mE(0, e, n, r);
            return kS.clearBuffer(), i
        }

        function mE(e, t, n, r) {
            const {
                float32Array: i,
                uint16Array: o,
                uint32Array: a
            } = kS;
            let s = 2 * e;
            if (dS(s, o)) {
                return function(e, t, n, r, i) {
                    const {
                        geometry: o,
                        _indirectBuffer: a
                    } = e;
                    let s = 1 / 0,
                        l = null;
                    for (let c = r, u = r + i; c < u; c++) {
                        let e;
                        e = rE(o, t, n, c), e && e.distance < s && (l = e, s = e.distance)
                    }
                    return l
                }(t, n, r, hS(e, a), pS(s, o))
            } {
                const o = gS(e, a),
                    s = pE[o],
                    l = r.direction[s] >= 0;
                let c, u;
                l ? (c = fS(e), u = mS(e, a)) : (c = mS(e, a), u = fS(e));
                const d = lE(c, i, r, hE) ? mE(c, t, n, r) : null;
                if (d) {
                    const e = d.point[s];
                    if (l ? e <= i[u + o] : e >= i[u + o + 3]) return d
                }
                const h = lE(u, i, r, hE) ? mE(u, t, n, r) : null;
                return d && h ? d.distance <= h.distance ? d : h : d || h || null
            }
        }
        const gE = new Ou,
            vE = new OS,
            yE = new OS,
            bE = new od,
            xE = new BS,
            _E = new BS;

        function ME(e, t, n, r) {
            kS.setBuffer(e._roots[t]);
            const i = wE(0, e, n, r);
            return kS.clearBuffer(), i
        }

        function wE(e, t, n, r) {
            let i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null;
            const {
                float32Array: o,
                uint16Array: a,
                uint32Array: s
            } = kS;
            let l = 2 * e;
            null === i && (n.boundingBox || n.computeBoundingBox(), xE.set(n.boundingBox.min, n.boundingBox.max, r), i = xE);
            if (!dS(l, a)) {
                const a = e + 8,
                    l = s[e + 6];
                ZA(a, o, gE);
                if (i.intersectsBox(gE) && wE(a, t, n, r, i)) return !0;
                ZA(l, o, gE);
                return !!(i.intersectsBox(gE) && wE(l, t, n, r, i))
            } {
                const i = t.geometry,
                    c = i.index,
                    u = i.attributes.position,
                    d = n.index,
                    h = n.attributes.position,
                    p = hS(e, s),
                    f = pS(l, a);
                if (bE.copy(r).invert(), n.boundsTree) {
                    ZA(e, o, _E), _E.matrix.copy(bE), _E.needsUpdate = !0;
                    const t = n.boundsTree.shapecast({
                        intersectsBounds: e => _E.intersectsBox(e),
                        intersectsTriangle: e => {
                            e.a.applyMatrix4(r), e.b.applyMatrix4(r), e.c.applyMatrix4(r), e.needsUpdate = !0;
                            for (let t = 3 * p, n = 3 * (f + p); t < n; t += 3)
                                if (iE(yE, t, c, u), yE.needsUpdate = !0, e.intersectsTriangle(yE)) return !0;
                            return !1
                        }
                    });
                    return t
                }
                for (let e = 3 * p, t = 3 * (f + p); e < t; e += 3) {
                    iE(vE, e, c, u), vE.a.applyMatrix4(bE), vE.b.applyMatrix4(bE), vE.c.applyMatrix4(bE), vE.needsUpdate = !0;
                    for (let e = 0, t = d.count; e < t; e += 3)
                        if (iE(yE, e, d, h), yE.needsUpdate = !0, vE.intersectsTriangle(yE)) return !0
                }
            }
        }
        const AE = new od,
            SE = new BS,
            EE = new BS,
            CE = new Pu,
            TE = new Pu,
            PE = new Pu,
            RE = new Pu;

        function IE(e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
                i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {},
                o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0,
                a = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1 / 0;
            t.boundingBox || t.computeBoundingBox(), SE.set(t.boundingBox.min, t.boundingBox.max, n), SE.needsUpdate = !0;
            const s = e.geometry,
                l = s.attributes.position,
                c = s.index,
                u = t.attributes.position,
                d = t.index,
                h = NS.getPrimitive(),
                p = NS.getPrimitive();
            let f = CE,
                m = TE,
                g = null,
                v = null;
            i && (g = PE, v = RE);
            let y = 1 / 0,
                b = null,
                x = null;
            return AE.copy(n).invert(), EE.matrix.copy(AE), e.shapecast({
                boundsTraverseOrder: e => SE.distanceToBox(e),
                intersectsBounds: (e, t, n) => n < y && n < a && (t && (EE.min.copy(e.min), EE.max.copy(e.max), EE.needsUpdate = !0), !0),
                intersectsRange: (e, r) => {
                    if (t.boundsTree) {
                        return t.boundsTree.shapecast({
                            boundsTraverseOrder: e => EE.distanceToBox(e),
                            intersectsBounds: (e, t, n) => n < y && n < a,
                            intersectsRange: (t, i) => {
                                for (let a = t, s = t + i; a < s; a++) {
                                    iE(p, 3 * a, d, u), p.a.applyMatrix4(n), p.b.applyMatrix4(n), p.c.applyMatrix4(n), p.needsUpdate = !0;
                                    for (let t = e, n = e + r; t < n; t++) {
                                        iE(h, 3 * t, c, l), h.needsUpdate = !0;
                                        const e = h.distanceToTriangle(p, f, g);
                                        if (e < y && (m.copy(f), v && v.copy(g), y = e, b = t, x = a), e < o) return !0
                                    }
                                }
                            }
                        })
                    }
                    for (let i = 0, a = XA(t); i < a; i++) {
                        iE(p, 3 * i, d, u), p.a.applyMatrix4(n), p.b.applyMatrix4(n), p.c.applyMatrix4(n), p.needsUpdate = !0;
                        for (let t = e, n = e + r; t < n; t++) {
                            iE(h, 3 * t, c, l), h.needsUpdate = !0;
                            const e = h.distanceToTriangle(p, f, g);
                            if (e < y && (m.copy(f), v && v.copy(g), y = e, b = t, x = i), e < o) return !0
                        }
                    }
                }
            }), NS.releasePrimitive(h), NS.releasePrimitive(p), y === 1 / 0 ? null : (r.point ? r.point.copy(m) : r.point = m.clone(), r.distance = y, r.faceIndex = b, i && (i.point ? i.point.copy(v) : i.point = v.clone(), i.point.applyMatrix4(AE), m.applyMatrix4(AE), i.distance = m.sub(i.point).length(), i.faceIndex = x), r)
        }

        function OE(e, t, n, r, i, o, a) {
            const {
                geometry: s
            } = n, {
                index: l
            } = s, c = s.attributes.position;
            for (let u = e, d = t + e; u < d; u++) {
                let e;
                if (e = n.resolveTriangleIndex(u), iE(a, 3 * e, l, c), a.needsUpdate = !0, r(a, e, i, o)) return !0
            }
            return !1
        }

        function BE(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
            t && Array.isArray(t) && (t = new Set(t));
            const n = e.geometry,
                r = n.index ? n.index.array : null,
                i = n.attributes.position;
            let o, a, s, l, c = 0;
            const u = e._roots;
            for (let h = 0, p = u.length; h < p; h++) o = u[h], a = new Uint32Array(o), s = new Uint16Array(o), l = new Float32Array(o), d(0, c), c += o.byteLength;

            function d(n, o) {
                let c = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                const u = 2 * n;
                if (s[u + 15] === GA) {
                    const t = a[n + 6];
                    let o = 1 / 0,
                        c = 1 / 0,
                        d = 1 / 0,
                        h = -1 / 0,
                        p = -1 / 0,
                        f = -1 / 0;
                    for (let n = t, a = t + s[u + 14]; n < a; n++) {
                        const t = 3 * e.resolveTriangleIndex(n);
                        for (let e = 0; e < 3; e++) {
                            let n = t + e;
                            n = r ? r[n] : n;
                            const a = i.getX(n),
                                s = i.getY(n),
                                l = i.getZ(n);
                            a < o && (o = a), a > h && (h = a), s < c && (c = s), s > p && (p = s), l < d && (d = l), l > f && (f = l)
                        }
                    }
                    return (l[n + 0] !== o || l[n + 1] !== c || l[n + 2] !== d || l[n + 3] !== h || l[n + 4] !== p || l[n + 5] !== f) && (l[n + 0] = o, l[n + 1] = c, l[n + 2] = d, l[n + 3] = h, l[n + 4] = p, l[n + 5] = f, !0)
                } {
                    const e = n + 8,
                        r = a[n + 6],
                        i = e + o,
                        s = r + o;
                    let u = c,
                        h = !1,
                        p = !1;
                    t ? u || (h = t.has(i), p = t.has(s), u = !h && !p) : (h = !0, p = !0);
                    const f = u || p;
                    let m = !1;
                    (u || h) && (m = d(e, o, u));
                    let g = !1;
                    f && (g = d(r, o, u));
                    const v = m || g;
                    if (v)
                        for (let t = 0; t < 3; t++) {
                            const i = e + t,
                                o = r + t,
                                a = l[i],
                                s = l[i + 3],
                                c = l[o],
                                u = l[o + 3];
                            l[n + t] = a < c ? a : c, l[n + t + 3] = s > u ? s : u
                        }
                    return v
                }
            }
        }
        const LE = new Pu;

        function DE(e, t, n, r, i) {
            kS.setBuffer(e._roots[t]), NE(0, e, n, r, i), kS.clearBuffer()
        }

        function NE(e, t, n, r, i) {
            const {
                float32Array: o,
                uint16Array: a,
                uint32Array: s
            } = kS, l = 2 * e;
            if (dS(l, a)) {
                ! function(e, t, n, r, i, o) {
                    const {
                        geometry: a,
                        _indirectBuffer: s
                    } = e;
                    for (let l = r, c = r + i; l < c; l++) rE(a, t, n, s ? s[l] : l, o)
                }(t, n, r, hS(e, s), pS(l, a), i)
            } else {
                const a = fS(e);
                lE(a, o, r, LE) && NE(a, t, n, r, i);
                const l = mS(e, s);
                lE(l, o, r, LE) && NE(l, t, n, r, i)
            }
        }
        const kE = new Pu,
            FE = ["x", "y", "z"];

        function UE(e, t, n, r) {
            kS.setBuffer(e._roots[t]);
            const i = zE(0, e, n, r);
            return kS.clearBuffer(), i
        }

        function zE(e, t, n, r) {
            const {
                float32Array: i,
                uint16Array: o,
                uint32Array: a
            } = kS;
            let s = 2 * e;
            if (dS(s, o)) {
                return function(e, t, n, r, i) {
                    const {
                        geometry: o,
                        _indirectBuffer: a
                    } = e;
                    let s = 1 / 0,
                        l = null;
                    for (let c = r, u = r + i; c < u; c++) {
                        let e;
                        e = rE(o, t, n, a ? a[c] : c), e && e.distance < s && (l = e, s = e.distance)
                    }
                    return l
                }(t, n, r, hS(e, a), pS(s, o))
            } {
                const o = gS(e, a),
                    s = FE[o],
                    l = r.direction[s] >= 0;
                let c, u;
                l ? (c = fS(e), u = mS(e, a)) : (c = mS(e, a), u = fS(e));
                const d = lE(c, i, r, kE) ? zE(c, t, n, r) : null;
                if (d) {
                    const e = d.point[s];
                    if (l ? e <= i[u + o] : e >= i[u + o + 3]) return d
                }
                const h = lE(u, i, r, kE) ? zE(u, t, n, r) : null;
                return d && h ? d.distance <= h.distance ? d : h : d || h || null
            }
        }
        const HE = new Ou,
            jE = new OS,
            GE = new OS,
            VE = new od,
            qE = new BS,
            WE = new BS;

        function XE(e, t, n, r) {
            kS.setBuffer(e._roots[t]);
            const i = KE(0, e, n, r);
            return kS.clearBuffer(), i
        }

        function KE(e, t, n, r) {
            let i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null;
            const {
                float32Array: o,
                uint16Array: a,
                uint32Array: s
            } = kS;
            let l = 2 * e;
            null === i && (n.boundingBox || n.computeBoundingBox(), qE.set(n.boundingBox.min, n.boundingBox.max, r), i = qE);
            if (!dS(l, a)) {
                const a = e + 8,
                    l = s[e + 6];
                ZA(a, o, HE);
                if (i.intersectsBox(HE) && KE(a, t, n, r, i)) return !0;
                ZA(l, o, HE);
                return !!(i.intersectsBox(HE) && KE(l, t, n, r, i))
            } {
                const i = t.geometry,
                    c = i.index,
                    u = i.attributes.position,
                    d = n.index,
                    h = n.attributes.position,
                    p = hS(e, s),
                    f = pS(l, a);
                if (VE.copy(r).invert(), n.boundsTree) {
                    ZA(e, o, WE), WE.matrix.copy(VE), WE.needsUpdate = !0;
                    const i = n.boundsTree.shapecast({
                        intersectsBounds: e => WE.intersectsBox(e),
                        intersectsTriangle: e => {
                            e.a.applyMatrix4(r), e.b.applyMatrix4(r), e.c.applyMatrix4(r), e.needsUpdate = !0;
                            for (let n = p, r = f + p; n < r; n++)
                                if (iE(GE, 3 * t.resolveTriangleIndex(n), c, u), GE.needsUpdate = !0, e.intersectsTriangle(GE)) return !0;
                            return !1
                        }
                    });
                    return i
                }
                for (let e = p, n = f + p; e < n; e++) {
                    const n = t.resolveTriangleIndex(e);
                    iE(jE, 3 * n, c, u), jE.a.applyMatrix4(VE), jE.b.applyMatrix4(VE), jE.c.applyMatrix4(VE), jE.needsUpdate = !0;
                    for (let e = 0, t = d.count; e < t; e += 3)
                        if (iE(GE, e, d, h), GE.needsUpdate = !0, jE.intersectsTriangle(GE)) return !0
                }
            }
        }
        const JE = new od,
            YE = new BS,
            QE = new BS,
            ZE = new Pu,
            $E = new Pu,
            eC = new Pu,
            tC = new Pu;

        function nC(e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
                i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {},
                o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0,
                a = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1 / 0;
            t.boundingBox || t.computeBoundingBox(), YE.set(t.boundingBox.min, t.boundingBox.max, n), YE.needsUpdate = !0;
            const s = e.geometry,
                l = s.attributes.position,
                c = s.index,
                u = t.attributes.position,
                d = t.index,
                h = NS.getPrimitive(),
                p = NS.getPrimitive();
            let f = ZE,
                m = $E,
                g = null,
                v = null;
            i && (g = eC, v = tC);
            let y = 1 / 0,
                b = null,
                x = null;
            return JE.copy(n).invert(), QE.matrix.copy(JE), e.shapecast({
                boundsTraverseOrder: e => YE.distanceToBox(e),
                intersectsBounds: (e, t, n) => n < y && n < a && (t && (QE.min.copy(e.min), QE.max.copy(e.max), QE.needsUpdate = !0), !0),
                intersectsRange: (r, i) => {
                    if (t.boundsTree) {
                        const s = t.boundsTree;
                        return s.shapecast({
                            boundsTraverseOrder: e => QE.distanceToBox(e),
                            intersectsBounds: (e, t, n) => n < y && n < a,
                            intersectsRange: (t, a) => {
                                for (let _ = t, M = t + a; _ < M; _++) {
                                    const t = s.resolveTriangleIndex(_);
                                    iE(p, 3 * t, d, u), p.a.applyMatrix4(n), p.b.applyMatrix4(n), p.c.applyMatrix4(n), p.needsUpdate = !0;
                                    for (let n = r, a = r + i; n < a; n++) {
                                        const t = e.resolveTriangleIndex(n);
                                        iE(h, 3 * t, c, l), h.needsUpdate = !0;
                                        const r = h.distanceToTriangle(p, f, g);
                                        if (r < y && (m.copy(f), v && v.copy(g), y = r, b = n, x = _), r < o) return !0
                                    }
                                }
                            }
                        })
                    }
                    for (let a = 0, s = XA(t); a < s; a++) {
                        iE(p, 3 * a, d, u), p.a.applyMatrix4(n), p.b.applyMatrix4(n), p.c.applyMatrix4(n), p.needsUpdate = !0;
                        for (let t = r, n = r + i; t < n; t++) {
                            const n = e.resolveTriangleIndex(t);
                            iE(h, 3 * n, c, l), h.needsUpdate = !0;
                            const r = h.distanceToTriangle(p, f, g);
                            if (r < y && (m.copy(f), v && v.copy(g), y = r, b = t, x = a), r < o) return !0
                        }
                    }
                }
            }), NS.releasePrimitive(h), NS.releasePrimitive(p), y === 1 / 0 ? null : (r.point ? r.point.copy(m) : r.point = m.clone(), r.distance = y, r.faceIndex = b, i && (i.point ? i.point.copy(v) : i.point = v.clone(), i.point.applyMatrix4(JE), m.applyMatrix4(JE), i.distance = m.sub(i.point).length(), i.faceIndex = x), r)
        }
        const rC = new kS.constructor,
            iC = new kS.constructor,
            oC = new LS((() => new Ou)),
            aC = new Ou,
            sC = new Ou,
            lC = new Ou,
            cC = new Ou;
        let uC = !1;

        function dC(e, t, n, r, i) {
            let o, a, s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0,
                l = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0,
                c = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0,
                u = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0,
                d = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : null,
                h = arguments.length > 10 && void 0 !== arguments[10] && arguments[10];
            h ? (o = iC, a = rC) : (o = rC, a = iC);
            const p = o.float32Array,
                f = o.uint32Array,
                m = o.uint16Array,
                g = a.float32Array,
                v = a.uint32Array,
                y = a.uint16Array,
                b = 2 * t,
                x = dS(2 * e, m),
                _ = dS(b, y);
            let M = !1;
            if (_ && x) M = h ? i(hS(t, v), pS(2 * t, y), hS(e, f), pS(2 * e, m), u, l + t, c, s + e) : i(hS(e, f), pS(2 * e, m), hS(t, v), pS(2 * t, y), c, s + e, u, l + t);
            else if (_) {
                const o = oC.getPrimitive();
                ZA(t, g, o), o.applyMatrix4(n);
                const a = fS(e),
                    d = mS(e, f);
                ZA(a, p, aC), ZA(d, p, sC);
                const m = o.intersectsBox(aC),
                    v = o.intersectsBox(sC);
                M = m && dC(t, a, r, n, i, l, s, u, c + 1, o, !h) || v && dC(t, d, r, n, i, l, s, u, c + 1, o, !h), oC.releasePrimitive(o)
            } else {
                const o = fS(t),
                    a = mS(t, v);
                ZA(o, g, lC), ZA(a, g, cC);
                const m = d.intersectsBox(lC),
                    y = d.intersectsBox(cC);
                if (m && y) M = dC(e, o, n, r, i, s, l, c, u + 1, d, h) || dC(e, a, n, r, i, s, l, c, u + 1, d, h);
                else if (m)
                    if (x) M = dC(e, o, n, r, i, s, l, c, u + 1, d, h);
                    else {
                        const t = oC.getPrimitive();
                        t.copy(lC).applyMatrix4(n);
                        const a = fS(e),
                            d = mS(e, f);
                        ZA(a, p, aC), ZA(d, p, sC);
                        const m = t.intersectsBox(aC),
                            g = t.intersectsBox(sC);
                        M = m && dC(o, a, r, n, i, l, s, u, c + 1, t, !h) || g && dC(o, d, r, n, i, l, s, u, c + 1, t, !h), oC.releasePrimitive(t)
                    }
                else if (y)
                    if (x) M = dC(e, a, n, r, i, s, l, c, u + 1, d, h);
                    else {
                        const t = oC.getPrimitive();
                        t.copy(cC).applyMatrix4(n);
                        const o = fS(e),
                            d = mS(e, f);
                        ZA(o, p, aC), ZA(d, p, sC);
                        const m = t.intersectsBox(aC),
                            g = t.intersectsBox(sC);
                        M = m && dC(a, o, r, n, i, l, s, u, c + 1, t, !h) || g && dC(a, d, r, n, i, l, s, u, c + 1, t, !h), oC.releasePrimitive(t)
                    }
            }
            return M
        }
        const hC = new BS,
            pC = new Ou,
            fC = {
                strategy: NA,
                maxDepth: 40,
                maxLeafTris: 10,
                useSharedArrayBuffer: !1,
                setBoundingBox: !0,
                onProgress: null,
                indirect: !1,
                verbose: !0
            };
        class mC {
            static serialize(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                t = {
                    cloneBuffers: !0,
                    ...t
                };
                const n = e.geometry,
                    r = e._roots,
                    i = e._indirectBuffer,
                    o = n.getIndex();
                let a;
                return a = t.cloneBuffers ? {
                    roots: r.map((e => e.slice())),
                    index: o.array.slice(),
                    indirectBuffer: i ? i.slice() : null
                } : {
                    roots: r,
                    index: o.array,
                    indirectBuffer: i
                }, a
            }
            static deserialize(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                n = {
                    setIndex: !0,
                    indirect: Boolean(e.indirectBuffer),
                    ...n
                };
                const {
                    index: r,
                    roots: i,
                    indirectBuffer: o
                } = e, a = new mC(t, { ...n,
                    [qA]: !0
                });
                if (a._roots = i, a._indirectBuffer = o || null, n.setIndex) {
                    const n = t.getIndex();
                    if (null === n) {
                        const n = new ih(e.index, 1, !1);
                        t.setIndex(n)
                    } else n.array !== r && (n.array.set(r), n.needsUpdate = !0)
                }
                return a
            }
            get indirect() {
                return !!this._indirectBuffer
            }
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (!e.isBufferGeometry) throw new Error("MeshBVH: Only BufferGeometries are supported.");
                if (e.index && e.index.isInterleavedBufferAttribute) throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
                if (t = Object.assign({ ...fC,
                        [qA]: !1
                    }, t), t.useSharedArrayBuffer && "undefined" === typeof SharedArrayBuffer) throw new Error("MeshBVH: SharedArrayBuffer is not available.");
                this.geometry = e, this._roots = null, this._indirectBuffer = null, t[qA] || (ES(this, t), !e.boundingBox && t.setBoundingBox && (e.boundingBox = this.getBoundingBox(new Ou)));
                const {
                    _indirectBuffer: n
                } = this;
                this.resolveTriangleIndex = t.indirect ? e => n[e] : e => e
            }
            refit() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                return (this.indirect ? BE : aE)(this, e)
            }
            traverse(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                const n = this._roots[t],
                    r = new Uint32Array(n),
                    i = new Uint16Array(n);
                ! function t(o) {
                    let a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                    const s = 2 * o,
                        l = i[s + 15] === GA;
                    if (l) {
                        const t = r[o + 6],
                            c = i[s + 14];
                        e(a, l, new Float32Array(n, 4 * o, 6), t, c)
                    } else {
                        const i = o + jA / 4,
                            s = r[o + 6],
                            c = r[o + 7];
                        e(a, l, new Float32Array(n, 4 * o, 6), c) || (t(i, a + 1), t(s, a + 1))
                    }
                }(0)
            }
            raycast(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ca;
                const n = this._roots,
                    r = this.geometry,
                    i = [],
                    o = t.isMaterial,
                    a = Array.isArray(t),
                    s = r.groups,
                    l = o ? t.side : t,
                    c = this.indirect ? DE : uE;
                for (let u = 0, d = n.length; u < d; u++) {
                    const n = a ? t[s[u].materialIndex].side : l,
                        r = i.length;
                    if (c(this, u, n, e, i), a) {
                        const e = s[u].materialIndex;
                        for (let t = r, n = i.length; t < n; t++) i[t].face.materialIndex = e
                    }
                }
                return i
            }
            raycastFirst(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ca;
                const n = this._roots,
                    r = this.geometry,
                    i = t.isMaterial,
                    o = Array.isArray(t);
                let a = null;
                const s = r.groups,
                    l = i ? t.side : t,
                    c = this.indirect ? UE : fE;
                for (let u = 0, d = n.length; u < d; u++) {
                    const n = c(this, u, o ? t[s[u].materialIndex].side : l, e);
                    null != n && (null == a || n.distance < a.distance) && (a = n, o && (n.face.materialIndex = s[u].materialIndex))
                }
                return a
            }
            intersectsGeometry(e, t) {
                let n = !1;
                const r = this._roots,
                    i = this.indirect ? XE : ME;
                for (let o = 0, a = r.length; o < a && (n = i(this, o, e, t), !n); o++);
                return n
            }
            shapecast(e) {
                const t = NS.getPrimitive(),
                    n = this.indirect ? OE : oE;
                let {
                    boundsTraverseOrder: r,
                    intersectsBounds: i,
                    intersectsRange: o,
                    intersectsTriangle: a
                } = e;
                if (o && a) {
                    const e = o;
                    o = (r, i, o, s, l) => !!e(r, i, o, s, l) || n(r, i, this, a, o, s, t)
                } else o || (o = a ? (e, r, i, o) => n(e, r, this, a, i, o, t) : (e, t, n) => n);
                let s = !1,
                    l = 0;
                const c = this._roots;
                for (let u = 0, d = c.length; u < d; u++) {
                    const e = c[u];
                    if (s = jS(this, u, i, o, r, l), s) break;
                    l += e.byteLength
                }
                return NS.releasePrimitive(t), s
            }
            bvhcast(e, t, n) {
                let {
                    intersectsRanges: r,
                    intersectsTriangles: i
                } = n;
                const o = NS.getPrimitive(),
                    a = this.geometry.index,
                    s = this.geometry.attributes.position,
                    l = this.indirect ? e => {
                        const t = this.resolveTriangleIndex(e);
                        iE(o, 3 * t, a, s)
                    } : e => {
                        iE(o, 3 * e, a, s)
                    },
                    c = NS.getPrimitive(),
                    u = e.geometry.index,
                    d = e.geometry.attributes.position,
                    h = e.indirect ? t => {
                        const n = e.resolveTriangleIndex(t);
                        iE(c, 3 * n, u, d)
                    } : e => {
                        iE(c, 3 * e, u, d)
                    };
                if (i) {
                    const e = (e, n, r, a, s, u, d, p) => {
                        for (let f = r, m = r + a; f < m; f++) {
                            h(f), c.a.applyMatrix4(t), c.b.applyMatrix4(t), c.c.applyMatrix4(t), c.needsUpdate = !0;
                            for (let t = e, r = e + n; t < r; t++)
                                if (l(t), o.needsUpdate = !0, i(o, c, t, f, s, u, d, p)) return !0
                        }
                        return !1
                    };
                    if (r) {
                        const t = r;
                        r = function(n, r, i, o, a, s, l, c) {
                            return !!t(n, r, i, o, a, s, l, c) || e(n, r, i, o, a, s, l, c)
                        }
                    } else r = e
                }
                return function(e, t, n, r) {
                    if (uC) throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
                    uC = !0;
                    const i = e._roots,
                        o = t._roots;
                    let a, s = 0,
                        l = 0;
                    const c = (new od).copy(n).invert();
                    for (let u = 0, d = i.length; u < d; u++) {
                        rC.setBuffer(i[u]), l = 0;
                        const e = oC.getPrimitive();
                        ZA(0, rC.float32Array, e), e.applyMatrix4(c);
                        for (let t = 0, i = o.length; t < i && (iC.setBuffer(o[u]), a = dC(0, 0, n, c, r, s, l, 0, 0, e), iC.clearBuffer(), l += o[t].length, !a); t++);
                        if (oC.releasePrimitive(e), rC.clearBuffer(), s += i[u].length, a) break
                    }
                    return uC = !1, a
                }(this, e, t, r)
            }
            intersectsBox(e, t) {
                return hC.set(e.min, e.max, t), hC.needsUpdate = !0, this.shapecast({
                    intersectsBounds: e => hC.intersectsBox(e),
                    intersectsTriangle: e => hC.intersectsTriangle(e)
                })
            }
            intersectsSphere(e) {
                return this.shapecast({
                    intersectsBounds: t => e.intersectsBox(t),
                    intersectsTriangle: t => t.intersectsSphere(e)
                })
            }
            closestPointToGeometry(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
                    i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
                    o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1 / 0;
                return (this.indirect ? nC : IE)(this, e, t, n, r, i, o)
            }
            closestPointToPoint(e) {
                return function(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                        r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                        i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1 / 0;
                    const o = r * r,
                        a = i * i;
                    let s = 1 / 0,
                        l = null;
                    if (e.shapecast({
                            boundsTraverseOrder: e => (VS.copy(t).clamp(e.min, e.max), VS.distanceToSquared(t)),
                            intersectsBounds: (e, t, n) => n < s && n < a,
                            intersectsTriangle: (e, n) => {
                                e.closestPointToPoint(t, VS);
                                const r = t.distanceToSquared(VS);
                                return r < s && (qS.copy(VS), s = r, l = n), r < o
                            }
                        }), s === 1 / 0) return null;
                    const c = Math.sqrt(s);
                    return n.point ? n.point.copy(qS) : n.point = qS.clone(), n.distance = c, n.faceIndex = l, n
                }(this, e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1 / 0)
            }
            getBoundingBox(e) {
                e.makeEmpty();
                return this._roots.forEach((t => {
                    ZA(0, new Float32Array(t), pC), e.union(pC)
                })), e
            }
        }
        const gC = 1e-6;
        Math.pow(10, -Math.log10(gC));
        new Pu;
        new Pu, new Pu, new id;
        new Yc, new Pu, new xu;
        new Pu, new Pu, new Pu;
        new d_, new d_, new Pu, new Pu, new Pu, new ap, new OS;
        new id, new od, new Hd, new Pu, new xu, new xu, new xu, new xu, new xu, new xu, new d_, new Pu;
        new od, new Qc, new Hd, new Hd, new Hd, new Hd;

        function vC(e, t) {
            if (t === Ll) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), e;
            if (t === Nl || t === Dl) {
                let n = e.getIndex();
                if (null === n) {
                    const t = [],
                        r = e.getAttribute("position");
                    if (void 0 === r) return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e;
                    for (let e = 0; e < r.count; e++) t.push(e);
                    e.setIndex(t), n = e.getIndex()
                }
                const r = n.count - 2,
                    i = [];
                if (t === Nl)
                    for (let e = 1; e <= r; e++) i.push(n.getX(0)), i.push(n.getX(e)), i.push(n.getX(e + 1));
                else
                    for (let e = 0; e < r; e++) e % 2 === 0 ? (i.push(n.getX(e)), i.push(n.getX(e + 1)), i.push(n.getX(e + 2))) : (i.push(n.getX(e + 2)), i.push(n.getX(e + 1)), i.push(n.getX(e)));
                i.length / 3 !== r && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                const o = e.clone();
                return o.setIndex(i), o.clearGroups(), o
            }
            return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t), e
        }
        class yC extends Lb {
            constructor(e) {
                super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function(e) {
                    return new AC(e)
                })), this.register((function(e) {
                    return new BC(e)
                })), this.register((function(e) {
                    return new LC(e)
                })), this.register((function(e) {
                    return new DC(e)
                })), this.register((function(e) {
                    return new EC(e)
                })), this.register((function(e) {
                    return new CC(e)
                })), this.register((function(e) {
                    return new TC(e)
                })), this.register((function(e) {
                    return new PC(e)
                })), this.register((function(e) {
                    return new wC(e)
                })), this.register((function(e) {
                    return new RC(e)
                })), this.register((function(e) {
                    return new SC(e)
                })), this.register((function(e) {
                    return new OC(e)
                })), this.register((function(e) {
                    return new IC(e)
                })), this.register((function(e) {
                    return new _C(e)
                })), this.register((function(e) {
                    return new NC(e)
                })), this.register((function(e) {
                    return new kC(e)
                }))
            }
            load(e, t, n, r) {
                const i = this;
                let o;
                if ("" !== this.resourcePath) o = this.resourcePath;
                else if ("" !== this.path) {
                    const t = ux.extractUrlBase(e);
                    o = ux.resolveURL(t, this.path)
                } else o = ux.extractUrlBase(e);
                this.manager.itemStart(e);
                const a = function(t) {
                        r ? r(t) : console.error(t), i.manager.itemError(e), i.manager.itemEnd(e)
                    },
                    s = new kb(this.manager);
                s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (function(n) {
                    try {
                        i.parse(n, o, (function(n) {
                            t(n), i.manager.itemEnd(e)
                        }), a)
                    } catch (ER) {
                        a(ER)
                    }
                }), n, a)
            }
            setDRACOLoader(e) {
                return this.dracoLoader = e, this
            }
            setDDSLoader() {
                throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
            }
            setKTX2Loader(e) {
                return this.ktx2Loader = e, this
            }
            setMeshoptDecoder(e) {
                return this.meshoptDecoder = e, this
            }
            register(e) {
                return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this
            }
            unregister(e) {
                return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
            }
            parse(e, t, n, r) {
                let i;
                const o = {},
                    a = {},
                    s = new TextDecoder;
                if ("string" === typeof e) i = JSON.parse(e);
                else if (e instanceof ArrayBuffer) {
                    if (s.decode(new Uint8Array(e, 0, 4)) === FC) {
                        try {
                            o[xC.KHR_BINARY_GLTF] = new HC(e)
                        } catch (c) {
                            return void(r && r(c))
                        }
                        i = JSON.parse(o[xC.KHR_BINARY_GLTF].content)
                    } else i = JSON.parse(s.decode(e))
                } else i = e;
                if (void 0 === i.asset || i.asset.version[0] < 2) return void(r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                const l = new pT(i, {
                    path: t || this.resourcePath || "",
                    crossOrigin: this.crossOrigin,
                    requestHeader: this.requestHeader,
                    manager: this.manager,
                    ktx2Loader: this.ktx2Loader,
                    meshoptDecoder: this.meshoptDecoder
                });
                l.fileLoader.setRequestHeader(this.requestHeader);
                for (let u = 0; u < this.pluginCallbacks.length; u++) {
                    const e = this.pluginCallbacks[u](l);
                    e.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), a[e.name] = e, o[e.name] = !0
                }
                if (i.extensionsUsed)
                    for (let u = 0; u < i.extensionsUsed.length; ++u) {
                        const e = i.extensionsUsed[u],
                            t = i.extensionsRequired || [];
                        switch (e) {
                            case xC.KHR_MATERIALS_UNLIT:
                                o[e] = new MC;
                                break;
                            case xC.KHR_DRACO_MESH_COMPRESSION:
                                o[e] = new jC(i, this.dracoLoader);
                                break;
                            case xC.KHR_TEXTURE_TRANSFORM:
                                o[e] = new GC;
                                break;
                            case xC.KHR_MESH_QUANTIZATION:
                                o[e] = new VC;
                                break;
                            default:
                                t.indexOf(e) >= 0 && void 0 === a[e] && console.warn('THREE.GLTFLoader: Unknown extension "' + e + '".')
                        }
                    }
                l.setExtensions(o), l.setPlugins(a), l.parse(n, r)
            }
            parseAsync(e, t) {
                const n = this;
                return new Promise((function(r, i) {
                    n.parse(e, t, r, i)
                }))
            }
        }

        function bC() {
            let e = {};
            return {
                get: function(t) {
                    return e[t]
                },
                add: function(t, n) {
                    e[t] = n
                },
                remove: function(t) {
                    delete e[t]
                },
                removeAll: function() {
                    e = {}
                }
            }
        }
        const xC = {
            KHR_BINARY_GLTF: "KHR_binary_glTF",
            KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
            KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
            KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
            KHR_MATERIALS_IOR: "KHR_materials_ior",
            KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
            KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
            KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
            KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
            KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
            KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
            KHR_MATERIALS_VOLUME: "KHR_materials_volume",
            KHR_TEXTURE_BASISU: "KHR_texture_basisu",
            KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
            KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
            KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
            EXT_MATERIALS_BUMP: "EXT_materials_bump",
            EXT_TEXTURE_WEBP: "EXT_texture_webp",
            EXT_TEXTURE_AVIF: "EXT_texture_avif",
            EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
            EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
        };
        class _C {
            constructor(e) {
                this.parser = e, this.name = xC.KHR_LIGHTS_PUNCTUAL, this.cache = {
                    refs: {},
                    uses: {}
                }
            }
            _markDefs() {
                const e = this.parser,
                    t = this.parser.json.nodes || [];
                for (let n = 0, r = t.length; n < r; n++) {
                    const r = t[n];
                    r.extensions && r.extensions[this.name] && void 0 !== r.extensions[this.name].light && e._addNodeRef(this.cache, r.extensions[this.name].light)
                }
            }
            _loadLight(e) {
                const t = this.parser,
                    n = "light:" + e;
                let r = t.cache.get(n);
                if (r) return r;
                const i = t.json,
                    o = ((i.extensions && i.extensions[this.name] || {}).lights || [])[e];
                let a;
                const s = new Wd(16777215);
                void 0 !== o.color && s.setRGB(o.color[0], o.color[1], o.color[2], ql);
                const l = void 0 !== o.range ? o.range : 0;
                switch (o.type) {
                    case "directional":
                        a = new ix(s), a.target.position.set(0, 0, -1), a.add(a.target);
                        break;
                    case "point":
                        a = new nx(s), a.distance = l;
                        break;
                    case "spot":
                        a = new Qb(s), a.distance = l, o.spot = o.spot || {}, o.spot.innerConeAngle = void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0, o.spot.outerConeAngle = void 0 !== o.spot.outerConeAngle ? o.spot.outerConeAngle : Math.PI / 4, a.angle = o.spot.outerConeAngle, a.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle, a.target.position.set(0, 0, -1), a.add(a.target);
                        break;
                    default:
                        throw new Error("THREE.GLTFLoader: Unexpected light type: " + o.type)
                }
                return a.position.set(0, 0, 0), a.decay = 2, sT(a, o), void 0 !== o.intensity && (a.intensity = o.intensity), a.name = t.createUniqueName(o.name || "light_" + e), r = Promise.resolve(a), t.cache.add(n, r), r
            }
            getDependency(e, t) {
                if ("light" === e) return this._loadLight(t)
            }
            createNodeAttachment(e) {
                const t = this,
                    n = this.parser,
                    r = n.json.nodes[e],
                    i = (r.extensions && r.extensions[this.name] || {}).light;
                return void 0 === i ? null : this._loadLight(i).then((function(e) {
                    return n._getNodeRef(t.cache, i, e)
                }))
            }
        }
        class MC {
            constructor() {
                this.name = xC.KHR_MATERIALS_UNLIT
            }
            getMaterialType() {
                return Yd
            }
            extendParams(e, t, n) {
                const r = [];
                e.color = new Wd(1, 1, 1), e.opacity = 1;
                const i = t.pbrMetallicRoughness;
                if (i) {
                    if (Array.isArray(i.baseColorFactor)) {
                        const t = i.baseColorFactor;
                        e.color.setRGB(t[0], t[1], t[2], ql), e.opacity = t[3]
                    }
                    void 0 !== i.baseColorTexture && r.push(n.assignTexture(e, "map", i.baseColorTexture, Vl))
                }
                return Promise.all(r)
            }
        }
        class wC {
            constructor(e) {
                this.parser = e, this.name = xC.KHR_MATERIALS_EMISSIVE_STRENGTH
            }
            extendMaterialParams(e, t) {
                const n = this.parser.json.materials[e];
                if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                const r = n.extensions[this.name].emissiveStrength;
                return void 0 !== r && (t.emissiveIntensity = r), Promise.resolve()
            }
        }
        class AC {
            constructor(e) {
                this.parser = e, this.name = xC.KHR_MATERIALS_CLEARCOAT
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ib : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                const i = [],
                    o = r.extensions[this.name];
                if (void 0 !== o.clearcoatFactor && (t.clearcoat = o.clearcoatFactor), void 0 !== o.clearcoatTexture && i.push(n.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), void 0 !== o.clearcoatRoughnessFactor && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), void 0 !== o.clearcoatRoughnessTexture && i.push(n.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), void 0 !== o.clearcoatNormalTexture && (i.push(n.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), void 0 !== o.clearcoatNormalTexture.scale)) {
                    const e = o.clearcoatNormalTexture.scale;
                    t.clearcoatNormalScale = new Yc(e, e)
                }
                return Promise.all(i)
            }
        }
        class SC {
            constructor(e) {
                this.parser = e, this.name = xC.KHR_MATERIALS_IRIDESCENCE
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ib : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                const i = [],
                    o = r.extensions[this.name];
                return void 0 !== o.iridescenceFactor && (t.iridescence = o.iridescenceFactor), void 0 !== o.iridescenceTexture && i.push(n.assignTexture(t, "iridescenceMap", o.iridescenceTexture)), void 0 !== o.iridescenceIor && (t.iridescenceIOR = o.iridescenceIor), void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]), void 0 !== o.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), void 0 !== o.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), void 0 !== o.iridescenceThicknessTexture && i.push(n.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)), Promise.all(i)
            }
        }
        class EC {
            constructor(e) {
                this.parser = e, this.name = xC.KHR_MATERIALS_SHEEN
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ib : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                const i = [];
                t.sheenColor = new Wd(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
                const o = r.extensions[this.name];
                if (void 0 !== o.sheenColorFactor) {
                    const e = o.sheenColorFactor;
                    t.sheenColor.setRGB(e[0], e[1], e[2], ql)
                }
                return void 0 !== o.sheenRoughnessFactor && (t.sheenRoughness = o.sheenRoughnessFactor), void 0 !== o.sheenColorTexture && i.push(n.assignTexture(t, "sheenColorMap", o.sheenColorTexture, Vl)), void 0 !== o.sheenRoughnessTexture && i.push(n.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(i)
            }
        }
        class CC {
            constructor(e) {
                this.parser = e, this.name = xC.KHR_MATERIALS_TRANSMISSION
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ib : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                const i = [],
                    o = r.extensions[this.name];
                return void 0 !== o.transmissionFactor && (t.transmission = o.transmissionFactor), void 0 !== o.transmissionTexture && i.push(n.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(i)
            }
        }
        class TC {
            constructor(e) {
                this.parser = e, this.name = xC.KHR_MATERIALS_VOLUME
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ib : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                const i = [],
                    o = r.extensions[this.name];
                t.thickness = void 0 !== o.thicknessFactor ? o.thicknessFactor : 0, void 0 !== o.thicknessTexture && i.push(n.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0;
                const a = o.attenuationColor || [1, 1, 1];
                return t.attenuationColor = (new Wd).setRGB(a[0], a[1], a[2], ql), Promise.all(i)
            }
        }
        class PC {
            constructor(e) {
                this.parser = e, this.name = xC.KHR_MATERIALS_IOR
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ib : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser.json.materials[e];
                if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                const r = n.extensions[this.name];
                return t.ior = void 0 !== r.ior ? r.ior : 1.5, Promise.resolve()
            }
        }
        class RC {
            constructor(e) {
                this.parser = e, this.name = xC.KHR_MATERIALS_SPECULAR
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ib : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                const i = [],
                    o = r.extensions[this.name];
                t.specularIntensity = void 0 !== o.specularFactor ? o.specularFactor : 1, void 0 !== o.specularTexture && i.push(n.assignTexture(t, "specularIntensityMap", o.specularTexture));
                const a = o.specularColorFactor || [1, 1, 1];
                return t.specularColor = (new Wd).setRGB(a[0], a[1], a[2], ql), void 0 !== o.specularColorTexture && i.push(n.assignTexture(t, "specularColorMap", o.specularColorTexture, Vl)), Promise.all(i)
            }
        }
        class IC {
            constructor(e) {
                this.parser = e, this.name = xC.EXT_MATERIALS_BUMP
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ib : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                const i = [],
                    o = r.extensions[this.name];
                return t.bumpScale = void 0 !== o.bumpFactor ? o.bumpFactor : 1, void 0 !== o.bumpTexture && i.push(n.assignTexture(t, "bumpMap", o.bumpTexture)), Promise.all(i)
            }
        }
        class OC {
            constructor(e) {
                this.parser = e, this.name = xC.KHR_MATERIALS_ANISOTROPY
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ib : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                const i = [],
                    o = r.extensions[this.name];
                return void 0 !== o.anisotropyStrength && (t.anisotropy = o.anisotropyStrength), void 0 !== o.anisotropyRotation && (t.anisotropyRotation = o.anisotropyRotation), void 0 !== o.anisotropyTexture && i.push(n.assignTexture(t, "anisotropyMap", o.anisotropyTexture)), Promise.all(i)
            }
        }
        class BC {
            constructor(e) {
                this.parser = e, this.name = xC.KHR_TEXTURE_BASISU
            }
            loadTexture(e) {
                const t = this.parser,
                    n = t.json,
                    r = n.textures[e];
                if (!r.extensions || !r.extensions[this.name]) return null;
                const i = r.extensions[this.name],
                    o = t.options.ktx2Loader;
                if (!o) {
                    if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                    return null
                }
                return t.loadTextureImage(e, i.source, o)
            }
        }
        class LC {
            constructor(e) {
                this.parser = e, this.name = xC.EXT_TEXTURE_WEBP, this.isSupported = null
            }
            loadTexture(e) {
                const t = this.name,
                    n = this.parser,
                    r = n.json,
                    i = r.textures[e];
                if (!i.extensions || !i.extensions[t]) return null;
                const o = i.extensions[t],
                    a = r.images[o.source];
                let s = n.textureLoader;
                if (a.uri) {
                    const e = n.options.manager.getHandler(a.uri);
                    null !== e && (s = e)
                }
                return this.detectSupport().then((function(i) {
                    if (i) return n.loadTextureImage(e, o.source, s);
                    if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                    return n.loadTexture(e)
                }))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function(e) {
                    const t = new Image;
                    t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
                        e(1 === t.height)
                    }
                }))), this.isSupported
            }
        }
        class DC {
            constructor(e) {
                this.parser = e, this.name = xC.EXT_TEXTURE_AVIF, this.isSupported = null
            }
            loadTexture(e) {
                const t = this.name,
                    n = this.parser,
                    r = n.json,
                    i = r.textures[e];
                if (!i.extensions || !i.extensions[t]) return null;
                const o = i.extensions[t],
                    a = r.images[o.source];
                let s = n.textureLoader;
                if (a.uri) {
                    const e = n.options.manager.getHandler(a.uri);
                    null !== e && (s = e)
                }
                return this.detectSupport().then((function(i) {
                    if (i) return n.loadTextureImage(e, o.source, s);
                    if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
                    return n.loadTexture(e)
                }))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function(e) {
                    const t = new Image;
                    t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
                        e(1 === t.height)
                    }
                }))), this.isSupported
            }
        }
        class NC {
            constructor(e) {
                this.name = xC.EXT_MESHOPT_COMPRESSION, this.parser = e
            }
            loadBufferView(e) {
                const t = this.parser.json,
                    n = t.bufferViews[e];
                if (n.extensions && n.extensions[this.name]) {
                    const e = n.extensions[this.name],
                        r = this.parser.getDependency("buffer", e.buffer),
                        i = this.parser.options.meshoptDecoder;
                    if (!i || !i.supported) {
                        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                        return null
                    }
                    return r.then((function(t) {
                        const n = e.byteOffset || 0,
                            r = e.byteLength || 0,
                            o = e.count,
                            a = e.byteStride,
                            s = new Uint8Array(t, n, r);
                        return i.decodeGltfBufferAsync ? i.decodeGltfBufferAsync(o, a, s, e.mode, e.filter).then((function(e) {
                            return e.buffer
                        })) : i.ready.then((function() {
                            const t = new ArrayBuffer(o * a);
                            return i.decodeGltfBuffer(new Uint8Array(t), o, a, s, e.mode, e.filter), t
                        }))
                    }))
                }
                return null
            }
        }
        class kC {
            constructor(e) {
                this.name = xC.EXT_MESH_GPU_INSTANCING, this.parser = e
            }
            createNodeMesh(e) {
                const t = this.parser.json,
                    n = t.nodes[e];
                if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh) return null;
                const r = t.meshes[n.mesh];
                for (const s of r.primitives)
                    if (s.mode !== KC.TRIANGLES && s.mode !== KC.TRIANGLE_STRIP && s.mode !== KC.TRIANGLE_FAN && void 0 !== s.mode) return null;
                const i = n.extensions[this.name].attributes,
                    o = [],
                    a = {};
                for (const s in i) o.push(this.parser.getDependency("accessor", i[s]).then((e => (a[s] = e, a[s]))));
                return o.length < 1 ? null : (o.push(this.parser.createNodeMesh(e)), Promise.all(o).then((e => {
                    const t = e.pop(),
                        n = t.isGroup ? t.children : [t],
                        r = e[0].count,
                        i = [];
                    for (const o of n) {
                        const e = new od,
                            t = new Pu,
                            n = new Tu,
                            s = new Pu(1, 1, 1),
                            l = new Vg(o.geometry, o.material, r);
                        for (let i = 0; i < r; i++) a.TRANSLATION && t.fromBufferAttribute(a.TRANSLATION, i), a.ROTATION && n.fromBufferAttribute(a.ROTATION, i), a.SCALE && s.fromBufferAttribute(a.SCALE, i), l.setMatrixAt(i, e.compose(t, n, s));
                        for (const r in a)
                            if ("_COLOR_0" === r) {
                                const e = a[r];
                                l.instanceColor = new Ng(e.array, e.itemSize, e.normalized)
                            } else "TRANSLATION" !== r && "ROTATION" !== r && "SCALE" !== r && o.geometry.setAttribute(r, a[r]);
                        Rd.prototype.copy.call(l, o), this.parser.assignFinalMaterial(l), i.push(l)
                    }
                    return t.isGroup ? (t.clear(), t.add(...i), t) : i[0]
                })))
            }
        }
        const FC = "glTF",
            UC = 1313821514,
            zC = 5130562;
        class HC {
            constructor(e) {
                this.name = xC.KHR_BINARY_GLTF, this.content = null, this.body = null;
                const t = new DataView(e, 0, 12),
                    n = new TextDecoder;
                if (this.header = {
                        magic: n.decode(new Uint8Array(e.slice(0, 4))),
                        version: t.getUint32(4, !0),
                        length: t.getUint32(8, !0)
                    }, this.header.magic !== FC) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                const r = this.header.length - 12,
                    i = new DataView(e, 12);
                let o = 0;
                for (; o < r;) {
                    const t = i.getUint32(o, !0);
                    o += 4;
                    const r = i.getUint32(o, !0);
                    if (o += 4, r === UC) {
                        const r = new Uint8Array(e, 12 + o, t);
                        this.content = n.decode(r)
                    } else if (r === zC) {
                        const n = 12 + o;
                        this.body = e.slice(n, n + t)
                    }
                    o += t
                }
                if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
            }
        }
        class jC {
            constructor(e, t) {
                if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                this.name = xC.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload()
            }
            decodePrimitive(e, t) {
                const n = this.json,
                    r = this.dracoLoader,
                    i = e.extensions[this.name].bufferView,
                    o = e.extensions[this.name].attributes,
                    a = {},
                    s = {},
                    l = {};
                for (const c in o) {
                    const e = $C[c] || c.toLowerCase();
                    a[e] = o[c]
                }
                for (const c in e.attributes) {
                    const t = $C[c] || c.toLowerCase();
                    if (void 0 !== o[c]) {
                        const r = n.accessors[e.attributes[c]],
                            i = JC[r.componentType];
                        l[t] = i.name, s[t] = !0 === r.normalized
                    }
                }
                return t.getDependency("bufferView", i).then((function(e) {
                    return new Promise((function(t, n) {
                        r.decodeDracoFile(e, (function(e) {
                            for (const t in e.attributes) {
                                const n = e.attributes[t],
                                    r = s[t];
                                void 0 !== r && (n.normalized = r)
                            }
                            t(e)
                        }), a, l, ql, n)
                    }))
                }))
            }
        }
        class GC {
            constructor() {
                this.name = xC.KHR_TEXTURE_TRANSFORM
            }
            extendTexture(e, t) {
                return void 0 !== t.texCoord && t.texCoord !== e.channel || void 0 !== t.offset || void 0 !== t.rotation || void 0 !== t.scale ? (e = e.clone(), void 0 !== t.texCoord && (e.channel = t.texCoord), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0, e) : e
            }
        }
        class VC {
            constructor() {
                this.name = xC.KHR_MESH_QUANTIZATION
            }
        }
        class qC extends vb {
            constructor(e, t, n, r) {
                super(e, t, n, r)
            }
            copySampleValue_(e) {
                const t = this.resultBuffer,
                    n = this.sampleValues,
                    r = this.valueSize,
                    i = e * r * 3 + r;
                for (let o = 0; o !== r; o++) t[o] = n[i + o];
                return t
            }
            interpolate_(e, t, n, r) {
                const i = this.resultBuffer,
                    o = this.sampleValues,
                    a = this.valueSize,
                    s = 2 * a,
                    l = 3 * a,
                    c = r - t,
                    u = (n - t) / c,
                    d = u * u,
                    h = d * u,
                    p = e * l,
                    f = p - l,
                    m = -2 * h + 3 * d,
                    g = h - d,
                    v = 1 - m,
                    y = g - d + u;
                for (let b = 0; b !== a; b++) {
                    const e = o[f + b + a],
                        t = o[f + b + s] * c,
                        n = o[p + b + a],
                        r = o[p + b] * c;
                    i[b] = v * e + y * t + m * n + g * r
                }
                return i
            }
        }
        const WC = new Tu;
        class XC extends qC {
            interpolate_(e, t, n, r) {
                const i = super.interpolate_(e, t, n, r);
                return WC.fromArray(i).normalize().toArray(i), i
            }
        }
        const KC = {
                FLOAT: 5126,
                FLOAT_MAT3: 35675,
                FLOAT_MAT4: 35676,
                FLOAT_VEC2: 35664,
                FLOAT_VEC3: 35665,
                FLOAT_VEC4: 35666,
                LINEAR: 9729,
                REPEAT: 10497,
                SAMPLER_2D: 35678,
                POINTS: 0,
                LINES: 1,
                LINE_LOOP: 2,
                LINE_STRIP: 3,
                TRIANGLES: 4,
                TRIANGLE_STRIP: 5,
                TRIANGLE_FAN: 6,
                UNSIGNED_BYTE: 5121,
                UNSIGNED_SHORT: 5123
            },
            JC = {
                5120: Int8Array,
                5121: Uint8Array,
                5122: Int16Array,
                5123: Uint16Array,
                5125: Uint32Array,
                5126: Float32Array
            },
            YC = {
                9728: ps,
                9729: ys,
                9984: fs,
                9985: bs,
                9986: gs,
                9987: _s
            },
            QC = {
                33071: ds,
                33648: hs,
                10497: us
            },
            ZC = {
                SCALAR: 1,
                VEC2: 2,
                VEC3: 3,
                VEC4: 4,
                MAT2: 4,
                MAT3: 9,
                MAT4: 16
            },
            $C = {
                POSITION: "position",
                NORMAL: "normal",
                TANGENT: "tangent",
                TEXCOORD_0: "uv",
                TEXCOORD_1: "uv1",
                TEXCOORD_2: "uv2",
                TEXCOORD_3: "uv3",
                COLOR_0: "color",
                WEIGHTS_0: "skinWeight",
                JOINTS_0: "skinIndex"
            },
            eT = {
                scale: "scale",
                translation: "position",
                rotation: "quaternion",
                weights: "morphTargetInfluences"
            },
            tT = {
                CUBICSPLINE: void 0,
                LINEAR: Cl,
                STEP: El
            },
            nT = "OPAQUE",
            rT = "MASK",
            iT = "BLEND";

        function oT(e) {
            return void 0 === e.DefaultMaterial && (e.DefaultMaterial = new rb({
                color: 16777215,
                emissive: 0,
                metalness: 1,
                roughness: 1,
                transparent: !1,
                depthTest: !0,
                side: ca
            })), e.DefaultMaterial
        }

        function aT(e, t, n) {
            for (const r in n.extensions) void 0 === e[r] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[r] = n.extensions[r])
        }

        function sT(e, t) {
            void 0 !== t.extras && ("object" === typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
        }

        function lT(e, t) {
            if (e.updateMorphTargets(), void 0 !== t.weights)
                for (let n = 0, r = t.weights.length; n < r; n++) e.morphTargetInfluences[n] = t.weights[n];
            if (t.extras && Array.isArray(t.extras.targetNames)) {
                const n = t.extras.targetNames;
                if (e.morphTargetInfluences.length === n.length) {
                    e.morphTargetDictionary = {};
                    for (let t = 0, r = n.length; t < r; t++) e.morphTargetDictionary[n[t]] = t
                } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
            }
        }

        function cT(e) {
            let t;
            const n = e.extensions && e.extensions[xC.KHR_DRACO_MESH_COMPRESSION];
            if (t = n ? "draco:" + n.bufferView + ":" + n.indices + ":" + uT(n.attributes) : e.indices + ":" + uT(e.attributes) + ":" + e.mode, void 0 !== e.targets)
                for (let r = 0, i = e.targets.length; r < i; r++) t += ":" + uT(e.targets[r]);
            return t
        }

        function uT(e) {
            let t = "";
            const n = Object.keys(e).sort();
            for (let r = 0, i = n.length; r < i; r++) t += n[r] + ":" + e[n[r]] + ";";
            return t
        }

        function dT(e) {
            switch (e) {
                case Int8Array:
                    return 1 / 127;
                case Uint8Array:
                    return 1 / 255;
                case Int16Array:
                    return 1 / 32767;
                case Uint16Array:
                    return 1 / 65535;
                default:
                    throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
            }
        }
        const hT = new od;
        class pT {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new bC, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
                    refs: {},
                    uses: {}
                }, this.cameraCache = {
                    refs: {},
                    uses: {}
                }, this.lightCache = {
                    refs: {},
                    uses: {}
                }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
                let n = !1,
                    r = !1,
                    i = -1;
                "undefined" !== typeof navigator && (n = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent), r = navigator.userAgent.indexOf("Firefox") > -1, i = r ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), "undefined" === typeof createImageBitmap || n || r && i < 98 ? this.textureLoader = new Gb(this.options.manager) : this.textureLoader = new vx(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new kb(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
            }
            setExtensions(e) {
                this.extensions = e
            }
            setPlugins(e) {
                this.plugins = e
            }
            parse(e, t) {
                const n = this,
                    r = this.json,
                    i = this.extensions;
                this.cache.removeAll(), this.nodeCache = {}, this._invokeAll((function(e) {
                    return e._markDefs && e._markDefs()
                })), Promise.all(this._invokeAll((function(e) {
                    return e.beforeRoot && e.beforeRoot()
                }))).then((function() {
                    return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                })).then((function(t) {
                    const o = {
                        scene: t[0][r.scene || 0],
                        scenes: t[0],
                        animations: t[1],
                        cameras: t[2],
                        asset: r.asset,
                        parser: n,
                        userData: {}
                    };
                    return aT(i, o, r), sT(o, r), Promise.all(n._invokeAll((function(e) {
                        return e.afterRoot && e.afterRoot(o)
                    }))).then((function() {
                        e(o)
                    }))
                })).catch(t)
            }
            _markDefs() {
                const e = this.json.nodes || [],
                    t = this.json.skins || [],
                    n = this.json.meshes || [];
                for (let r = 0, i = t.length; r < i; r++) {
                    const n = t[r].joints;
                    for (let t = 0, r = n.length; t < r; t++) e[n[t]].isBone = !0
                }
                for (let r = 0, i = e.length; r < i; r++) {
                    const t = e[r];
                    void 0 !== t.mesh && (this._addNodeRef(this.meshCache, t.mesh), void 0 !== t.skin && (n[t.mesh].isSkinnedMesh = !0)), void 0 !== t.camera && this._addNodeRef(this.cameraCache, t.camera)
                }
            }
            _addNodeRef(e, t) {
                void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
            }
            _getNodeRef(e, t, n) {
                if (e.refs[t] <= 1) return n;
                const r = n.clone(),
                    i = (e, t) => {
                        const n = this.associations.get(e);
                        null != n && this.associations.set(t, n);
                        for (const [r, o] of e.children.entries()) i(o, t.children[r])
                    };
                return i(n, r), r.name += "_instance_" + e.uses[t]++, r
            }
            _invokeOne(e) {
                const t = Object.values(this.plugins);
                t.push(this);
                for (let n = 0; n < t.length; n++) {
                    const r = e(t[n]);
                    if (r) return r
                }
                return null
            }
            _invokeAll(e) {
                const t = Object.values(this.plugins);
                t.unshift(this);
                const n = [];
                for (let r = 0; r < t.length; r++) {
                    const i = e(t[r]);
                    i && n.push(i)
                }
                return n
            }
            getDependency(e, t) {
                const n = e + ":" + t;
                let r = this.cache.get(n);
                if (!r) {
                    switch (e) {
                        case "scene":
                            r = this.loadScene(t);
                            break;
                        case "node":
                            r = this._invokeOne((function(e) {
                                return e.loadNode && e.loadNode(t)
                            }));
                            break;
                        case "mesh":
                            r = this._invokeOne((function(e) {
                                return e.loadMesh && e.loadMesh(t)
                            }));
                            break;
                        case "accessor":
                            r = this.loadAccessor(t);
                            break;
                        case "bufferView":
                            r = this._invokeOne((function(e) {
                                return e.loadBufferView && e.loadBufferView(t)
                            }));
                            break;
                        case "buffer":
                            r = this.loadBuffer(t);
                            break;
                        case "material":
                            r = this._invokeOne((function(e) {
                                return e.loadMaterial && e.loadMaterial(t)
                            }));
                            break;
                        case "texture":
                            r = this._invokeOne((function(e) {
                                return e.loadTexture && e.loadTexture(t)
                            }));
                            break;
                        case "skin":
                            r = this.loadSkin(t);
                            break;
                        case "animation":
                            r = this._invokeOne((function(e) {
                                return e.loadAnimation && e.loadAnimation(t)
                            }));
                            break;
                        case "camera":
                            r = this.loadCamera(t);
                            break;
                        default:
                            if (r = this._invokeOne((function(n) {
                                    return n != this && n.getDependency && n.getDependency(e, t)
                                })), !r) throw new Error("Unknown type: " + e)
                    }
                    this.cache.add(n, r)
                }
                return r
            }
            getDependencies(e) {
                let t = this.cache.get(e);
                if (!t) {
                    const n = this,
                        r = this.json[e + ("mesh" === e ? "es" : "s")] || [];
                    t = Promise.all(r.map((function(t, r) {
                        return n.getDependency(e, r)
                    }))), this.cache.add(e, t)
                }
                return t
            }
            loadBuffer(e) {
                const t = this.json.buffers[e],
                    n = this.fileLoader;
                if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
                if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[xC.KHR_BINARY_GLTF].body);
                const r = this.options;
                return new Promise((function(e, i) {
                    n.load(ux.resolveURL(t.uri, r.path), e, void 0, (function() {
                        i(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                    }))
                }))
            }
            loadBufferView(e) {
                const t = this.json.bufferViews[e];
                return this.getDependency("buffer", t.buffer).then((function(e) {
                    const n = t.byteLength || 0,
                        r = t.byteOffset || 0;
                    return e.slice(r, r + n)
                }))
            }
            loadAccessor(e) {
                const t = this,
                    n = this.json,
                    r = this.json.accessors[e];
                if (void 0 === r.bufferView && void 0 === r.sparse) {
                    const e = ZC[r.type],
                        t = JC[r.componentType],
                        n = !0 === r.normalized,
                        i = new t(r.count * e);
                    return Promise.resolve(new ih(i, e, n))
                }
                const i = [];
                return void 0 !== r.bufferView ? i.push(this.getDependency("bufferView", r.bufferView)) : i.push(null), void 0 !== r.sparse && (i.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), i.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(i).then((function(e) {
                    const i = e[0],
                        o = ZC[r.type],
                        a = JC[r.componentType],
                        s = a.BYTES_PER_ELEMENT,
                        l = s * o,
                        c = r.byteOffset || 0,
                        u = void 0 !== r.bufferView ? n.bufferViews[r.bufferView].byteStride : void 0,
                        d = !0 === r.normalized;
                    let h, p;
                    if (u && u !== l) {
                        const e = Math.floor(c / u),
                            n = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + e + ":" + r.count;
                        let l = t.cache.get(n);
                        l || (h = new a(i, e * u, r.count * u / s), l = new $m(h, u / s), t.cache.add(n, l)), p = new tg(l, o, c % u / s, d)
                    } else h = null === i ? new a(r.count * o) : new a(i, c, r.count * o), p = new ih(h, o, d);
                    if (void 0 !== r.sparse) {
                        const t = ZC.SCALAR,
                            n = JC[r.sparse.indices.componentType],
                            s = r.sparse.indices.byteOffset || 0,
                            l = r.sparse.values.byteOffset || 0,
                            c = new n(e[1], s, r.sparse.count * t),
                            u = new a(e[2], l, r.sparse.count * o);
                        null !== i && (p = new ih(p.array.slice(), p.itemSize, p.normalized));
                        for (let e = 0, r = c.length; e < r; e++) {
                            const t = c[e];
                            if (p.setX(t, u[e * o]), o >= 2 && p.setY(t, u[e * o + 1]), o >= 3 && p.setZ(t, u[e * o + 2]), o >= 4 && p.setW(t, u[e * o + 3]), o >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                        }
                    }
                    return p
                }))
            }
            loadTexture(e) {
                const t = this.json,
                    n = this.options,
                    r = t.textures[e].source,
                    i = t.images[r];
                let o = this.textureLoader;
                if (i.uri) {
                    const e = n.manager.getHandler(i.uri);
                    null !== e && (o = e)
                }
                return this.loadTextureImage(e, r, o)
            }
            loadTextureImage(e, t, n) {
                const r = this,
                    i = this.json,
                    o = i.textures[e],
                    a = i.images[t],
                    s = (a.uri || a.bufferView) + ":" + o.sampler;
                if (this.textureCache[s]) return this.textureCache[s];
                const l = this.loadImageSource(t, n).then((function(t) {
                    t.flipY = !1, t.name = o.name || a.name || "", "" === t.name && "string" === typeof a.uri && !1 === a.uri.startsWith("data:image/") && (t.name = a.uri);
                    const n = (i.samplers || {})[o.sampler] || {};
                    return t.magFilter = YC[n.magFilter] || ys, t.minFilter = YC[n.minFilter] || _s, t.wrapS = QC[n.wrapS] || us, t.wrapT = QC[n.wrapT] || us, r.associations.set(t, {
                        textures: e
                    }), t
                })).catch((function() {
                    return null
                }));
                return this.textureCache[s] = l, l
            }
            loadImageSource(e, t) {
                const n = this,
                    r = this.json,
                    i = this.options;
                if (void 0 !== this.sourceCache[e]) return this.sourceCache[e].then((e => e.clone()));
                const o = r.images[e],
                    a = self.URL || self.webkitURL;
                let s = o.uri || "",
                    l = !1;
                if (void 0 !== o.bufferView) s = n.getDependency("bufferView", o.bufferView).then((function(e) {
                    l = !0;
                    const t = new Blob([e], {
                        type: o.mimeType
                    });
                    return s = a.createObjectURL(t), s
                }));
                else if (void 0 === o.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
                const c = Promise.resolve(s).then((function(e) {
                    return new Promise((function(n, r) {
                        let o = n;
                        !0 === t.isImageBitmapLoader && (o = function(e) {
                            const t = new bu(e);
                            t.needsUpdate = !0, n(t)
                        }), t.load(ux.resolveURL(e, i.path), o, void 0, r)
                    }))
                })).then((function(e) {
                    var t;
                    return !0 === l && a.revokeObjectURL(s), e.userData.mimeType = o.mimeType || ((t = o.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), e
                })).catch((function(e) {
                    throw console.error("THREE.GLTFLoader: Couldn't load texture", s), e
                }));
                return this.sourceCache[e] = c, c
            }
            assignTexture(e, t, n, r) {
                const i = this;
                return this.getDependency("texture", n.index).then((function(o) {
                    if (!o) return null;
                    if (void 0 !== n.texCoord && n.texCoord > 0 && ((o = o.clone()).channel = n.texCoord), i.extensions[xC.KHR_TEXTURE_TRANSFORM]) {
                        const e = void 0 !== n.extensions ? n.extensions[xC.KHR_TEXTURE_TRANSFORM] : void 0;
                        if (e) {
                            const t = i.associations.get(o);
                            o = i.extensions[xC.KHR_TEXTURE_TRANSFORM].extendTexture(o, e), i.associations.set(o, t)
                        }
                    }
                    return void 0 !== r && (o.colorSpace = r), e[t] = o, o
                }))
            }
            assignFinalMaterial(e) {
                const t = e.geometry;
                let n = e.material;
                const r = void 0 === t.attributes.tangent,
                    i = void 0 !== t.attributes.color,
                    o = void 0 === t.attributes.normal;
                if (e.isPoints) {
                    const e = "PointsMaterial:" + n.uuid;
                    let t = this.cache.get(e);
                    t || (t = new bv, Jd.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, t.sizeAttenuation = !1, this.cache.add(e, t)), n = t
                } else if (e.isLine) {
                    const e = "LineBasicMaterial:" + n.uuid;
                    let t = this.cache.get(e);
                    t || (t = new lv, Jd.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, this.cache.add(e, t)), n = t
                }
                if (r || i || o) {
                    let e = "ClonedMaterial:" + n.uuid + ":";
                    r && (e += "derivative-tangents:"), i && (e += "vertex-colors:"), o && (e += "flat-shading:");
                    let t = this.cache.get(e);
                    t || (t = n.clone(), i && (t.vertexColors = !0), o && (t.flatShading = !0), r && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(n))), n = t
                }
                e.material = n
            }
            getMaterialType() {
                return rb
            }
            loadMaterial(e) {
                const t = this,
                    n = this.json,
                    r = this.extensions,
                    i = n.materials[e];
                let o;
                const a = {},
                    s = [];
                if ((i.extensions || {})[xC.KHR_MATERIALS_UNLIT]) {
                    const e = r[xC.KHR_MATERIALS_UNLIT];
                    o = e.getMaterialType(), s.push(e.extendParams(a, i, t))
                } else {
                    const n = i.pbrMetallicRoughness || {};
                    if (a.color = new Wd(1, 1, 1), a.opacity = 1, Array.isArray(n.baseColorFactor)) {
                        const e = n.baseColorFactor;
                        a.color.setRGB(e[0], e[1], e[2], ql), a.opacity = e[3]
                    }
                    void 0 !== n.baseColorTexture && s.push(t.assignTexture(a, "map", n.baseColorTexture, Vl)), a.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, a.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (s.push(t.assignTexture(a, "metalnessMap", n.metallicRoughnessTexture)), s.push(t.assignTexture(a, "roughnessMap", n.metallicRoughnessTexture))), o = this._invokeOne((function(t) {
                        return t.getMaterialType && t.getMaterialType(e)
                    })), s.push(Promise.all(this._invokeAll((function(t) {
                        return t.extendMaterialParams && t.extendMaterialParams(e, a)
                    }))))
                }!0 === i.doubleSided && (a.side = da);
                const l = i.alphaMode || nT;
                if (l === iT ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, l === rT && (a.alphaTest = void 0 !== i.alphaCutoff ? i.alphaCutoff : .5)), void 0 !== i.normalTexture && o !== Yd && (s.push(t.assignTexture(a, "normalMap", i.normalTexture)), a.normalScale = new Yc(1, 1), void 0 !== i.normalTexture.scale)) {
                    const e = i.normalTexture.scale;
                    a.normalScale.set(e, e)
                }
                if (void 0 !== i.occlusionTexture && o !== Yd && (s.push(t.assignTexture(a, "aoMap", i.occlusionTexture)), void 0 !== i.occlusionTexture.strength && (a.aoMapIntensity = i.occlusionTexture.strength)), void 0 !== i.emissiveFactor && o !== Yd) {
                    const e = i.emissiveFactor;
                    a.emissive = (new Wd).setRGB(e[0], e[1], e[2], ql)
                }
                return void 0 !== i.emissiveTexture && o !== Yd && s.push(t.assignTexture(a, "emissiveMap", i.emissiveTexture, Vl)), Promise.all(s).then((function() {
                    const n = new o(a);
                    return i.name && (n.name = i.name), sT(n, i), t.associations.set(n, {
                        materials: e
                    }), i.extensions && aT(r, n, i), n
                }))
            }
            createUniqueName(e) {
                const t = Wx.sanitizeNodeName(e || "");
                return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t)
            }
            loadGeometries(e) {
                const t = this,
                    n = this.extensions,
                    r = this.primitiveCache;

                function i(e) {
                    return n[xC.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function(n) {
                        return fT(n, e, t)
                    }))
                }
                const o = [];
                for (let a = 0, s = e.length; a < s; a++) {
                    const n = e[a],
                        s = cT(n),
                        l = r[s];
                    if (l) o.push(l.promise);
                    else {
                        let e;
                        e = n.extensions && n.extensions[xC.KHR_DRACO_MESH_COMPRESSION] ? i(n) : fT(new Mh, n, t), r[s] = {
                            primitive: n,
                            promise: e
                        }, o.push(e)
                    }
                }
                return Promise.all(o)
            }
            loadMesh(e) {
                const t = this,
                    n = this.json,
                    r = this.extensions,
                    i = n.meshes[e],
                    o = i.primitives,
                    a = [];
                for (let s = 0, l = o.length; s < l; s++) {
                    const e = void 0 === o[s].material ? oT(this.cache) : this.getDependency("material", o[s].material);
                    a.push(e)
                }
                return a.push(t.loadGeometries(o)), Promise.all(a).then((function(n) {
                    const a = n.slice(0, n.length - 1),
                        s = n[n.length - 1],
                        l = [];
                    for (let u = 0, d = s.length; u < d; u++) {
                        const n = s[u],
                            c = o[u];
                        let d;
                        const h = a[u];
                        if (c.mode === KC.TRIANGLES || c.mode === KC.TRIANGLE_STRIP || c.mode === KC.TRIANGLE_FAN || void 0 === c.mode) d = !0 === i.isSkinnedMesh ? new Rg(n, h) : new zh(n, h), !0 === d.isSkinnedMesh && d.normalizeSkinWeights(), c.mode === KC.TRIANGLE_STRIP ? d.geometry = vC(d.geometry, Dl) : c.mode === KC.TRIANGLE_FAN && (d.geometry = vC(d.geometry, Nl));
                        else if (c.mode === KC.LINES) d = new vv(n, h);
                        else if (c.mode === KC.LINE_STRIP) d = new fv(n, h);
                        else if (c.mode === KC.LINE_LOOP) d = new yv(n, h);
                        else {
                            if (c.mode !== KC.POINTS) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + c.mode);
                            d = new Av(n, h)
                        }
                        Object.keys(d.geometry.morphAttributes).length > 0 && lT(d, i), d.name = t.createUniqueName(i.name || "mesh_" + e), sT(d, i), c.extensions && aT(r, d, c), t.assignFinalMaterial(d), l.push(d)
                    }
                    for (let r = 0, i = l.length; r < i; r++) t.associations.set(l[r], {
                        meshes: e,
                        primitives: r
                    });
                    if (1 === l.length) return i.extensions && aT(r, l[0], i), l[0];
                    const c = new Hm;
                    i.extensions && aT(r, c, i), t.associations.set(c, {
                        meshes: e
                    });
                    for (let e = 0, t = l.length; e < t; e++) c.add(l[e]);
                    return c
                }))
            }
            loadCamera(e) {
                let t;
                const n = this.json.cameras[e],
                    r = n[n.type];
                if (r) return "perspective" === n.type ? t = new Zh(Jc.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : "orthographic" === n.type && (t = new wp(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), n.name && (t.name = this.createUniqueName(n.name)), sT(t, n), Promise.resolve(t);
                console.warn("THREE.GLTFLoader: Missing camera parameters.")
            }
            loadSkin(e) {
                const t = this.json.skins[e],
                    n = [];
                for (let r = 0, i = t.joints.length; r < i; r++) n.push(this._loadNodeShallow(t.joints[r]));
                return void 0 !== t.inverseBindMatrices ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then((function(e) {
                    const n = e.pop(),
                        r = e,
                        i = [],
                        o = [];
                    for (let a = 0, s = r.length; a < s; a++) {
                        const e = r[a];
                        if (e) {
                            i.push(e);
                            const t = new od;
                            null !== n && t.fromArray(n.array, 16 * a), o.push(t)
                        } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[a])
                    }
                    return new Dg(i, o)
                }))
            }
            loadAnimation(e) {
                const t = this.json,
                    n = this,
                    r = t.animations[e],
                    i = r.name ? r.name : "animation_" + e,
                    o = [],
                    a = [],
                    s = [],
                    l = [],
                    c = [];
                for (let u = 0, d = r.channels.length; u < d; u++) {
                    const e = r.channels[u],
                        t = r.samplers[e.sampler],
                        n = e.target,
                        i = n.node,
                        d = void 0 !== r.parameters ? r.parameters[t.input] : t.input,
                        h = void 0 !== r.parameters ? r.parameters[t.output] : t.output;
                    void 0 !== n.node && (o.push(this.getDependency("node", i)), a.push(this.getDependency("accessor", d)), s.push(this.getDependency("accessor", h)), l.push(t), c.push(n))
                }
                return Promise.all([Promise.all(o), Promise.all(a), Promise.all(s), Promise.all(l), Promise.all(c)]).then((function(e) {
                    const t = e[0],
                        r = e[1],
                        o = e[2],
                        a = e[3],
                        s = e[4],
                        l = [];
                    for (let i = 0, c = t.length; i < c; i++) {
                        const e = t[i],
                            c = r[i],
                            u = o[i],
                            d = a[i],
                            h = s[i];
                        if (void 0 === e) continue;
                        e.updateMatrix && e.updateMatrix();
                        const p = n._createAnimationTracks(e, c, u, d, h);
                        if (p)
                            for (let t = 0; t < p.length; t++) l.push(p[t])
                    }
                    return new Pb(i, void 0, l)
                }))
            }
            createNodeMesh(e) {
                const t = this.json,
                    n = this,
                    r = t.nodes[e];
                return void 0 === r.mesh ? null : n.getDependency("mesh", r.mesh).then((function(e) {
                    const t = n._getNodeRef(n.meshCache, r.mesh, e);
                    return void 0 !== r.weights && t.traverse((function(e) {
                        if (e.isMesh)
                            for (let t = 0, n = r.weights.length; t < n; t++) e.morphTargetInfluences[t] = r.weights[t]
                    })), t
                }))
            }
            loadNode(e) {
                const t = this,
                    n = this.json.nodes[e],
                    r = t._loadNodeShallow(e),
                    i = [],
                    o = n.children || [];
                for (let s = 0, l = o.length; s < l; s++) i.push(t.getDependency("node", o[s]));
                const a = void 0 === n.skin ? Promise.resolve(null) : t.getDependency("skin", n.skin);
                return Promise.all([r, Promise.all(i), a]).then((function(e) {
                    const t = e[0],
                        n = e[1],
                        r = e[2];
                    null !== r && t.traverse((function(e) {
                        e.isSkinnedMesh && e.bind(r, hT)
                    }));
                    for (let i = 0, o = n.length; i < o; i++) t.add(n[i]);
                    return t
                }))
            }
            _loadNodeShallow(e) {
                const t = this.json,
                    n = this.extensions,
                    r = this;
                if (void 0 !== this.nodeCache[e]) return this.nodeCache[e];
                const i = t.nodes[e],
                    o = i.name ? r.createUniqueName(i.name) : "",
                    a = [],
                    s = r._invokeOne((function(t) {
                        return t.createNodeMesh && t.createNodeMesh(e)
                    }));
                return s && a.push(s), void 0 !== i.camera && a.push(r.getDependency("camera", i.camera).then((function(e) {
                    return r._getNodeRef(r.cameraCache, i.camera, e)
                }))), r._invokeAll((function(t) {
                    return t.createNodeAttachment && t.createNodeAttachment(e)
                })).forEach((function(e) {
                    a.push(e)
                })), this.nodeCache[e] = Promise.all(a).then((function(t) {
                    let a;
                    if (a = !0 === i.isBone ? new Ig : t.length > 1 ? new Hm : 1 === t.length ? t[0] : new Rd, a !== t[0])
                        for (let e = 0, n = t.length; e < n; e++) a.add(t[e]);
                    if (i.name && (a.userData.name = i.name, a.name = o), sT(a, i), i.extensions && aT(n, a, i), void 0 !== i.matrix) {
                        const e = new od;
                        e.fromArray(i.matrix), a.applyMatrix4(e)
                    } else void 0 !== i.translation && a.position.fromArray(i.translation), void 0 !== i.rotation && a.quaternion.fromArray(i.rotation), void 0 !== i.scale && a.scale.fromArray(i.scale);
                    return r.associations.has(a) || r.associations.set(a, {}), r.associations.get(a).nodes = e, a
                })), this.nodeCache[e]
            }
            loadScene(e) {
                const t = this.extensions,
                    n = this.json.scenes[e],
                    r = this,
                    i = new Hm;
                n.name && (i.name = r.createUniqueName(n.name)), sT(i, n), n.extensions && aT(t, i, n);
                const o = n.nodes || [],
                    a = [];
                for (let s = 0, l = o.length; s < l; s++) a.push(r.getDependency("node", o[s]));
                return Promise.all(a).then((function(e) {
                    for (let t = 0, n = e.length; t < n; t++) i.add(e[t]);
                    return r.associations = (e => {
                        const t = new Map;
                        for (const [n, i] of r.associations)(n instanceof Jd || n instanceof bu) && t.set(n, i);
                        return e.traverse((e => {
                            const n = r.associations.get(e);
                            null != n && t.set(e, n)
                        })), t
                    })(i), i
                }))
            }
            _createAnimationTracks(e, t, n, r, i) {
                const o = [],
                    a = e.name ? e.name : e.uuid,
                    s = [];
                let l;
                switch (eT[i.path] === eT.weights ? e.traverse((function(e) {
                    e.morphTargetInfluences && s.push(e.name ? e.name : e.uuid)
                })) : s.push(a), eT[i.path]) {
                    case eT.weights:
                        l = Ab;
                        break;
                    case eT.rotation:
                        l = Eb;
                        break;
                    case eT.position:
                    case eT.scale:
                        l = Tb;
                        break;
                    default:
                        if (1 === n.itemSize) l = Ab;
                        else l = Tb
                }
                const c = void 0 !== r.interpolation ? tT[r.interpolation] : Cl,
                    u = this._getArrayFromAccessor(n);
                for (let d = 0, h = s.length; d < h; d++) {
                    const e = new l(s[d] + "." + eT[i.path], t.array, u, c);
                    "CUBICSPLINE" === r.interpolation && this._createCubicSplineTrackInterpolant(e), o.push(e)
                }
                return o
            }
            _getArrayFromAccessor(e) {
                let t = e.array;
                if (e.normalized) {
                    const e = dT(t.constructor),
                        n = new Float32Array(t.length);
                    for (let r = 0, i = t.length; r < i; r++) n[r] = t[r] * e;
                    t = n
                }
                return t
            }
            _createCubicSplineTrackInterpolant(e) {
                e.createInterpolant = function(e) {
                    return new(this instanceof Eb ? XC : qC)(this.times, this.values, this.getValueSize() / 3, e)
                }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
            }
        }

        function fT(e, t, n) {
            const r = t.attributes,
                i = [];

            function o(t, r) {
                return n.getDependency("accessor", t).then((function(t) {
                    e.setAttribute(r, t)
                }))
            }
            for (const a in r) {
                const t = $C[a] || a.toLowerCase();
                t in e.attributes || i.push(o(r[a], t))
            }
            if (void 0 !== t.indices && !e.index) {
                const r = n.getDependency("accessor", t.indices).then((function(t) {
                    e.setIndex(t)
                }));
                i.push(r)
            }
            return uu.workingColorSpace !== ql && "COLOR_0" in r && console.warn('THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "'.concat(uu.workingColorSpace, '" not supported.')), sT(e, t),
                function(e, t, n) {
                    const r = t.attributes,
                        i = new Ou;
                    if (void 0 === r.POSITION) return; {
                        const e = n.json.accessors[r.POSITION],
                            t = e.min,
                            o = e.max;
                        if (void 0 === t || void 0 === o) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                        if (i.set(new Pu(t[0], t[1], t[2]), new Pu(o[0], o[1], o[2])), e.normalized) {
                            const t = dT(JC[e.componentType]);
                            i.min.multiplyScalar(t), i.max.multiplyScalar(t)
                        }
                    }
                    const o = t.targets;
                    if (void 0 !== o) {
                        const e = new Pu,
                            t = new Pu;
                        for (let r = 0, i = o.length; r < i; r++) {
                            const i = o[r];
                            if (void 0 !== i.POSITION) {
                                const r = n.json.accessors[i.POSITION],
                                    o = r.min,
                                    a = r.max;
                                if (void 0 !== o && void 0 !== a) {
                                    if (t.setX(Math.max(Math.abs(o[0]), Math.abs(a[0]))), t.setY(Math.max(Math.abs(o[1]), Math.abs(a[1]))), t.setZ(Math.max(Math.abs(o[2]), Math.abs(a[2]))), r.normalized) {
                                        const e = dT(JC[r.componentType]);
                                        t.multiplyScalar(e)
                                    }
                                    e.max(t)
                                } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                            }
                        }
                        i.expandByVector(e)
                    }
                    e.boundingBox = i;
                    const a = new Yu;
                    i.getCenter(a.center), a.radius = i.min.distanceTo(i.max) / 2, e.boundingSphere = a
                }(e, t, n), Promise.all(i).then((function() {
                    return void 0 !== t.targets ? function(e, t, n) {
                        let r = !1,
                            i = !1,
                            o = !1;
                        for (let c = 0, u = t.length; c < u; c++) {
                            const e = t[c];
                            if (void 0 !== e.POSITION && (r = !0), void 0 !== e.NORMAL && (i = !0), void 0 !== e.COLOR_0 && (o = !0), r && i && o) break
                        }
                        if (!r && !i && !o) return Promise.resolve(e);
                        const a = [],
                            s = [],
                            l = [];
                        for (let c = 0, u = t.length; c < u; c++) {
                            const u = t[c];
                            if (r) {
                                const t = void 0 !== u.POSITION ? n.getDependency("accessor", u.POSITION) : e.attributes.position;
                                a.push(t)
                            }
                            if (i) {
                                const t = void 0 !== u.NORMAL ? n.getDependency("accessor", u.NORMAL) : e.attributes.normal;
                                s.push(t)
                            }
                            if (o) {
                                const t = void 0 !== u.COLOR_0 ? n.getDependency("accessor", u.COLOR_0) : e.attributes.color;
                                l.push(t)
                            }
                        }
                        return Promise.all([Promise.all(a), Promise.all(s), Promise.all(l)]).then((function(t) {
                            const n = t[0],
                                a = t[1],
                                s = t[2];
                            return r && (e.morphAttributes.position = n), i && (e.morphAttributes.normal = a), o && (e.morphAttributes.color = s), e.morphTargetsRelative = !0, e
                        }))
                    }(e, t.targets, n) : e
                }))
        }
        n(7832);
        const mT = e => {
            let {
                diamondsVisibility: t,
                bandMetal: n,
                scaleReducerVector: i,
                scaleReducer: o,
                bandStyle: a,
                bandFit: s,
                bandWidth: l,
                ringSize: c,
                bandInnerRadius: u,
                bandPaveStyle: d,
                bandPaveLength: h,
                prongWidths: p,
                halosVerticalPlacement: f,
                centerHaloThickness: m,
                centerBezelTopThickness: g,
                centerBezelBottomThickness: v,
                basketsVerticalPlacement: y,
                basketsDimensions: b,
                headProperties: x,
                cathedral: _,
                headCount: M,
                headRotations: w,
                position: A,
                extraMetal: S,
                numberOfElements: E,
                centerStoneCheckForKiteOrCompass: C,
                centerStoneCheckForProngPave: T
            } = e;
            const {
                gl: P,
                scene: R
            } = KM(), I = (0, r.useMemo)((() => new rb({
                color: n,
                metalness: 1,
                roughness: .05,
                wireframe: !1
            })), [n]), O = Bo((e => e.setBandPave)), B = Bo((e => e.setBandVolume)), [L, D] = (0, r.useState)(0), [N, k] = (0, r.useState)(0), [F, U] = (0, r.useState)(0), [z, H] = (0, r.useState)(0), j = new Hm;
            let G = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/test/band/Band0.22V2.glb"),
                V = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/test/band/Band0.22Manufacturing0.99V2.glb"),
                q = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/test/band/Band0.22NoMetalLeft.glb"),
                W = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/test/band/Band0.22NoMetalLeftManufacturingV2.glb"),
                X = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/test/band/Band0.22NoMetalRight.glb"),
                K = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/test/band/Band0.22NoMetalRightManufacturingV2.glb"),
                J = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/test/band/Cathedral0.22V3.glb"),
                Y = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/test/band/Cathedral0.22Manufacturing.glb");
            S && (G = V, q = W, X = K, J = Y);
            let Q = (0, r.useRef)(0),
                Z = 0,
                $ = 0,
                ee = 0,
                te = {
                    point: null,
                    angle: null,
                    remainder: null,
                    cathedralLength: null,
                    totalLength: null,
                    numberOfBlocksFromHalfPointTilShoulder: null,
                    cathedralGirdleCenterLinePoints: null
                },
                ne = 0,
                re = 0;
            return (0, r.useEffect)((() => {
                Q.current = 0;
                let e = .888888888888889 * l + (.1 + l / 2.8 * .01);
                const n = .6351111111111111 * l;
                let r = .9;
                S && (r = .99);
                const i = 1.8,
                    c = .2 * i;
                let A = i;
                "None" !== d && (A = c + Math.max(.8 * i, n), "None" !== _ && (A = c + Math.max(.8 * i, 1.2 * n)));
                const E = A - c,
                    T = u + c;
                let P = 256;
                const O = 24;
                let V = 0;
                const W = {
                    Half: Math.PI / 2,
                    "Three Quarters": Math.PI / 180 * 135
                };
                let K = 0,
                    Y = .05 * l;
                S && (K = .05 * l);
                let ie = .05,
                    oe = {
                        x: 0,
                        y: 0,
                        z: 0
                    },
                    ae = {
                        x: 0,
                        y: 0,
                        z: 0
                    },
                    se = {
                        higherPoints: [],
                        lowerPoints: []
                    };
                let le, ce, ue, de = [],
                    he = 0,
                    pe = [],
                    fe = 0,
                    me = 0,
                    ge = 0,
                    ve = 0,
                    ye = [],
                    be = [],
                    xe = 0,
                    _e = 0,
                    Me = 0,
                    we = 0,
                    Ae = 0,
                    Se = 0,
                    Ee = 0,
                    Ce = {
                        x: 0,
                        y: 0,
                        z: 0
                    },
                    Te = {
                        x: 0,
                        y: 0,
                        z: 0
                    },
                    Pe = {
                        x: 0,
                        y: 0,
                        z: 0
                    };
                const Re = 2 * Math.PI * (u + A),
                    Ie = .15566666666666668 * l,
                    Oe = 2 * Math.PI * (u + A - Ie);
                Z = Math.floor(Oe / e);
                const Be = 2 / (2 * Z) * 2 * Math.PI,
                    Le = Oe / Z,
                    De = n - Ie,
                    Ne = .25;
                let ke, Fe, Ue;
                1 === M ? (ke = 2 * (p[1] + Ne) / Re * 2 * Math.PI, $ = Math.ceil(ke / Be), Fe = $ / 2 * Be, Ue = 2 * Math.PI - Fe) : 2 === M ? (ke = (p[2] + Ne) / Re * 2 * Math.PI - w[2] + (p[0] + Ne) / Re * 2 * Math.PI + w[0], $ = Math.ceil(ke / Be), Fe = $ / 2 * Be, Ue = 2 * Math.PI - Fe) : 3 === M && (ke = 2 * ((p[2] + Ne) / Re * 2 * Math.PI - w[2]), $ = Math.ceil(ke / Be), Fe = $ / 2 * Be, Ue = 2 * Math.PI - Fe), "None" !== _ && "None" !== d && ($ = 2);
                let ze = W[h],
                    He = 2 * Math.PI - W[h];
                "Half" === h ? (ee = Math.round(.5 * Z / 2), ze = (ee - $ % 2) * Be, He = (Z - ee) * Be, $ % 2 !== 0 && (ze += Be / 2, He += Be / 2)) : "Three Quarters" === h && (ee = Math.round(Z * (3 / 4) / 2), ze = (ee - $ % 2) * Be, He = (Z - ee) * Be, $ % 2 !== 0 && (ze += Be / 2, He += Be / 2));
                let je = [Fe, ze, He, Ue];
                const Ge = new Yd({
                        color: 65280
                    }),
                    Ve = new Yd({
                        color: 16711680
                    }),
                    qe = (new Yd({
                        color: 65280
                    }), new Xy(.05, 32, 32));

                function We(e, t, n, r) {
                    return Math.sqrt(Math.pow(n - e, 2) + Math.pow(r - t, 2))
                }

                function Xe(e, t) {
                    const n = {
                            x: 0,
                            y: 0,
                            z: 0
                        },
                        r = Math.PI / 2 - e;
                    return n.z = t.z - Math.cos(r) * De, n.x = t.x + Math.sin(r) * De, n
                }

                function Ke(e, t) {
                    const n = {
                            x: 0,
                            y: 0,
                            z: 0
                        },
                        r = Math.PI / 2 - e;
                    return n.z = t.z + Math.cos(r) * (De + .007), n.x = t.x - Math.sin(r) * (De + .007), n
                }

                function Je(e, t, n, r) {
                    let i, o, a, s = e + t,
                        c = oe.x - ae.x,
                        u = oe.z - ae.z;
                    for (let h = 0; h < P; h++) {
                        let f = h / P * 2 * Math.PI,
                            m = 1 - h / he,
                            g = 1 - (P - h - 1) / (he - 1),
                            v = (.85 * p[1] + (l - .85 * p[1]) * Math.sin(h / (he - 1) * Math.PI / 2)) / l,
                            y = (.85 * p[1] + (l - .85 * p[1]) * Math.sin((P - h - 1) / (he - 1) * Math.PI / 2)) / l,
                            b = (.85 * p[1] + (A - .85 * p[1]) * Math.sin(h / (he - 1) * Math.PI / 2)) / A,
                            M = (.85 * p[1] + (A - .85 * p[1]) * Math.sin((P - h - 1) / (he - 1) * Math.PI / 2)) / A;
                        "None" !== _ && "None" !== d && (v = 1, y = 1, b = .8 * Math.sin(h / (he - 1) * Math.PI / 2) + .2, M = .8 * Math.sin((P - h - 1) / (he - 1) * Math.PI / 2) + .2), x && x.basketHalo && (b = .9 * Math.sin(h / (he - 1) * Math.PI / 2) + .1, M = .9 * Math.sin((P - h - 1) / (he - 1) * Math.PI / 2) + .1);
                        const w = Math.PI / he * h,
                            S = Math.PI / (he - 1) * (P - h - 1);
                        Math.sin(w), Math.sin(S);
                        if ("None" !== _ && h < he + 1) {
                            s = e + t * b, i = m * (c * m + Math.cos(ue) * s) + (1 - m) * (s * Math.cos(f)), o = n * v, a = m * (u * m + Math.sin(ue) * s) + (1 - m) * (s * Math.sin(f)), r.push(i, o, a);
                            new zh(qe, Ve).position.set(i, o, a)
                        } else if ("None" !== _ && h > P - he - 1) {
                            if (s = e + t * M, i = g * (c * g + Math.cos(ue) * s) + (1 - g) * (s * Math.cos(f)), o = n * y, a = -g * (u * g + Math.sin(ue) * s) + (1 - g) * (s * Math.sin(f)), pe.length < he) {
                                if (pe.length > 0) {
                                    const e = pe[pe.length - 1];
                                    fe += We(e.x, e.z, i, a)
                                }
                                pe.push({
                                    x: i,
                                    y: 0,
                                    z: a
                                });
                                new zh(qe, Ve).position.set(i, 0, a)
                            }
                            r.push(i, o, a), h === P - 1 && se.lowerPoints.push({
                                x: i,
                                y: o,
                                z: a
                            });
                            new zh(qe, Ve).position.set(i, o, a)
                        } else {
                            i = s * Math.cos(f), o = n, a = s * Math.sin(f), r.push(i, o, a);
                            new zh(qe, Ge).position.set(i, o, a)
                        }
                    }
                }

                function Ye(e, t, n, r) {
                    let i, o, a, s, c = e + t,
                        u = "High";
                    "None" !== _ && "None" !== d && (u = "Incremently");
                    let h = oe.x - ae.x,
                        f = oe.z - ae.z;
                    for (let m = 0; m < P; m++) {
                        let g = m / P * 2 * Math.PI,
                            v = 1 - m / he,
                            y = 1 - (P - m - 1) / (he - 1),
                            b = (.85 * p[1] + (l - .85 * p[1]) * Math.sin(m / (he - 1) * Math.PI / 2)) / l,
                            x = (.85 * p[1] + (l - .85 * p[1]) * Math.sin((P - m - 1) / (he - 1) * Math.PI / 2)) / l,
                            M = (.6 * p[1] + (A - .6 * p[1]) * Math.sin(m / (he - 1) * Math.PI / 2)) / A,
                            w = (.6 * p[1] + (A - .6 * p[1]) * Math.sin((P - m - 1) / (he - 1) * Math.PI / 2)) / A;
                        "None" !== _ && "None" !== d && (b = 1, x = 1, M = (.85 * p[1] + (A - .85 * p[1]) * Math.sin(m / (he - 1) * Math.PI / 2)) / A, w = (.85 * p[1] + (A - .85 * p[1]) * Math.sin((P - m - 1) / (he - 1) * Math.PI / 2)) / A);
                        const S = Math.PI / he * m,
                            E = Math.PI / (he - 1) * (P - m - 1);
                        Math.sin(S), Math.sin(E);
                        if ("None" !== d)
                            if ("None" !== _ && m < he + 1) {
                                for (let t = 0; t < je.length; t++)
                                    if (c = e, g <= je[t] && g + 1 / P * 2 * Math.PI > je[t]) {
                                        c = e, o = v * (h * v + Math.cos(ue) * c) + (1 - v) * (c * Math.cos(g)), a = n * b, s = v * (f * v + Math.sin(ue) * c) + (1 - v) * (c * Math.sin(g)), r.push(o, a, s);
                                        new zh(qe, Ge).position.set(o, a, s)
                                    }
                                if (m === ve && (u = "Low", i = "paveStartAngleRightSide"), "Low" === u) {
                                    o = v * (h * v + Math.cos(ue) * c) + (1 - v) * (c * Math.cos(g)), a = n * b, s = v * (f * v + Math.sin(ue) * c) + (1 - v) * (c * Math.sin(g)), r.push(o, a, s);
                                    new zh(qe, Ge).position.set(o, a, s), c = e
                                } else if ("High" === u) {
                                    c = e + t * M, o = v * (h * v + Math.cos(ue) * c) + (1 - v) * (c * Math.cos(g)), a = n * b, s = v * (f * v + Math.sin(ue) * c) + (1 - v) * (c * Math.sin(g)), r.push(o, a, s);
                                    new zh(qe, Ge).position.set(o, a, s)
                                } else if ("Incremently" === u) {
                                    if (0 === m && e > T) {
                                        const t = ve / P * 2 * Math.PI,
                                            r = 1 - (ve - 1) / (he - 1);
                                        Pe = {
                                            x: r * (h * r + Math.cos(ue) * e) + (1 - r) * (e * Math.cos(t)),
                                            y: n * b,
                                            z: r * (f * r + Math.sin(ue) * e) + (1 - r) * (e * Math.sin(t))
                                        };
                                        new zh(qe, Ve).position.set(o, 0, s)
                                    }
                                    if (m < ve && e > T) {
                                        const e = m / (ve - 1);
                                        o = oe.x - e * (oe.x - Pe.x), a = n * b, s = oe.z - e * (oe.z - Pe.z)
                                    } else o = v * (h * v + Math.cos(ue) * c) + (1 - v) * (c * Math.cos(g)), a = n * b, s = v * (f * v + Math.sin(ue) * c) + (1 - v) * (c * Math.sin(g));
                                    r.push(o, a, s);
                                    new zh(qe, Ge).position.set(o, a, s)
                                }
                            } else if ("None" !== _ && m > P - he - 1) {
                            for (let t = 0; t < je.length; t++)
                                if (g <= je[t] && g + 1 / P * 2 * Math.PI > je[t]) {
                                    c = e, o = y * (h * y + Math.cos(ue) * c) + (1 - y) * (c * Math.cos(g)), a = n * x, s = -y * (f * y + Math.sin(ue) * c) + (1 - y) * (c * Math.sin(g)), r.push(o, a, s);
                                    new zh(qe, Ve).position.set(o, a, s)
                                }
                            if (m === P - ve && (u = "Incremently", i = "paveEndAngleLeftSide"), "Low" === u) {
                                if (o = y * (h * y + Math.cos(ue) * c) + (1 - y) * (c * Math.cos(g)), a = n * x, s = -y * (f * y + Math.sin(ue) * c) + (1 - y) * (c * Math.sin(g)), ye.length < 2 * he) {
                                    ye.push({
                                        x: o,
                                        y: 0,
                                        z: s
                                    });
                                    new zh(qe, Ve).position.set(o, 0, s)
                                }
                                r.push(o, a, s);
                                new zh(qe, Ve).position.set(o, a, s), c = e
                            } else if ("High" === u) {
                                c = e + t * w, o = y * (h * y + Math.cos(ue) * c) + (1 - y) * (c * Math.cos(g)), a = n * x, s = -y * (f * y + Math.sin(ue) * c) + (1 - y) * (c * Math.sin(g)), r.push(o, a, s);
                                new zh(qe, Ve).position.set(o, a, s)
                            } else if ("Incremently" === u) {
                                if (m > P - ve && e > T) {
                                    const e = (P - m - 1) / (ve - 1);
                                    o = oe.x - e * (oe.x - Pe.x), a = n * x, s = -oe.z - e * (-oe.z - Pe.z)
                                } else o = y * (h * y + Math.cos(ue) * c) + (1 - y) * (c * Math.cos(g)), a = n * x, s = -y * (f * y + Math.sin(ue) * c) + (1 - y) * (c * Math.sin(g));
                                if (m === P - ve && e > T) {
                                    Pe = {
                                        x: o,
                                        y: a,
                                        z: s
                                    };
                                    new zh(qe, Ve).position.set(o, 0, s)
                                }
                                if (ye.length < 2 * he) {
                                    ye.push({
                                        x: o,
                                        y: 0,
                                        z: s
                                    });
                                    new zh(qe, Ve).position.set(o, 0, s)
                                }
                                r.push(o, a, s), m === P - 1 && se.higherPoints.push({
                                    x: o,
                                    y: a,
                                    z: s
                                });
                                new zh(qe, Ve).position.set(o, a, s)
                            }
                        } else {
                            for (let e = 0; e < je.length; e++)
                                if (g <= je[e] && g + 1 / P * 2 * Math.PI > je[e]) {
                                    o = c * Math.cos(g), a = n, s = c * Math.sin(g), r.push(o, a, s);
                                    new zh(qe, Ge).position.set(o, a, s), 0 === e ? (g = je[e], u = "Low", i = "paveStartAngleRightSide") : 1 === e ? (g = je[e], u = "High", i = "paveEndAngleRightSide") : 2 === e ? (g = je[e], u = "Low", i = "paveStartAngleLeftSide") : 3 === e && (g = je[e], u = "High", i = "paveEndAngleLeftSide")
                                }
                            if ("Low" === u) {
                                o = c * Math.cos(g), a = n, s = c * Math.sin(g), r.push(o, a, s);
                                new zh(qe, Ge).position.set(o, a, s), c = e
                            } else if ("High" === u) {
                                c = e + t, o = c * Math.cos(g), a = n, s = c * Math.sin(g), r.push(o, a, s);
                                new zh(qe, Ge).position.set(o, a, s)
                            }
                        } else if ("None" !== _ && m < he + 1) {
                            c = e + t * M, o = v * (h * v + Math.cos(ue) * c) + (1 - v) * (c * Math.cos(g)), a = n * b, s = v * (f * v + Math.sin(ue) * c) + (1 - v) * (c * Math.sin(g)), r.push(o, a, s);
                            new zh(qe, Ve).position.set(o, a, s)
                        } else if ("None" !== _ && m > P - he - 1) {
                            c = e + t * w, o = y * (h * y + Math.cos(ue) * c) + (1 - y) * (c * Math.cos(g)), a = n * x, s = -y * (f * y + Math.sin(ue) * c) + (1 - y) * (c * Math.sin(g)), r.push(o, a, s), m === P - 1 && se.higherPoints.push({
                                x: o,
                                y: a,
                                z: s
                            });
                            new zh(qe, Ve).position.set(o, a, s)
                        } else {
                            o = c * Math.cos(g), a = n, s = c * Math.sin(g), r.push(o, a, s);
                            new zh(qe, Ge).position.set(o, a, s)
                        }
                    }
                }

                function Qe(e, t, n, r) {
                    let i, o, a, s = e + t;
                    for (let l = 0; l < P; l++) {
                        let e = l / P * 2 * Math.PI;
                        i = s * Math.cos(e), o = n, a = s * Math.sin(e), r.push(i, o, a);
                        new zh(qe, Ge).position.set(i, o, a)
                    }
                }

                function Ze(e, t, n, r) {
                    let i = e + t;
                    for (let o = 0; o < P; o++) {
                        let e = o / P * 2 * Math.PI;
                        const t = i * Math.cos(e),
                            a = n,
                            s = i * Math.sin(e);
                        r.push(t, a, s);
                        new zh(qe, Ge).position.set(t, a, s)
                    }
                }
                if ("None" !== _) {
                    let bt = (Z - Math.round(.5 * Z / 2)) * Be;
                    if ($ % 2 !== 0 && (bt += Be / 2), 1 == M) {
                        x.basketHalo && "Bezel" == x.basketHalo.name ? ("East-West" == x.orientation ? oe.z = x.diamondLength / 2 + g / 8 - v / 4 : "Kite" == x.orientation ? oe.z = x.diamondWidth / 2 * Math.sqrt(2) + g / 8 - v / 4 : oe.z = x.diamondWidth / 2 + g / 8 - v / 3, oe.x = f[1] * o) : x.basketHalo && "Classic" == x.basketHalo.name ? ("East-West" == x.orientation ? oe.z = x.diamondLength / 2 + m / 8 : "Kite" == x.orientation ? oe.z = x.diamondWidth / 2 * Math.sqrt(2) + m / 8 : oe.z = x.diamondWidth / 2 + m / 8, oe.x = f[1] * o) : x.basketHalo && "Classic" != x.basketHalo.name ? ("East-West" == x.orientation ? oe.z = b[1].bottomInnerLength * o : "Kite" == x.orientation ? oe.z = b[1].bottomInnerWidth * o * Math.sqrt(2) : oe.z = C ? x.diamondWidth / 2 * .8 : b[1].bottomInnerWidth * o, oe.x = (y[1] - b[1].height / 2) * o) : ("East-West" == x.orientation ? oe.z = x.diamondLength / 2 * .975 : "Kite" == x.orientation ? oe.z = x.diamondWidth / 2 * Math.sqrt(2) * .825 : oe.z = C ? x.diamondWidth / 2 : x.diamondWidth / 2 * .9, oe.x = (y[1] - b[1].height / 2) * o), x.basketHalo && ("Bezel" === x.basketHalo.name ? oe.x += g / 16 : "Classic" === x.basketHalo.name ? oe.x -= m / 4 : (oe.z += .045000000000000005, oe.x += .036000000000000004)), x.basketHalo || (oe.z = .8 * oe.z), le = Math.atan(oe.z / oe.x), ce = 1.6 * (oe.x - T) / (2 * T * Math.PI) * 2 * Math.PI, ue = Math.min(Math.min(le + ce, 2 * Math.PI - bt - Be), 65 * Math.PI / 180), ae.z = T * Math.sin(ue), ae.x = T * Math.cos(ue), de.push({
                            point: ae,
                            angle: ue
                        });
                        for (let Mt = 0; Mt < 4; Mt++) {
                            const wt = {
                                    x: 0,
                                    y: 0,
                                    z: 0
                                },
                                At = ue - .036 * ce * (Mt + 1);
                            wt.z = T * Math.sin(At), wt.x = T * Math.cos(At), de.push({
                                point: wt,
                                angle: At
                            })
                        }
                        for (let St = 0; St < 16; St++) {
                            const Et = {
                                    x: 0,
                                    y: 0,
                                    z: 0
                                },
                                Ct = ue + .036 * ce * (St + 1);
                            Ct + bt + Be / 2 < 2 * Math.PI && (Et.z = T * Math.sin(Ct), Et.x = T * Math.cos(Ct), de.push({
                                point: Et,
                                angle: Ct
                            }))
                        }
                        he = Math.floor(ue / (2 * Math.PI) * P)
                    }
                    const xt = new Yd({
                            color: 255
                        }),
                        _t = new Xy(.05, 32, 32);
                    new zh(_t, xt).position.set(oe.x, oe.y, -oe.z)
                }
                const $e = (e, t, r) => {
                    let i = 0,
                        o = [],
                        a = [];
                    let s = T + (A - c - n),
                        l = oe.x - e.x,
                        u = oe.z - e.z;
                    for (let n = 0; n < r; n++) {
                        let e = (P - r + n) / P * 2 * Math.PI,
                            i = n / (r - 1),
                            a = i * (l * i + Math.cos(t) * s) + (1 - i) * (s * Math.cos(e)),
                            c = 0,
                            d = -i * (u * i + Math.sin(t) * s) + (1 - i) * (s * Math.sin(e));
                        o.push({
                            x: a,
                            y: 0,
                            z: d
                        });
                        new zh(qe, Ve).position.set(a, c, d)
                    }
                    for (let n = 0; n < r; n++) {
                        let e;
                        if (0 === n) e = Math.PI / 2 - Math.atan(-o[0].x / o[0].z);
                        else if (n === r - 1) {
                            const t = o[n - 1],
                                r = o[n],
                                i = (r.x - t.x) / (r.z - t.z);
                            e = i > 0 ? Math.atan(i) : Math.PI + Math.atan(i)
                        } else {
                            const t = o[n - 1],
                                r = o[n + 1],
                                i = (r.x - t.x) / (r.z - t.z);
                            e = i > 0 ? Math.atan(i) : Math.PI + Math.atan(i)
                        }
                        const t = Xe(e, o[n]),
                            s = t.x,
                            l = t.y,
                            c = t.z;
                        if (a.length > 0) {
                            const e = a[a.length - 1];
                            i += We(e.x, e.z, s, c)
                        }
                        a.push({
                            x: s,
                            y: l,
                            z: c
                        });
                        new zh(qe, Ve).position.set(s, l, c)
                    }
                    return [i, a]
                };
                if ("None" !== _ && "None" !== d) {
                    V = A - c - n;
                    const Tt = 2 * Math.PI * (T + V - .007);
                    let Pt = (Z - Math.round(.5 * Z / 2)) * Be;
                    $ % 2 !== 0 && (Pt += Be / 2);
                    let Rt = {
                            point: null,
                            angle: null,
                            remainder: null,
                            cathedralLength: null,
                            totalLength: null,
                            numberOfBlocksFromHalfPointTilShoulder: null,
                            cathedralGirdleCenterLinePoints: null
                        },
                        It = {
                            point: null,
                            angle: null,
                            remainder: null,
                            cathedralLength: null,
                            totalLength: null,
                            numberOfBlocksFromHalfPointTilShoulder: null,
                            cathedralGirdleCenterLinePoints: null
                        };
                    const Ot = 0;
                    for (let kt = 0; kt < de.length; kt++) {
                        const Ft = Math.floor(de[kt].angle / (2 * Math.PI) * P),
                            [Ut, zt] = $e(de[kt].point, de[kt].angle, Ft),
                            Ht = Ut + (2 * (1 - Ft / P) * Math.PI - Pt) / (2 * Math.PI) * Tt;
                        _e = (Ht - Ot) / Le;
                        const jt = _e - Math.floor(_e);
                        0 === kt ? (Rt.point = de[kt].point, Rt.angle = de[kt].angle, Rt.remainder = jt, Rt.cathedralLength = Ut, Rt.totalLength = Ht, Rt.numberOfBlocksFromHalfPointTilShoulder = _e, Rt.cathedralGirdleCenterLinePoints = zt, It.point = de[kt].point, It.angle = de[kt].angle, It.remainder = jt, It.cathedralLength = Ut, It.totalLength = Ht, It.numberOfBlocksFromHalfPointTilShoulder = _e, It.cathedralGirdleCenterLinePoints = zt) : (jt < Rt.remainder && (Rt.point = de[kt].point, Rt.angle = de[kt].angle, Rt.remainder = jt, Rt.cathedralLength = Ut, Rt.totalLength = Ht, Rt.numberOfBlocksFromHalfPointTilShoulder = _e, Rt.cathedralGirdleCenterLinePoints = zt), jt > It.remainder && (It.point = de[kt].point, It.angle = de[kt].angle, It.remainder = jt, It.cathedralLength = Ut, It.totalLength = Ht, It.numberOfBlocksFromHalfPointTilShoulder = _e, It.cathedralGirdleCenterLinePoints = zt))
                    }
                    Rt.remainder > .5 && It.remainder > .9 ? (te = It, ne = It.remainder - 1, te.numberOfBlocksFromHalfPointTilShoulder = Math.ceil(te.numberOfBlocksFromHalfPointTilShoulder)) : (te = Rt, ne = Rt.remainder, te.numberOfBlocksFromHalfPointTilShoulder = Math.floor(te.numberOfBlocksFromHalfPointTilShoulder));
                    for (let Gt = 0; Gt < te.cathedralGirdleCenterLinePoints.length; Gt++) {
                        const Vt = te.cathedralGirdleCenterLinePoints[Gt],
                            qt = new Xy(.05, 32, 32);
                        new zh(qt, Ve).position.set(Vt.x, Vt.y, Vt.z)
                    }
                    ae = te.point, ue = te.angle, he = Math.floor(te.angle / (2 * Math.PI) * P);
                    const Bt = new Yd({
                            color: 255
                        }),
                        Lt = new Xy(.05, 32, 32);
                    new zh(Lt, Bt).position.set(ae.x, ae.y, -ae.z), fe = te.cathedralLength, Me = Math.round((Pt - He) / (2 * Math.PI) * Oe / Le);
                    const Dt = .54 * l,
                        Nt = 2 * te.cathedralLength + (2 * Math.PI - 2 * ue) / (2 * Math.PI) * Oe - Dt;
                    we = Math.floor(Nt / e), Ae = Nt / we, Se = Ae / Oe * 2 * Math.PI, Ee = Math.round((2 * te.cathedralLength - Dt) / Ae) / 2
                }
                const et = new Mh;
                let tt = [];
                if ((() => {
                        if ("Comfort Fit" == s) {
                            const e = T;
                            for (let t = 0; t <= O; t++) {
                                const n = Math.PI / O * t;
                                Je(e, -(c * Math.sin(n)), (l + 2 * K) / 2 * Math.cos(n), tt)
                            }
                            U(Math.PI * c * (l + 2 * Y) / 2 / 2)
                        } else if ("Standard Fit" == s) {
                            const e = .2,
                                t = T;
                            for (let n = 0; n < 6; n++) {
                                Je(t, -(n / 6 * (c - e)), (l + 2 * K) / 2, tt)
                            }
                            for (let n = 0; n < 12; n++) {
                                const r = Math.PI / 2 / 12 * n;
                                Je(t, -(c - e + e * Math.sin(r)), (l + 2 * K) / 2 - e + e * Math.cos(r), tt)
                            }
                            for (let n = 0; n < 6; n++) {
                                Je(t, -.36000000000000004, (l + 2 * K) / 2 - e - n / 6 * (l + 2 * K - 2 * e), tt)
                            }
                            for (let n = 0; n < 12; n++) {
                                const r = Math.PI / 2 + Math.PI / 2 / 12 * n;
                                Je(t, -(c - e + e * Math.sin(r)), -(l + 2 * K) / 2 + e + e * Math.cos(r), tt)
                            }
                            for (let n = 0; n <= 6; n++) {
                                Je(t, -(c - e) + n / 6 * (c - e), -(l + 2 * K) / 2, tt)
                            }
                            U(c * (l + 2 * Y))
                        }
                    })(), "None" !== _ && "None" !== d) {
                    ge = te.remainder * Le, xe = ge / fe;
                    const Wt = l / (fe / he);
                    ve = Math.ceil(xe * he) + Math.ceil(Wt)
                }
                const nt = [];
                let rt = P;
                "None" !== _ && (rt = P - 1);
                for (let Xt = 0; Xt < rt; Xt++)
                    for (let Kt = 0; Kt < tt.length / 3 / P - 1; Kt++) {
                        const Jt = Kt * P + Xt,
                            Yt = Kt * P + (Xt + 1) % P,
                            Qt = Kt * P + Xt + P,
                            Zt = Yt + P,
                            $t = tt.length / 3;
                        Jt >= $t || Yt >= $t || Qt >= $t || Zt >= $t || (nt.push(Jt, Qt, Yt), nt.push(Zt, Yt, Qt))
                    }
                et.setAttribute("position", new ph(tt, 3)), et.setIndex(nt), et.computeVertexNormals(), et.setAttribute("uv", new ph(new Float32Array([]), 2)); {
                    const en = new zh(et, I);
                    en.position.set(0, 0, 0), j.add(en)
                }
                const it = new Mh;
                let ot = [];
                if ("Round" == a) {
                    V = "None" == d ? 0 : A - c - n, Ye(T, 0, (l + 2 * K) / 2, ot);
                    const tn = T + V;
                    for (let nn = 0; nn <= O; nn++) {
                        const rn = Math.PI / O * nn;
                        Ye(tn, +((E + 2 * K - V) * Math.sin(rn)), (l + 2 * K) / 2 * Math.cos(rn), ot)
                    }
                    Ye(T, 0, -(l + 2 * K) / 2, ot), k(V * (l + 2 * Y)), D(Math.PI * (E + Y - V) * (l + 2 * Y) / 2 / 2)
                } else if ("Square" == a) {
                    V = "None" == d ? 0 : A - c - n;
                    const on = .2,
                        an = T + V;
                    Ye(T, 0, (l + 2 * K) / 2, ot);
                    for (let sn = 0; sn < 6; sn++) {
                        Ye(an, +(sn / 6 * (E - ie + 2 * K - on - V)), (l + 2 * K) / 2, ot)
                    }
                    for (let ln = 0; ln < 12; ln++) {
                        const cn = Math.PI / 2 / 12 * ln;
                        Ye(an, +(E - ie + 2 * K - on - V + on * Math.sin(cn)), (l + 2 * K) / 2 - on + on * Math.cos(cn), ot)
                    }
                    for (let un = 0; un < 6; un++) {
                        Ye(an, +(E - ie + 2 * K) - V, (l + 2 * K) / 2 - on - un / 6 * (l + 2 * K - 2 * on), ot)
                    }
                    for (let dn = 0; dn < 12; dn++) {
                        const hn = Math.PI / 2 + Math.PI / 2 / 12 * dn;
                        Ye(an, +(E - ie + 2 * K - on - V + on * Math.sin(hn)), -(l + 2 * K) / 2 + on + on * Math.cos(hn), ot)
                    }
                    for (let pn = 0; pn <= 6; pn++) {
                        Ye(an, +((6 - pn) / 6 * (E - ie + 2 * K - on - V)), -(l + 2 * K) / 2, ot)
                    }
                    Ye(T, 0, -(l + 2 * K) / 2, ot), k(V * (l + 2 * Y)), D((E - ie + Y) * (l + 2 * Y))
                } else if ("Knife Edge" == a) {
                    const fn = .05;
                    Ye(T, 0, (l + 2 * K) / 2, ot);
                    const mn = T + fn;
                    for (let gn = 0; gn <= O; gn++) {
                        const vn = Math.PI / O * gn,
                            yn = (E + K - fn) * Math.sin(vn),
                            bn = gn / O;
                        let xn;
                        xn = gn <= 12 ? 2 * bn * (E + K - fn) : E + K - fn - (2 * bn * (E + K - fn) - (E + K - fn)), Ye(mn, +(yn + xn) / 2, (l + 2 * K) / 2 - bn * (l + 2 * K), ot)
                    }
                    Ye(T, 0, -(l + 2 * K) / 2, ot), k(fn * (l + 2 * Y)), D((E + Y - fn) * (l + 2 * Y) / 2)
                }
                const at = [];
                "None" !== d && (P += "Half" === h || "Three Quarters" === h ? 4 : 2), rt = P, "None" !== _ && (rt = P - 1);
                for (let _n = 0; _n < rt; _n++)
                    for (let Mn = 0; Mn < ot.length / 3 / P - 1; Mn++) {
                        const wn = Mn * P + _n;
                        let An = Mn * P + (_n + 1) % P;
                        const Sn = Mn * P + _n + P,
                            En = An + P,
                            Cn = ot.length / 3;
                        wn >= Cn || An >= Cn || Sn >= Cn || En >= Cn || (at.push(wn, An, Sn), at.push(An, En, Sn))
                    }
                it.setAttribute("position", new ph(ot, 3)), it.setIndex(at), it.computeVertexNormals(), it.setAttribute("uv", new ph(new Float32Array([]), 2)); {
                    const Tn = new zh(it, I);
                    Tn.position.set(0, 0, 0), j.add(Tn)
                }
                const st = new Mh;
                let lt = [],
                    ct = .9;
                V = "None" == d ? E - 1.08 : A - c - n, Qe(T, 0, (l * ct + 2 * K) / 2, lt);
                const ut = T + V;
                for (let Pn = 0; Pn <= O; Pn++) {
                    const Rn = Math.PI / O * Pn;
                    Qe(ut, .5 * +((E - V) * Math.sin(Rn)), (l * ct + 2 * K) / 2 * Math.cos(Rn), lt)
                }
                Qe(T, 0, -(l * ct + 2 * K) / 2, lt);
                const dt = [];
                for (let In = 0; In < P; In++)
                    for (let On = 0; On < lt.length / 3 / P - 1; On++) {
                        const Bn = On * P + In;
                        let Ln = On * P + (In + 1) % P;
                        const Dn = On * P + In + P,
                            Nn = Ln + P,
                            kn = lt.length / 3;
                        Bn >= kn || Ln >= kn || Dn >= kn || Nn >= kn || (dt.push(Bn, Ln, Dn), dt.push(Ln, Nn, Dn))
                    }
                st.setAttribute("position", new ph(lt, 3)), st.setIndex(dt), st.computeVertexNormals();
                const ht = new zh(st, I);
                ht.position.set(0, 0, 0);
                const pt = new Mh;
                let ft = [];
                if ("Comfort Fit" == s) {
                    const Fn = T;
                    for (let Un = 0; Un <= O; Un++) {
                        const zn = Math.PI / O * Un;
                        Ze(Fn, -(c * Math.sin(zn)), (l * ct + 2 * K) / 2 * Math.cos(zn), ft)
                    }
                } else if ("Standard Fit" == s) {
                    const Hn = .2,
                        jn = T;
                    for (let Gn = 0; Gn < 6; Gn++) {
                        Ze(jn, -(Gn / 6 * (c - Hn)), (l * ct + 2 * K) / 2, ft)
                    }
                    for (let Vn = 0; Vn < 12; Vn++) {
                        const qn = Math.PI / 2 / 12 * Vn;
                        Ze(jn, -(c - Hn + Hn * Math.sin(qn)), (l * ct + 2 * K) / 2 - Hn + Hn * Math.cos(qn), ft)
                    }
                    for (let Wn = 0; Wn < 6; Wn++) {
                        Ze(jn, -.36000000000000004, (l * ct + 2 * K) / 2 - Hn - Wn / 6 * (l * ct + 2 * K - 2 * Hn), ft)
                    }
                    for (let Xn = 0; Xn < 12; Xn++) {
                        const Kn = Math.PI / 2 + Math.PI / 2 / 12 * Xn;
                        Ze(jn, -(c - Hn + Hn * Math.sin(Kn)), -(l * ct + 2 * K) / 2 + Hn + Hn * Math.cos(Kn), ft)
                    }
                    for (let Jn = 0; Jn <= 6; Jn++) {
                        Ze(jn, -(c - Hn) + Jn / 6 * (c - Hn), -(l * ct + 2 * K) / 2, ft)
                    }
                }
                const mt = [];
                for (let Yn = 0; Yn < P; Yn++)
                    for (let Qn = 0; Qn < ft.length / 3 / P - 1; Qn++) {
                        const Zn = Qn * P + Yn,
                            $n = Qn * P + (Yn + 1) % P,
                            er = Qn * P + Yn + P,
                            tr = $n + P,
                            nr = ft.length / 3;
                        Zn >= nr || $n >= nr || er >= nr || tr >= nr || (mt.push(Zn, er, $n), mt.push(tr, $n, er))
                    }
                pt.setAttribute("position", new ph(ft, 3)), pt.setIndex(mt), pt.computeVertexNormals(), pt.setAttribute("uv", new ph(new Float32Array([]), 2));
                const gt = new zh(pt, I);
                let vt;
                if (gt.position.set(0, 0, 0), "None" !== _ && (j.add(ht), j.add(gt), H(ct * (F + .5 * L))), R.traverse((e => {
                        e.isMesh && "Band" === e.name && (vt = e.material)
                    })), "None" !== _) {
                    const rr = se.higherPoints.length,
                        ir = se.lowerPoints.length,
                        or = rr % 2 === 1 ? se.higherPoints[Math.floor(rr / 2)] : {
                            x: (se.higherPoints[rr / 2].x + se.higherPoints[rr / 2 - 1].x) / 2,
                            y: (se.higherPoints[rr / 2].y + se.higherPoints[rr / 2 - 1].y) / 2,
                            z: (se.higherPoints[rr / 2].z + se.higherPoints[rr / 2 - 1].z) / 2
                        },
                        ar = ir % 2 === 1 ? se.lowerPoints[Math.floor(ir / 2)] : {
                            x: (se.lowerPoints[ir / 2].x + se.lowerPoints[ir / 2 - 1].x) / 2,
                            y: (se.lowerPoints[ir / 2].y + se.lowerPoints[ir / 2 - 1].y) / 2,
                            z: (se.lowerPoints[ir / 2].z + se.lowerPoints[ir / 2 - 1].z) / 2
                        };
                    let sr = .6 * p[1] / 4;
                    (x && x.basketHalo || "None" !== d) && (sr = 0);
                    const lr = Math.PI / 2 + Math.atan((or.x - ar.x) / (or.z - ar.z)),
                        cr = (or.x, ar.x, Math.sin(lr), or.y, ar.y, or.z, ar.z, Math.cos(lr), {
                            x: (or.x + ar.x) / 2,
                            y: (or.y + ar.y) / 2,
                            z: (or.z + ar.z) / 2
                        });
                    let ur = [];

                    function dr(e, t, n) {
                        ur.push(e, t, n);
                        const r = new Xy(.01, 32, 32);
                        new zh(r, Ge).position.set(e, t, n)
                    }
                    const hr = 5;
                    for (let vr = 0; vr < rr; vr++)
                        for (let yr = 0; yr <= hr; yr++) {
                            const br = yr / hr;
                            dr((1 - br) * se.higherPoints[vr].x + br * cr.x + sr * Math.sin(lr) * Math.sin(Math.PI / 2 * br), (1 - br) * se.higherPoints[vr].y + br * cr.y, (1 - br) * se.higherPoints[vr].z + br * cr.z + sr * Math.cos(lr) * Math.sin(Math.PI / 2 * br))
                        }
                    for (let xr = ir - 1; xr >= 0; xr--)
                        for (let _r = 0; _r <= hr; _r++) {
                            const Mr = _r / hr;
                            dr((1 - Mr) * se.lowerPoints[xr].x + Mr * cr.x + sr * Math.sin(lr) * Math.sin(Math.PI / 2 * Mr), (1 - Mr) * se.lowerPoints[xr].y + Mr * cr.y, (1 - Mr) * se.lowerPoints[xr].z + Mr * cr.z + sr * Math.cos(lr) * Math.sin(Math.PI / 2 * Mr))
                        }
                    let pr = new Mh,
                        fr = [];
                    for (let wr = 0; wr < ur.length / 3; wr++)
                        for (let Ar = 0; Ar < hr; Ar++) {
                            const Sr = wr * (hr + 1) + Ar;
                            let Er = wr * (hr + 1) + Ar + 1;
                            const Cr = (wr + 1) * (hr + 1) + Ar,
                                Tr = (wr + 1) * (hr + 1) + Ar + 1,
                                Pr = ur.length / 3;
                            Sr >= Pr || Er >= Pr || Cr >= Pr || Tr >= Pr || (fr.push(Sr, Er, Cr), fr.push(Er, Tr, Cr))
                        }
                    pr.setAttribute("position", new ph(ur, 3)), pr.setIndex(fr), pr.computeVertexNormals(), pr.setAttribute("uv", new ph(new Float32Array([]), 2));
                    const mr = new zh(pr, I);
                    mr.position.set(0, 0, 0), j.add(mr), ur = [];
                    for (let Rr = 0; Rr < rr; Rr++)
                        for (let Ir = 0; Ir <= hr; Ir++) {
                            const Or = Ir / hr;
                            dr((1 - Or) * se.higherPoints[Rr].x + Or * cr.x + sr * Math.sin(lr) * Math.sin(Math.PI / 2 * Or), (1 - Or) * se.higherPoints[Rr].y + Or * cr.y, -((1 - Or) * se.higherPoints[Rr].z + Or * cr.z + sr * Math.cos(lr) * Math.sin(Math.PI / 2 * Or)))
                        }
                    for (let Br = ir - 1; Br >= 0; Br--)
                        for (let Lr = 0; Lr <= hr; Lr++) {
                            const Dr = Lr / hr;
                            dr((1 - Dr) * se.lowerPoints[Br].x + Dr * cr.x + sr * Math.sin(lr) * Math.sin(Math.PI / 2 * Dr), (1 - Dr) * se.lowerPoints[Br].y + Dr * cr.y, -((1 - Dr) * se.lowerPoints[Br].z + Dr * cr.z + sr * Math.cos(lr) * Math.sin(Math.PI / 2 * Dr)))
                        }
                    pr = new Mh, fr = [];
                    for (let Nr = 0; Nr < ur.length / 3; Nr++)
                        for (let kr = 0; kr < hr; kr++) {
                            const Fr = Nr * (hr + 1) + kr;
                            let Ur = Nr * (hr + 1) + kr + 1;
                            const zr = (Nr + 1) * (hr + 1) + kr,
                                Hr = (Nr + 1) * (hr + 1) + kr + 1,
                                jr = ur.length / 3;
                            Fr >= jr || Ur >= jr || zr >= jr || Hr >= jr || (fr.push(Fr, zr, Ur), fr.push(Hr, Ur, zr))
                        }
                    pr.setAttribute("position", new ph(ur, 3)), pr.setIndex(fr), pr.computeVertexNormals(), pr.setAttribute("uv", new ph(new Float32Array([]), 2));
                    const gr = new zh(pr, I);
                    gr.position.set(0, 0, 0), j.add(gr)
                }
                B("None" !== _ ? (L + N + F) * ((2 * Math.PI - 2 * ue) * (u + A / 2) + 2 * fe) + 2 * z * Math.PI * (u + A / 2) * (2 * ue / (2 * Math.PI)) + 9.644 : 2 * (L + N + F) * Math.PI * (u + A / 2) + 9.644);
                const yt = ne * Le / (Me + te.numberOfBlocksFromHalfPointTilShoulder - 1) / Oe * (2 * Math.PI);
                if ("None" !== d) {
                    let Gr = 0,
                        Vr = (Z - Math.round(.5 * Z / 2)) * Be;
                    $ % 2 !== 0 && (Vr += Be / 2);
                    for (let qr = 0; qr < 2 * Z + 1; qr++)
                        if ("Eternity" === h && qr % 2 === 1 && qr >= $ / 2 * 2 && qr < 2 * (Z - $ / 2)) {
                            let Wr, Xr, Kr = "Diamondmesh434",
                                Jr = "Diamondmesh434";
                            qr === $ / 2 * 2 || qr === $ / 2 * 2 + 1 ? (Wr = q.scene.clone(!0), Kr = "Diamondmesh439") : qr === 2 * (Z - $ / 2) || qr === 2 * (Z - $ / 2) - 1 || qr === 2 * (Z - $ / 2) - 2 ? (Wr = X.scene.clone(!0), Kr = "Diamondmesh440") : Wr = G.scene.clone(!0), $ % 2 !== 0 && (Gr = Be / 2);
                            const Yr = -(-Math.PI / 2 + qr * (Be / 2) + Gr);
                            let Qr, Zr, $r;
                            const ei = ue / Be,
                                ti = 2 * ei,
                                ni = T + V - .007,
                                ri = (oe.x, ae.x, oe.z - ae.z);
                            const ii = Math.PI / ti * qr,
                                oi = Math.PI / (ti - 1) * (2 * Z - qr - 1);
                            Math.sin(ii), Math.sin(oi);
                            "None" === _ && (Qr = ni * Math.sin(Yr), Zr = 0, $r = ni * Math.cos(Yr), Wr.rotation.set(0, Yr - Math.PI / 2, 0), -Yr + Math.PI / 2 > Vr && (re += 1), Wr.position.set(Qr, Zr, $r), Wr.scale.set((l + 2 * K) / r, (l + 2 * K) / r, (l + 2 * K) / r), j.add(Wr), Q.current += 1);
                            if (new zh(qe, Ge).position.set(Qr, Zr, $r), Wr.traverse((e => {
                                    e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = I))
                                })), Xr && Xr.traverse((e => {
                                    e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = I))
                                })), S && (Kr = "Diamondmesh434", Jr = "Diamondmesh434"), t) Wr.getObjectByName(Kr).material = vt, Xr && (Xr.getObjectByName(Jr).material = vt);
                            else {
                                let ai = Wr.getObjectByName(Kr);
                                ai.parent.remove(ai), Xr && (ai = Xr.getObjectByName(Jr), ai.parent.remove(ai))
                            }
                        } else if (qr % 2 === 1 && (qr >= $ / 2 * 2 && qr < 2 * ee - $ % 2 || qr > 2 * (Z - ee) && qr < 2 * (Z - $ / 2))) {
                        let si, li = "Diamondmesh434";
                        qr === $ / 2 * 2 || qr === $ / 2 * 2 + 1 || qr === 2 * (Z - ee) + 1 ? (si = q.scene.clone(!0), li = "Diamondmesh439") : qr === 2 * (Z - $ / 2) || qr === 2 * (Z - $ / 2) - 1 || qr === 2 * (Z - $ / 2) - 2 || qr === 2 * ee - $ % 2 - 1 || qr === 2 * ee - $ % 2 - 2 ? (si = X.scene.clone(!0), li = "Diamondmesh440") : si = G.scene.clone(!0), $ % 2 !== 0 && (Gr = Be / 2);
                        const ci = -(-Math.PI / 2 + qr * (Be / 2) + Gr);
                        let ui, di, hi;
                        const pi = T + V - .007;
                        "None" === _ && (ui = pi * Math.sin(ci), di = 0, hi = pi * Math.cos(ci), si.rotation.set(0, ci - Math.PI / 2, 0), -ci + Math.PI / 2 > Vr && (re += 1), si.position.set(ui, di, hi), si.scale.set((l + 2 * K) / r, (l + 2 * K) / r, (l + 2 * K) / r), j.add(si), Q.current += 1);
                        if (new zh(qe, Ge).position.set(ui, di, hi), si.traverse((e => {
                                e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = I))
                            })), S && (li = "Diamondmesh434"), t) si.getObjectByName(li).material = vt;
                        else {
                            let fi = si.getObjectByName(li);
                            fi.parent.remove(fi)
                        }
                    }
                    if ("None" !== _) {
                        let mi = q.scene.clone(!0),
                            gi = "Diamondmesh439",
                            vi = X.scene.clone(!0),
                            yi = "Diamondmesh440";
                        const bi = T + V - .007;
                        let xi = He + Be / 2,
                            _i = Be + yt;
                        if ("Eternity" === h) {
                            if (we % 2 === 0) xi = Math.PI + Se / 2;
                            else {
                                xi = Math.PI + Se;
                                let Ci = G.scene.clone(!0),
                                    Ti = "Diamondmesh434",
                                    Pi = bi * Math.sin(-Math.PI / 2),
                                    Ri = 0,
                                    Ii = bi * Math.cos(-Math.PI / 2);
                                if (Ci.rotation.set(0, -Math.PI, 0), Ci.position.set(Pi, Ri, Ii), Ci.scale.set((l + 2 * K) / r, (l + 2 * K) / r, (l + 2 * K) / r), j.add(Ci), Q.current += 1, Ci.traverse((e => {
                                        e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = I))
                                    })), S && (Ti = "Diamondmesh434"), t) Ci.getObjectByName(Ti).material = vt;
                                else {
                                    let Oi = Ci.getObjectByName(Ti);
                                    Oi.parent.remove(Oi)
                                }
                            }
                            _i = Se
                        }
                        let Mi = -(-Math.PI / 2 + xi),
                            wi = bi * Math.sin(Mi),
                            Ai = 0,
                            Si = bi * Math.cos(Mi);
                        if (mi.rotation.set(0, Mi - Math.PI / 2, 0), -Mi + Math.PI / 2 > Vr && (re += 1), mi.position.set(wi, Ai, Si), mi.scale.set((l + 2 * K) / r, (l + 2 * K) / r, (l + 2 * K) / r), j.add(mi), Q.current += 1, vi.rotation.set(0, -(Mi - Math.PI / 2), 0), vi.position.set(wi, Ai, -Si), vi.scale.set((l + 2 * K) / r, (l + 2 * K) / r, (l + 2 * K) / r), j.add(vi), Q.current += 1, null != wi && null != Ai && null != Si && (Ce.x = wi, Ce.y = Ai, Ce.z = Si), mi.traverse((e => {
                                e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = I))
                            })), S && (gi = "Diamondmesh434"), t) mi.getObjectByName(gi).material = vt;
                        else {
                            let Bi = mi.getObjectByName(gi);
                            Bi.parent.remove(Bi)
                        }
                        if (vi.traverse((e => {
                                e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = I))
                            })), S && (yi = "Diamondmesh434"), t) vi.getObjectByName(yi).material = vt;
                        else {
                            let Li = vi.getObjectByName(yi);
                            Li.parent.remove(Li)
                        }
                        let Ei = xi + _i;
                        for (; Ei < 2 * Math.PI - ue;) {
                            mi = G.scene.clone(!0), gi = "Diamondmesh434", vi = G.scene.clone(!0), yi = "Diamondmesh434";
                            let Di = -(-Math.PI / 2 + Ei),
                                Ni = bi * Math.sin(Di),
                                ki = 0,
                                Fi = bi * Math.cos(Di);
                            if (mi.rotation.set(0, Di - Math.PI / 2, 0), Ei > Vr && (re += 1), mi.position.set(Ni, ki, Fi), mi.scale.set((l + 2 * K) / r, (l + 2 * K) / r, (l + 2 * K) / r), j.add(mi), Q.current += 1, vi.rotation.set(0, -(Di - Math.PI / 2), 0), vi.position.set(Ni, ki, -Fi), vi.scale.set((l + 2 * K) / r, (l + 2 * K) / r, (l + 2 * K) / r), j.add(vi), Q.current += 1, null != Ni && null != ki && null != Fi && (Ce.x = Ni, Ce.y = ki, Ce.z = Fi), Ei += _i, mi.traverse((e => {
                                    e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = I))
                                })), S && (gi = "Diamondmesh434"), t) mi.getObjectByName(gi).material = vt;
                            else {
                                let Ui = mi.getObjectByName(gi);
                                Ui.parent.remove(Ui)
                            }
                            if (vi.traverse((e => {
                                    e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = I))
                                })), S && (yi = "Diamondmesh434"), t) vi.getObjectByName(yi).material = vt;
                            else {
                                let zi = vi.getObjectByName(yi);
                                zi.parent.remove(zi)
                            }
                        }
                    }
                    if ("None" !== _) {
                        me = "Eternity" === h ? Ee : Math.floor(te.numberOfBlocksFromHalfPointTilShoulder) - re, ye.length === 2 * he && (ye = ye.slice(he)), be.push(Xe(Math.PI / 2 - Math.atan(-Ce.x / Ce.z), Ce));
                        const Hi = te.cathedralGirdleCenterLinePoints;
                        let ji, Gi, Vi, qi, Wi = 0;
                        for (let oo = 0; oo < me; oo++) {
                            let ao;
                            ao = "Eternity" === h ? Ae : Le + ne * Le / (Me + te.numberOfBlocksFromHalfPointTilShoulder - 1);
                            let so = be[oo];
                            for (; ao > 0 && Wi < Hi.length;) {
                                let lo = We(so.x, so.z, Hi[Wi].x, Hi[Wi].z);
                                if (ao -= lo, ao <= 0) {
                                    const co = 1 + ao / lo,
                                        uo = {
                                            x: so.x + co * (Hi[Wi].x - so.x),
                                            y: 0,
                                            z: so.z + co * (Hi[Wi].z - so.z),
                                            prevIndex: Wi - 1
                                        };
                                    be.push(uo);
                                    const ho = new Xy(.5, 32, 32);
                                    new zh(ho, Ge).position.set(uo.x, uo.y, uo.z)
                                } else so = Hi[Wi], Wi += 1
                            }
                        }
                        let Xi = {
                            highPoint: {
                                x: 0,
                                y: 0,
                                z: 0
                            },
                            lowPoint: {
                                x: 0,
                                y: 0,
                                z: 0
                            },
                            angle: null,
                            highPointCorner: {
                                x: 0,
                                y: 0,
                                z: 0
                            }
                        };
                        for (let po = 1; po < be.length; po++) {
                            ji = J.scene.clone(!0), Gi = J.scene.clone(!0), Vi = "Diamondmesh434", qi = "Diamondmesh434";
                            const fo = be[po];
                            let mo = fo.prevIndex,
                                go = Hi[mo];
                            mo < 0 && (go = fo);
                            const vo = Hi[mo + 1],
                                yo = (go.x - vo.x) / (go.z - vo.z);
                            let bo = Math.atan(yo);
                            yo < 0 && (bo = Math.PI + bo), ji.rotation.set(0, bo, 0);
                            const xo = Ke(bo, fo);
                            ji.position.set(xo.x, xo.y, xo.z), ji.scale.set((l + 2 * K) / r, (l + 2 * K) / r, (l + 2 * K) / r), j.add(ji), Q.current += 1, po === be.length - 1 && (Xi.highPoint.z = fo.z + Math.cos(Math.PI / 2 - bo) * (.55 * De + .007), Xi.highPoint.x = fo.x - Math.sin(Math.PI / 2 - bo) * (.55 * De + .007), Xi.lowPoint.z = fo.z + Math.cos(Math.PI / 2 - bo) * (De + .007), Xi.lowPoint.x = fo.x - Math.sin(Math.PI / 2 - bo) * (De + .007), Xi.highPointCorner.z = fo.z + Math.cos(Math.PI / 2 - bo) * (.65 * De + .007), Xi.highPointCorner.x = fo.x - Math.sin(Math.PI / 2 - bo) * (.65 * De + .007), Xi.angle = bo);
                            let _o = Math.atan(-yo);
                            if (yo < 0 && (_o = Math.PI + _o), Gi.rotation.set(0, _o, 0), Gi.position.set(xo.x, xo.y, -xo.z), Gi.scale.set((l + 2 * K) / r, (l + 2 * K) / r, (l + 2 * K) / r), j.add(Gi), Q.current += 1, ji.traverse((e => {
                                    e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = I))
                                })), t) ji.getObjectByName(Vi).material = vt;
                            else {
                                let Mo = ji.getObjectByName(Vi);
                                Mo.parent.remove(Mo)
                            }
                            if (Gi.traverse((e => {
                                    e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = I))
                                })), t) Gi.getObjectByName(qi).material = vt;
                            else {
                                let wo = Gi.getObjectByName(qi);
                                wo.parent.remove(wo)
                            }
                        }
                        let Ki = [];
                        Te.x = Xi.highPoint.x + Math.sin(Xi.angle) * l / (1.54 - .025 * te.remainder), Te.z = Xi.highPoint.z + Math.cos(Xi.angle) * l / (1.54 - .025 * te.remainder);
                        const Ji = {
                            x: Xi.highPointCorner.x + Math.sin(Xi.angle) * l / 1.8,
                            z: Xi.highPointCorner.z + Math.cos(Xi.angle) * l / 1.8
                        };

                        function Yi(e, t, n) {
                            Ki.push(e, t, n);
                            const r = new Xy(.01, 32, 32);
                            new zh(r, Ge).position.set(e, t, n)
                        }
                        const Qi = 10,
                            Zi = .07 * l,
                            $i = Math.abs(Math.atan((oe.x - Te.x) / (-oe.z - Te.z)));
                        for (let Ao = 0; Ao <= Qi; Ao++) {
                            const So = .001 * l + .001 * l * (Qi - Ao) / Qi;
                            let Eo = .05 * l + .05 * l * (Qi - Ao) / Qi;
                            Ao >= Qi - 1 && (Eo = .05 * Math.sin(Math.PI - Math.PI / 2 * (Qi - Ao) / 2) * l + .05 * Math.sin(Math.PI - Math.PI / 2 * (Qi - Ao) / 2) * l * (Qi - Ao) / Qi);
                            const Co = Math.PI / 4 + Math.pow(1 + 3 * Math.PI / 4, (Ao + 1) / (Qi + 1)) - 1,
                                To = Math.sin(Co) * Zi * Math.sin(Math.PI / 2 - $i),
                                Po = Math.sin(Co) * Zi * Math.cos(Math.PI / 2 - $i),
                                Ro = Ao / Qi * oe.x + (1 - Ao / Qi) * Te.x + To,
                                Io = Ao / Qi * -oe.z + (1 - Ao / Qi) * Te.z - Po,
                                Oo = Ao / Qi * oe.x + (1 - Ao / Qi) * Pe.x,
                                Bo = Ao / Qi * -oe.z + (1 - Ao / Qi) * Pe.z;
                            Yi(Oo, (l + 2 * K + .001) / 2, Bo);
                            for (let Lo = 0; Lo < O; Lo++) {
                                const Do = Math.PI / O * Lo,
                                    No = Math.PI * (Lo / O * 3.5 - .75) + Math.PI,
                                    ko = (l + 2 * K) / 2 * Math.cos(Do),
                                    Fo = Math.cos(No) * So * Math.sin(Math.PI / 2 - $i) * -Math.cos(0),
                                    Uo = Math.cos(No) * So * Math.cos(Math.PI / 2 - $i) * -Math.cos(0),
                                    zo = Ao / Qi * (Math.sin(Do) * Eo * Math.sin(Math.PI / 2 - $i) * -Math.cos(Math.PI * Ao / Qi)) + (1 - Ao / Qi) * Fo,
                                    Ho = Ao / Qi * (Math.sin(Do) * Eo * Math.cos(Math.PI / 2 - $i) * -Math.cos(Math.PI * Ao / Qi)) + (1 - Ao / Qi) * Uo;
                                0 === Lo || 23 === Lo ? Yi(Ao / Qi * oe.x + (1 - Ao / Qi) * Ji.x + To + zo, ko, Ao / Qi * -oe.z + (1 - Ao / Qi) * Ji.z - Po - Ho) : 1 === Lo || 22 === Lo ? Yi(Ao / Qi * oe.x + (1 - Ao / Qi) * (.67 * Ji.x + .33 * Te.x) + To + zo, ko, Ao / Qi * -oe.z + (1 - Ao / Qi) * (.67 * Ji.z + .33 * Te.z) - Po - Ho) : 2 === Lo || 21 === Lo ? Yi(Ao / Qi * oe.x + (1 - Ao / Qi) * (.33 * Ji.x + .67 * Te.x) + To + zo, ko, Ao / Qi * -oe.z + (1 - Ao / Qi) * (.33 * Ji.z + .67 * Te.z) - Po - Ho) : 3 === Lo || 20 === Lo ? Yi(Ao / Qi * oe.x + (1 - Ao / Qi) * (.15 * Ji.x + .85 * Te.x) + To + zo, ko, Ao / Qi * -oe.z + (1 - Ao / Qi) * (.15 * Ji.z + .85 * Te.z) - Po - Ho) : 4 === Lo || 19 === Lo ? Yi(Ao / Qi * oe.x + (1 - Ao / Qi) * (.06 * Ji.x + .94 * Te.x) + To + zo, ko, Ao / Qi * -oe.z + (1 - Ao / Qi) * (.06 * Ji.z + .94 * Te.z) - Po - Ho) : Yi(Ro + zo, ko, Io - Ho)
                            }
                            Yi(Oo, -(l + 2 * K + .001) / 2, Bo)
                        }
                        let eo = new Mh,
                            to = [];
                        const no = 26;
                        for (let jo = 0; jo < Qi; jo++)
                            for (let Go = 0; Go < no - 1; Go++) {
                                const Vo = jo * no + Go;
                                let qo = (jo + 1) * no + Go;
                                const Wo = jo * no + Go + 1,
                                    Xo = (jo + 1) * no + Go + 1,
                                    Ko = Ki.length / 3;
                                Vo >= Ko || qo >= Ko || Wo >= Ko || Xo >= Ko || (to.push(Vo, qo, Wo), to.push(qo, Xo, Wo))
                            }
                        eo.setAttribute("position", new ph(Ki, 3)), eo.setIndex(to), eo.computeVertexNormals(), eo.setAttribute("uv", new ph(new Float32Array([]), 2));
                        const ro = new zh(eo, I);
                        ro.position.set(0, 0, 0), j.add(ro), Ki = [];
                        for (let Jo = 0; Jo <= Qi; Jo++) {
                            const Yo = .001 * l + .001 * l * (Qi - Jo) / Qi;
                            let Qo = .05 * l + .05 * l * (Qi - Jo) / Qi;
                            Jo >= Qi - 1 && (Qo = .05 * Math.sin(Math.PI - Math.PI / 2 * (Qi - Jo) / 2) * l + .05 * Math.sin(Math.PI - Math.PI / 2 * (Qi - Jo) / 2) * l * (Qi - Jo) / Qi);
                            const Zo = Math.PI / 4 + Math.pow(1 + 3 * Math.PI / 4, (Jo + 1) / (Qi + 1)) - 1,
                                $o = Math.sin(Zo) * Zi * Math.sin(Math.PI / 2 - $i),
                                ea = Math.sin(Zo) * Zi * Math.cos(Math.PI / 2 - $i),
                                ta = Jo / Qi * oe.x + (1 - Jo / Qi) * Te.x + $o,
                                na = Jo / Qi * -oe.z + (1 - Jo / Qi) * Te.z - ea,
                                ra = Jo / Qi * oe.x + (1 - Jo / Qi) * Pe.x,
                                ia = Jo / Qi * -oe.z + (1 - Jo / Qi) * Pe.z;
                            Yi(ra, (l + 2 * K + .001) / 2, -ia);
                            for (let oa = 0; oa < O; oa++) {
                                const aa = Math.PI / O * oa,
                                    sa = Math.PI * (oa / O * 3.5 - .75) + Math.PI,
                                    la = (l + 2 * K) / 2 * Math.cos(aa),
                                    ca = Math.cos(sa) * Yo * Math.sin(Math.PI / 2 - $i) * -Math.cos(0),
                                    ua = Math.cos(sa) * Yo * Math.cos(Math.PI / 2 - $i) * -Math.cos(0),
                                    da = Jo / Qi * (Math.sin(aa) * Qo * Math.sin(Math.PI / 2 - $i) * -Math.cos(Math.PI * Jo / Qi)) + (1 - Jo / Qi) * ca,
                                    ha = Jo / Qi * (Math.sin(aa) * Qo * Math.cos(Math.PI / 2 - $i) * -Math.cos(Math.PI * Jo / Qi)) + (1 - Jo / Qi) * ua;
                                0 === oa || 23 === oa ? Yi(Jo / Qi * oe.x + (1 - Jo / Qi) * Ji.x + $o + da, la, -(Jo / Qi * -oe.z + (1 - Jo / Qi) * Ji.z - ea - ha)) : 1 === oa || 22 === oa ? Yi(Jo / Qi * oe.x + (1 - Jo / Qi) * (.67 * Ji.x + .33 * Te.x) + $o + da, la, -(Jo / Qi * -oe.z + (1 - Jo / Qi) * (.67 * Ji.z + .33 * Te.z) - ea - ha)) : 2 === oa || 21 === oa ? Yi(Jo / Qi * oe.x + (1 - Jo / Qi) * (.33 * Ji.x + .67 * Te.x) + $o + da, la, -(Jo / Qi * -oe.z + (1 - Jo / Qi) * (.33 * Ji.z + .67 * Te.z) - ea - ha)) : 3 === oa || 20 === oa ? Yi(Jo / Qi * oe.x + (1 - Jo / Qi) * (.15 * Ji.x + .85 * Te.x) + $o + da, la, -(Jo / Qi * -oe.z + (1 - Jo / Qi) * (.15 * Ji.z + .85 * Te.z) - ea - ha)) : 4 === oa || 19 === oa ? Yi(Jo / Qi * oe.x + (1 - Jo / Qi) * (.06 * Ji.x + .94 * Te.x) + $o + da, la, -(Jo / Qi * -oe.z + (1 - Jo / Qi) * (.06 * Ji.z + .94 * Te.z) - ea - ha)) : Yi(ta + da, la, -(na - ha))
                            }
                            Yi(ra, -(l + 2 * K + .001) / 2, -ia)
                        }
                        eo = new Mh, to = [];
                        for (let pa = 0; pa < Qi; pa++)
                            for (let fa = 0; fa < no - 1; fa++) {
                                const ma = pa * no + fa;
                                let ga = (pa + 1) * no + fa;
                                const va = pa * no + fa + 1,
                                    ya = (pa + 1) * no + fa + 1,
                                    ba = Ki.length / 3;
                                ma >= ba || ga >= ba || va >= ba || ya >= ba || (to.push(ma, va, ga), to.push(ya, ga, va))
                            }
                        eo.setAttribute("position", new ph(Ki, 3)), eo.setIndex(to), eo.computeVertexNormals(), eo.setAttribute("uv", new ph(new Float32Array([]), 2));
                        const io = new zh(eo, I);
                        io.position.set(0, 0, 0), j.add(io)
                    }
                }
            }), [j, s, u, d, a, l, M, I, R, S]), j.rotation.order = "XYZ", j.rotation.set(Math.PI / 2, Math.PI / 2, 0), j.position.set(...A), (0, r.useEffect)((() => {
                if ("None" !== d) {
                    let e = .8,
                        t = .9;
                    O([{
                        quantity: Q.current,
                        size: e / t * l,
                        shape: "Round",
                        style: "Petite French Pave"
                    }])
                } else O([])
            }), [h, d, l, Z, ee, $, c, _]), (0, Nn.jsx)(Nn.Fragment, {
                children: (0, Nn.jsx)("primitive", {
                    object: j,
                    scale: i
                })
            })
        };

        function gT(e) {
            let {
                diamondsVisibility: t,
                bandMetal: n,
                scaleReducerVector: i,
                scaleReducer: o,
                bandStyle: a,
                bandFit: s,
                bandWidth: l,
                ringSize: c,
                bandInnerRadius: u,
                bandPaveStyle: d,
                bandPaveLength: h,
                halosVerticalPlacement: p,
                centerHaloThickness: f,
                centerBezelTopThickness: m,
                centerBezelBottomThickness: g,
                basketsVerticalPlacement: v,
                basketsDimensions: y,
                headProperties: b,
                cathedral: x,
                headCount: _,
                prongWidths: M,
                headRotations: w,
                extraMetal: A,
                centerStoneCheckForKiteOrCompass: S,
                centerStoneCheckForProngPave: E,
                numberOfElements: C
            } = e;
            return (0, Nn.jsxs)(r.Suspense, {
                children: [(0, Nn.jsx)(CA, {
                    files: "Mod blurred x2 contrast_v6_90.hdr"
                }), (0, Nn.jsx)(mT, {
                    position: [0, 0, 0],
                    diamondsVisibility: t,
                    bandMetal: n,
                    scaleReducerVector: i,
                    scaleReducer: o,
                    bandStyle: a,
                    bandFit: s,
                    bandWidth: l,
                    ringSize: c,
                    bandInnerRadius: u,
                    bandPaveStyle: d,
                    bandPaveLength: h,
                    halosVerticalPlacement: p,
                    centerHaloThickness: f,
                    centerBezelTopThickness: m,
                    centerBezelBottomThickness: g,
                    basketsVerticalPlacement: v,
                    basketsDimensions: y,
                    headProperties: b,
                    cathedral: x,
                    headCount: _,
                    prongWidths: M,
                    headRotations: w,
                    extraMetal: A,
                    centerStoneCheckForKiteOrCompass: S,
                    centerStoneCheckForProngPave: E,
                    numberOfElements: C
                })]
            })
        }
        const vT = new WeakMap;
        class yT extends Lb {
            constructor(e) {
                super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
                    position: "POSITION",
                    normal: "NORMAL",
                    color: "COLOR",
                    uv: "TEX_COORD"
                }, this.defaultAttributeTypes = {
                    position: "Float32Array",
                    normal: "Float32Array",
                    color: "Float32Array",
                    uv: "Float32Array"
                }
            }
            setDecoderPath(e) {
                return this.decoderPath = e, this
            }
            setDecoderConfig(e) {
                return this.decoderConfig = e, this
            }
            setWorkerLimit(e) {
                return this.workerLimit = e, this
            }
            load(e, t, n, r) {
                const i = new kb(this.manager);
                i.setPath(this.path), i.setResponseType("arraybuffer"), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(e, (e => {
                    const n = {
                        attributeIDs: this.defaultAttributeIDs,
                        attributeTypes: this.defaultAttributeTypes,
                        useUniqueIDs: !1
                    };
                    this.decodeGeometry(e, n).then(t).catch(r)
                }), n, r)
            }
            decodeDracoFile(e, t, n, r) {
                const i = {
                    attributeIDs: n || this.defaultAttributeIDs,
                    attributeTypes: r || this.defaultAttributeTypes,
                    useUniqueIDs: !!n
                };
                this.decodeGeometry(e, i).then(t)
            }
            decodeGeometry(e, t) {
                for (const s in t.attributeTypes) {
                    const e = t.attributeTypes[s];
                    void 0 !== e.BYTES_PER_ELEMENT && (t.attributeTypes[s] = e.name)
                }
                const n = JSON.stringify(t);
                if (vT.has(e)) {
                    const t = vT.get(e);
                    if (t.key === n) return t.promise;
                    if (0 === e.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                }
                let r;
                const i = this.workerNextTaskID++,
                    o = e.byteLength,
                    a = this._getWorker(i, o).then((n => (r = n, new Promise(((n, o) => {
                        r._callbacks[i] = {
                            resolve: n,
                            reject: o
                        }, r.postMessage({
                            type: "decode",
                            id: i,
                            taskConfig: t,
                            buffer: e
                        }, [e])
                    }))))).then((e => this._createGeometry(e.geometry)));
                return a.catch((() => !0)).then((() => {
                    r && i && this._releaseTask(r, i)
                })), vT.set(e, {
                    key: n,
                    promise: a
                }), a
            }
            _createGeometry(e) {
                const t = new Mh;
                e.index && t.setIndex(new ih(e.index.array, 1));
                for (let n = 0; n < e.attributes.length; n++) {
                    const r = e.attributes[n],
                        i = r.name,
                        o = r.array,
                        a = r.itemSize;
                    t.setAttribute(i, new ih(o, a))
                }
                return t
            }
            _loadLibrary(e, t) {
                const n = new kb(this.manager);
                return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise(((t, r) => {
                    n.load(e, t, void 0, r)
                }))
            }
            preload() {
                return this._initDecoder(), this
            }
            _initDecoder() {
                if (this.decoderPending) return this.decoderPending;
                const e = "object" !== typeof WebAssembly || "js" === this.decoderConfig.type,
                    t = [];
                return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((t => {
                    const n = t[0];
                    e || (this.decoderConfig.wasmBinary = t[1]);
                    const r = bT.toString(),
                        i = ["/* draco decoder */", n, "", "/* worker */", r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))].join("\n");
                    this.workerSourceURL = URL.createObjectURL(new Blob([i]))
                })), this.decoderPending
            }
            _getWorker(e, t) {
                return this._initDecoder().then((() => {
                    if (this.workerPool.length < this.workerLimit) {
                        const e = new Worker(this.workerSourceURL);
                        e._callbacks = {}, e._taskCosts = {}, e._taskLoad = 0, e.postMessage({
                            type: "init",
                            decoderConfig: this.decoderConfig
                        }), e.onmessage = function(t) {
                            const n = t.data;
                            switch (n.type) {
                                case "decode":
                                    e._callbacks[n.id].resolve(n);
                                    break;
                                case "error":
                                    e._callbacks[n.id].reject(n);
                                    break;
                                default:
                                    console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"')
                            }
                        }, this.workerPool.push(e)
                    } else this.workerPool.sort((function(e, t) {
                        return e._taskLoad > t._taskLoad ? -1 : 1
                    }));
                    const n = this.workerPool[this.workerPool.length - 1];
                    return n._taskCosts[e] = t, n._taskLoad += t, n
                }))
            }
            _releaseTask(e, t) {
                e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t]
            }
            debug() {
                console.log("Task load: ", this.workerPool.map((e => e._taskLoad)))
            }
            dispose() {
                for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
                return this.workerPool.length = 0, this
            }
        }

        function bT() {
            let e, t;

            function n(e, t, n, r, i, o) {
                const a = o.num_components(),
                    s = n.num_points() * a,
                    l = s * i.BYTES_PER_ELEMENT,
                    c = function(e, t) {
                        switch (t) {
                            case Float32Array:
                                return e.DT_FLOAT32;
                            case Int8Array:
                                return e.DT_INT8;
                            case Int16Array:
                                return e.DT_INT16;
                            case Int32Array:
                                return e.DT_INT32;
                            case Uint8Array:
                                return e.DT_UINT8;
                            case Uint16Array:
                                return e.DT_UINT16;
                            case Uint32Array:
                                return e.DT_UINT32
                        }
                    }(e, i),
                    u = e._malloc(l);
                t.GetAttributeDataArrayForAllPoints(n, o, c, l, u);
                const d = new i(e.HEAPF32.buffer, u, s).slice();
                return e._free(u), {
                    name: r,
                    array: d,
                    itemSize: a
                }
            }
            onmessage = function(r) {
                const i = r.data;
                switch (i.type) {
                    case "init":
                        e = i.decoderConfig, t = new Promise((function(t) {
                            e.onModuleLoaded = function(e) {
                                t({
                                    draco: e
                                })
                            }, DracoDecoderModule(e)
                        }));
                        break;
                    case "decode":
                        const r = i.buffer,
                            o = i.taskConfig;
                        t.then((e => {
                            const t = e.draco,
                                a = new t.Decoder,
                                s = new t.DecoderBuffer;
                            s.Init(new Int8Array(r), r.byteLength);
                            try {
                                const e = function(e, t, r, i) {
                                        const o = i.attributeIDs,
                                            a = i.attributeTypes;
                                        let s, l;
                                        const c = t.GetEncodedGeometryType(r);
                                        if (c === e.TRIANGULAR_MESH) s = new e.Mesh, l = t.DecodeBufferToMesh(r, s);
                                        else {
                                            if (c !== e.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                            s = new e.PointCloud, l = t.DecodeBufferToPointCloud(r, s)
                                        }
                                        if (!l.ok() || 0 === s.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
                                        const u = {
                                            index: null,
                                            attributes: []
                                        };
                                        for (const d in o) {
                                            const r = self[a[d]];
                                            let l, c;
                                            if (i.useUniqueIDs) c = o[d], l = t.GetAttributeByUniqueId(s, c);
                                            else {
                                                if (c = t.GetAttributeId(s, e[o[d]]), -1 === c) continue;
                                                l = t.GetAttribute(s, c)
                                            }
                                            u.attributes.push(n(e, t, s, d, r, l))
                                        }
                                        c === e.TRIANGULAR_MESH && (u.index = function(e, t, n) {
                                            const r = n.num_faces(),
                                                i = 3 * r,
                                                o = 4 * i,
                                                a = e._malloc(o);
                                            t.GetTrianglesUInt32Array(n, o, a);
                                            const s = new Uint32Array(e.HEAPF32.buffer, a, i).slice();
                                            return e._free(a), {
                                                array: s,
                                                itemSize: 1
                                            }
                                        }(e, t, s));
                                        return e.destroy(s), u
                                    }(t, a, s, o),
                                    r = e.attributes.map((e => e.array.buffer));
                                e.index && r.push(e.index.array.buffer), self.postMessage({
                                    type: "decode",
                                    id: i.id,
                                    geometry: e
                                }, r)
                            } catch (l) {
                                console.error(l), self.postMessage({
                                    type: "error",
                                    id: i.id,
                                    error: l.message
                                })
                            } finally {
                                t.destroy(s), t.destroy(a)
                            }
                        }))
                }
            }
        }
        let xT;
        const _T = () => {
            if (xT) return xT;
            const e = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]),
                t = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]);
            if ("object" !== typeof WebAssembly) return {
                supported: !1
            };
            let n, r = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB";
            WebAssembly.validate(e) && (r = "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB");
            const i = WebAssembly.instantiate(function(e) {
                const n = new Uint8Array(e.length);
                for (let t = 0; t < e.length; ++t) {
                    const r = e.charCodeAt(t);
                    n[t] = r > 96 ? r - 71 : r > 64 ? r - 65 : r > 47 ? r + 4 : r > 46 ? 63 : 62
                }
                let r = 0;
                for (let i = 0; i < e.length; ++i) n[r++] = n[i] < 60 ? t[n[i]] : 64 * (n[i] - 60) + n[++i];
                return n.buffer.slice(0, r)
            }(r), {}).then((e => {
                n = e.instance, n.exports.__wasm_call_ctors()
            }));

            function o(e, t, r, i, o, a) {
                const s = n.exports.sbrk,
                    l = r + 3 & -4,
                    c = s(l * i),
                    u = s(o.length),
                    d = new Uint8Array(n.exports.memory.buffer);
                d.set(o, u);
                const h = e(c, r, i, u, o.length);
                if (0 === h && a && a(c, l, i), t.set(d.subarray(c, c + r * i)), s(c - s(0)), 0 !== h) throw new Error("Malformed buffer data: ".concat(h))
            }
            const a = {
                    0: "",
                    1: "meshopt_decodeFilterOct",
                    2: "meshopt_decodeFilterQuat",
                    3: "meshopt_decodeFilterExp",
                    NONE: "",
                    OCTAHEDRAL: "meshopt_decodeFilterOct",
                    QUATERNION: "meshopt_decodeFilterQuat",
                    EXPONENTIAL: "meshopt_decodeFilterExp"
                },
                s = {
                    0: "meshopt_decodeVertexBuffer",
                    1: "meshopt_decodeIndexBuffer",
                    2: "meshopt_decodeIndexSequence",
                    ATTRIBUTES: "meshopt_decodeVertexBuffer",
                    TRIANGLES: "meshopt_decodeIndexBuffer",
                    INDICES: "meshopt_decodeIndexSequence"
                };
            return xT = {
                ready: i,
                supported: !0,
                decodeVertexBuffer(e, t, r, i, s) {
                    o(n.exports.meshopt_decodeVertexBuffer, e, t, r, i, n.exports[a[s]])
                },
                decodeIndexBuffer(e, t, r, i) {
                    o(n.exports.meshopt_decodeIndexBuffer, e, t, r, i)
                },
                decodeIndexSequence(e, t, r, i) {
                    o(n.exports.meshopt_decodeIndexSequence, e, t, r, i)
                },
                decodeGltfBuffer(e, t, r, i, l, c) {
                    o(n.exports[s[l]], e, t, r, i, n.exports[a[c]])
                }
            }, xT
        };

        function MT(e, t) {
            if (t === Ll) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), e;
            if (t === Nl || t === Dl) {
                let n = e.getIndex();
                if (null === n) {
                    const t = [],
                        r = e.getAttribute("position");
                    if (void 0 === r) return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e;
                    for (let e = 0; e < r.count; e++) t.push(e);
                    e.setIndex(t), n = e.getIndex()
                }
                const r = n.count - 2,
                    i = [];
                if (n)
                    if (t === Nl)
                        for (let e = 1; e <= r; e++) i.push(n.getX(0)), i.push(n.getX(e)), i.push(n.getX(e + 1));
                    else
                        for (let e = 0; e < r; e++) e % 2 === 0 ? (i.push(n.getX(e)), i.push(n.getX(e + 1)), i.push(n.getX(e + 2))) : (i.push(n.getX(e + 2)), i.push(n.getX(e + 1)), i.push(n.getX(e)));
                i.length / 3 !== r && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                const o = e.clone();
                return o.setIndex(i), o.clearGroups(), o
            }
            return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t), e
        }
        const wT = parseInt(Zo.replace(/\D+/g, ""));
        class AT extends Lb {
            constructor(e) {
                super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function(e) {
                    return new RT(e)
                })), this.register((function(e) {
                    return new FT(e)
                })), this.register((function(e) {
                    return new UT(e)
                })), this.register((function(e) {
                    return new zT(e)
                })), this.register((function(e) {
                    return new OT(e)
                })), this.register((function(e) {
                    return new BT(e)
                })), this.register((function(e) {
                    return new LT(e)
                })), this.register((function(e) {
                    return new DT(e)
                })), this.register((function(e) {
                    return new PT(e)
                })), this.register((function(e) {
                    return new NT(e)
                })), this.register((function(e) {
                    return new IT(e)
                })), this.register((function(e) {
                    return new kT(e)
                })), this.register((function(e) {
                    return new CT(e)
                })), this.register((function(e) {
                    return new HT(e)
                })), this.register((function(e) {
                    return new jT(e)
                }))
            }
            load(e, t, n, r) {
                const i = this;
                let o;
                o = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : ux.extractUrlBase(e), this.manager.itemStart(e);
                const a = function(t) {
                        r ? r(t) : console.error(t), i.manager.itemError(e), i.manager.itemEnd(e)
                    },
                    s = new kb(this.manager);
                s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (function(n) {
                    try {
                        i.parse(n, o, (function(n) {
                            t(n), i.manager.itemEnd(e)
                        }), a)
                    } catch (ER) {
                        a(ER)
                    }
                }), n, a)
            }
            setDRACOLoader(e) {
                return this.dracoLoader = e, this
            }
            setDDSLoader() {
                throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
            }
            setKTX2Loader(e) {
                return this.ktx2Loader = e, this
            }
            setMeshoptDecoder(e) {
                return this.meshoptDecoder = e, this
            }
            register(e) {
                return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this
            }
            unregister(e) {
                return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
            }
            parse(e, t, n, r) {
                let i;
                const o = {},
                    a = {};
                if ("string" === typeof e) i = JSON.parse(e);
                else if (e instanceof ArrayBuffer) {
                    if (ux.decodeText(new Uint8Array(e.slice(0, 4))) === GT) {
                        try {
                            o[ET.KHR_BINARY_GLTF] = new WT(e)
                        } catch (l) {
                            return void(r && r(l))
                        }
                        i = JSON.parse(o[ET.KHR_BINARY_GLTF].content)
                    } else i = JSON.parse(ux.decodeText(new Uint8Array(e)))
                } else i = e;
                if (void 0 === i.asset || i.asset.version[0] < 2) return void(r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                const s = new yP(i, {
                    path: t || this.resourcePath || "",
                    crossOrigin: this.crossOrigin,
                    requestHeader: this.requestHeader,
                    manager: this.manager,
                    ktx2Loader: this.ktx2Loader,
                    meshoptDecoder: this.meshoptDecoder
                });
                s.fileLoader.setRequestHeader(this.requestHeader);
                for (let c = 0; c < this.pluginCallbacks.length; c++) {
                    const e = this.pluginCallbacks[c](s);
                    a[e.name] = e, o[e.name] = !0
                }
                if (i.extensionsUsed)
                    for (let c = 0; c < i.extensionsUsed.length; ++c) {
                        const e = i.extensionsUsed[c],
                            t = i.extensionsRequired || [];
                        switch (e) {
                            case ET.KHR_MATERIALS_UNLIT:
                                o[e] = new TT;
                                break;
                            case ET.KHR_DRACO_MESH_COMPRESSION:
                                o[e] = new XT(i, this.dracoLoader);
                                break;
                            case ET.KHR_TEXTURE_TRANSFORM:
                                o[e] = new KT;
                                break;
                            case ET.KHR_MESH_QUANTIZATION:
                                o[e] = new JT;
                                break;
                            default:
                                t.indexOf(e) >= 0 && void 0 === a[e] && console.warn('THREE.GLTFLoader: Unknown extension "' + e + '".')
                        }
                    }
                s.setExtensions(o), s.setPlugins(a), s.parse(n, r)
            }
            parseAsync(e, t) {
                const n = this;
                return new Promise((function(r, i) {
                    n.parse(e, t, r, i)
                }))
            }
        }

        function ST() {
            let e = {};
            return {
                get: function(t) {
                    return e[t]
                },
                add: function(t, n) {
                    e[t] = n
                },
                remove: function(t) {
                    delete e[t]
                },
                removeAll: function() {
                    e = {}
                }
            }
        }
        const ET = {
            KHR_BINARY_GLTF: "KHR_binary_glTF",
            KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
            KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
            KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
            KHR_MATERIALS_IOR: "KHR_materials_ior",
            KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
            KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
            KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
            KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
            KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
            KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
            KHR_MATERIALS_VOLUME: "KHR_materials_volume",
            KHR_TEXTURE_BASISU: "KHR_texture_basisu",
            KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
            KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
            KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
            EXT_TEXTURE_WEBP: "EXT_texture_webp",
            EXT_TEXTURE_AVIF: "EXT_texture_avif",
            EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
            EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
        };
        class CT {
            constructor(e) {
                this.parser = e, this.name = ET.KHR_LIGHTS_PUNCTUAL, this.cache = {
                    refs: {},
                    uses: {}
                }
            }
            _markDefs() {
                const e = this.parser,
                    t = this.parser.json.nodes || [];
                for (let n = 0, r = t.length; n < r; n++) {
                    const r = t[n];
                    r.extensions && r.extensions[this.name] && void 0 !== r.extensions[this.name].light && e._addNodeRef(this.cache, r.extensions[this.name].light)
                }
            }
            _loadLight(e) {
                const t = this.parser,
                    n = "light:" + e;
                let r = t.cache.get(n);
                if (r) return r;
                const i = t.json,
                    o = ((i.extensions && i.extensions[this.name] || {}).lights || [])[e];
                let a;
                const s = new Wd(16777215);
                void 0 !== o.color && s.fromArray(o.color);
                const l = void 0 !== o.range ? o.range : 0;
                switch (o.type) {
                    case "directional":
                        a = new ix(s), a.target.position.set(0, 0, -1), a.add(a.target);
                        break;
                    case "point":
                        a = new nx(s), a.distance = l;
                        break;
                    case "spot":
                        a = new Qb(s), a.distance = l, o.spot = o.spot || {}, o.spot.innerConeAngle = void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0, o.spot.outerConeAngle = void 0 !== o.spot.outerConeAngle ? o.spot.outerConeAngle : Math.PI / 4, a.angle = o.spot.outerConeAngle, a.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle, a.target.position.set(0, 0, -1), a.add(a.target);
                        break;
                    default:
                        throw new Error("THREE.GLTFLoader: Unexpected light type: " + o.type)
                }
                return a.position.set(0, 0, 0), a.decay = 2, hP(a, o), void 0 !== o.intensity && (a.intensity = o.intensity), a.name = t.createUniqueName(o.name || "light_" + e), r = Promise.resolve(a), t.cache.add(n, r), r
            }
            getDependency(e, t) {
                if ("light" === e) return this._loadLight(t)
            }
            createNodeAttachment(e) {
                const t = this,
                    n = this.parser,
                    r = n.json.nodes[e],
                    i = (r.extensions && r.extensions[this.name] || {}).light;
                return void 0 === i ? null : this._loadLight(i).then((function(e) {
                    return n._getNodeRef(t.cache, i, e)
                }))
            }
        }
        class TT {
            constructor() {
                this.name = ET.KHR_MATERIALS_UNLIT
            }
            getMaterialType() {
                return Yd
            }
            extendParams(e, t, n) {
                const r = [];
                e.color = new Wd(1, 1, 1), e.opacity = 1;
                const i = t.pbrMetallicRoughness;
                if (i) {
                    if (Array.isArray(i.baseColorFactor)) {
                        const t = i.baseColorFactor;
                        e.color.fromArray(t), e.opacity = t[3]
                    }
                    void 0 !== i.baseColorTexture && r.push(n.assignTexture(e, "map", i.baseColorTexture, 3001))
                }
                return Promise.all(r)
            }
        }
        class PT {
            constructor(e) {
                this.parser = e, this.name = ET.KHR_MATERIALS_EMISSIVE_STRENGTH
            }
            extendMaterialParams(e, t) {
                const n = this.parser.json.materials[e];
                if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                const r = n.extensions[this.name].emissiveStrength;
                return void 0 !== r && (t.emissiveIntensity = r), Promise.resolve()
            }
        }
        class RT {
            constructor(e) {
                this.parser = e, this.name = ET.KHR_MATERIALS_CLEARCOAT
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ib : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                const i = [],
                    o = r.extensions[this.name];
                if (void 0 !== o.clearcoatFactor && (t.clearcoat = o.clearcoatFactor), void 0 !== o.clearcoatTexture && i.push(n.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), void 0 !== o.clearcoatRoughnessFactor && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), void 0 !== o.clearcoatRoughnessTexture && i.push(n.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), void 0 !== o.clearcoatNormalTexture && (i.push(n.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), void 0 !== o.clearcoatNormalTexture.scale)) {
                    const e = o.clearcoatNormalTexture.scale;
                    t.clearcoatNormalScale = new Yc(e, e)
                }
                return Promise.all(i)
            }
        }
        class IT {
            constructor(e) {
                this.parser = e, this.name = ET.KHR_MATERIALS_IRIDESCENCE
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ib : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                const i = [],
                    o = r.extensions[this.name];
                return void 0 !== o.iridescenceFactor && (t.iridescence = o.iridescenceFactor), void 0 !== o.iridescenceTexture && i.push(n.assignTexture(t, "iridescenceMap", o.iridescenceTexture)), void 0 !== o.iridescenceIor && (t.iridescenceIOR = o.iridescenceIor), void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]), void 0 !== o.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), void 0 !== o.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), void 0 !== o.iridescenceThicknessTexture && i.push(n.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)), Promise.all(i)
            }
        }
        class OT {
            constructor(e) {
                this.parser = e, this.name = ET.KHR_MATERIALS_SHEEN
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ib : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                const i = [];
                t.sheenColor = new Wd(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
                const o = r.extensions[this.name];
                return void 0 !== o.sheenColorFactor && t.sheenColor.fromArray(o.sheenColorFactor), void 0 !== o.sheenRoughnessFactor && (t.sheenRoughness = o.sheenRoughnessFactor), void 0 !== o.sheenColorTexture && i.push(n.assignTexture(t, "sheenColorMap", o.sheenColorTexture, 3001)), void 0 !== o.sheenRoughnessTexture && i.push(n.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(i)
            }
        }
        class BT {
            constructor(e) {
                this.parser = e, this.name = ET.KHR_MATERIALS_TRANSMISSION
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ib : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                const i = [],
                    o = r.extensions[this.name];
                return void 0 !== o.transmissionFactor && (t.transmission = o.transmissionFactor), void 0 !== o.transmissionTexture && i.push(n.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(i)
            }
        }
        class LT {
            constructor(e) {
                this.parser = e, this.name = ET.KHR_MATERIALS_VOLUME
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ib : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                const i = [],
                    o = r.extensions[this.name];
                t.thickness = void 0 !== o.thicknessFactor ? o.thicknessFactor : 0, void 0 !== o.thicknessTexture && i.push(n.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0;
                const a = o.attenuationColor || [1, 1, 1];
                return t.attenuationColor = new Wd(a[0], a[1], a[2]), Promise.all(i)
            }
        }
        class DT {
            constructor(e) {
                this.parser = e, this.name = ET.KHR_MATERIALS_IOR
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ib : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser.json.materials[e];
                if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                const r = n.extensions[this.name];
                return t.ior = void 0 !== r.ior ? r.ior : 1.5, Promise.resolve()
            }
        }
        class NT {
            constructor(e) {
                this.parser = e, this.name = ET.KHR_MATERIALS_SPECULAR
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ib : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                const i = [],
                    o = r.extensions[this.name];
                t.specularIntensity = void 0 !== o.specularFactor ? o.specularFactor : 1, void 0 !== o.specularTexture && i.push(n.assignTexture(t, "specularIntensityMap", o.specularTexture));
                const a = o.specularColorFactor || [1, 1, 1];
                return t.specularColor = new Wd(a[0], a[1], a[2]), void 0 !== o.specularColorTexture && i.push(n.assignTexture(t, "specularColorMap", o.specularColorTexture, 3001)), Promise.all(i)
            }
        }
        class kT {
            constructor(e) {
                this.parser = e, this.name = ET.KHR_MATERIALS_ANISOTROPY
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? ib : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                const i = [],
                    o = r.extensions[this.name];
                return void 0 !== o.anisotropyStrength && (t.anisotropy = o.anisotropyStrength), void 0 !== o.anisotropyRotation && (t.anisotropyRotation = o.anisotropyRotation), void 0 !== o.anisotropyTexture && i.push(n.assignTexture(t, "anisotropyMap", o.anisotropyTexture)), Promise.all(i)
            }
        }
        class FT {
            constructor(e) {
                this.parser = e, this.name = ET.KHR_TEXTURE_BASISU
            }
            loadTexture(e) {
                const t = this.parser,
                    n = t.json,
                    r = n.textures[e];
                if (!r.extensions || !r.extensions[this.name]) return null;
                const i = r.extensions[this.name],
                    o = t.options.ktx2Loader;
                if (!o) {
                    if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                    return null
                }
                return t.loadTextureImage(e, i.source, o)
            }
        }
        class UT {
            constructor(e) {
                this.parser = e, this.name = ET.EXT_TEXTURE_WEBP, this.isSupported = null
            }
            loadTexture(e) {
                const t = this.name,
                    n = this.parser,
                    r = n.json,
                    i = r.textures[e];
                if (!i.extensions || !i.extensions[t]) return null;
                const o = i.extensions[t],
                    a = r.images[o.source];
                let s = n.textureLoader;
                if (a.uri) {
                    const e = n.options.manager.getHandler(a.uri);
                    null !== e && (s = e)
                }
                return this.detectSupport().then((function(i) {
                    if (i) return n.loadTextureImage(e, o.source, s);
                    if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                    return n.loadTexture(e)
                }))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function(e) {
                    const t = new Image;
                    t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
                        e(1 === t.height)
                    }
                }))), this.isSupported
            }
        }
        class zT {
            constructor(e) {
                this.parser = e, this.name = ET.EXT_TEXTURE_AVIF, this.isSupported = null
            }
            loadTexture(e) {
                const t = this.name,
                    n = this.parser,
                    r = n.json,
                    i = r.textures[e];
                if (!i.extensions || !i.extensions[t]) return null;
                const o = i.extensions[t],
                    a = r.images[o.source];
                let s = n.textureLoader;
                if (a.uri) {
                    const e = n.options.manager.getHandler(a.uri);
                    null !== e && (s = e)
                }
                return this.detectSupport().then((function(i) {
                    if (i) return n.loadTextureImage(e, o.source, s);
                    if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
                    return n.loadTexture(e)
                }))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function(e) {
                    const t = new Image;
                    t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
                        e(1 === t.height)
                    }
                }))), this.isSupported
            }
        }
        class HT {
            constructor(e) {
                this.name = ET.EXT_MESHOPT_COMPRESSION, this.parser = e
            }
            loadBufferView(e) {
                const t = this.parser.json,
                    n = t.bufferViews[e];
                if (n.extensions && n.extensions[this.name]) {
                    const e = n.extensions[this.name],
                        r = this.parser.getDependency("buffer", e.buffer),
                        i = this.parser.options.meshoptDecoder;
                    if (!i || !i.supported) {
                        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                        return null
                    }
                    return r.then((function(t) {
                        const n = e.byteOffset || 0,
                            r = e.byteLength || 0,
                            o = e.count,
                            a = e.byteStride,
                            s = new Uint8Array(t, n, r);
                        return i.decodeGltfBufferAsync ? i.decodeGltfBufferAsync(o, a, s, e.mode, e.filter).then((function(e) {
                            return e.buffer
                        })) : i.ready.then((function() {
                            const t = new ArrayBuffer(o * a);
                            return i.decodeGltfBuffer(new Uint8Array(t), o, a, s, e.mode, e.filter), t
                        }))
                    }))
                }
                return null
            }
        }
        class jT {
            constructor(e) {
                this.name = ET.EXT_MESH_GPU_INSTANCING, this.parser = e
            }
            createNodeMesh(e) {
                const t = this.parser.json,
                    n = t.nodes[e];
                if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh) return null;
                const r = t.meshes[n.mesh];
                for (const s of r.primitives)
                    if (s.mode !== $T.TRIANGLES && s.mode !== $T.TRIANGLE_STRIP && s.mode !== $T.TRIANGLE_FAN && void 0 !== s.mode) return null;
                const i = n.extensions[this.name].attributes,
                    o = [],
                    a = {};
                for (const s in i) o.push(this.parser.getDependency("accessor", i[s]).then((e => (a[s] = e, a[s]))));
                return o.length < 1 ? null : (o.push(this.parser.createNodeMesh(e)), Promise.all(o).then((e => {
                    const t = e.pop(),
                        n = t.isGroup ? t.children : [t],
                        r = e[0].count,
                        i = [];
                    for (const o of n) {
                        const e = new od,
                            t = new Pu,
                            n = new Tu,
                            s = new Pu(1, 1, 1),
                            l = new Vg(o.geometry, o.material, r);
                        for (let i = 0; i < r; i++) a.TRANSLATION && t.fromBufferAttribute(a.TRANSLATION, i), a.ROTATION && n.fromBufferAttribute(a.ROTATION, i), a.SCALE && s.fromBufferAttribute(a.SCALE, i), l.setMatrixAt(i, e.compose(t, n, s));
                        for (const r in a) "TRANSLATION" !== r && "ROTATION" !== r && "SCALE" !== r && o.geometry.setAttribute(r, a[r]);
                        Rd.prototype.copy.call(l, o), this.parser.assignFinalMaterial(l), i.push(l)
                    }
                    return t.isGroup ? (t.clear(), t.add(...i), t) : i[0]
                })))
            }
        }
        const GT = "glTF",
            VT = 1313821514,
            qT = 5130562;
        class WT {
            constructor(e) {
                this.name = ET.KHR_BINARY_GLTF, this.content = null, this.body = null;
                const t = new DataView(e, 0, 12);
                if (this.header = {
                        magic: ux.decodeText(new Uint8Array(e.slice(0, 4))),
                        version: t.getUint32(4, !0),
                        length: t.getUint32(8, !0)
                    }, this.header.magic !== GT) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                const n = this.header.length - 12,
                    r = new DataView(e, 12);
                let i = 0;
                for (; i < n;) {
                    const t = r.getUint32(i, !0);
                    i += 4;
                    const n = r.getUint32(i, !0);
                    if (i += 4, n === VT) {
                        const n = new Uint8Array(e, 12 + i, t);
                        this.content = ux.decodeText(n)
                    } else if (n === qT) {
                        const n = 12 + i;
                        this.body = e.slice(n, n + t)
                    }
                    i += t
                }
                if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
            }
        }
        class XT {
            constructor(e, t) {
                if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                this.name = ET.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload()
            }
            decodePrimitive(e, t) {
                const n = this.json,
                    r = this.dracoLoader,
                    i = e.extensions[this.name].bufferView,
                    o = e.extensions[this.name].attributes,
                    a = {},
                    s = {},
                    l = {};
                for (const c in o) {
                    const e = iP[c] || c.toLowerCase();
                    a[e] = o[c]
                }
                for (const c in e.attributes) {
                    const t = iP[c] || c.toLowerCase();
                    if (void 0 !== o[c]) {
                        const r = n.accessors[e.attributes[c]],
                            i = eP[r.componentType];
                        l[t] = i.name, s[t] = !0 === r.normalized
                    }
                }
                return t.getDependency("bufferView", i).then((function(e) {
                    return new Promise((function(t) {
                        r.decodeDracoFile(e, (function(e) {
                            for (const t in e.attributes) {
                                const n = e.attributes[t],
                                    r = s[t];
                                void 0 !== r && (n.normalized = r)
                            }
                            t(e)
                        }), a, l)
                    }))
                }))
            }
        }
        class KT {
            constructor() {
                this.name = ET.KHR_TEXTURE_TRANSFORM
            }
            extendTexture(e, t) {
                return void 0 !== t.texCoord && t.texCoord !== e.channel || void 0 !== t.offset || void 0 !== t.rotation || void 0 !== t.scale ? (e = e.clone(), void 0 !== t.texCoord && (e.channel = t.texCoord), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0, e) : e
            }
        }
        class JT {
            constructor() {
                this.name = ET.KHR_MESH_QUANTIZATION
            }
        }
        class YT extends vb {
            constructor(e, t, n, r) {
                super(e, t, n, r)
            }
            copySampleValue_(e) {
                const t = this.resultBuffer,
                    n = this.sampleValues,
                    r = this.valueSize,
                    i = e * r * 3 + r;
                for (let o = 0; o !== r; o++) t[o] = n[i + o];
                return t
            }
            interpolate_(e, t, n, r) {
                const i = this.resultBuffer,
                    o = this.sampleValues,
                    a = this.valueSize,
                    s = 2 * a,
                    l = 3 * a,
                    c = r - t,
                    u = (n - t) / c,
                    d = u * u,
                    h = d * u,
                    p = e * l,
                    f = p - l,
                    m = -2 * h + 3 * d,
                    g = h - d,
                    v = 1 - m,
                    y = g - d + u;
                for (let b = 0; b !== a; b++) {
                    const e = o[f + b + a],
                        t = o[f + b + s] * c,
                        n = o[p + b + a],
                        r = o[p + b] * c;
                    i[b] = v * e + y * t + m * n + g * r
                }
                return i
            }
        }
        const QT = new Tu;
        class ZT extends YT {
            interpolate_(e, t, n, r) {
                const i = super.interpolate_(e, t, n, r);
                return QT.fromArray(i).normalize().toArray(i), i
            }
        }
        const $T = {
                FLOAT: 5126,
                FLOAT_MAT3: 35675,
                FLOAT_MAT4: 35676,
                FLOAT_VEC2: 35664,
                FLOAT_VEC3: 35665,
                FLOAT_VEC4: 35666,
                LINEAR: 9729,
                REPEAT: 10497,
                SAMPLER_2D: 35678,
                POINTS: 0,
                LINES: 1,
                LINE_LOOP: 2,
                LINE_STRIP: 3,
                TRIANGLES: 4,
                TRIANGLE_STRIP: 5,
                TRIANGLE_FAN: 6,
                UNSIGNED_BYTE: 5121,
                UNSIGNED_SHORT: 5123
            },
            eP = {
                5120: Int8Array,
                5121: Uint8Array,
                5122: Int16Array,
                5123: Uint16Array,
                5125: Uint32Array,
                5126: Float32Array
            },
            tP = {
                9728: ps,
                9729: ys,
                9984: fs,
                9985: bs,
                9986: gs,
                9987: _s
            },
            nP = {
                33071: ds,
                33648: hs,
                10497: us
            },
            rP = {
                SCALAR: 1,
                VEC2: 2,
                VEC3: 3,
                VEC4: 4,
                MAT2: 4,
                MAT3: 9,
                MAT4: 16
            },
            iP = {
                POSITION: "position",
                NORMAL: "normal",
                TANGENT: "tangent",
                ...wT >= 152 ? {
                    TEXCOORD_0: "uv",
                    TEXCOORD_1: "uv1",
                    TEXCOORD_2: "uv2",
                    TEXCOORD_3: "uv3"
                } : {
                    TEXCOORD_0: "uv",
                    TEXCOORD_1: "uv2"
                },
                COLOR_0: "color",
                WEIGHTS_0: "skinWeight",
                JOINTS_0: "skinIndex"
            },
            oP = {
                scale: "scale",
                translation: "position",
                rotation: "quaternion",
                weights: "morphTargetInfluences"
            },
            aP = {
                CUBICSPLINE: void 0,
                LINEAR: Cl,
                STEP: El
            },
            sP = "OPAQUE",
            lP = "MASK",
            cP = "BLEND";

        function uP(e) {
            return void 0 === e.DefaultMaterial && (e.DefaultMaterial = new rb({
                color: 16777215,
                emissive: 0,
                metalness: 1,
                roughness: 1,
                transparent: !1,
                depthTest: !0,
                side: ca
            })), e.DefaultMaterial
        }

        function dP(e, t, n) {
            for (const r in n.extensions) void 0 === e[r] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[r] = n.extensions[r])
        }

        function hP(e, t) {
            void 0 !== t.extras && ("object" === typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
        }

        function pP(e, t) {
            if (e.updateMorphTargets(), void 0 !== t.weights)
                for (let n = 0, r = t.weights.length; n < r; n++) e.morphTargetInfluences[n] = t.weights[n];
            if (t.extras && Array.isArray(t.extras.targetNames)) {
                const n = t.extras.targetNames;
                if (e.morphTargetInfluences.length === n.length) {
                    e.morphTargetDictionary = {};
                    for (let t = 0, r = n.length; t < r; t++) e.morphTargetDictionary[n[t]] = t
                } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
            }
        }

        function fP(e) {
            let t;
            const n = e.extensions && e.extensions[ET.KHR_DRACO_MESH_COMPRESSION];
            if (t = n ? "draco:" + n.bufferView + ":" + n.indices + ":" + mP(n.attributes) : e.indices + ":" + mP(e.attributes) + ":" + e.mode, void 0 !== e.targets)
                for (let r = 0, i = e.targets.length; r < i; r++) t += ":" + mP(e.targets[r]);
            return t
        }

        function mP(e) {
            let t = "";
            const n = Object.keys(e).sort();
            for (let r = 0, i = n.length; r < i; r++) t += n[r] + ":" + e[n[r]] + ";";
            return t
        }

        function gP(e) {
            switch (e) {
                case Int8Array:
                    return 1 / 127;
                case Uint8Array:
                    return 1 / 255;
                case Int16Array:
                    return 1 / 32767;
                case Uint16Array:
                    return 1 / 65535;
                default:
                    throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
            }
        }
        const vP = new od;
        class yP {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new ST, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
                    refs: {},
                    uses: {}
                }, this.cameraCache = {
                    refs: {},
                    uses: {}
                }, this.lightCache = {
                    refs: {},
                    uses: {}
                }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
                let n = !1,
                    r = !1,
                    i = -1;
                "undefined" !== typeof navigator && "undefined" !== typeof navigator.userAgent && (n = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent), r = navigator.userAgent.indexOf("Firefox") > -1, i = r ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), "undefined" === typeof createImageBitmap || n || r && i < 98 ? this.textureLoader = new Gb(this.options.manager) : this.textureLoader = new vx(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new kb(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
            }
            setExtensions(e) {
                this.extensions = e
            }
            setPlugins(e) {
                this.plugins = e
            }
            parse(e, t) {
                const n = this,
                    r = this.json,
                    i = this.extensions;
                this.cache.removeAll(), this.nodeCache = {}, this._invokeAll((function(e) {
                    return e._markDefs && e._markDefs()
                })), Promise.all(this._invokeAll((function(e) {
                    return e.beforeRoot && e.beforeRoot()
                }))).then((function() {
                    return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                })).then((function(t) {
                    const o = {
                        scene: t[0][r.scene || 0],
                        scenes: t[0],
                        animations: t[1],
                        cameras: t[2],
                        asset: r.asset,
                        parser: n,
                        userData: {}
                    };
                    dP(i, o, r), hP(o, r), Promise.all(n._invokeAll((function(e) {
                        return e.afterRoot && e.afterRoot(o)
                    }))).then((function() {
                        e(o)
                    }))
                })).catch(t)
            }
            _markDefs() {
                const e = this.json.nodes || [],
                    t = this.json.skins || [],
                    n = this.json.meshes || [];
                for (let r = 0, i = t.length; r < i; r++) {
                    const n = t[r].joints;
                    for (let t = 0, r = n.length; t < r; t++) e[n[t]].isBone = !0
                }
                for (let r = 0, i = e.length; r < i; r++) {
                    const t = e[r];
                    void 0 !== t.mesh && (this._addNodeRef(this.meshCache, t.mesh), void 0 !== t.skin && (n[t.mesh].isSkinnedMesh = !0)), void 0 !== t.camera && this._addNodeRef(this.cameraCache, t.camera)
                }
            }
            _addNodeRef(e, t) {
                void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
            }
            _getNodeRef(e, t, n) {
                if (e.refs[t] <= 1) return n;
                const r = n.clone(),
                    i = (e, t) => {
                        const n = this.associations.get(e);
                        null != n && this.associations.set(t, n);
                        for (const [r, o] of e.children.entries()) i(o, t.children[r])
                    };
                return i(n, r), r.name += "_instance_" + e.uses[t]++, r
            }
            _invokeOne(e) {
                const t = Object.values(this.plugins);
                t.push(this);
                for (let n = 0; n < t.length; n++) {
                    const r = e(t[n]);
                    if (r) return r
                }
                return null
            }
            _invokeAll(e) {
                const t = Object.values(this.plugins);
                t.unshift(this);
                const n = [];
                for (let r = 0; r < t.length; r++) {
                    const i = e(t[r]);
                    i && n.push(i)
                }
                return n
            }
            getDependency(e, t) {
                const n = e + ":" + t;
                let r = this.cache.get(n);
                if (!r) {
                    switch (e) {
                        case "scene":
                            r = this.loadScene(t);
                            break;
                        case "node":
                            r = this._invokeOne((function(e) {
                                return e.loadNode && e.loadNode(t)
                            }));
                            break;
                        case "mesh":
                            r = this._invokeOne((function(e) {
                                return e.loadMesh && e.loadMesh(t)
                            }));
                            break;
                        case "accessor":
                            r = this.loadAccessor(t);
                            break;
                        case "bufferView":
                            r = this._invokeOne((function(e) {
                                return e.loadBufferView && e.loadBufferView(t)
                            }));
                            break;
                        case "buffer":
                            r = this.loadBuffer(t);
                            break;
                        case "material":
                            r = this._invokeOne((function(e) {
                                return e.loadMaterial && e.loadMaterial(t)
                            }));
                            break;
                        case "texture":
                            r = this._invokeOne((function(e) {
                                return e.loadTexture && e.loadTexture(t)
                            }));
                            break;
                        case "skin":
                            r = this.loadSkin(t);
                            break;
                        case "animation":
                            r = this._invokeOne((function(e) {
                                return e.loadAnimation && e.loadAnimation(t)
                            }));
                            break;
                        case "camera":
                            r = this.loadCamera(t);
                            break;
                        default:
                            if (r = this._invokeOne((function(n) {
                                    return n != this && n.getDependency && n.getDependency(e, t)
                                })), !r) throw new Error("Unknown type: " + e)
                    }
                    this.cache.add(n, r)
                }
                return r
            }
            getDependencies(e) {
                let t = this.cache.get(e);
                if (!t) {
                    const n = this,
                        r = this.json[e + ("mesh" === e ? "es" : "s")] || [];
                    t = Promise.all(r.map((function(t, r) {
                        return n.getDependency(e, r)
                    }))), this.cache.add(e, t)
                }
                return t
            }
            loadBuffer(e) {
                const t = this.json.buffers[e],
                    n = this.fileLoader;
                if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
                if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[ET.KHR_BINARY_GLTF].body);
                const r = this.options;
                return new Promise((function(e, i) {
                    n.load(ux.resolveURL(t.uri, r.path), e, void 0, (function() {
                        i(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                    }))
                }))
            }
            loadBufferView(e) {
                const t = this.json.bufferViews[e];
                return this.getDependency("buffer", t.buffer).then((function(e) {
                    const n = t.byteLength || 0,
                        r = t.byteOffset || 0;
                    return e.slice(r, r + n)
                }))
            }
            loadAccessor(e) {
                const t = this,
                    n = this.json,
                    r = this.json.accessors[e];
                if (void 0 === r.bufferView && void 0 === r.sparse) {
                    const e = rP[r.type],
                        t = eP[r.componentType],
                        n = !0 === r.normalized,
                        i = new t(r.count * e);
                    return Promise.resolve(new ih(i, e, n))
                }
                const i = [];
                return void 0 !== r.bufferView ? i.push(this.getDependency("bufferView", r.bufferView)) : i.push(null), void 0 !== r.sparse && (i.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), i.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(i).then((function(e) {
                    const i = e[0],
                        o = rP[r.type],
                        a = eP[r.componentType],
                        s = a.BYTES_PER_ELEMENT,
                        l = s * o,
                        c = r.byteOffset || 0,
                        u = void 0 !== r.bufferView ? n.bufferViews[r.bufferView].byteStride : void 0,
                        d = !0 === r.normalized;
                    let h, p;
                    if (u && u !== l) {
                        const e = Math.floor(c / u),
                            n = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + e + ":" + r.count;
                        let l = t.cache.get(n);
                        l || (h = new a(i, e * u, r.count * u / s), l = new $m(h, u / s), t.cache.add(n, l)), p = new tg(l, o, c % u / s, d)
                    } else h = null === i ? new a(r.count * o) : new a(i, c, r.count * o), p = new ih(h, o, d);
                    if (void 0 !== r.sparse) {
                        const t = rP.SCALAR,
                            n = eP[r.sparse.indices.componentType],
                            s = r.sparse.indices.byteOffset || 0,
                            l = r.sparse.values.byteOffset || 0,
                            c = new n(e[1], s, r.sparse.count * t),
                            u = new a(e[2], l, r.sparse.count * o);
                        null !== i && (p = new ih(p.array.slice(), p.itemSize, p.normalized));
                        for (let e = 0, r = c.length; e < r; e++) {
                            const t = c[e];
                            if (p.setX(t, u[e * o]), o >= 2 && p.setY(t, u[e * o + 1]), o >= 3 && p.setZ(t, u[e * o + 2]), o >= 4 && p.setW(t, u[e * o + 3]), o >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                        }
                    }
                    return p
                }))
            }
            loadTexture(e) {
                const t = this.json,
                    n = this.options,
                    r = t.textures[e].source,
                    i = t.images[r];
                let o = this.textureLoader;
                if (i.uri) {
                    const e = n.manager.getHandler(i.uri);
                    null !== e && (o = e)
                }
                return this.loadTextureImage(e, r, o)
            }
            loadTextureImage(e, t, n) {
                const r = this,
                    i = this.json,
                    o = i.textures[e],
                    a = i.images[t],
                    s = (a.uri || a.bufferView) + ":" + o.sampler;
                if (this.textureCache[s]) return this.textureCache[s];
                const l = this.loadImageSource(t, n).then((function(t) {
                    t.flipY = !1, t.name = o.name || a.name || "", "" === t.name && "string" === typeof a.uri && !1 === a.uri.startsWith("data:image/") && (t.name = a.uri);
                    const n = (i.samplers || {})[o.sampler] || {};
                    return t.magFilter = tP[n.magFilter] || ys, t.minFilter = tP[n.minFilter] || _s, t.wrapS = nP[n.wrapS] || us, t.wrapT = nP[n.wrapT] || us, r.associations.set(t, {
                        textures: e
                    }), t
                })).catch((function() {
                    return null
                }));
                return this.textureCache[s] = l, l
            }
            loadImageSource(e, t) {
                const n = this,
                    r = this.json,
                    i = this.options;
                if (void 0 !== this.sourceCache[e]) return this.sourceCache[e].then((e => e.clone()));
                const o = r.images[e],
                    a = self.URL || self.webkitURL;
                let s = o.uri || "",
                    l = !1;
                if (void 0 !== o.bufferView) s = n.getDependency("bufferView", o.bufferView).then((function(e) {
                    l = !0;
                    const t = new Blob([e], {
                        type: o.mimeType
                    });
                    return s = a.createObjectURL(t), s
                }));
                else if (void 0 === o.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
                const c = Promise.resolve(s).then((function(e) {
                    return new Promise((function(n, r) {
                        let o = n;
                        !0 === t.isImageBitmapLoader && (o = function(e) {
                            const t = new bu(e);
                            t.needsUpdate = !0, n(t)
                        }), t.load(ux.resolveURL(e, i.path), o, void 0, r)
                    }))
                })).then((function(e) {
                    var t;
                    return !0 === l && a.revokeObjectURL(s), e.userData.mimeType = o.mimeType || ((t = o.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), e
                })).catch((function(e) {
                    throw console.error("THREE.GLTFLoader: Couldn't load texture", s), e
                }));
                return this.sourceCache[e] = c, c
            }
            assignTexture(e, t, n, r) {
                const i = this;
                return this.getDependency("texture", n.index).then((function(o) {
                    if (!o) return null;
                    if (void 0 !== n.texCoord && n.texCoord > 0 && ((o = o.clone()).channel = n.texCoord), i.extensions[ET.KHR_TEXTURE_TRANSFORM]) {
                        const e = void 0 !== n.extensions ? n.extensions[ET.KHR_TEXTURE_TRANSFORM] : void 0;
                        if (e) {
                            const t = i.associations.get(o);
                            o = i.extensions[ET.KHR_TEXTURE_TRANSFORM].extendTexture(o, e), i.associations.set(o, t)
                        }
                    }
                    return void 0 !== r && ("colorSpace" in o ? o.colorSpace = 3001 === r ? "srgb" : "srgb-linear" : o.encoding = r), e[t] = o, o
                }))
            }
            assignFinalMaterial(e) {
                const t = e.geometry;
                let n = e.material;
                const r = void 0 === t.attributes.tangent,
                    i = void 0 !== t.attributes.color,
                    o = void 0 === t.attributes.normal;
                if (e.isPoints) {
                    const e = "PointsMaterial:" + n.uuid;
                    let t = this.cache.get(e);
                    t || (t = new bv, Jd.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, t.sizeAttenuation = !1, this.cache.add(e, t)), n = t
                } else if (e.isLine) {
                    const e = "LineBasicMaterial:" + n.uuid;
                    let t = this.cache.get(e);
                    t || (t = new lv, Jd.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, this.cache.add(e, t)), n = t
                }
                if (r || i || o) {
                    let e = "ClonedMaterial:" + n.uuid + ":";
                    r && (e += "derivative-tangents:"), i && (e += "vertex-colors:"), o && (e += "flat-shading:");
                    let t = this.cache.get(e);
                    t || (t = n.clone(), i && (t.vertexColors = !0), o && (t.flatShading = !0), r && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(n))), n = t
                }
                e.material = n
            }
            getMaterialType() {
                return rb
            }
            loadMaterial(e) {
                const t = this,
                    n = this.json,
                    r = this.extensions,
                    i = n.materials[e];
                let o;
                const a = {},
                    s = [];
                if ((i.extensions || {})[ET.KHR_MATERIALS_UNLIT]) {
                    const e = r[ET.KHR_MATERIALS_UNLIT];
                    o = e.getMaterialType(), s.push(e.extendParams(a, i, t))
                } else {
                    const n = i.pbrMetallicRoughness || {};
                    if (a.color = new Wd(1, 1, 1), a.opacity = 1, Array.isArray(n.baseColorFactor)) {
                        const e = n.baseColorFactor;
                        a.color.fromArray(e), a.opacity = e[3]
                    }
                    void 0 !== n.baseColorTexture && s.push(t.assignTexture(a, "map", n.baseColorTexture, 3001)), a.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, a.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (s.push(t.assignTexture(a, "metalnessMap", n.metallicRoughnessTexture)), s.push(t.assignTexture(a, "roughnessMap", n.metallicRoughnessTexture))), o = this._invokeOne((function(t) {
                        return t.getMaterialType && t.getMaterialType(e)
                    })), s.push(Promise.all(this._invokeAll((function(t) {
                        return t.extendMaterialParams && t.extendMaterialParams(e, a)
                    }))))
                }!0 === i.doubleSided && (a.side = da);
                const l = i.alphaMode || sP;
                if (l === cP ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, l === lP && (a.alphaTest = void 0 !== i.alphaCutoff ? i.alphaCutoff : .5)), void 0 !== i.normalTexture && o !== Yd && (s.push(t.assignTexture(a, "normalMap", i.normalTexture)), a.normalScale = new Yc(1, 1), void 0 !== i.normalTexture.scale)) {
                    const e = i.normalTexture.scale;
                    a.normalScale.set(e, e)
                }
                return void 0 !== i.occlusionTexture && o !== Yd && (s.push(t.assignTexture(a, "aoMap", i.occlusionTexture)), void 0 !== i.occlusionTexture.strength && (a.aoMapIntensity = i.occlusionTexture.strength)), void 0 !== i.emissiveFactor && o !== Yd && (a.emissive = (new Wd).fromArray(i.emissiveFactor)), void 0 !== i.emissiveTexture && o !== Yd && s.push(t.assignTexture(a, "emissiveMap", i.emissiveTexture, 3001)), Promise.all(s).then((function() {
                    const n = new o(a);
                    return i.name && (n.name = i.name), hP(n, i), t.associations.set(n, {
                        materials: e
                    }), i.extensions && dP(r, n, i), n
                }))
            }
            createUniqueName(e) {
                const t = Wx.sanitizeNodeName(e || "");
                return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t)
            }
            loadGeometries(e) {
                const t = this,
                    n = this.extensions,
                    r = this.primitiveCache;

                function i(e) {
                    return n[ET.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function(n) {
                        return bP(n, e, t)
                    }))
                }
                const o = [];
                for (let a = 0, s = e.length; a < s; a++) {
                    const n = e[a],
                        s = fP(n),
                        l = r[s];
                    if (l) o.push(l.promise);
                    else {
                        let e;
                        e = n.extensions && n.extensions[ET.KHR_DRACO_MESH_COMPRESSION] ? i(n) : bP(new Mh, n, t), r[s] = {
                            primitive: n,
                            promise: e
                        }, o.push(e)
                    }
                }
                return Promise.all(o)
            }
            loadMesh(e) {
                const t = this,
                    n = this.json,
                    r = this.extensions,
                    i = n.meshes[e],
                    o = i.primitives,
                    a = [];
                for (let s = 0, l = o.length; s < l; s++) {
                    const e = void 0 === o[s].material ? uP(this.cache) : this.getDependency("material", o[s].material);
                    a.push(e)
                }
                return a.push(t.loadGeometries(o)), Promise.all(a).then((function(n) {
                    const a = n.slice(0, n.length - 1),
                        s = n[n.length - 1],
                        l = [];
                    for (let u = 0, d = s.length; u < d; u++) {
                        const n = s[u],
                            c = o[u];
                        let d;
                        const h = a[u];
                        if (c.mode === $T.TRIANGLES || c.mode === $T.TRIANGLE_STRIP || c.mode === $T.TRIANGLE_FAN || void 0 === c.mode) d = !0 === i.isSkinnedMesh ? new Rg(n, h) : new zh(n, h), !0 === d.isSkinnedMesh && d.normalizeSkinWeights(), c.mode === $T.TRIANGLE_STRIP ? d.geometry = MT(d.geometry, Dl) : c.mode === $T.TRIANGLE_FAN && (d.geometry = MT(d.geometry, Nl));
                        else if (c.mode === $T.LINES) d = new vv(n, h);
                        else if (c.mode === $T.LINE_STRIP) d = new fv(n, h);
                        else if (c.mode === $T.LINE_LOOP) d = new yv(n, h);
                        else {
                            if (c.mode !== $T.POINTS) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + c.mode);
                            d = new Av(n, h)
                        }
                        Object.keys(d.geometry.morphAttributes).length > 0 && pP(d, i), d.name = t.createUniqueName(i.name || "mesh_" + e), hP(d, i), c.extensions && dP(r, d, c), t.assignFinalMaterial(d), l.push(d)
                    }
                    for (let r = 0, i = l.length; r < i; r++) t.associations.set(l[r], {
                        meshes: e,
                        primitives: r
                    });
                    if (1 === l.length) return i.extensions && dP(r, l[0], i), l[0];
                    const c = new Hm;
                    i.extensions && dP(r, c, i), t.associations.set(c, {
                        meshes: e
                    });
                    for (let e = 0, t = l.length; e < t; e++) c.add(l[e]);
                    return c
                }))
            }
            loadCamera(e) {
                let t;
                const n = this.json.cameras[e],
                    r = n[n.type];
                if (r) return "perspective" === n.type ? t = new Zh(Jc.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : "orthographic" === n.type && (t = new wp(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), n.name && (t.name = this.createUniqueName(n.name)), hP(t, n), Promise.resolve(t);
                console.warn("THREE.GLTFLoader: Missing camera parameters.")
            }
            loadSkin(e) {
                const t = this.json.skins[e],
                    n = [];
                for (let r = 0, i = t.joints.length; r < i; r++) n.push(this._loadNodeShallow(t.joints[r]));
                return void 0 !== t.inverseBindMatrices ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then((function(e) {
                    const n = e.pop(),
                        r = e,
                        i = [],
                        o = [];
                    for (let a = 0, s = r.length; a < s; a++) {
                        const e = r[a];
                        if (e) {
                            i.push(e);
                            const t = new od;
                            null !== n && t.fromArray(n.array, 16 * a), o.push(t)
                        } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[a])
                    }
                    return new Dg(i, o)
                }))
            }
            loadAnimation(e) {
                const t = this.json.animations[e],
                    n = t.name ? t.name : "animation_" + e,
                    r = [],
                    i = [],
                    o = [],
                    a = [],
                    s = [];
                for (let l = 0, c = t.channels.length; l < c; l++) {
                    const e = t.channels[l],
                        n = t.samplers[e.sampler],
                        c = e.target,
                        u = c.node,
                        d = void 0 !== t.parameters ? t.parameters[n.input] : n.input,
                        h = void 0 !== t.parameters ? t.parameters[n.output] : n.output;
                    void 0 !== c.node && (r.push(this.getDependency("node", u)), i.push(this.getDependency("accessor", d)), o.push(this.getDependency("accessor", h)), a.push(n), s.push(c))
                }
                return Promise.all([Promise.all(r), Promise.all(i), Promise.all(o), Promise.all(a), Promise.all(s)]).then((function(e) {
                    const t = e[0],
                        r = e[1],
                        i = e[2],
                        o = e[3],
                        a = e[4],
                        s = [];
                    for (let n = 0, l = t.length; n < l; n++) {
                        const e = t[n],
                            l = r[n],
                            c = i[n],
                            u = o[n],
                            d = a[n];
                        if (void 0 === e) continue;
                        let h;
                        switch (e.updateMatrix(), oP[d.path]) {
                            case oP.weights:
                                h = Ab;
                                break;
                            case oP.rotation:
                                h = Eb;
                                break;
                            default:
                                h = Tb
                        }
                        const p = e.name ? e.name : e.uuid,
                            f = void 0 !== u.interpolation ? aP[u.interpolation] : Cl,
                            m = [];
                        oP[d.path] === oP.weights ? e.traverse((function(e) {
                            e.morphTargetInfluences && m.push(e.name ? e.name : e.uuid)
                        })) : m.push(p);
                        let g = c.array;
                        if (c.normalized) {
                            const e = gP(g.constructor),
                                t = new Float32Array(g.length);
                            for (let n = 0, r = g.length; n < r; n++) t[n] = g[n] * e;
                            g = t
                        }
                        for (let t = 0, n = m.length; t < n; t++) {
                            const e = new h(m[t] + "." + oP[d.path], l.array, g, f);
                            "CUBICSPLINE" === u.interpolation && (e.createInterpolant = function(e) {
                                return new(this instanceof Eb ? ZT : YT)(this.times, this.values, this.getValueSize() / 3, e)
                            }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), s.push(e)
                        }
                    }
                    return new Pb(n, void 0, s)
                }))
            }
            createNodeMesh(e) {
                const t = this.json,
                    n = this,
                    r = t.nodes[e];
                return void 0 === r.mesh ? null : n.getDependency("mesh", r.mesh).then((function(e) {
                    const t = n._getNodeRef(n.meshCache, r.mesh, e);
                    return void 0 !== r.weights && t.traverse((function(e) {
                        if (e.isMesh)
                            for (let t = 0, n = r.weights.length; t < n; t++) e.morphTargetInfluences[t] = r.weights[t]
                    })), t
                }))
            }
            loadNode(e) {
                const t = this,
                    n = this.json.nodes[e],
                    r = t._loadNodeShallow(e),
                    i = [],
                    o = n.children || [];
                for (let s = 0, l = o.length; s < l; s++) i.push(t.getDependency("node", o[s]));
                const a = void 0 === n.skin ? Promise.resolve(null) : t.getDependency("skin", n.skin);
                return Promise.all([r, Promise.all(i), a]).then((function(e) {
                    const t = e[0],
                        n = e[1],
                        r = e[2];
                    null !== r && t.traverse((function(e) {
                        e.isSkinnedMesh && e.bind(r, vP)
                    }));
                    for (let i = 0, o = n.length; i < o; i++) t.add(n[i]);
                    return t
                }))
            }
            _loadNodeShallow(e) {
                const t = this.json,
                    n = this.extensions,
                    r = this;
                if (void 0 !== this.nodeCache[e]) return this.nodeCache[e];
                const i = t.nodes[e],
                    o = i.name ? r.createUniqueName(i.name) : "",
                    a = [],
                    s = r._invokeOne((function(t) {
                        return t.createNodeMesh && t.createNodeMesh(e)
                    }));
                return s && a.push(s), void 0 !== i.camera && a.push(r.getDependency("camera", i.camera).then((function(e) {
                    return r._getNodeRef(r.cameraCache, i.camera, e)
                }))), r._invokeAll((function(t) {
                    return t.createNodeAttachment && t.createNodeAttachment(e)
                })).forEach((function(e) {
                    a.push(e)
                })), this.nodeCache[e] = Promise.all(a).then((function(t) {
                    let a;
                    if (a = !0 === i.isBone ? new Ig : t.length > 1 ? new Hm : 1 === t.length ? t[0] : new Rd, a !== t[0])
                        for (let e = 0, n = t.length; e < n; e++) a.add(t[e]);
                    if (i.name && (a.userData.name = i.name, a.name = o), hP(a, i), i.extensions && dP(n, a, i), void 0 !== i.matrix) {
                        const e = new od;
                        e.fromArray(i.matrix), a.applyMatrix4(e)
                    } else void 0 !== i.translation && a.position.fromArray(i.translation), void 0 !== i.rotation && a.quaternion.fromArray(i.rotation), void 0 !== i.scale && a.scale.fromArray(i.scale);
                    return r.associations.has(a) || r.associations.set(a, {}), r.associations.get(a).nodes = e, a
                })), this.nodeCache[e]
            }
            loadScene(e) {
                const t = this.extensions,
                    n = this.json.scenes[e],
                    r = this,
                    i = new Hm;
                n.name && (i.name = r.createUniqueName(n.name)), hP(i, n), n.extensions && dP(t, i, n);
                const o = n.nodes || [],
                    a = [];
                for (let s = 0, l = o.length; s < l; s++) a.push(r.getDependency("node", o[s]));
                return Promise.all(a).then((function(e) {
                    for (let t = 0, n = e.length; t < n; t++) i.add(e[t]);
                    return r.associations = (e => {
                        const t = new Map;
                        for (const [n, i] of r.associations)(n instanceof Jd || n instanceof bu) && t.set(n, i);
                        return e.traverse((e => {
                            const n = r.associations.get(e);
                            null != n && t.set(e, n)
                        })), t
                    })(i), i
                }))
            }
        }

        function bP(e, t, n) {
            const r = t.attributes,
                i = [];

            function o(t, r) {
                return n.getDependency("accessor", t).then((function(t) {
                    e.setAttribute(r, t)
                }))
            }
            for (const a in r) {
                const t = iP[a] || a.toLowerCase();
                t in e.attributes || i.push(o(r[a], t))
            }
            if (void 0 !== t.indices && !e.index) {
                const r = n.getDependency("accessor", t.indices).then((function(t) {
                    e.setIndex(t)
                }));
                i.push(r)
            }
            return hP(e, t),
                function(e, t, n) {
                    const r = t.attributes,
                        i = new Ou;
                    if (void 0 === r.POSITION) return; {
                        const e = n.json.accessors[r.POSITION],
                            t = e.min,
                            o = e.max;
                        if (void 0 === t || void 0 === o) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                        if (i.set(new Pu(t[0], t[1], t[2]), new Pu(o[0], o[1], o[2])), e.normalized) {
                            const t = gP(eP[e.componentType]);
                            i.min.multiplyScalar(t), i.max.multiplyScalar(t)
                        }
                    }
                    const o = t.targets;
                    if (void 0 !== o) {
                        const e = new Pu,
                            t = new Pu;
                        for (let r = 0, i = o.length; r < i; r++) {
                            const i = o[r];
                            if (void 0 !== i.POSITION) {
                                const r = n.json.accessors[i.POSITION],
                                    o = r.min,
                                    a = r.max;
                                if (void 0 !== o && void 0 !== a) {
                                    if (t.setX(Math.max(Math.abs(o[0]), Math.abs(a[0]))), t.setY(Math.max(Math.abs(o[1]), Math.abs(a[1]))), t.setZ(Math.max(Math.abs(o[2]), Math.abs(a[2]))), r.normalized) {
                                        const e = gP(eP[r.componentType]);
                                        t.multiplyScalar(e)
                                    }
                                    e.max(t)
                                } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                            }
                        }
                        i.expandByVector(e)
                    }
                    e.boundingBox = i;
                    const a = new Yu;
                    i.getCenter(a.center), a.radius = i.min.distanceTo(i.max) / 2, e.boundingSphere = a
                }(e, t, n), Promise.all(i).then((function() {
                    return void 0 !== t.targets ? function(e, t, n) {
                        let r = !1,
                            i = !1,
                            o = !1;
                        for (let c = 0, u = t.length; c < u; c++) {
                            const e = t[c];
                            if (void 0 !== e.POSITION && (r = !0), void 0 !== e.NORMAL && (i = !0), void 0 !== e.COLOR_0 && (o = !0), r && i && o) break
                        }
                        if (!r && !i && !o) return Promise.resolve(e);
                        const a = [],
                            s = [],
                            l = [];
                        for (let c = 0, u = t.length; c < u; c++) {
                            const u = t[c];
                            if (r) {
                                const t = void 0 !== u.POSITION ? n.getDependency("accessor", u.POSITION) : e.attributes.position;
                                a.push(t)
                            }
                            if (i) {
                                const t = void 0 !== u.NORMAL ? n.getDependency("accessor", u.NORMAL) : e.attributes.normal;
                                s.push(t)
                            }
                            if (o) {
                                const t = void 0 !== u.COLOR_0 ? n.getDependency("accessor", u.COLOR_0) : e.attributes.color;
                                l.push(t)
                            }
                        }
                        return Promise.all([Promise.all(a), Promise.all(s), Promise.all(l)]).then((function(t) {
                            const n = t[0],
                                a = t[1],
                                s = t[2];
                            return r && (e.morphAttributes.position = n), i && (e.morphAttributes.normal = a), o && (e.morphAttributes.color = s), e.morphTargetsRelative = !0, e
                        }))
                    }(e, t.targets, n) : e
                }))
        }
        let xP = null,
            _P = "https://www.gstatic.com/draco/versioned/decoders/1.5.5/";

        function MP(e, t, n) {
            return r => {
                n && n(r), e && (xP || (xP = new yT), xP.setDecoderPath("string" === typeof e ? e : _P), r.setDRACOLoader(xP)), t && r.setMeshoptDecoder("function" === typeof _T ? _T() : _T)
            }
        }

        function wP(e) {
            return ZM(AT, e, MP(!(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], arguments.length > 3 ? arguments[3] : void 0))
        }

        function AP(e) {
            let {
                children: t,
                frames: n = 1 / 0,
                resolution: i,
                near: o,
                far: a,
                envMap: s,
                fog: l,
                ...c
            } = e;
            const u = r.useRef(null),
                {
                    fbo: d,
                    camera: h,
                    update: p
                } = function() {
                    let {
                        resolution: e = 256,
                        near: t = .1,
                        far: n = 1e3,
                        envMap: i,
                        fog: o
                    } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    const a = KM((e => {
                            let {
                                gl: t
                            } = e;
                            return t
                        })),
                        s = KM((e => {
                            let {
                                scene: t
                            } = e;
                            return t
                        })),
                        l = (0, r.useMemo)((() => {
                            const t = new np(e);
                            return t.texture.type = Rs, t
                        }), [e]);
                    (0, r.useEffect)((() => () => {
                        l.dispose()
                    }), [l]);
                    const c = (0, r.useMemo)((() => new ep(t, n, l)), [t, n, l]);
                    let u, d;
                    const h = r.useCallback((() => {
                        u = s.fog, d = s.background, s.background = i || d, s.fog = o || u, c.update(a, s), s.fog = u, s.background = d
                    }), [a, s, c]);
                    return {
                        fbo: l,
                        camera: c,
                        update: h
                    }
                }({
                    resolution: i,
                    near: o,
                    far: a,
                    envMap: s,
                    fog: l
                });
            let f = 0;
            return JM((() => {
                u.current && (n === 1 / 0 || f < n) && (u.current.visible = !1, p(), u.current.visible = !0, f++)
            })), r.createElement("group", c, r.createElement("primitive", {
                object: h
            }), r.createElement("group", {
                ref: u
            }, t(d.texture)))
        }

        function SP(e) {
            switch (e) {
                case 1:
                    return Hs;
                case 2:
                    return Gs;
                case 3:
                case 4:
                    return Vs
            }
        }
        wP.preload = function(e) {
            let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                r = arguments.length > 3 ? arguments[3] : void 0;
            return ZM.preload(AT, e, MP(t, n, r))
        }, wP.clear = e => ZM.clear(AT, e), wP.setDecoderPath = e => {
            _P = e
        };
        class EP extends Og {
            constructor() {
                super(), this.minFilter = ps, this.magFilter = ps, this.generateMipmaps = !1, this.overrideItemSize = null, this._forcedType = null
            }
            updateFrom(e) {
                const t = this.overrideItemSize,
                    n = e.itemSize,
                    r = e.count;
                if (null !== t) {
                    if (n * r % t !== 0) throw new Error("VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.");
                    e.itemSize = t, e.count = r * n / t
                }
                const i = e.itemSize,
                    o = e.count,
                    a = e.normalized,
                    s = e.array.constructor,
                    l = s.BYTES_PER_ELEMENT;
                let c, u, d, h, p = this._forcedType,
                    f = i;
                if (null === p) switch (s) {
                    case Float32Array:
                        p = Ps;
                        break;
                    case Uint8Array:
                    case Uint16Array:
                    case Uint32Array:
                        p = Ts;
                        break;
                    case Int8Array:
                    case Int16Array:
                    case Int32Array:
                        p = Cs
                }
                let m = function(e) {
                    switch (e) {
                        case 1:
                            return "R";
                        case 2:
                            return "RG";
                        case 3:
                        case 4:
                            return "RGBA"
                    }
                    throw new Error
                }(i);
                switch (p) {
                    case Ps:
                        d = 1, u = function(e) {
                            switch (e) {
                                case 1:
                                    return zs;
                                case 2:
                                    return js;
                                case 3:
                                case 4:
                                    return Ds
                            }
                        }(i), a && 1 === l ? (h = s, m += "8", s === Uint8Array ? c = ws : (c = As, m += "_SNORM")) : (h = Float32Array, m += "32F", c = Ps);
                        break;
                    case Cs:
                        m += 8 * l + "I", d = a ? Math.pow(2, 8 * s.BYTES_PER_ELEMENT - 1) : 1, u = SP(i), 1 === l ? (h = Int8Array, c = As) : 2 === l ? (h = Int16Array, c = Ss) : (h = Int32Array, c = Cs);
                        break;
                    case Ts:
                        m += 8 * l + "UI", d = a ? Math.pow(2, 8 * s.BYTES_PER_ELEMENT - 1) : 1, u = SP(i), 1 === l ? (h = Uint8Array, c = ws) : 2 === l ? (h = Uint16Array, c = Es) : (h = Uint32Array, c = Ts)
                }
                3 !== f || u !== Ds && u !== Vs || (f = 4);
                const g = Math.ceil(Math.sqrt(o)),
                    v = new h(f * g * g),
                    y = e.normalized;
                e.normalized = !1;
                for (let b = 0; b < o; b++) {
                    const t = f * b;
                    v[t] = e.getX(b) / d, i >= 2 && (v[t + 1] = e.getY(b) / d), i >= 3 && (v[t + 2] = e.getZ(b) / d, 4 === f && (v[t + 3] = 1)), i >= 4 && (v[t + 3] = e.getW(b) / d)
                }
                e.normalized = y, this.internalFormat = m, this.format = u, this.type = c, this.image.width = g, this.image.height = g, this.image.data = v, this.needsUpdate = !0, this.dispose(), e.itemSize = n, e.count = r
            }
        }
        class CP extends EP {
            constructor() {
                super(), this._forcedType = Ts
            }
        }
        class TP extends EP {
            constructor() {
                super(), this._forcedType = Ps
            }
        }
        class PP {
            constructor() {
                this.index = new CP, this.position = new TP, this.bvhBounds = new Og, this.bvhContents = new Og, this._cachedIndexAttr = null, this.index.overrideItemSize = 3
            }
            updateFrom(e) {
                const {
                    geometry: t
                } = e;
                if (function(e, t, n) {
                        const r = e._roots;
                        if (1 !== r.length) throw new Error("MeshBVHUniformStruct: Multi-root BVHs not supported.");
                        const i = r[0],
                            o = new Uint16Array(i),
                            a = new Uint32Array(i),
                            s = new Float32Array(i),
                            l = i.byteLength / jA,
                            c = 2 * Math.ceil(Math.sqrt(l / 2)),
                            u = new Float32Array(4 * c * c),
                            d = Math.ceil(Math.sqrt(l)),
                            h = new Uint32Array(2 * d * d);
                        for (let p = 0; p < l; p++) {
                            const e = p * jA / 4,
                                t = 2 * e,
                                n = e;
                            for (let r = 0; r < 3; r++) u[8 * p + 0 + r] = s[n + 0 + r], u[8 * p + 4 + r] = s[n + 3 + r];
                            if (dS(t, o)) {
                                const n = pS(t, o),
                                    r = hS(e, a),
                                    i = 4294901760 | n;
                                h[2 * p + 0] = i, h[2 * p + 1] = r
                            } else {
                                const t = 4 * mS(e, a) / jA,
                                    n = gS(e, a);
                                h[2 * p + 0] = n, h[2 * p + 1] = t
                            }
                        }
                        t.image.data = u, t.image.width = c, t.image.height = c, t.format = Ds, t.type = Ps, t.internalFormat = "RGBA32F", t.minFilter = ps, t.magFilter = ps, t.generateMipmaps = !1, t.needsUpdate = !0, t.dispose(), n.image.data = h, n.image.width = d, n.image.height = d, n.format = Gs, n.type = Ts, n.internalFormat = "RG32UI", n.minFilter = ps, n.magFilter = ps, n.generateMipmaps = !1, n.needsUpdate = !0, n.dispose()
                    }(e, this.bvhBounds, this.bvhContents), this.position.updateFrom(t.attributes.position), e.indirect) {
                    const n = e._indirectBuffer;
                    if (null === this._cachedIndexAttr || this._cachedIndexAttr.count !== n.length)
                        if (t.index) this._cachedIndexAttr = t.index.clone();
                        else {
                            const e = KA(WA(t));
                            this._cachedIndexAttr = new ih(e, 1, !1)
                        }! function(e, t, n) {
                        const r = n.array,
                            i = e.index ? e.index.array : null;
                        for (let o = 0, a = t.length; o < a; o++) {
                            const e = 3 * o,
                                n = 3 * t[o];
                            for (let t = 0; t < 3; t++) r[e + t] = i ? i[n + t] : n + t
                        }
                    }(t, n, this._cachedIndexAttr), this.index.updateFrom(this._cachedIndexAttr)
                } else this.index.updateFrom(t.index)
            }
            dispose() {
                const {
                    index: e,
                    position: t,
                    bvhBounds: n,
                    bvhContents: r
                } = this;
                e && e.dispose(), t && t.dispose(), n && n.dispose(), r && r.dispose()
            }
        }

        function RP(e, t, n, r) {
            const i = class extends Xh {
                constructor() {
                    let i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    const o = Object.entries(e);
                    super({
                        uniforms: o.reduce(((e, t) => {
                            let [n, r] = t;
                            return { ...e,
                                ...Wh.clone({
                                    [n]: {
                                        value: r
                                    }
                                })
                            }
                        }), {}),
                        vertexShader: t,
                        fragmentShader: n
                    }), this.key = "", o.forEach((e => {
                        let [t] = e;
                        return Object.defineProperty(this, t, {
                            get: () => this.uniforms[t].value,
                            set: e => this.uniforms[t].value = e
                        })
                    })), Object.assign(this, i), r && r(this)
                }
            };
            return i.key = Jc.generateUUID(), i
        }
        const IP = "\n\t".concat("\n\n// A stack of uint32 indices can can store the indices for\n// a perfectly balanced tree with a depth up to 31. Lower stack\n// depth gets higher performance.\n//\n// However not all trees are balanced. Best value to set this to\n// is the trees max depth.\n#ifndef BVH_STACK_DEPTH\n#define BVH_STACK_DEPTH 60\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\n// Utilities\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n", "\n\t").concat("\n\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n// Raycasting\nbool intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax, out float dist ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tdist = max( t0, 0.0 );\n\n\treturn t1 >= dist;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// outputs\n\tinout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nbool intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, sampler2D bvhBounds, uint currNodeIndex, out float dist ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax, dist );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\tbvhIntersectFirstHit(\t\tbvh,\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\t)\t_bvhIntersectFirstHit(\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\t)\n\nbool _bvhIntersectFirstHit(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables split into separate variables due to output precision\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = INFINITY;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance;\n\t\tif (\n\t\t\t! intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh_bvhBounds, currNodeIndex, boundsHitDistance )\n\t\t\t|| boundsHitDistance > triangleDistance\n\t\t) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count,\n\t\t\t\trayOrigin, rayDirection, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n", "\n"),
            OP = (() => parseInt(Zo.replace(/\D+/g, "")))(),
            BP = RP({
                envMap: null,
                bounces: 3,
                ior: 2.4,
                correctMips: !0,
                aberrationStrength: .01,
                fresnel: 0,
                bvh: new PP,
                color: new Wd("white"),
                resolution: new Yc,
                viewMatrixInverse: new od,
                projectionMatrixInverse: new od
            }, "\n  uniform mat4 viewMatrixInverse;\n\n  varying vec3 vWorldPosition;  \n  varying vec3 vNormal;\n  varying mat4 vModelMatrixInverse;\n\n  #ifdef USE_INSTANCING_COLOR\n    varying vec3 vInstanceColor;\n  #endif\n\n  void main() {        \n    vec4 transformedNormal = vec4(normal, 0.0);\n    vec4 transformedPosition = vec4(position, 1.0);\n    #ifdef USE_INSTANCING\n      transformedNormal = instanceMatrix * transformedNormal;\n      transformedPosition = instanceMatrix * transformedPosition;\n    #endif\n\n    #ifdef USE_INSTANCING\n      vModelMatrixInverse = inverse(modelMatrix * instanceMatrix);\n    #else\n      vModelMatrixInverse = inverse(modelMatrix);\n    #endif\n\n    #ifdef USE_INSTANCING_COLOR\n      vInstanceColor = instanceColor.rgb;\n    #endif\n\n    vWorldPosition = (modelMatrix * transformedPosition).xyz;\n    vNormal = normalize((viewMatrixInverse * vec4(normalMatrix * transformedNormal.xyz, 0.0)).xyz);\n    gl_Position = projectionMatrix * viewMatrix * modelMatrix * transformedPosition;\n  }", "\n  #define ENVMAP_TYPE_CUBE_UV\n  precision highp isampler2D;\n  precision highp usampler2D;\n  varying vec3 vWorldPosition;\n  varying vec3 vNormal;\n  varying mat4 vModelMatrixInverse;\n\n  #ifdef USE_INSTANCING_COLOR\n    varying vec3 vInstanceColor;\n  #endif\n    \n  #ifdef ENVMAP_TYPE_CUBEM\n    uniform samplerCube envMap;\n  #else\n    uniform sampler2D envMap;\n  #endif\n    \n  uniform float bounces;\n  ".concat("\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n", "\n  ").concat(IP, "\n  uniform BVH bvh;\n  uniform float ior;\n  uniform bool correctMips;\n  uniform vec2 resolution;\n  uniform float fresnel;\n  uniform mat4 modelMatrix;\n  uniform mat4 projectionMatrixInverse;\n  uniform mat4 viewMatrixInverse;\n  uniform float aberrationStrength;\n  uniform vec3 color;\n  \n  float fresnelFunc(vec3 viewDirection, vec3 worldNormal) {\n    return pow( 1.0 + dot( viewDirection, worldNormal), 10.0 );\n  }\n    \n  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 normal, float ior, mat4 modelMatrixInverse) {\n    vec3 rayOrigin = ro;\n    vec3 rayDirection = rd;\n    rayDirection = refract(rayDirection, normal, 1.0 / ior);\n    rayOrigin = vWorldPosition + rayDirection * 0.001;\n    rayOrigin = (modelMatrixInverse * vec4(rayOrigin, 1.0)).xyz;\n    rayDirection = normalize((modelMatrixInverse * vec4(rayDirection, 0.0)).xyz);\n    for(float i = 0.0; i < bounces; i++) {\n      uvec4 faceIndices = uvec4( 0u );\n      vec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n      vec3 barycoord = vec3( 0.0 );\n      float side = 1.0;\n      float dist = 0.0;\n      bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\n      vec3 hitPos = rayOrigin + rayDirection * max(dist - 0.001, 0.0);      \n      vec3 tempDir = refract(rayDirection, faceNormal, ior);\n      if (length(tempDir) != 0.0) {\n        rayDirection = tempDir;\n        break;\n      }\n      rayDirection = reflect(rayDirection, faceNormal);\n      rayOrigin = hitPos + rayDirection * 0.01;\n    }\n    rayDirection = normalize((modelMatrix * vec4(rayDirection, 0.0)).xyz);\n    return rayDirection;\n  }\n    \n  #include <common>\n  #include <cube_uv_reflection_fragment>\n    \n  #ifdef ENVMAP_TYPE_CUBEM\n    vec4 textureGradient(samplerCube envMap, vec3 rayDirection, vec3 directionCamPerfect) {\n      return textureGrad(envMap, rayDirection, dFdx(correctMips ? directionCamPerfect: rayDirection), dFdy(correctMips ? directionCamPerfect: rayDirection));\n    }\n  #else\n    vec4 textureGradient(sampler2D envMap, vec3 rayDirection, vec3 directionCamPerfect) {\n      vec2 uvv = equirectUv( rayDirection );\n      vec2 smoothUv = equirectUv( directionCamPerfect );\n      return textureGrad(envMap, uvv, dFdx(correctMips ? smoothUv : uvv), dFdy(correctMips ? smoothUv : uvv));\n    }\n  #endif\n  \n  void main() {\n    vec2 uv = gl_FragCoord.xy / resolution;\n    vec3 directionCamPerfect = (projectionMatrixInverse * vec4(uv * 2.0 - 1.0, 0.0, 1.0)).xyz;\n    directionCamPerfect = (viewMatrixInverse * vec4(directionCamPerfect, 0.0)).xyz;\n    directionCamPerfect = normalize(directionCamPerfect);\n    vec3 normal = vNormal;\n    vec3 rayOrigin = cameraPosition;\n    vec3 rayDirection = normalize(vWorldPosition - cameraPosition);\n    vec3 finalColor;\n    #ifdef CHROMATIC_ABERRATIONS\n      vec3 rayDirectionG = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);\n      #ifdef FAST_CHROMA \n        vec3 rayDirectionR = normalize(rayDirectionG + 1.0 * vec3(aberrationStrength / 2.0));\n        vec3 rayDirectionB = normalize(rayDirectionG - 1.0 * vec3(aberrationStrength / 2.0));\n      #else\n        vec3 rayDirectionR = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 - aberrationStrength), 1.0), vModelMatrixInverse);\n        vec3 rayDirectionB = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 + aberrationStrength), 1.0), vModelMatrixInverse);\n      #endif\n      float finalColorR = textureGradient(envMap, rayDirectionR, directionCamPerfect).r;\n      float finalColorG = textureGradient(envMap, rayDirectionG, directionCamPerfect).g;\n      float finalColorB = textureGradient(envMap, rayDirectionB, directionCamPerfect).b;\n      finalColor = vec3(finalColorR, finalColorG, finalColorB);\n    #else\n      rayDirection = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);\n      finalColor = textureGradient(envMap, rayDirection, directionCamPerfect).rgb;    \n    #endif\n\n    finalColor *= color;\n    #ifdef USE_INSTANCING_COLOR\n      finalColor *= vInstanceColor;\n    #endif\n\n    vec3 viewDirection = normalize(vWorldPosition - cameraPosition);\n    float nFresnel = fresnelFunc(viewDirection, normal) * fresnel;\n    gl_FragColor = vec4(mix(finalColor, vec3(1.0), nFresnel), 1.0);      \n    #include <tonemapping_fragment>\n    #include <").concat(OP >= 154 ? "colorspace_fragment" : "encodings_fragment", ">\n  }"));

        function LP(e) {
            let {
                aberrationStrength: t = 0,
                fastChroma: n = !0,
                envMap: i,
                ...o
            } = e;
            nM({
                MeshRefractionMaterial: BP
            });
            const a = (0, r.useRef)(),
                {
                    size: s
                } = KM(),
                l = (0, r.useMemo)((() => {
                    var e, r;
                    const o = {},
                        a = (s = i) && s.isCubeTexture;
                    var s;
                    const l = (null !== (e = a ? null == (r = i.image[0]) ? void 0 : r.width : i.image.width) && void 0 !== e ? e : 1024) / 4,
                        c = Math.floor(Math.log2(l)),
                        u = Math.pow(2, c),
                        d = 3 * Math.max(u, 112),
                        h = 4 * u;
                    return a && (o.ENVMAP_TYPE_CUBEM = ""), o.CUBEUV_TEXEL_WIDTH = "".concat(1 / d), o.CUBEUV_TEXEL_HEIGHT = "".concat(1 / h), o.CUBEUV_MAX_MIP = "".concat(c, ".0"), t > 0 && (o.CHROMATIC_ABERRATIONS = ""), n && (o.FAST_CHROMA = ""), o
                }), [t, n]);
            return (0, r.useLayoutEffect)((() => {
                var e;
                const t = null == (e = a.current) || null == (e = e.__r3f) || null == (e = e.parent) ? void 0 : e.geometry;
                t && (a.current.bvh = new PP, a.current.bvh.updateFrom(new mC(t.clone().toNonIndexed(), {
                    lazyGeneration: !1,
                    strategy: FA
                })))
            }), []), JM((e => {
                let {
                    camera: t
                } = e;
                a.current.viewMatrixInverse = t.matrixWorld, a.current.projectionMatrixInverse = t.projectionMatrixInverse
            })), r.createElement("meshRefractionMaterial", (0, uw.c)({
                key: JSON.stringify(l),
                defines: l,
                ref: a,
                resolution: [s.width, s.height],
                aberrationStrength: t,
                envMap: i
            }, o))
        }
        const DP = e => {
            let {
                diamondsVisibility: t,
                type: n,
                positionY: i,
                caratWeight: o,
                scaleReducer: a,
                caratWeightMultiplier: s,
                onLoadComplete: l
            } = e;
            const {
                nodes: c,
                scene: u
            } = wP(n.diamondShape), d = (0, r.useRef)(!1);
            let h = ZM(Fw, "diamond (1).hdr");
            const p = (0, r.useRef)(),
                [f, m] = (0, r.useState)(0);
            let g;
            g = u.children[0].geometry ? u.children[0].geometry : u.children[0].children[0].geometry, (0, r.useEffect)((() => {
                u && !d.current && (d.current = !0, l())
            }), [u]), (0, r.useEffect)((() => {
                m((e => e + 1))
            }), [g]);
            const v = {
                bounces: 3,
                aberrationStrength: .01,
                ior: 2.75,
                fresnel: 1,
                color: "white",
                fastChroma: !0
            };
            let y = Math.pow(o, s.L) * a,
                b = Math.pow(o, s.W) * a,
                x = Math.pow(o, s.D) * a;
            return (0, Nn.jsx)(AP, {
                resolution: 1024,
                envMap: h,
                children: e => t && (0, Nn.jsx)("mesh", {
                    ref: p,
                    geometry: g,
                    scale: [b, x, y],
                    rotation: [0, 0, 0],
                    position: [0, i, 0],
                    children: (0, Nn.jsx)(LP, {
                        envMap: e,
                        ...v,
                        toneMapped: !1
                    })
                }, f)
            })
        };

        function NP(e) {
            let {
                diamondsVisibility: t,
                caratWeight: n,
                scaleReducer: i,
                caratWeightMultiplier: o,
                type: a,
                positionY: s,
                onLoadComplete: l
            } = e;
            return (0, Nn.jsx)(r.Suspense, {
                fallback: null,
                children: (0, Nn.jsx)(DP, {
                    diamondsVisibility: t,
                    type: a,
                    positionY: s,
                    caratWeight: n,
                    scaleReducer: i,
                    caratWeightMultiplier: o,
                    onLoadComplete: l
                })
            })
        }
        const kP = e => {
            let {} = e;
            const {
                nodes: t,
                scene: n
            } = wP("./DiamondPave.glb");
            let i = ZM(Fw, "diamond (1).hdr");
            const o = (0, r.useRef)(),
                [a, s] = (0, r.useState)(0),
                l = n.children[0].children[0].geometry;
            (0, r.useEffect)((() => {
                o.current.name = "diamondmesh"
            }), [l]);
            const c = {
                bounces: 3,
                aberrationStrength: .01,
                ior: 2.75,
                fresnel: 1,
                color: "white",
                fastChroma: !0
            };
            return (0, Nn.jsx)(AP, {
                resolution: 1024,
                envMap: i,
                children: e => (0, Nn.jsx)("mesh", {
                    ref: o,
                    geometry: l,
                    scale: [.01, .01, .01],
                    position: [0, 0, 0],
                    children: (0, Nn.jsx)(LP, {
                        envMap: e,
                        ...c
                    })
                }, a)
            })
        };

        function FP(e) {
            let {} = e;
            return (0, Nn.jsx)(r.Suspense, {
                fallback: null,
                children: (0, Nn.jsx)(kP, {})
            })
        }
        class UP {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                this.x = e, this.y = t, this.z = n
            }
            copy(e) {
                return this.x = e.x, this.y = e.y, this.z = e.z, this
            }
            clone() {
                return new UP(this.x, this.y, this.z)
            }
            negate() {
                return this.x *= -1, this.y *= -1, this.z *= -1, this
            }
            add(e) {
                return this.x += e.x, this.y += e.y, this.z += e.z, this
            }
            sub(e) {
                return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
            }
            times(e) {
                return this.x *= e, this.y *= e, this.z *= e, this
            }
            dividedBy(e) {
                return this.x /= e, this.y /= e, this.z /= e, this
            }
            lerp(e, t) {
                return this.add((new UP).copy(e).sub(this).times(t))
            }
            unit() {
                return this.dividedBy(this.length())
            }
            length() {
                return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2))
            }
            normalize() {
                return this.unit()
            }
            cross(e) {
                const t = this.clone(),
                    n = t.x,
                    r = t.y,
                    i = t.z,
                    o = e.x,
                    a = e.y,
                    s = e.z;
                return this.x = r * s - i * a, this.y = i * o - n * s, this.z = n * a - r * o, this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y + this.z * e.z
            }
            toVector3() {
                return new Pu(this.x, this.y, this.z)
            }
        }
        class zP {
            constructor(e, t) {
                this.normal = e, this.w = t, this.normal = e, this.w = t
            }
            clone() {
                return new zP(this.normal.clone(), this.w)
            }
            flip() {
                this.normal.negate(), this.w = -this.w
            }
            splitPolygon(e, t, n, r, i) {
                let o = 0;
                const a = [];
                for (let s = 0; s < e.vertices.length; s++) {
                    const t = this.normal.dot(e.vertices[s].pos) - this.w,
                        n = t < -zP.EPSILON ? 2 : t > zP.EPSILON ? 1 : 0;
                    o |= n, a.push(n)
                }
                switch (o) {
                    case 0:
                        (this.normal.dot(e.plane.normal) > 0 ? t : n).push(e);
                        break;
                    case 1:
                        r.push(e);
                        break;
                    case 2:
                        i.push(e);
                        break;
                    case 3:
                        {
                            const t = [],
                                n = [];
                            for (let r = 0; r < e.vertices.length; r++) {
                                const i = (r + 1) % e.vertices.length,
                                    o = a[r],
                                    s = a[i],
                                    l = e.vertices[r],
                                    c = e.vertices[i];
                                if (2 != o && t.push(l), 1 != o && n.push(2 != o ? l.clone() : l), 3 == (o | s)) {
                                    const e = (this.w - this.normal.dot(l.pos)) / this.normal.dot((new UP).copy(c.pos).sub(l.pos)),
                                        r = l.interpolate(c, e);
                                    t.push(r), n.push(r.clone())
                                }
                            }
                            t.length >= 3 && r.push(new HP(t, e.shared)),
                            n.length >= 3 && i.push(new HP(n, e.shared));
                            break
                        }
                }
            }
            static fromPoints(e, t, n) {
                const r = (new UP).copy(t).sub(e).cross((new UP).copy(n).sub(e)).normalize();
                return new zP(r.clone(), r.dot(e))
            }
        }
        zP.EPSILON = 1e-5;
        class HP {
            constructor(e, t) {
                this.vertices = e, this.shared = t, this.plane = zP.fromPoints(e[0].pos, e[1].pos, e[2].pos)
            }
            clone() {
                return new HP(this.vertices.map((e => e.clone())), this.shared)
            }
            flip() {
                this.vertices.reverse().map((e => e.flip())), this.plane.flip()
            }
        }
        const jP = e => {
            let {
                type: t,
                index: n,
                prongCount: i,
                handleProngArmsVolumeUpdate: o,
                handleProngArmsPaveUpdate: a,
                cathedral: s,
                diamondsVisibility: l,
                extraMetal: c,
                material: u,
                prongLength: d,
                position: h,
                rotation: p,
                prongTipType: f,
                prongWidth: m,
                caratWeight: g,
                hasProngPave: v,
                scaleReducerVector: y,
                scaleReducer: b,
                basketHalo: x,
                headOrientation: _
            } = e;
            "None" === s || p[1] + _ !== Math.PI / 2 && p[1] + _ !== 1.5 * Math.PI || (v = !1);
            let M = "";
            c && (M += "_manufacturing");
            let w = "";
            v && (w += "Pave"), c && (w += "Manufacturing");
            let A = "Manufacturing";
            v && (A = "PaveManufacturing");
            const {
                gl: S,
                scene: E
            } = KM();

            function C(e) {
                let t = d / m,
                    n = Math.sqrt(Math.pow(t, 2) - Math.pow(e, 2)),
                    r = Math.asin(e / t);
                let i = -(p[0] - r);
                Math.PI;
                x && x.name;
                let o = .2;
                x && "Classic" === x.name && (o = .2);
                let a;
                a = .2;
                let s = n - o - P,
                    l = 0,
                    c = 0;
                for (const [u, d] of Object.entries(R)) d < s && (l = d, c = u);
                return [c, s - l + P, l, r, i]
            }
            let T = .2938;
            let P = 1.1;
            let R = {
                0: 0,
                1: 1.0073,
                2: 1.9169,
                3: 2.8169,
                4: 3.7169,
                5: 4.6169,
                6: 5.5169,
                7: 6.4169
            };
            c && v && (R = {
                0: 0,
                1: 1.1265,
                2: 1.9786,
                3: 2.8461,
                4: 3.688,
                5: 4.529,
                6: 5.3701,
                7: 6.2111
            });
            let I, [O, B, L, D, N] = C(T),
                k = O;
            1 == O && (P = .3, [O, B, L, D, N] = C(T), k = O - 1), N * (180 / Math.PI) >= 32.5 && N * (180 / Math.PI) <= 37.5 ? I = 35 : N * (180 / Math.PI) > 37.5 && N * (180 / Math.PI) <= 42.5 ? I = 40 : N * (180 / Math.PI) > 42.5 && N * (180 / Math.PI) <= 47.5 ? I = 45 : N * (180 / Math.PI) > 47.5 && N * (180 / Math.PI) <= 52.5 ? I = 50 : N * (180 / Math.PI) > 52.5 && N * (180 / Math.PI) <= 57.5 ? I = 55 : N * (180 / Math.PI) > 57.5 && N * (180 / Math.PI) <= 62.5 ? I = 60 : N * (180 / Math.PI) > 62.5 && N * (180 / Math.PI) <= 67.5 ? I = 65 : N * (180 / Math.PI) > 67.5 && N * (180 / Math.PI) <= 72.5 ? I = 70 : N * (180 / Math.PI) > 72.5 && N * (180 / Math.PI) <= 77.5 ? I = 75 : N * (180 / Math.PI) > 77.5 && N * (180 / Math.PI) <= 82.5 ? I = 80 : N * (180 / Math.PI) > 82.5 && N * (180 / Math.PI) <= 87.5 && (I = 85);
            let F = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/prongarm/middle" + M + "/Middle" + k + w + ".glb"),
                U = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/prongarm/bottom" + M + "/Bottom" + w + ".glb"),
                z = ZM(yC, f.glb);
            const H = new Hm;
            let j = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/prongarm/tip" + M + "/WedgeTip" + I + w + ".glb"),
                G = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/prongarm/tip_manufacturing/Tip" + I + A + ".glb");
            const V = F.scene.clone(!0);
            let q = U.scene.clone(!0),
                W = U.scene.children[0].children[0].geometry.clone();
            q.children[0].children[0].geometry = W, c && v && (W = U.scene.children[0].children[1].geometry.clone(), q.children[0].children[1].geometry = W);
            const X = z.scene.clone(!0),
                K = j.scene.clone(!0),
                J = G.scene.clone(!0);

            function Y(e, t) {
                const n = e.geometry,
                    r = n.morphAttributes.position[0],
                    i = n.attributes.position,
                    o = r.array,
                    a = new Float32Array(3 * i.count);
                for (let c = 0; c < i.count; c++) a[3 * c] = o[3 * c] * t, a[3 * c + 1] = o[3 * c + 1] * t, a[3 * c + 2] = o[3 * c + 2] * t;
                const s = new Mh;
                s.setAttribute("position", new ih(a, 3));
                for (const c in n.attributes) "position" !== c && s.setAttribute(c, n.attributes[c]);
                null !== n.index && s.setIndex(n.index);
                const l = new zh(s, u);
                return l.scale.set(100, 100, 100), l.rotation.copy(e.rotation), l.quaternion.copy(e.quaternion), l
            }(0, r.useEffect)((() => {
                let e, t, n;
                e = q, c && v ? (t = e.children[0].children[1], n = e.children[0].children[0]) : (t = e.children[0].children[0], n = e.children[0].children[1]);
                let r = (B - .55) / 2.25,
                    i = t.geometry.attributes.position.array;
                for (let l = 0; l < i.length - 2; l += 3) {
                    i[l];
                    let e = i[l + 2];
                    i[l + 1];
                    100 * e > .5 && (t.geometry.attributes.position.array[l + 2] = B / 100, e = B / 100)
                }
                t.geometry.attributes.position.needsUpdate = !0;
                let o, a = function(e) {
                    var t = e.geometry;
                    t.computeBoundingBox();
                    var n = new Pu;
                    return t.boundingBox.getCenter(n), e.localToWorld(n), n
                }(Y(n, r));
                if (V.position.set(a.x, a.y, a.z + 0), o = X, !x || "Classic" !== x.name && "Bezel" !== x.name)
                    if (c) o = J;
                    else {
                        let e = 0,
                            t = 0,
                            n = 0;
                        o.children[0].children[0] && (o.children[0].children[0].morphTargetInfluences = [t, e, n]), o.children[0].children[1] && (o.children[0].children[1].morphTargetInfluences = [t, e, n])
                    }
                else o = K;
                let s;
                o.position.set(a.x + 0, a.y + R[O] - R[2], a.z + 0), e.traverse((e => {
                    e.isMesh && (e.material = u)
                })), V.traverse((e => {
                    e.isMesh && (e.material = u)
                })), o.traverse((e => {
                    e.isMesh && (e.material = u)
                })), E.traverse((e => {
                    v && e.isMesh && "onecround" === e.name && (s = e.material)
                }));
                let d = [];
                V.traverse((e => {
                    e.isMesh && "diamondmesh" === e.name.substring(0, 11) && (l ? V.getObjectByName(e.name).material = s : d.push(V.getObjectByName(e.name)))
                }));
                for (let l = 0; l < d.length; l++) {
                    const e = d[l];
                    e.parent.remove(e)
                }
                H.add(o), H.add(V), H.add(e)
            }), [d, q, X, f.name, v, B, V, O, x, R, E, H, N, u, Y, l, K]), H.rotation.order = "YXZ", H.rotation.set(...p), H.rotation.x = H.rotation.x - D, H.position.set(...h);
            return (0, r.useEffect)((() => {
                let e = 1.08,
                    t = .9853,
                    r = 1;
                v && (e = 1.1704, t = 1.0736, r = 1.308);
                const i = e * m,
                    s = t * m,
                    l = Math.PI * i / 2 * s / 2;
                o(n, l * ((B + L) * m * r + 1.7982 * m)), a(n, v ? parseInt(k, 10) : 0)
            }), [v, n, O, m, B, L, i]), (0, Nn.jsx)(Nn.Fragment, {
                children: (0, Nn.jsx)("primitive", {
                    object: H,
                    scale: [m / b, m / b, m / b]
                })
            })
        };

        function GP(e) {
            let {
                type: t,
                index: n,
                prongCount: i,
                handleProngArmsVolumeUpdate: o,
                handleProngArmsPaveUpdate: a,
                diamondsVisibility: s,
                extraMetal: l,
                cathedral: c,
                basketHalo: u,
                scaleReducerVector: d,
                scaleReducer: h,
                prongTipType: p,
                material: f,
                position: m,
                rotation: g,
                prongLength: v,
                prongWidth: y,
                caratWeight: b,
                hasProngPave: x,
                headOrientation: _
            } = e;
            return (0, Nn.jsx)(r.Suspense, {
                fallback: null,
                children: (0, Nn.jsx)(jP, {
                    type: t,
                    index: n,
                    prongCount: i,
                    handleProngArmsVolumeUpdate: o,
                    handleProngArmsPaveUpdate: a,
                    cathedral: c,
                    diamondsVisibility: s,
                    extraMetal: l,
                    material: f,
                    rotation: g,
                    position: m,
                    prongLength: v,
                    prongTipType: p,
                    prongWidth: y,
                    caratWeight: b,
                    hasProngPave: x,
                    scaleReducerVector: d,
                    scaleReducer: h,
                    basketHalo: u,
                    headOrientation: _
                })
            })
        }
        const VP = e => {
                let {
                    type: t,
                    headCount: n,
                    setProngsVolume: i,
                    setProngsPave: o,
                    diamondsVisibility: a,
                    extraMetal: s,
                    basketHalo: l,
                    scaleReducerVector: c,
                    scaleReducer: u,
                    prongCount: d,
                    prongArmCalculations: h,
                    prongArmType: p,
                    prongTipType: f,
                    hasProngPave: m,
                    prongWidth: g,
                    prongMetalColor: v,
                    cathedral: y,
                    caratWeight: b,
                    bandInnerRadius: x,
                    bandWidth: _,
                    bandPaveStyle: M,
                    headOrientation: w
                } = e;
                const [A, S] = (0, r.useState)([]), [E, C] = (0, r.useState)([]), T = h.prongOrientation, P = h.prongAngleOfApproach, R = h.prongArmLength, I = .5749 / .9 * _;
                let O = 1.8;
                "None" !== M && (O = .36000000000000004 + Math.max(.8 * 1.8, I));
                const B = (x + O - .45 * g) / u,
                    L = (0, r.useMemo)((() => Array.from({
                        length: d
                    }, ((e, t) => ({
                        position: [0, B, 0],
                        rotation: [-P[t], T[t], 0]
                    })))), [P, T, d]),
                    D = (0, r.useMemo)((() => new rb({
                        color: v,
                        metalness: 1,
                        roughness: .05
                    })), [v]);
                (0, r.useMemo)((() => {
                    S(new Array(parseInt(d, 10)).fill(0)), C(new Array(parseInt(d, 10)).fill(0))
                }), [d]);
                const N = (e, t) => {
                        S((n => {
                            const r = [...n];
                            return r[e] = t, r
                        }))
                    },
                    k = (e, t) => {
                        C((n => {
                            const r = [...n];
                            return r[e] = t, r
                        }))
                    };
                return (0, r.useEffect)((() => {
                    const e = E.reduce(((e, t) => e + t), 0);
                    i(e)
                }), [m, E]), (0, r.useEffect)((() => {
                    m || S([])
                }), [m]), (0, r.useEffect)((() => {
                    if (m) {
                        const e = A.reduce(((e, t) => e + t), 0);
                        o([{
                            quantity: e,
                            size: .8 * g,
                            shape: "Round",
                            style: "Petite French Pave"
                        }])
                    } else o([])
                }), [m, A, g]), (0, Nn.jsx)("group", {
                    children: L.map(((e, n) => (0, Nn.jsx)(GP, {
                        type: t,
                        index: n,
                        prongCount: d,
                        handleProngArmsVolumeUpdate: k,
                        handleProngArmsPaveUpdate: N,
                        cathedral: y,
                        diamondsVisibility: a,
                        extraMetal: s,
                        basketHalo: l,
                        scaleReducerVector: c,
                        scaleReducer: u,
                        prongWidth: g,
                        caratWeight: b,
                        hasProngPave: m,
                        prongTipType: f,
                        material: D,
                        position: e.position,
                        rotation: e.rotation,
                        prongLength: R[n],
                        headOrientation: w
                    }, n)))
                })
            },
            qP = e => {
                let t;
                return t = Math.min(Math.floor(10 * (.8 + e / 10)) / 10, 10) / .8, t
            },
            WP = e => {
                let t;
                return t = Math.min(Math.floor(10 * (.8 + e / 10)) / 10, 1.3) / .8, t
            },
            XP = (e, t, n, r, i, o, a, s) => {
                let l = e + t / i + n / i - 1.1834 * r / i;
                return o && (l = e + t / i + n / i + s - a), l
            },
            KP = {
                Round: {
                    topOuter: .85,
                    bottomOuter: .75,
                    verticalPlacement: .6,
                    verticalPlacementFixedSubtraction: .1
                },
                Oval: {
                    topOuter: .825,
                    bottomOuter: .775,
                    verticalPlacement: .6,
                    verticalPlacementFixedSubtraction: .1
                },
                Princess: {
                    topOuter: .8,
                    bottomOuter: .65,
                    verticalPlacement: .5,
                    verticalPlacementFixedSubtraction: .1325
                },
                Asscher: {
                    topOuter: .75,
                    bottomOuter: .57,
                    verticalPlacement: .5,
                    verticalPlacementFixedSubtraction: .1325
                },
                Emerald: {
                    topOuter: .8,
                    bottomOuter: .62,
                    verticalPlacement: .5,
                    verticalPlacementFixedSubtraction: .1325
                },
                Radiant: {
                    topOuter: .75,
                    bottomOuter: .57,
                    verticalPlacement: .5,
                    verticalPlacementFixedSubtraction: .1325
                },
                Cushion: {
                    topOuter: .81,
                    bottomOuter: .7,
                    verticalPlacement: .55,
                    verticalPlacementFixedSubtraction: .12
                },
                Marquise: {
                    topOuter: .8,
                    bottomOuter: .7,
                    verticalPlacement: .5,
                    verticalPlacementFixedSubtraction: .1
                },
                Pear: {
                    topOuter: .79,
                    bottomOuter: .69,
                    verticalPlacement: .5,
                    verticalPlacementFixedSubtraction: .1
                }
            },
            JP = (e, t, n, r, i, o) => t - r.clearance + Math.min(KP[e].verticalPlacement * (r.clearance + n / o), r.clearance + n / o - KP[e].verticalPlacementFixedSubtraction),
            YP = (e, t, n, r, i, o, a, s) => {
                let l;
                const c = .8419 / s * a;
                let u, d, h, p, f, m, g, v;
                if (e) {
                    let r = t / 2 / s,
                        a = n / 2 / s;
                    "Pear" === e && (a = (n - t / 2) / s);
                    const l = i.prongWidth / s;
                    u = KP[e].topOuter * r, d = KP[e].topOuter * a, h = u - .25 * l, p = d - .25 * l, f = Math.max(KP[e].bottomOuter * r, h + .05 * l), m = Math.max(KP[e].bottomOuter * a, p + .05 * l), g = f - .5 * l, v = m - .5 * l;
                    o && (u = h + .05 * l, d = p + .05 * l, f = u, m = d)
                }
                return l = {
                    height: c,
                    topOuterWidth: u,
                    topOuterLength: d,
                    topInnerWidth: h,
                    topInnerLength: p,
                    bottomOuterWidth: f,
                    bottomOuterLength: m,
                    bottomInnerWidth: g,
                    bottomInnerLength: v,
                    diamondEdgeToTopOuterRatio: KP[e].topOuter
                }, l
            },
            QP = e => {
                let {
                    prongCount: t,
                    prongWidth: n,
                    setHaloBasketVolume: i,
                    setHaloBasketPave: o,
                    prongOrientation: a,
                    extraMetal: s,
                    diamondsVisibility: l,
                    scaleReducerVector: c,
                    scaleReducer: u,
                    type: d,
                    prongTipType: h,
                    basketHalo: p,
                    caratWeight: f,
                    diamondWidth: m,
                    diamondLength: g,
                    diamondPavHeight: v,
                    diamondGirdleThickness: y,
                    diamondCrownHeight: b,
                    diamondPositionY: x,
                    haloThicknessRatio: _,
                    prongArmCalculations: M,
                    prongMetalColor: w
                } = e;
                const {
                    gl: A,
                    scene: S
                } = KM(), E = (0, r.useMemo)((() => new rb({
                    color: w,
                    metalness: 1,
                    roughness: .05,
                    wireframe: !1
                })), [w]), C = (0, r.useMemo)((() => new Hm), [f, d, p, h, l, s, u, x, t, a]);
                let T = "";
                s && (T += "_manufacturing");
                let P = "";
                s && (P += "Manufacturing");
                let R = "";
                "Asscher" != d.name && "Emerald" != d.name && "Radiant" != d.name || (R += "CutCorner");
                const I = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/halo/arm/Arm.glb"),
                    O = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/halo/arm/RoundTip" + R + ".glb"),
                    B = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/halo/arm/ClawTip" + R + ".glb"),
                    L = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/halo/arm/PetiteClawTip" + R + ".glb"),
                    D = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/halo/arm/TabTip" + R + ".glb"),
                    N = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/halo/arm_manufacturing/Tip" + R + "Manufacturing.glb"),
                    k = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/halo/arm/ArmCutCornerStraight.glb");
                let F = XP(x, v, y, _, u, !1, null, null),
                    U = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/halo/block" + T + "/RoundEdge" + P + ".glb"),
                    z = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/halo/block" + T + "/OvalEdge" + P + ".glb"),
                    H = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/halo/block" + T + "/PrincessEdge" + P + ".glb"),
                    j = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/halo/block" + T + "/PrincessEdgeExtraMetal" + P + ".glb"),
                    G = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/halo/block" + T + "/PrincessCorner" + P + ".glb"),
                    V = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/halo/block" + T + "/AsscherEdge" + P + ".glb"),
                    q = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/halo/block" + T + "/AsscherEdgeExtraMetal" + P + ".glb"),
                    W = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/halo/block" + T + "/AsscherCorner" + P + ".glb"),
                    X = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/halo/block" + T + "/AsscherCornerMirrored" + P + ".glb"),
                    K = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/halo/block" + T + "/CushionCorner" + P + ".glb"),
                    J = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/halo/block" + T + "/CushionEdge" + P + ".glb"),
                    Y = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/halo/block" + T + "/MarquiseCorner" + P + ".glb"),
                    Q = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/halo/block" + T + "/MarquiseEdge" + P + ".glb");
                const [Z, $] = (0, r.useState)(0);
                return (0, r.useEffect)((() => {
                    let e = 0,
                        t = 0,
                        n = 0,
                        r = 0;
                    if ("Round" == d.name) {
                        const f = 100;
                        let v = .8 / u,
                            x = (v - .005 / u) * _,
                            w = (v + .05 / u) * _,
                            A = .5302 / u,
                            T = m / 2 / u,
                            P = T + x;
                        if (s) {
                            e = .10062893081761001 * x
                        }
                        t = .10062893081761001 * x;
                        const R = new Mh,
                            F = [P + 3 * e, T];

                        function Z(e, t, n) {
                            for (let r = 0; r < f; r++) {
                                const i = r / f * 2 * Math.PI,
                                    o = e * Math.cos(i),
                                    a = t,
                                    s = e * Math.sin(i);
                                n.push(o, a, s)
                            }
                        }
                        const ee = [];
                        Z(F[0], 0, ee), Z(F[1], 0, ee), R.setAttribute("position", new ph(ee, 3));
                        const te = [];
                        for (let me = 0; me < f; me++) {
                            const ge = (me + 1) % f;
                            te.push(me, me + f, ge), te.push(ge, me + f, ge + f)
                        }
                        R.setIndex(te), R.computeVertexNormals();
                        const ne = new zh(R, E);
                        ne.position.set(0, .004 / u, 0), C.add(ne);
                        const re = x / 2;
                        let ie = T + re,
                            oe = new Jy(ie + 1.5 * e, re + 1.5 * e, 30, f);
                        const ae = [];
                        for (let ve = 0; ve < oe.index.count; ve += 3) {
                            const ye = oe.index.array[ve],
                                be = oe.index.array[ve + 1],
                                xe = oe.index.array[ve + 2],
                                _e = oe.attributes.position.array[3 * ye + 2],
                                Me = oe.attributes.position.array[3 * be + 2],
                                we = oe.attributes.position.array[3 * xe + 2];
                            _e < .01 / u && Me < .01 / u && we < .01 / u || ae.push(ye, be, xe)
                        }
                        oe.setIndex(ae);
                        const se = new zh(oe, E);
                        se.rotation.order = "YXZ", se.rotation.set(Math.PI / 2, 0, 0), se.position.set(0, .004 / u, 0), se.scale.set(1, 1, 1), C.add(se);
                        const le = x / 20,
                            ce = new Jy(T + x - le - 1e-4 / u, le, 30, f),
                            ue = new zh(ce, E);
                        ue.rotation.order = "YXZ", ue.rotation.set(Math.PI / 2, 0, 0), ue.position.set(0, 0, 0);
                        new jh(v, A, x), new Yd({
                            color: 255
                        });
                        let de, he = 2 * Math.PI * ie,
                            pe = Math.floor(he / w);
                        $(pe), S.traverse((e => {
                            e.isMesh && "diamondmesh" === e.name && (de = e.material)
                        }));
                        let fe = .021;
                        s && (fe = -.01);
                        for (let Ae = 0; Ae < pe; Ae++) {
                            const Se = U.scene.clone(!0);
                            let Ee = Ae / pe * 2 * Math.PI;
                            Se.position.set((ie + 2 * e - fe / u * _) * Math.cos(Ee), 0, (ie + 2 * e - fe / u * _) * Math.sin(Ee)), Se.rotation.set(0, -Ee, 0), Se.scale.set(_ / u, _ / u, _ / u), Se.traverse((e => {
                                e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = E))
                            }));
                            const Ce = "DiamondMesh";
                            if (l) Se.getObjectByName(Ce).material = de;
                            else {
                                let Te = Se.getObjectByName(Ce);
                                Te.parent.remove(Te)
                            }
                            C.add(Se)
                        }
                        n = (x + 3 * t) * u, r = 2 * Math.PI * (P + 3 * t + T) / 2 * u
                    } else if ("Oval" == d.name) {
                        const Pe = 100;
                        let Re = .8 / u,
                            Ie = (Re - .005 / u) * _,
                            Oe = (Re + 2 * (.05 / u)) * _;
                        if (s) {
                            e = .10062893081761001 * Ie
                        }
                        t = .10062893081761001 * Ie;
                        let Be = m / 2 / u,
                            Le = g / 2 / u,
                            De = Be + Ie,
                            Ne = Le + Ie,
                            ke = Be + Ie / 2,
                            Fe = Le + Ie / 2;
                        const Ue = 2,
                            ze = new Mh,
                            He = 0;

                        function je(e, t, n, r) {
                            for (let i = 0; i < Pe; i++) {
                                const o = i / Pe * 2 * Math.PI,
                                    a = e * Math.cos(o),
                                    s = n,
                                    l = t * Math.sin(o);
                                r.push(a, s, l)
                            }
                        }

                        function Ge(e, t, n, r) {
                            const i = -e / (n * n),
                                o = -t / (r * r),
                                a = Math.sqrt(i * i + o * o);
                            return {
                                nx: i / a,
                                nz: o / a
                            }
                        }

                        function Ve(t, n, r, i, o, a) {
                            for (let s = 0; s < Pe + 1; s++) {
                                const l = s / Pe * 2 * Math.PI,
                                    c = t * Math.cos(l),
                                    u = n * Math.sin(l),
                                    d = (c + r * Math.cos(l)) / 2,
                                    h = (u + i * Math.sin(l)) / 2,
                                    {
                                        nx: p,
                                        nz: f
                                    } = Ge(d, h, (t + r) / 2, (n + i) / 2);
                                for (let t = 0; t < Pe; t++) {
                                    const n = Math.PI / 99 * t,
                                        r = d + (Ie + 3 * e) / 2 * p * Math.cos(n),
                                        i = h + (Ie + 3 * e) / 2 * f * Math.cos(n),
                                        s = o - (Ie + 3 * e) / 2 * Math.sin(n);
                                    a.push(r, s, i)
                                }
                            }
                        }
                        const qe = [];
                        je(Be, Le, He, qe), je(De + 3 * e, Ne + 3 * e, He, qe), Ve(De + 3 * e, Ne + 3 * e, Be, Le, He, qe);
                        const We = [];
                        for (let ft = 0; ft < Pe; ft++) {
                            const mt = (ft + 1) % Pe,
                                gt = ft,
                                vt = ft + Pe;
                            We.push(gt, mt, vt), We.push(mt + Pe, vt, mt)
                        }
                        const Xe = 2 * Pe;
                        for (let yt = 0; yt < Pe; yt++)
                            for (let bt = 0; bt < Pe - 1; bt++) {
                                const xt = Xe + yt * Pe + bt,
                                    _t = xt + 1,
                                    Mt = xt + Pe,
                                    wt = _t + Pe,
                                    At = qe.length / 3;
                                xt >= At || _t >= At || Mt >= At || wt >= At ? console.error("Index out of bounds: current=".concat(xt, ", next=").concat(_t, ", below=").concat(Mt, ", belowNext=").concat(wt)) : (We.push(xt, _t, Mt), We.push(_t, wt, Mt))
                            }
                        ze.setAttribute("position", new ph(qe, 3)), ze.setIndex(We), ze.computeVertexNormals();
                        const Ke = new zh(ze, E);
                        let Je;
                        Ke.position.set(0, 0, 0), Ke.scale.set(1, 1, 1), C.add(Ke), S.traverse((e => {
                            e.isMesh && "diamondmesh" === e.name && (Je = e.material)
                        }));
                        const Ye = Math.PI * (3 * (Fe + ke) - Math.sqrt((3 * Fe + ke) * (Fe + 3 * ke))),
                            Qe = Math.floor(Ye / Oe),
                            Ze = Ye / Qe / Ue;
                        let $e = .0019 * _;

                        function et(e, t, n) {
                            return Math.sqrt(Math.pow(t * Math.sin(e), 2) + Math.pow(n * Math.cos(e), 2))
                        }

                        function tt(e, t, n) {
                            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e3;
                            const i = (n - t) / r;
                            let o = (e(t) + e(n)) / 2;
                            for (let a = 1; a < r; a++) o += e(t + a * i);
                            return o * i
                        }
                        let nt = [0];

                        function rt(e, t, n, r) {
                            let i = 0,
                                o = e;
                            for (; i < t;) o += .05, i = tt((e => et(e, n, r)), e, o);
                            for (; i > t;) o -= .001, i = tt((e => et(e, n, r)), e, o);
                            for (; i < t;) o += 1e-4, i = tt((e => et(e, n, r)), e, o);
                            return o
                        }
                        const it = Qe * Ue;
                        for (let St = 0; St < it - 1; St++) {
                            const Et = rt(nt[nt.length - 1], Ze, Fe, ke);
                            nt.push(Et)
                        }
                        s && ($e = -.01 * _ / u);
                        const ot = nt.map((t => (ke + 2 * e - $e) * Math.sin(t))),
                            at = nt.map((t => -(Fe + 2 * e - $e) * Math.cos(t))),
                            st = nt.map((e => 0 !== Math.sin(e) ? ke * Math.cos(e) / (Fe * Math.sin(e)) : 1 / 0)),
                            lt = st.map((e => Math.atan(e))),
                            ct = nt.map(((e, t) => ({
                                theta: e,
                                x: ot[t],
                                z: at[t],
                                node_tangent: st[t],
                                node_rotation: lt[t]
                            }))),
                            ut = 2 * Math.floor(Qe / 2),
                            dt = (Qe + 1) % 2;
                        $(Math.floor((ct.length - 1 - dt) / 2 + 1));
                        for (let Ct = dt; Ct < ct.length; Ct += 2) {
                            const Tt = ct[Ct];
                            let Pt = z.scene.clone(!0);
                            Pt.position.set(Tt.x, 0, Tt.z), Pt.rotation.set(0, Tt.node_rotation, 0), Ct > ut && (Pt.rotation.y = Tt.node_rotation + Math.PI), Pt.scale.set(_ / u, _ / u, _ / u), Pt.traverse((e => {
                                e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = E))
                            }));
                            let Rt = "DiamondMesh003";
                            if (s && (Rt = "DiamondMesh"), l) Pt.getObjectByName(Rt).material = Je;
                            else {
                                let It = Pt.getObjectByName(Rt);
                                It.parent.remove(It)
                            }
                            C.add(Pt)
                        }
                        n = (Ie + 3 * t) * u;
                        const ht = (De + 3 * t + Be) / 2,
                            pt = (Ne + 3 * t + Le) / 2;
                        r = Math.PI * (3 * (pt + ht) - Math.sqrt((3 * pt + ht) * (pt + 3 * ht))) * u
                    } else if ("Princess" == d.name) {
                        let Ot = .8 / u,
                            Bt = (Ot - .005 / u) * _,
                            Lt = (Ot + .1 / u) * _;
                        const Dt = Bt / 2,
                            Nt = Bt / 2,
                            kt = m / u,
                            Ft = 100;
                        if (s) {
                            e = .10062893081761001 * Bt
                        }
                        let Ut, zt;
                        t = .10062893081761001 * Bt, S.traverse((e => {
                            e.isMesh && "diamondmesh" === e.name ? Ut = e.material : e.isMesh && "diamondmeshcorner" === e.name && (zt = e.material)
                        }));
                        const Ht = new ry(Dt + 1.5 * e, Nt + 1.5 * e, kt, Ft),
                            jt = [];
                        for (let sn = 0; sn < Ht.index.count; sn += 3) {
                            const ln = Ht.index.array[sn],
                                cn = Ht.index.array[sn + 1],
                                un = Ht.index.array[sn + 2],
                                dn = Ht.attributes.position.array[3 * ln + 2],
                                hn = Ht.attributes.position.array[3 * cn + 2],
                                pn = Ht.attributes.position.array[3 * un + 2];
                            dn < .01 / u && hn < .01 / u && pn < .01 / u || jt.push(ln, cn, un)
                        }
                        Ht.setIndex(jt);
                        const Gt = new zh(Ht, E),
                            Vt = new zh(Ht, E),
                            qt = new zh(Ht, E),
                            Wt = new zh(Ht, E);
                        Gt.position.set(0, 0, -m / u / 2 - (Dt + 1.5 * e)), Vt.position.set(0, 0, m / u / 2 + (Dt + 1.5 * e)), qt.position.set(m / u / 2 + (Dt + 1.5 * e), 0, 0), Wt.position.set(-m / u / 2 - (Dt + 1.5 * e), 0, 0), Gt.rotation.order = "YXZ", Vt.rotation.order = "YXZ", qt.rotation.order = "YXZ", Wt.rotation.order = "YXZ", Gt.rotation.set(Math.PI / 2, Math.PI / 2, 0), Vt.rotation.set(Math.PI / 2, Math.PI / 2, 0), qt.rotation.set(Math.PI / 2, 0, 0), Wt.rotation.set(Math.PI / 2, 0, 0), Gt.scale.set(1, 1, 1), Vt.scale.set(1, 1, 1), qt.scale.set(1, 1, 1), Wt.scale.set(1, 1, 1), C.add(Gt), C.add(Vt), C.add(qt), C.add(Wt);
                        const Xt = G.scene.clone(!0),
                            Kt = G.scene.clone(!0),
                            Jt = G.scene.clone(!0),
                            Yt = G.scene.clone(!0);
                        Xt.position.set(m / u / 2 + (Dt + 2 * e), 0, -m / u / 2 - (Dt + 2 * e)), Xt.rotation.set(0, 0, 0), Xt.scale.set(_ / u, _ / u, _ / u), C.add(Xt), Kt.position.set(m / u / 2 + (Dt + 2 * e), 0, m / u / 2 + (Dt + 2 * e)), Kt.rotation.set(0, -Math.PI / 2, 0), Kt.scale.set(_ / u, _ / u, _ / u), C.add(Kt), Jt.position.set(-m / u / 2 - (Dt + 2 * e), 0, -m / u / 2 - (Dt + 2 * e)), Jt.rotation.set(0, Math.PI / 2, 0), Jt.scale.set(_ / u, _ / u, _ / u), C.add(Jt), Yt.position.set(-m / u / 2 - (Dt + 2 * e), 0, m / u / 2 + (Dt + 2 * e)), Yt.rotation.set(0, Math.PI, 0), Yt.scale.set(_ / u, _ / u, _ / u), C.add(Yt);
                        let Qt = [Xt, Kt, Jt, Yt];
                        for (let fn = 0; fn < Qt.length; fn++) {
                            const mn = Qt[fn];
                            mn.traverse((e => {
                                e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = E))
                            }));
                            let gn = "DiamondMesh015";
                            if (s && (gn = "DiamondMesh"), l) mn.getObjectByName(gn).material = zt;
                            else {
                                let vn = mn.getObjectByName(gn);
                                vn.parent.remove(vn)
                            }
                        }
                        let Zt = m / u + Bt + 4 * e,
                            $t = Math.floor(Zt / Lt),
                            en = (Zt - $t * Lt) / $t,
                            tn = .019 / u * _;
                        s && (tn = -.01 * _ / u);
                        let nn = m / u / 2 + (Dt + 2 * e);
                        for (let yn = 0; yn < $t - 1; yn++) {
                            let bn, xn;
                            if (en < Ot * _ / u ? (bn = H.scene.clone(!0), xn = "DiamondMesh014") : (bn = j.scene.clone(!0), xn = "DiamondMesh027"), s && (xn = "DiamondMesh"), nn = nn - en - Lt, bn.position.set(m / u / 2 + (Dt + 2 * e) - tn, -.005 / u, -nn), bn.rotation.set(0, 0, 0), bn.scale.set(_ / u, _ / u, _ / u), bn.traverse((e => {
                                    e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = E))
                                })), l) bn.getObjectByName(xn).material = Ut;
                            else {
                                let _n = bn.getObjectByName(xn);
                                _n.parent.remove(_n)
                            }
                            C.add(bn)
                        }
                        let rn = m / u / 2 + (Dt + 2 * e);
                        for (let Mn = 0; Mn < $t - 1; Mn++) {
                            let wn, An;
                            if (en < Ot * _ / u ? (wn = H.scene.clone(!0), An = "DiamondMesh014") : (wn = j.scene.clone(!0), An = "DiamondMesh027"), s && (An = "DiamondMesh"), rn = rn - en - Lt, wn.position.set(-m / u / 2 - (Dt + 2 * e) + tn, -.005 / u, -rn), wn.rotation.set(0, Math.PI, 0), wn.scale.set(_ / u, _ / u, _ / u), wn.traverse((e => {
                                    e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = E))
                                })), l) wn.getObjectByName(An).material = Ut;
                            else {
                                let Sn = wn.getObjectByName(An);
                                Sn.parent.remove(Sn)
                            }
                            C.add(wn)
                        }
                        let on = m / u / 2 + (Dt + 2 * e);
                        for (let En = 0; En < $t - 1; En++) {
                            let Cn, Tn;
                            if (en < Ot * _ / u ? (Cn = H.scene.clone(!0), Tn = "DiamondMesh014") : (Cn = j.scene.clone(!0), Tn = "DiamondMesh027"), s && (Tn = "DiamondMesh"), on = on - en - Lt, Cn.position.set(-on, -.005 / u, -m / u / 2 - (Dt + 2 * e) + tn), Cn.rotation.set(0, Math.PI / 2, 0), Cn.scale.set(_ / u, _ / u, _ / u), Cn.traverse((e => {
                                    e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = E))
                                })), l) Cn.getObjectByName(Tn).material = Ut;
                            else {
                                let Pn = Cn.getObjectByName(Tn);
                                Pn.parent.remove(Pn)
                            }
                            C.add(Cn)
                        }
                        let an = m / u / 2 + (Dt + 2 * e);
                        for (let Rn = 0; Rn < $t - 1; Rn++) {
                            let In, On;
                            if (en < Ot * _ / u ? (In = H.scene.clone(!0), On = "DiamondMesh014") : (In = j.scene.clone(!0), On = "DiamondMesh027"), s && (On = "DiamondMesh"), an = an - en - Lt, In.position.set(-an, -.005 / u, m / u / 2 + (Dt + 2 * e) - tn), In.rotation.set(0, -Math.PI / 2, 0), In.scale.set(_ / u, _ / u, _ / u), In.traverse((e => {
                                    e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = E))
                                })), l) In.getObjectByName(On).material = Ut;
                            else {
                                let Bn = In.getObjectByName(On);
                                Bn.parent.remove(Bn)
                            }
                            C.add(In)
                        }
                        $(4 * $t), n = (Bt + 3 * t) * u, r = 4 * (m + n)
                    } else if ("Cushion" == d.name) {
                        const Ln = 100;
                        let Dn = .8 / u,
                            Nn = (Dn - .005 / u) * _,
                            kn = (Dn + 2 * (.05 / u)) * _,
                            Fn = m / 2 / u,
                            Un = g / 2 / u,
                            zn = Fn + Nn,
                            Hn = Un + Nn,
                            jn = Fn + Nn / 2,
                            Gn = Un + Nn / 2;
                        const Vn = 0,
                            qn = 64,
                            Wn = .3,
                            Xn = 2;
                        if (s) {
                            e = .10062893081761001 * Nn
                        }

                        function Kn(e, t, n) {
                            return Math.sqrt(Math.pow(t * Math.sin(e), 2) + Math.pow(n * Math.cos(e), 2))
                        }

                        function Jn(e, t, n) {
                            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e3;
                            const i = (n - t) / r;
                            let o = (e(t) + e(n)) / 2;
                            for (let a = 1; a < r; a++) o += e(t + a * i);
                            return o * i
                        }

                        function Yn(e, t, n, r) {
                            let i = 0,
                                o = e;
                            for (; i < t;) o += .05, i = Jn((e => Kn(e, n, r)), e, o);
                            for (; i > t;) o -= .001, i = Jn((e => Kn(e, n, r)), e, o);
                            for (; i < t;) o += 1e-4, i = Jn((e => Kn(e, n, r)), e, o);
                            for (; i > t;) o -= 1e-5, i = Jn((e => Kn(e, n, r)), e, o);
                            return o
                        }

                        function Qn(e, t, n, r) {
                            let i = [0];
                            const o = Math.PI * (3 * (t + e) - Math.sqrt((3 * t + e) * (t + 3 * e))) / qn;
                            for (let u = 0; u < qn - 1; u++) {
                                const n = Yn(i[i.length - 1], o, t, e);
                                i.push(n)
                            }
                            const a = i.map((t => e * Math.sin(t))),
                                s = i.map((e => -t * Math.cos(e))),
                                l = i.map((n => 0 !== Math.sin(n) ? e * Math.cos(n) / (t * Math.sin(n)) : 1 / 0)),
                                c = l.map((e => Math.atan(e))),
                                d = i.map(((e, t) => ({
                                    theta: e,
                                    x: a[t],
                                    z: s[t],
                                    node_tangent: l[t],
                                    node_rotation: c[t]
                                }))),
                                h = new Yd({
                                    color: 65280
                                });
                            d.forEach((e => {
                                const t = new Xy(.1 / u, 32, 32);
                                new zh(t, h).position.set(e.x, n, e.z)
                            }));
                            const p = [],
                                f = 2 * (2 * e + 2 * t) / qn;
                            let m = 0;

                            function g(e, t) {
                                p.push({
                                    x: e,
                                    y: n,
                                    z: t
                                })
                            }
                            let v = f,
                                y = -t;
                            for (; v <= e; v += f) g(v, y), m += f;
                            for (v = e, y = f - (e - m) - t; y <= t; y += f) g(v, y), m += f;
                            for (y = t, v = e - (f - (2 * t + e - m)); v >= -e; v -= f) g(v, y), m += f;
                            for (v = -e, y = t - (f - (2 * t + 3 * e - m)); y >= -t; y -= f) g(v, y), m += f;
                            for (y = -t, v = f - (4 * t + 3 * e - m) - e; p.length < qn;) g(v, y), v += f, m += f;
                            const b = new Yd({
                                color: 255
                            });
                            p.forEach((e => {
                                const t = new Xy(.1 / u, 32, 32);
                                new zh(t, b).position.set(e.x, n, e.z)
                            }));
                            const x = new Yd({
                                color: 16711680
                            });
                            for (let _ = 0; _ < qn; _++) {
                                const i = new Xy(.1 / u, 32, 32),
                                    o = (new zh(i, x), [e - Math.abs(p[(_ + (qn - 1)) % qn].x) + (t - Math.abs(p[(_ + (qn - 1)) % qn].z))] / (e + t) * (1 - Wn) + Wn),
                                    a = 1 - o,
                                    s = a * d[_].x + o * p[(_ + (qn - 1)) % qn].x,
                                    l = n,
                                    c = a * d[_].z + o * p[(_ + (qn - 1)) % qn].z;
                                r.push(s, l, c)
                            }
                        }

                        function Zn(e, t, n, r) {
                            const i = -e / (n * n),
                                o = -t / (r * r),
                                a = Math.sqrt(i * i + o * o);
                            return {
                                nx: i / a,
                                nz: o / a
                            }
                        }

                        function $n(e, t) {
                            for (let n = 0; n < e.length / 2 + 3; n += 3) {
                                const r = e[n % (3 * qn)],
                                    i = e[(n + 1) % (3 * qn)],
                                    o = e[(n + 2) % (3 * qn)],
                                    a = e[n % (3 * qn) + 3 * qn],
                                    s = e[(n + 1) % (3 * qn) + 3 * qn],
                                    l = e[(n + 2) % (3 * qn) + 3 * qn],
                                    c = (r + a) / 2,
                                    u = (o + l) / 2,
                                    d = (i + s) / 2,
                                    {
                                        nx: h,
                                        nz: p
                                    } = Zn(c, u, (zn + Fn) / 2, (Hn + Un) / 2);
                                for (let e = 0; e < Ln; e++) {
                                    const n = Math.PI / 99 * e,
                                        i = r + e / (Ln - 1) * (a - r),
                                        s = o + e / (Ln - 1) * (l - o),
                                        c = d - Nn / 2 * Math.sin(n);
                                    t.push(i, c, s)
                                }
                            }
                        }
                        t = .10062893081761001 * Nn;
                        const er = new Mh;
                        let tr = [],
                            nr = [];
                        Qn(Fn, Un, 0, tr), Qn(zn, Hn, 0, tr), $n(tr, nr), tr = tr.concat(nr);
                        const rr = [];
                        for (let br = 0; br < qn; br++) {
                            const xr = (br + 1) % qn,
                                _r = br,
                                Mr = br + qn;
                            rr.push(_r, xr, Mr), rr.push(xr + qn, Mr, xr)
                        }
                        const ir = 2 * qn;
                        for (let wr = 0; wr < qn; wr++)
                            for (let Ar = 0; Ar < Ln - 1; Ar++) {
                                const Sr = ir + wr * Ln + Ar,
                                    Er = Sr + 1,
                                    Cr = Sr + Ln,
                                    Tr = Er + Ln,
                                    Pr = tr.length / 3;
                                Sr >= Pr || Er >= Pr || Cr >= Pr || Tr >= Pr ? console.error("Index out of bounds: current=".concat(Sr, ", next=").concat(Er, ", below=").concat(Cr, ", belowNext=").concat(Tr)) : (rr.push(Sr, Er, Cr), rr.push(Er, Tr, Cr))
                            }
                        er.setAttribute("position", new ph(tr, 3)), er.setIndex(rr), er.computeVertexNormals();
                        const or = new zh(er, E);
                        let ar;

                        function sr(e, t, n, r, i) {
                            let o = [i];
                            for (let s = 0; s < n - 1; s++) {
                                const e = Yn(o[o.length - 1], r, Gn, jn);
                                o.push(e)
                            }
                            const a = o.map((e => jn * Math.sin(e))),
                                c = o.map((e => -Gn * Math.cos(e))),
                                d = o.map((e => 0 !== Math.sin(e) ? jn * Math.cos(e) / (Gn * Math.sin(e)) : 1 / 0)),
                                h = d.map((e => Math.atan(e))),
                                p = o.map(((e, t) => ({
                                    theta: e,
                                    x: a[t],
                                    z: c[t],
                                    node_tangent: d[t],
                                    node_rotation: h[t]
                                }))),
                                f = new Yd({
                                    color: 65280
                                });
                            p.forEach((e => {
                                const t = new Xy(.1 / u, 32, 32);
                                new zh(t, f).position.set(e.x, 0, e.z)
                            }));
                            const m = [],
                                g = e / n;

                            function v(e, t) {
                                m.push({
                                    x: e,
                                    y: 0,
                                    z: t
                                })
                            }
                            if ("South" == t) {
                                let e = jn,
                                    t = Gn;
                                v(e, t);
                                for (let r = 0; r < n - 1; r++) e -= g, v(e, t)
                            } else if ("West" == t) {
                                let e = -jn,
                                    t = Gn;
                                v(e, t);
                                for (let r = 0; r < n - 1; r++) t -= g, v(e, t)
                            } else if ("North" == t) {
                                let e = -jn,
                                    t = -Gn;
                                v(e, t);
                                for (let r = 0; r < n - 1; r++) e += g, v(e, t)
                            } else if ("East" == t) {
                                let e = jn,
                                    t = -Gn;
                                v(e, t);
                                for (let r = 0; r < n - 1; r++) t += g, v(e, t)
                            }
                            const y = new Yd({
                                color: 255
                            });
                            m.forEach((e => {
                                const t = new Xy(.1 / u, 32, 32);
                                new zh(t, y).position.set(e.x, 0, e.z)
                            }));
                            const b = new Yd({
                                color: 16711680
                            });
                            for (let x = 0; x < n; x++) {
                                const e = new Xy(.1 / u, 32, 32),
                                    r = new zh(e, b),
                                    i = [jn - Math.abs(m[x].x) + (Gn - Math.abs(m[x].z))] / (jn + Gn) * (1 - Wn) + Wn,
                                    o = 1 - i,
                                    a = o * p[x].x + i * m[x].x,
                                    c = 0,
                                    d = o * p[x].z + i * m[x].z;
                                let h, f, g;
                                if (r.position.set(a, c, d), g = "South" == t ? Math.PI / 2 : "North" == t ? -Math.PI / 2 : 0, 1 == x || x == n - 1 ? (h = K.scene.clone(!0), f = "DiamondMesh026") : x % 2 == 1 && (h = J.scene.clone(!0), f = "DiamondMesh091"), s && (f = "DiamondMesh"), h)
                                    if (h.rotation.set(0, o * p[x].node_rotation - (1 - o) * g, 0), h.scale.set(_ / u, _ / u, _ / u), h.position.set(a, c - .005 / u, d), C.add(h), a < 0 && h.rotation.set(0, o * p[x].node_rotation + (1 - o) * g + Math.PI, 0), h.traverse((e => {
                                            e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = E))
                                        })), l) h.getObjectByName(f).material = ar;
                                    else {
                                        let e = h.getObjectByName(f);
                                        e.parent.remove(e)
                                    }
                            }
                        }
                        or.position.set(0, 0, 0), or.scale.set(1, 1, 1), C.add(or), S.traverse((e => {
                            e.isMesh && "diamondmesh" === e.name && (ar = e.material)
                        }));
                        const lr = Math.atan(jn / Gn),
                            cr = {
                                x: jn * Math.sin(lr),
                                y: Vn,
                                z: -Gn * Math.sin(lr)
                            },
                            ur = {
                                x: jn,
                                y: Vn,
                                z: -Gn
                            },
                            dr = {
                                x: Wn * ur.x + (1 - Wn) * cr.x,
                                y: Wn * ur.y + (1 - Wn) * cr.y,
                                z: Wn * ur.z + (1 - Wn) * cr.z
                            },
                            hr = 2 * Math.abs(dr.z),
                            pr = 2 * Math.abs(dr.x),
                            fr = Math.floor(hr / kn),
                            mr = Math.floor(pr / kn),
                            gr = hr / fr / Xn,
                            vr = pr / mr / Xn;
                        $(2 * fr + 2 * mr);
                        const yr = K.scene.clone(!0);
                        yr.rotation.set(0, 0, 0), yr.scale.set(_ / u, _ / u, _ / u), yr.position.set(jn, 0, Gn), sr(2 * jn, "South", mr * Xn, vr, Math.PI - lr), sr(2 * Gn, "West", fr * Xn, gr, Math.PI + lr), sr(2 * jn, "North", mr * Xn, vr, -lr), sr(2 * Gn, "East", fr * Xn, gr, lr), n = (Nn + 3 * t) * u, r = 2 * (m + n) + 2 * (g + n)
                    } else if ("Asscher" == d.name || "Emerald" == d.name || "Radiant" == d.name) {
                        let Rr = .8 / u,
                            Ir = (Rr - .005 / u) * _,
                            Or = (Rr + .1 / u) * _;
                        const Br = Ir / 2,
                            Lr = Ir / 2,
                            Dr = {
                                Asscher: .15018,
                                Emerald: .2026,
                                Radiant: .15308
                            }[d.name],
                            Nr = 100,
                            kr = m / u + Ir,
                            Fr = g / u + Ir,
                            Ur = Dr * kr,
                            zr = kr - 2 * Ur,
                            Hr = Fr - 2 * Ur,
                            jr = Ur * Math.sqrt(2);
                        let Gr = 2 * (Ur - Or / Math.sqrt(2));
                        if (s) {
                            e = .10062893081761001 * Ir
                        }
                        let Vr, qr;
                        t = .10062893081761001 * Ir, S.traverse((e => {
                            e.isMesh && "diamondmesh" === e.name ? Vr = e.material : e.isMesh && "asschermeshcorner" === e.name && (qr = e.material)
                        }));
                        const Wr = new ry(Br + 1.5 * e, Lr + 1.5 * e, zr + Gr - Ir / 2, Nr),
                            Xr = new ry(Br + 1.5 * e, Lr + 1.5 * e, Hr + Gr - Ir / 2, Nr),
                            Kr = [];
                        for (let gi = 0; gi < Wr.index.count; gi += 3) {
                            const vi = Wr.index.array[gi],
                                yi = Wr.index.array[gi + 1],
                                bi = Wr.index.array[gi + 2],
                                xi = Wr.attributes.position.array[3 * vi + 2],
                                _i = Wr.attributes.position.array[3 * yi + 2],
                                Mi = Wr.attributes.position.array[3 * bi + 2];
                            xi < .01 / u && _i < .01 / u && Mi < .01 / u || Kr.push(vi, yi, bi)
                        }
                        Wr.setIndex(Kr);
                        const Jr = [];
                        for (let wi = 0; wi < Xr.index.count; wi += 3) {
                            const Ai = Xr.index.array[wi],
                                Si = Xr.index.array[wi + 1],
                                Ei = Xr.index.array[wi + 2],
                                Ci = Xr.attributes.position.array[3 * Ai + 2],
                                Ti = Xr.attributes.position.array[3 * Si + 2],
                                Pi = Xr.attributes.position.array[3 * Ei + 2];
                            Ci < .01 / u && Ti < .01 / u && Pi < .01 / u || Jr.push(Ai, Si, Ei)
                        }
                        Xr.setIndex(Jr);
                        const Yr = new zh(Wr, E),
                            Qr = new zh(Wr, E),
                            Zr = new zh(Xr, E),
                            $r = new zh(Xr, E);
                        Yr.position.set(0, 0, -(Fr / 2 + 1.5 * e)), Qr.position.set(0, 0, Fr / 2 + 1.5 * e), Zr.position.set(kr / 2 + 1.5 * e, 0, 0), $r.position.set(-(kr / 2 + 1.5 * e), 0, 0), Yr.rotation.order = "YXZ", Qr.rotation.order = "YXZ", Zr.rotation.order = "YXZ", $r.rotation.order = "YXZ", Yr.rotation.set(Math.PI / 2, Math.PI / 2, 0), Qr.rotation.set(Math.PI / 2, Math.PI / 2, 0), Zr.rotation.set(Math.PI / 2, 0, 0), $r.rotation.set(Math.PI / 2, 0, 0), Yr.scale.set(1, 1, 1), Qr.scale.set(1, 1, 1), Zr.scale.set(1, 1, 1), $r.scale.set(1, 1, 1), C.add(Yr), C.add(Qr), C.add(Zr), C.add($r);
                        Math.floor(jr / Or);
                        let ei, ti, ni, ri, ii, oi = zr + Gr + 4 * e,
                            ai = Hr + Gr + 4 * e,
                            si = Math.floor(oi / Or),
                            li = Math.floor(ai / Or),
                            ci = oi / si,
                            ui = ai / li;
                        ci - Or < 2 * Rr * _ / u ? (ei = V, ri = "DiamondMesh044") : (ei = q, ri = "DiamondMesh042"), ui - Or < 2 * Rr * _ / u ? (ti = V, ii = "DiamondMesh044") : (ti = q, ii = "DiamondMesh042"), $(2 * (si + 1) + 2 * (li + 1));
                        let di = 0;
                        s && (di = .01 * _ / u);
                        let hi = -oi / 2;
                        for (let Ri = 0; Ri < si + 1; Ri++) {
                            let Ii, Oi;
                            if (0 == Ri ? (Ii = W.scene.clone(!0), ni = "DiamondMesh045", Ii.rotation.set(0, Math.PI / 2, 0), Ii.scale.set(_ / u, _ / u, _ / u), Oi = 1.5 * e) : Ri == si ? (Ii = X.scene.clone(!0), ni = "DiamondMesh093", Ii.rotation.set(0, 0, 0), Ii.scale.set(_ / u, _ / u, _ / u), Oi = 1.5 * e) : (Ii = ei.scene.clone(!0), ni = ri, Ii.rotation.set(0, Math.PI / 2, 0), Ii.scale.set(_ / u, _ / u, _ / u), Oi = 2 * e), Ii.position.set(hi + ci * Ri, -.005 / u, -(Fr / 2 + Oi + di)), s && (ni = "DiamondMesh"), Ii.traverse((e => {
                                    e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = E))
                                })), l) Ii.getObjectByName(ni).material = qr;
                            else {
                                let Bi = Ii.getObjectByName(ni);
                                Bi.parent.remove(Bi)
                            }
                            C.add(Ii)
                        }
                        let pi = -ai / 2;
                        for (let Li = 0; Li < li + 1; Li++) {
                            let Di, Ni;
                            if (0 == Li ? (Di = W.scene.clone(!0), ni = "DiamondMesh045", Di.rotation.set(0, 0, 0), Di.scale.set(_ / u, _ / u, _ / u), Ni = 1.5 * e) : Li == li ? (Di = X.scene.clone(!0), ni = "DiamondMesh093", Di.rotation.set(0, -Math.PI / 2, 0), Di.scale.set(_ / u, _ / u, _ / u), Ni = 1.5 * e) : (Di = ti.scene.clone(!0), ni = ii, Di.rotation.set(0, 0, 0), Di.scale.set(_ / u, _ / u, _ / u), Ni = 2 * e), Di.position.set(kr / 2 + Ni + di, -.005 / u, pi + ui * Li), s && (ni = "DiamondMesh"), Di.traverse((e => {
                                    e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = E))
                                })), l) Di.getObjectByName(ni).material = qr;
                            else {
                                let ki = Di.getObjectByName(ni);
                                ki.parent.remove(ki)
                            }
                            C.add(Di)
                        }
                        let fi = oi / 2;
                        for (let Fi = 0; Fi < si + 1; Fi++) {
                            let Ui, zi;
                            if (0 == Fi ? (Ui = W.scene.clone(!0), ni = "DiamondMesh045", Ui.rotation.set(0, -Math.PI / 2, 0), Ui.scale.set(_ / u, _ / u, _ / u), zi = 1.5 * e) : Fi == si ? (Ui = X.scene.clone(!0), ni = "DiamondMesh093", Ui.rotation.set(0, Math.PI, 0), Ui.scale.set(_ / u, _ / u, _ / u), zi = 1.5 * e) : (Ui = ei.scene.clone(!0), ni = ri, Ui.rotation.set(0, -Math.PI / 2, 0), Ui.scale.set(_ / u, _ / u, _ / u), zi = 2 * e), Ui.position.set(fi - ci * Fi, -.005 / u, Fr / 2 + zi + di), s && (ni = "DiamondMesh"), Ui.traverse((e => {
                                    e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = E))
                                })), l) Ui.getObjectByName(ni).material = qr;
                            else {
                                let Hi = Ui.getObjectByName(ni);
                                Hi.parent.remove(Hi)
                            }
                            C.add(Ui)
                        }
                        let mi = ai / 2;
                        for (let ji = 0; ji < li + 1; ji++) {
                            let Gi, Vi;
                            if (0 == ji ? (Gi = W.scene.clone(!0), ni = "DiamondMesh045", Gi.rotation.set(0, Math.PI, 0), Gi.scale.set(_ / u, _ / u, _ / u), Vi = 1.5 * e) : ji == li ? (Gi = X.scene.clone(!0), ni = "DiamondMesh093", Gi.rotation.set(0, Math.PI / 2, 0), Gi.scale.set(_ / u, _ / u, _ / u), Vi = 1.5 * e) : (Gi = ti.scene.clone(!0), ni = ii, Gi.rotation.set(0, Math.PI, 0), Gi.scale.set(_ / u, _ / u, _ / u), Vi = 2 * e), Gi.position.set(-(kr / 2 + Vi + di), -.005 / u, mi - ui * ji), s && (ni = "DiamondMesh"), Gi.traverse((e => {
                                    e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = E))
                                })), l) Gi.getObjectByName(ni).material = qr;
                            else {
                                let qi = Gi.getObjectByName(ni);
                                qi.parent.remove(qi)
                            }
                            C.add(Gi)
                        }
                        n = (Ir + 3 * t) * u, r = 2 * (m + n) + 2 * (g + n)
                    } else if ("Marquise" == d.name) {
                        const Wi = 100;
                        let Xi = .8 / u,
                            Ki = (Xi - .005 / u) * _,
                            Ji = (Xi + 2 * (.05 / u)) * _,
                            Yi = m / 2 / u,
                            Qi = g / 2 / u,
                            Zi = Yi + Ki,
                            $i = Qi + Ki,
                            eo = Yi + Ki / 2,
                            to = Qi + Ki / 2;
                        const no = 64,
                            ro = 2;
                        if (s) {
                            e = .10062893081761001 * Ki
                        }

                        function io(e, t, n) {
                            return Math.sqrt(Math.pow(t * Math.sin(e), 2) + Math.pow(n * Math.cos(e), 2))
                        }

                        function oo(e, t, n) {
                            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e3;
                            const i = (n - t) / r;
                            let o = (e(t) + e(n)) / 2;
                            for (let a = 1; a < r; a++) o += e(t + a * i);
                            return o * i
                        }

                        function ao(e, t, n, r) {
                            let i = 0,
                                o = e;
                            for (; i < t;) o += .05, i = oo((e => io(e, n, r)), e, o);
                            for (; i > t;) o -= .001, i = oo((e => io(e, n, r)), e, o);
                            for (; i < t;) o += 1e-4, i = oo((e => io(e, n, r)), e, o);
                            for (; i > t;) o -= 1e-5, i = oo((e => io(e, n, r)), e, o);
                            return o
                        }

                        function so(e, t, n, r) {
                            const i = -e / (n * n),
                                o = -t / (r * r),
                                a = Math.sqrt(i * i + o * o);
                            return {
                                nx: i / a,
                                nz: o / a
                            }
                        }

                        function lo(t, n) {
                            for (let r = 0; r < t.length / 2 + 3; r += 3) {
                                const i = t[r % (3 * no)],
                                    o = t[(r + 1) % (3 * no)],
                                    a = t[(r + 2) % (3 * no)],
                                    s = t[r % (3 * no) + 3 * no],
                                    l = t[(r + 1) % (3 * no) + 3 * no],
                                    c = t[(r + 2) % (3 * no) + 3 * no],
                                    u = (i + s) / 2,
                                    d = (a + c) / 2,
                                    h = (o + l) / 2,
                                    {
                                        nx: p,
                                        nz: f
                                    } = so(u, d, (Zi + Yi) / 2, ($i + Qi) / 2);
                                for (let t = 0; t < Wi; t++) {
                                    const r = Math.PI / (Wi - 1) * t,
                                        o = i + t / (Wi - 1) * (s - i),
                                        l = a + t / (Wi - 1) * (c - a),
                                        u = h - (Ki + 3 * e) / 2 * Math.sin(r);
                                    n.push(o, u, l)
                                }
                            }
                        }

                        function co(e, t, n, r, i) {
                            let o = [0];
                            const a = Math.PI * (3 * (t + e) - Math.sqrt((3 * t + e) * (t + 3 * e))) / no;
                            for (let u = 0; u < no - 1; u++) {
                                const n = ao(o[o.length - 1], a, t, e);
                                o.push(n)
                            }
                            const s = o.map((t => e * Math.sin(t))),
                                l = o.map((e => -t * Math.cos(e))),
                                c = o.map((n => 0 !== Math.sin(n) ? e * Math.cos(n) / (t * Math.sin(n)) : 1 / 0)),
                                d = c.map((e => Math.atan(e))),
                                h = o.map(((e, t) => ({
                                    theta: e,
                                    x: s[t],
                                    z: l[t],
                                    node_tangent: c[t],
                                    node_rotation: d[t]
                                }))),
                                p = new Yd({
                                    color: 65280
                                });
                            h.forEach((e => {
                                const t = new Xy(.1 / u, 32, 32);
                                new zh(t, p).position.set(e.x, n, e.z)
                            }));
                            const f = [];

                            function m(e, t) {
                                f.push({
                                    x: e,
                                    z: t
                                })
                            }
                            for (let u = 0; u < no / 2; u++) {
                                const n = u * (2 * (t + r) / (no / 2)) - (t + r);
                                m(e - e / (t + r) * Math.abs(n), n)
                            }
                            for (let u = 0; u < no / 2; u++) {
                                const n = t + r - u * (2 * (t + r) / (no / 2));
                                m(-e + e / (t + r) * Math.abs(n), n)
                            }
                            const g = new Yd({
                                color: 255
                            });
                            f.forEach((e => {
                                const t = new Xy(.1 / u, 32, 32);
                                new zh(t, g).position.set(e.x, n, e.z)
                            }));
                            const v = new Yd({
                                color: 16711680
                            });
                            for (let y = 0; y < no; y++) {
                                const t = new Xy(.1 / u, 32, 32),
                                    r = new zh(t, v),
                                    o = (e - Math.abs(f[y].x)) / e,
                                    a = Math.min(.55 * o, 1),
                                    s = 1 - a,
                                    l = s * h[y].x + a * f[y].x,
                                    c = n,
                                    d = s * h[y].z + a * f[y].z;
                                if (e > Yi && e < Zi && y > 0) {
                                    let e = i[i.length - 3],
                                        t = i[i.length - 1];
                                    uo += Math.sqrt(Math.pow(l - e, 2) + Math.pow(d - t, 2)), 1 == y && (uo += Math.sqrt(Math.pow(l - e, 2) + Math.pow(d - t, 2)))
                                }
                                i.push(l, c, d), r.position.set(l, c, d)
                            }
                        }
                        t = .10062893081761001 * Ki;
                        let uo = 0;
                        const ho = new Mh;
                        let po = [],
                            fo = [];
                        co(Yi, Qi, 0, 0, po), co(Zi + 3 * e, $i + 3 * e, 0, Ki, po), lo(po, fo), po = po.concat(fo);
                        const mo = [];
                        for (let _o = 0; _o < no; _o++) {
                            const Mo = (_o + 1) % no,
                                wo = _o,
                                Ao = _o + no;
                            mo.push(wo, Mo, Ao), mo.push(Mo + no, Ao, Mo)
                        }
                        const go = 2 * no;
                        for (let So = 0; So < no; So++)
                            for (let Eo = 0; Eo < Wi - 1; Eo++) {
                                const Co = go + So * Wi + Eo,
                                    To = Co + 1,
                                    Po = Co + Wi,
                                    Ro = To + Wi,
                                    Io = po.length / 3;
                                Co >= Io || To >= Io || Po >= Io || Ro >= Io ? console.error("Index out of bounds: current=".concat(Co, ", next=").concat(To, ", below=").concat(Po, ", belowNext=").concat(Ro)) : (mo.push(Co, To, Po), mo.push(To, Ro, Po))
                            }
                        let vo;

                        function yo(e) {
                            let t = [0];
                            const n = Math.PI * (3 * (to + eo) - Math.sqrt((3 * to + eo) * (to + 3 * eo))) / e;
                            for (let s = 0; s < e - 1; s++) {
                                const e = ao(t[t.length - 1], n, to, eo);
                                t.push(e)
                            }
                            const r = t.map((e => eo * Math.sin(e))),
                                i = t.map((e => -to * Math.cos(e))),
                                o = t.map((e => 0 !== Math.sin(e) ? eo * Math.cos(e) / (to * Math.sin(e)) : 1 / 0)),
                                a = o.map((e => Math.atan(e))),
                                c = t.map(((e, t) => ({
                                    theta: e,
                                    x: r[t],
                                    z: i[t],
                                    node_tangent: o[t],
                                    node_rotation: a[t]
                                }))),
                                d = new Yd({
                                    color: 65280
                                });
                            c.forEach((e => {
                                const t = new Xy(.1 / u, 32, 32);
                                new zh(t, d).position.set(e.x, 0, e.z)
                            }));
                            const h = [];

                            function p(e, t) {
                                h.push({
                                    x: e,
                                    y: 0,
                                    z: t
                                })
                            }
                            for (let s = 0; s < e / 2; s++) {
                                const t = s * (2 * (to + Ki / 2) / (e / 2)) - (to + Ki / 2);
                                p(eo - eo / (to + Ki / 2) * Math.abs(t), t)
                            }
                            for (let s = 0; s < e / 2; s++) {
                                const t = to + Ki / 2 - s * (2 * (to + Ki / 2) / (e / 2));
                                p(-eo + eo / (to + Ki / 2) * Math.abs(t), t)
                            }
                            const f = new Yd({
                                color: 255
                            });
                            h.forEach((e => {
                                const t = new Xy(.1 / u, 32, 32);
                                new zh(t, f).position.set(e.x, 0, e.z)
                            }));
                            const m = new Yd({
                                    color: 16711680
                                }),
                                g = [];
                            for (let s = 0; s < e; s++) {
                                const e = new Xy(.1 / u, 32, 32),
                                    t = new zh(e, m),
                                    n = (eo - Math.abs(h[s].x)) / eo,
                                    r = Math.min(.55 * n, 1),
                                    i = 1 - r,
                                    o = i * c[s].x + r * h[s].x,
                                    a = 0,
                                    l = i * c[s].z + r * h[s].z;
                                t.position.set(o, a, l), g.push({
                                    x: o,
                                    y: a,
                                    z: l
                                })
                            }
                            for (let v = 0; v < e; v++) {
                                let t, n, r;
                                if (0 == v || v == e / 2 ? (t = Y.scene.clone(!0), n = "DiamondMesh033") : v % 2 == 0 && (t = Q.scene.clone(!0), n = "DiamondMesh032"), t) {
                                    r = 0 == v ? Math.PI / 2 : Math.atan((g[v + 1].x - g[v - 1].x) / (g[v + 1].z - g[v - 1].z)), t.rotation.set(0, r, 0);
                                    const i = g[v].x,
                                        o = g[v].y,
                                        a = g[v].z;
                                    if (v > e / 2 && (t.rotation.y += Math.PI), t.scale.set(_ / u, _ / u, _ / u), t.position.set(i, o, a), t.traverse((e => {
                                            e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = E))
                                        })), s && (n = "DiamondMesh"), l) t.getObjectByName(n).material = vo;
                                    else {
                                        let e = t.getObjectByName(n);
                                        e.parent.remove(e)
                                    }
                                    C.add(t)
                                }
                            }
                        }
                        co(eo, to, 0, Ki / 2, po), S.traverse((e => {
                            e.isMesh && "diamondmesh" === e.name && (vo = e.material)
                        }));
                        const bo = Math.floor(uo / 2 / Ji);
                        $(2 * bo);
                        yo(2 * bo * ro), ho.setAttribute("position", new ph(po, 3)), ho.setIndex(mo), ho.computeVertexNormals();
                        const xo = new zh(ho, E);
                        xo.position.set(0, 0, 0), xo.scale.set(1, 1, 1), C.add(xo), n = (Ki + 3 * t) * u, r = uo * u
                    } else if ("Pear" == d.name) {
                        const Oo = 100;
                        let Bo = .8 / u,
                            Lo = (Bo - .005 / u) * _,
                            Do = (Bo + 2 * (.05 / u)) * _,
                            No = m / 2 / u,
                            ko = (g - m / 2) / u,
                            Fo = No + Lo,
                            Uo = ko + Lo,
                            zo = No + Lo / 2,
                            Ho = ko + Lo / 2;
                        const jo = 64,
                            Go = 2;
                        if (s) {
                            e = .10062893081761001 * Lo
                        }

                        function Vo(e, t, n) {
                            return Math.sqrt(Math.pow(t * Math.sin(e), 2) + Math.pow(n * Math.cos(e), 2))
                        }

                        function qo(e, t, n) {
                            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e3;
                            const i = (n - t) / r;
                            let o = (e(t) + e(n)) / 2;
                            for (let a = 1; a < r; a++) o += e(t + a * i);
                            return o * i
                        }

                        function Wo(e, t, n, r) {
                            let i = 0,
                                o = e;
                            for (; i < t;) o += .05, i = qo((e => Vo(e, n, r)), e, o);
                            for (; i > t;) o -= .001, i = qo((e => Vo(e, n, r)), e, o);
                            for (; i < t;) o += 1e-4, i = qo((e => Vo(e, n, r)), e, o);
                            for (; i > t;) o -= 1e-5, i = qo((e => Vo(e, n, r)), e, o);
                            return o
                        }

                        function Xo(e, t, n, r) {
                            const i = -e / (n * n),
                                o = -t / (r * r),
                                a = Math.sqrt(i * i + o * o);
                            return {
                                nx: i / a,
                                nz: o / a
                            }
                        }

                        function Ko(e, t) {
                            for (let n = 0; n < e.length / 2 + 3; n += 3) {
                                const r = e[n % (3 * jo)],
                                    i = e[(n + 1) % (3 * jo)],
                                    o = e[(n + 2) % (3 * jo)],
                                    a = e[n % (3 * jo) + 3 * jo],
                                    s = e[(n + 1) % (3 * jo) + 3 * jo],
                                    l = e[(n + 2) % (3 * jo) + 3 * jo],
                                    c = (r + a) / 2,
                                    u = (o + l) / 2,
                                    d = (i + s) / 2,
                                    {
                                        nx: h,
                                        nz: p
                                    } = Xo(c, u, (Fo + No) / 2, (Uo + ko) / 2);
                                for (let e = 0; e < Oo; e++) {
                                    const n = Math.PI / (Oo - 1) * e,
                                        i = r + e / (Oo - 1) * (a - r),
                                        s = o + e / (Oo - 1) * (l - o),
                                        c = d - Lo / 2 * Math.sin(n);
                                    t.push(i, c, s)
                                }
                            }
                        }

                        function Jo(e, t, n, r, i) {
                            let o = [0];
                            const a = Math.PI * (3 * (t + e) - Math.sqrt((3 * t + e) * (t + 3 * e))) / jo;
                            for (let u = 0; u < jo - 1; u++) {
                                const n = Wo(o[o.length - 1], a, t, e);
                                o.push(n)
                            }
                            const s = o.map((t => e * Math.sin(t))),
                                l = o.map((n => n > Math.PI / 2 && n < 3 * Math.PI / 2 ? -e * Math.cos(n) : -t * Math.cos(n))),
                                c = o.map((n => 0 !== Math.sin(n) ? e * Math.cos(n) / (t * Math.sin(n)) : 1 / 0)),
                                d = c.map((e => Math.atan(e))),
                                h = o.map(((e, t) => ({
                                    theta: e,
                                    x: s[t],
                                    z: l[t],
                                    node_tangent: c[t],
                                    node_rotation: d[t]
                                }))),
                                p = new Yd({
                                    color: 65280
                                });
                            h.forEach((e => {
                                const t = new Xy(.1 / u, 32, 32);
                                new zh(t, p).position.set(e.x, n, e.z)
                            }));
                            const f = [];

                            function m(e, t) {
                                f.push({
                                    x: e,
                                    z: t
                                })
                            }
                            for (let u = 0; u < jo / 2; u++) {
                                const n = u * (2 * (t + r) / (jo / 2)) - (t + r),
                                    i = e - e / (t + r) * Math.abs(n);
                                n <= 0 ? m(i, n) : m(0, 0)
                            }
                            for (let u = 0; u < jo / 2; u++) {
                                const n = t + r - u * (2 * (t + r) / (jo / 2)),
                                    i = -e + e / (t + r) * Math.abs(n);
                                n <= 0 ? m(i, n) : m(0, 0)
                            }
                            const g = new Yd({
                                color: 255
                            });
                            f.forEach((e => {
                                const t = new Xy(.1 / u, 32, 32);
                                new zh(t, g).position.set(e.x, n, e.z)
                            }));
                            const v = new Yd({
                                color: 16711680
                            });
                            for (let y = 0; y < jo; y++) {
                                const t = new Xy(.1 / u, 32, 32),
                                    r = new zh(t, v),
                                    o = (e - Math.abs(f[y].x)) / e,
                                    a = Math.min(.55 * o, 1),
                                    s = 1 - a;
                                let l, c, d;
                                if (0 === f[y].x && 0 === f[y].z ? (l = h[y].x, c = n, d = h[y].z) : (l = s * h[y].x + a * f[y].x, c = n, d = s * h[y].z + a * f[y].z), e > No && e < Fo && y > 0) {
                                    let e = i[i.length - 3],
                                        t = i[i.length - 1];
                                    Yo += Math.sqrt(Math.pow(l - e, 2) + Math.pow(d - t, 2)), 1 == y && (Yo += Math.sqrt(Math.pow(l - e, 2) + Math.pow(d - t, 2)))
                                }
                                i.push(l, c, d), r.position.set(l, c, d)
                            }
                        }
                        t = .10062893081761001 * Lo;
                        let Yo = 0;
                        const Qo = new Mh;
                        let Zo = [],
                            $o = [];
                        Jo(No, ko, 0, 0, Zo), Jo(Fo, Uo, 0, Lo, Zo), Ko(Zo, $o), Zo = Zo.concat($o);
                        const ea = [];
                        for (let sa = 0; sa < jo; sa++) {
                            const la = (sa + 1) % jo,
                                ca = sa,
                                ua = sa + jo;
                            ea.push(ca, la, ua), ea.push(la + jo, ua, la)
                        }
                        const ta = 2 * jo;
                        for (let da = 0; da < jo; da++)
                            for (let ha = 0; ha < Oo - 1; ha++) {
                                const pa = ta + da * Oo + ha,
                                    fa = pa + 1,
                                    ma = pa + Oo,
                                    ga = fa + Oo,
                                    va = Zo.length / 3;
                                pa >= va || fa >= va || ma >= va || ga >= va ? console.error("Index out of bounds: current=".concat(pa, ", next=").concat(fa, ", below=").concat(ma, ", belowNext=").concat(ga)) : (ea.push(pa, fa, ma), ea.push(fa, ga, ma))
                            }
                        let na;

                        function ra(e, t) {
                            let n = [0];
                            const r = Math.PI * (3 * (Ho + zo) - Math.sqrt((3 * Ho + zo) * (Ho + 3 * zo))) / e;
                            for (let s = 0; s < e - 1; s++) {
                                const e = Wo(n[n.length - 1], r, Ho, zo);
                                n.push(e)
                            }
                            const i = n.map((e => zo * Math.sin(e))),
                                o = n.map((e => e > Math.PI / 2 && e < 3 * Math.PI / 2 ? -zo * Math.cos(e) : -Ho * Math.cos(e))),
                                a = n.map((e => 0 !== Math.sin(e) ? zo * Math.cos(e) / (Ho * Math.sin(e)) : 1 / 0)),
                                c = a.map((e => Math.atan(e))),
                                d = n.map(((e, t) => ({
                                    theta: e,
                                    x: i[t],
                                    z: o[t],
                                    node_tangent: a[t],
                                    node_rotation: c[t]
                                }))),
                                h = new Yd({
                                    color: 65280
                                });
                            d.forEach((e => {
                                const t = new Xy(.1 / u, 32, 32);
                                new zh(t, h).position.set(e.x, 0, e.z)
                            }));
                            const p = [];

                            function f(e, t) {
                                p.push({
                                    x: e,
                                    y: 0,
                                    z: t
                                })
                            }
                            for (let s = 0; s < e / 2; s++) {
                                const t = s * (2 * (Ho + Lo / 2) / (e / 2)) - (Ho + Lo / 2),
                                    n = zo - zo / (Ho + Lo / 2) * Math.abs(t);
                                t <= 0 ? f(n, t) : f(0, 0)
                            }
                            for (let s = 0; s < e / 2; s++) {
                                const t = Ho + Lo / 2 - s * (2 * (Ho + Lo / 2) / (e / 2)),
                                    n = -zo + zo / (Ho + Lo / 2) * Math.abs(t);
                                t <= 0 ? f(n, t) : f(0, 0)
                            }
                            const m = new Yd({
                                color: 255
                            });
                            p.forEach((e => {
                                const t = new Xy(.1 / u, 32, 32);
                                new zh(t, m).position.set(e.x, 0, e.z)
                            }));
                            const g = new Yd({
                                    color: 16711680
                                }),
                                v = [];
                            let y, b, x, M = {
                                x: 0,
                                y: 0,
                                z: 0
                            };
                            for (let s = 0; s < e; s++) {
                                const e = new Xy(.1 / u, 32, 32),
                                    t = new zh(e, g),
                                    n = (zo - Math.abs(p[s].x)) / zo,
                                    r = Math.min(.55 * n, 1),
                                    i = 1 - r;
                                0 === p[s].x && 0 === p[s].z ? (y = d[s].x, b = 0, x = d[s].z) : (y = i * d[s].x + r * p[s].x, b = 0, x = i * d[s].z + r * p[s].z), t.position.set(y, b, x), v.push({
                                    x: y,
                                    y: b,
                                    z: x
                                })
                            }
                            for (let R = 0; R < e / 2; R++) {
                                let e, t, n, r, i;
                                if (0 == R ? (e = Y.scene.clone(!0), t = "DiamondMesh033") : R % 2 == 0 && (n = Q.scene.clone(!0), r = Q.scene.clone(!0), t = "DiamondMesh032"), s && (t = "DiamondMesh"), n || r || e)
                                    if (0 == R)
                                        if (i = Math.PI / 2, e.scale.set(_ / u, _ / u, _ / u), e.rotation.set(0, i, 0), e.position.set(v[R].x, v[R].y, v[R].z), C.add(e), e.traverse((e => {
                                                e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = E))
                                            })), l) e.getObjectByName(t).material = na;
                                        else {
                                            let n = e.getObjectByName(t);
                                            n.parent.remove(n)
                                        }
                                else if (i = Math.atan((v[R + 1].x - v[R - 1].x) / (v[R + 1].z - v[R - 1].z)), v[R].z < 0) {
                                    if (y = v[R].x, b = v[R].y, x = v[R].z, y > 0 && (M = {
                                            x: y,
                                            y: b,
                                            z: x
                                        }), n.scale.set(_ / u, _ / u, _ / u), n.rotation.set(0, i, 0), n.position.set(y, b, x), C.add(n), r.scale.set(_ / u, _ / u, _ / u), r.rotation.set(0, -i - Math.PI, 0), r.position.set(-y, b, x), C.add(r), n.traverse((e => {
                                            e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = E))
                                        })), l) n.getObjectByName(t).material = na;
                                    else {
                                        let e = n.getObjectByName(t);
                                        e.parent.remove(e)
                                    }
                                    if (r.traverse((e => {
                                            e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = E))
                                        })), l) r.getObjectByName(t).material = na;
                                    else {
                                        let e = r.getObjectByName(t);
                                        e.parent.remove(e)
                                    }
                                }
                            }
                            const w = Math.atan(Math.abs(M.z) / M.x),
                                A = t / (2 * Math.PI * zo) * 2 * Math.PI,
                                S = (Math.PI + 2 * w - A) * zo,
                                T = Math.floor(S / Do);
                            $(2 * Math.floor(e / 8) + 1 + T);
                            const P = (Math.PI + 2 * w - A) / T / 2;
                            for (let R = 0; R < T; R++) {
                                const e = 2 * P - w + 2 * R * P;
                                y = zo * Math.cos(e), b = 0, x = zo * Math.sin(e);
                                const t = Q.scene.clone(!0);
                                t.rotation.set(0, -e, 0), t.scale.set(_ / u, _ / u, _ / u), t.position.set(y, b, x), C.add(t), t.traverse((e => {
                                    e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = E))
                                }));
                                let n = "DiamondMesh032";
                                if (s && (n = "DiamondMesh"), l) t.getObjectByName(n).material = na;
                                else {
                                    let e = t.getObjectByName(n);
                                    e.parent.remove(e)
                                }
                            }
                        }
                        Jo(zo, Ho, 0, Lo / 2, Zo), S.traverse((e => {
                            e.isMesh && "diamondmesh" === e.name && (na = e.material)
                        }));
                        const ia = Math.PI * zo,
                            oa = Math.floor((Yo - ia) / Do);
                        ra(2 * oa * Go, (Yo - ia) / oa), Qo.setAttribute("position", new ph(Zo, 3)), Qo.setIndex(ea), Qo.computeVertexNormals();
                        const aa = new zh(Qo, E);
                        aa.position.set(0, 0, 0), aa.scale.set(1, 1, 1), C.add(aa), n = (Lo + 3 * t) * u, r = Yo * u
                    }
                    i((.7522 * _ * n + Math.PI * (n / 2) * (n / 2) / 2) * r * .555);
                    const o = M.prongOrientation,
                        a = M.prongArmASide;
                    let c = 0,
                        p = .795 * _;
                    for (let ya = 0; ya < o.length; ya++) {
                        const ba = o[ya];
                        let xa, _a = I.scene.clone(!0);
                        if ("Asscher" != d.name && "Emerald" != d.name && "Radiant" != d.name || (_a = k.scene.clone(!0)), _a.position.set(-(a[ya] + p / 2) * Math.sin(ba) / u, 0, -(a[ya] + p / 2) * Math.cos(ba) / u), _a.rotation.set(0, ba, 0), _a.scale.set(_ / u, _ / u, _ / u), _a.traverse((e => {
                                e.isMesh && (e.material = E)
                            })), C.add(_a), s ? xa = N.scene.clone(!0) : "Rounded" === h.name ? xa = O.scene.clone(!0) : "Claw" === h.name ? xa = B.scene.clone(!0) : "Petite Claw" === h.name ? xa = L.scene.clone(!0) : "Tab" === h.name && (xa = D.scene.clone(!0)), s) {
                            let Ma = 1.6 * _ / u;
                            c = b + y / 2 - (.7497 - .75) * _;
                            const wa = (1.2431 * _ - c) / u;
                            let Aa = xa.children[0].children[0],
                                Sa = Aa.geometry.attributes.position.array;
                            const Ea = new Yd({
                                    color: 65280
                                }),
                                Ca = new Xy(.001, 32, 32),
                                Ta = 100 * _ / u;
                            for (let Pa = 0; Pa < Sa.length - 2; Pa += 3) {
                                let Ra = Sa[Pa],
                                    Ia = Sa[Pa + 1],
                                    Oa = Sa[Pa + 2];
                                if (Ia * Ta < Ma) {
                                    Aa.geometry.attributes.position.array[Pa + 1] = wa / Ta, Ia = wa / Ta;
                                    new zh(Ca, Ea).position.set(Ra * Ta, Ia * Ta, Oa * Ta)
                                }
                            }
                            Aa.geometry.attributes.position.needsUpdate = !0
                        }
                        xa.position.set(-(a[ya] + p / 2) * Math.sin(ba) / u, c / u, -(a[ya] + p / 2) * Math.cos(ba) / u), xa.rotation.set(0, ba, 0), xa.scale.set(_ / u, _ / u, _ / u), xa.traverse((e => {
                            e.isMesh && (e.material = E)
                        })), C.add(xa)
                    }
                }), [d, h, _, l, f, n, s, p, x, u, E, t, a]), (0, r.useEffect)((() => {
                    o([{
                        quantity: Z,
                        size: .8 * _,
                        shape: "Round",
                        style: "Petite French Pave"
                    }])
                }), [_, Z]), C.rotation.order = "YXZ", C.rotation.set(0, 0, 0), C.position.set(0, F, 0), (0, Nn.jsx)("primitive", {
                    object: C,
                    scale: [1, 1, 1]
                })
            },
            ZP = e => {
                let {
                    prongWidth: t,
                    setHaloBasketVolume: n,
                    setHaloBasketPave: i,
                    prongOrientation: o,
                    extraMetal: a,
                    diamondsVisibility: s,
                    scaleReducerVector: l,
                    scaleReducer: c,
                    type: u,
                    prongTipType: d,
                    basketHalo: h,
                    caratWeight: p,
                    diamondWidth: f,
                    diamondLength: m,
                    diamondPavHeight: g,
                    diamondGirdleThickness: v,
                    diamondCrownHeight: y,
                    diamondPositionY: b,
                    haloThicknessRatio: x,
                    prongArmCalculations: _,
                    prongMetalColor: M
                } = e;
                const {
                    gl: w,
                    scene: A
                } = KM(), S = (0, r.useMemo)((() => new rb({
                    color: M,
                    metalness: 1,
                    roughness: .05,
                    wireframe: !1
                })), [M]), E = (0, r.useMemo)((() => new Hm), [p, u, h, d, s, a, c, b]), C = 1.3 * t / c * .9, T = t / 2 / c * .9, P = 1.1 * t / c * .9, R = .2 / c, I = .075 / c, O = .2 / c, B = C - I / c, L = .1 / c;
                let D = XP(b, g, v, x, c, !0, C, R);
                const N = (e, t, n, r, i) => {
                    for (let o = 0; o < n; o++) {
                        const a = o + e * n,
                            s = (a + 1) % n === 0 ? a - n + 1 : a + 1,
                            l = o + t * n,
                            c = (l + 1) % n === 0 ? l - n + 1 : l + 1,
                            u = r.length / 3;
                        a >= u || s >= u || l >= u || c >= u ? console.error("Index out of bounds: current=".concat(a, ", next=").concat(s, ", below=").concat(l, ", belowNext=").concat(c)) : (i.push(a, l, s), i.push(c, s, l))
                    }
                };
                return (0, r.useEffect)((() => {
                    let e = 0,
                        t = 0,
                        r = 0;
                    if ("Round" == u.name) {
                        const i = 100;
                        let o = .8 / c,
                            s = (o - .005 / c) * x,
                            l = f / 2 / c;
                        if (a) {
                            e = .10062893081761001 * s
                        }
                        t = .10062893081761001 * s;
                        const d = new Mh,
                            h = [.98 * l + T, .98 * l],
                            p = [.98 * l + T, .98 * l + T - P];

                        function g(e, t, n) {
                            for (let r = 0; r < i; r++) {
                                const o = r / i * 2 * Math.PI,
                                    a = e * Math.cos(o),
                                    s = t,
                                    l = e * Math.sin(o);
                                n.push(a, s, l)
                            }
                        }
                        const y = [];
                        for (let w = 0; w < 12; w++) {
                            const D = Math.PI / 2 / 12 * w;
                            g(p[0] - O + O * Math.sin(D), B - B * Math.cos(D), y)
                        }
                        for (let k = 0; k < 12; k++) {
                            const F = Math.PI / 2 / 12 * k;
                            g(h[0] - I + I * Math.cos(F), C - I + I * Math.sin(F), y)
                        }
                        for (let U = 0; U < 12; U++) {
                            const z = Math.PI / 2 / 12 * U;
                            g(h[1] + I - I * Math.sin(z), C - I + I * Math.cos(z), y)
                        }
                        g(h[1], C - (R + v / c), y), g(p[1], 0, y), d.setAttribute("position", new ph(y, 3));
                        const b = [],
                            _ = 38;
                        for (let H = 0; H < _; H++) N(H, (H + 1) % _, i, y, b);
                        d.setIndex(b), d.computeVertexNormals();
                        const M = new zh(d, S);
                        M.position.set(0, 0 / c, 0), E.add(M), r = 2 * Math.PI * (.98 * l + T / 2) * c
                    } else if ("Oval" == u.name) {
                        const j = 100;
                        let G = .8 / c,
                            V = (G - .005 / c) * x,
                            q = (G + 2 * (.05 / c)) * x;
                        if (a) {
                            e = .10062893081761001 * V
                        }
                        t = .10062893081761001 * V;
                        let W = f / 2 / c,
                            X = m / 2 / c,
                            K = W + V / 2,
                            J = X + V / 2;
                        const Y = 2;
                        new Mh;

                        function Q(e, t, n, r) {
                            for (let i = 0; i < j; i++) {
                                const o = i / j * 2 * Math.PI,
                                    a = e * Math.cos(o),
                                    s = n,
                                    l = t * Math.sin(o);
                                r.push(a, s, l)
                            }
                        }
                        const Z = [.98 * W + T, .98 * W],
                            $ = [.98 * X + T, .98 * X],
                            ee = [.98 * W + T, .98 * W + T - P],
                            te = [.98 * X + T, .98 * X + T - P],
                            ne = new Mh,
                            re = [];
                        for (let we = 0; we < 12; we++) {
                            const Ae = Math.PI / 2 / 12 * we;
                            Q(ee[0] - O + O * Math.sin(Ae), te[0] - O + O * Math.sin(Ae), B - B * Math.cos(Ae), re)
                        }
                        for (let Se = 0; Se < 12; Se++) {
                            const Ee = Math.PI / 2 / 12 * Se;
                            Q(Z[0] - I + I * Math.cos(Ee), $[0] - I + I * Math.cos(Ee), C - I + I * Math.sin(Ee), re)
                        }
                        for (let Ce = 0; Ce < 12; Ce++) {
                            const Te = Math.PI / 2 / 12 * Ce;
                            Q(Z[1] + I - I * Math.sin(Te), $[1] + I - I * Math.sin(Te), C - I + I * Math.cos(Te), re)
                        }
                        Q(Z[1], $[1], C - (R + v / c), re), Q(ee[1], te[1], 0, re), ne.setAttribute("position", new ph(re, 3));
                        const ie = [],
                            oe = 38;
                        for (let Pe = 0; Pe < oe; Pe++) N(Pe, (Pe + 1) % oe, j, re, ie);
                        ne.setIndex(ie), ne.computeVertexNormals();
                        const ae = new zh(ne, S);
                        let se;
                        ae.position.set(0, 0 / c, 0), E.add(ae), A.traverse((e => {
                            e.isMesh && "diamondmesh" === e.name && (se = e.material)
                        }));
                        const le = Math.PI * (3 * (J + K) - Math.sqrt((3 * J + K) * (J + 3 * K))),
                            ce = Math.floor(le / q),
                            ue = le / ce / Y;
                        let de = .0019 * x;

                        function he(e, t, n) {
                            return Math.sqrt(Math.pow(t * Math.sin(e), 2) + Math.pow(n * Math.cos(e), 2))
                        }

                        function pe(e, t, n) {
                            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e3;
                            const i = (n - t) / r;
                            let o = (e(t) + e(n)) / 2;
                            for (let a = 1; a < r; a++) o += e(t + a * i);
                            return o * i
                        }
                        let fe = [0];

                        function me(e, t, n, r) {
                            let i = 0,
                                o = e;
                            for (; i < t;) o += .05, i = pe((e => he(e, n, r)), e, o);
                            for (; i > t;) o -= .001, i = pe((e => he(e, n, r)), e, o);
                            for (; i < t;) o += 1e-4, i = pe((e => he(e, n, r)), e, o);
                            return o
                        }
                        const ge = ce * Y;
                        for (let Re = 0; Re < ge - 1; Re++) {
                            const Ie = me(fe[fe.length - 1], ue, J, K);
                            fe.push(Ie)
                        }
                        a && (de = -.01 * x / c);
                        const ve = fe.map((t => (K + 2 * e - de) * Math.sin(t))),
                            ye = fe.map((t => -(J + 2 * e - de) * Math.cos(t))),
                            be = fe.map((e => 0 !== Math.sin(e) ? K * Math.cos(e) / (J * Math.sin(e)) : 1 / 0)),
                            xe = be.map((e => Math.atan(e))),
                            _e = (fe.map(((e, t) => ({
                                theta: e,
                                x: ve[t],
                                z: ye[t],
                                node_tangent: be[t],
                                node_rotation: xe[t]
                            }))), .98 * W + T / 2),
                            Me = .98 * X + T / 2;
                        r = Math.PI * (3 * (Me + _e) - Math.sqrt((3 * Me + _e) * (Me + 3 * _e))) * c
                    } else if ("Princess" == u.name) {
                        let Oe = .8 / c,
                            Be = (Oe - .005 / c) * x;
                        const Le = 100;
                        if (a) {
                            e = .10062893081761001 * Be
                        }
                        let De, Ne;

                        function ke(e, t, n, r) {
                            for (let i = 0; i < Le / 4 - 12; i++) {
                                const o = e / 2 - L - (e - 2 * L) * i / (Le / 4 - 12 - 1),
                                    a = n,
                                    s = t / 2;
                                r.push(o, a, s)
                            }
                            for (let i = 0; i < 12; i++) {
                                const o = Math.PI / 2 / 12 * i,
                                    a = -e / 2 + L - L * Math.sin(o),
                                    s = n,
                                    l = t / 2 - L + L * Math.cos(o);
                                r.push(a, s, l)
                            }
                            for (let i = 0; i < Le / 4 - 12; i++) {
                                const o = -e / 2,
                                    a = n,
                                    s = t / 2 - L - (t - 2 * L) * i / (Le / 4 - 12 - 1);
                                r.push(o, a, s)
                            }
                            for (let i = 0; i < 12; i++) {
                                const o = Math.PI / 2 / 12 * i,
                                    a = -e / 2 + L - L * Math.cos(o),
                                    s = n,
                                    l = -t / 2 + L - L * Math.sin(o);
                                r.push(a, s, l)
                            }
                            for (let i = 0; i < Le / 4 - 12; i++) {
                                const o = -e / 2 + L + (e - 2 * L) * i / (Le / 4 - 12 - 1),
                                    a = n,
                                    s = -t / 2;
                                r.push(o, a, s)
                            }
                            for (let i = 0; i < 12; i++) {
                                const o = Math.PI / 2 / 12 * i,
                                    a = e / 2 - L + L * Math.sin(o),
                                    s = n,
                                    l = -t / 2 + L - L * Math.cos(o);
                                r.push(a, s, l)
                            }
                            for (let i = 0; i < Le / 4 - 12; i++) {
                                const o = e / 2,
                                    a = n,
                                    s = -t / 2 + L + (t - 2 * L) * i / (Le / 4 - 12 - 1);
                                r.push(o, a, s)
                            }
                            for (let i = 0; i < 12; i++) {
                                const o = Math.PI / 2 / 12 * i,
                                    a = e / 2 - L + L * Math.cos(o),
                                    s = n,
                                    l = t / 2 - L + L * Math.sin(o);
                                r.push(a, s, l)
                            }
                        }
                        t = .10062893081761001 * Be, A.traverse((e => {
                            e.isMesh && "diamondmesh" === e.name ? De = e.material : e.isMesh && "diamondmeshcorner" === e.name && (Ne = e.material)
                        }));
                        const Fe = new Mh,
                            Ue = [],
                            ze = [f / c * .98 + 2 * T, f / c * .98],
                            He = [m / c * .98 + 2 * T, m / c * .98],
                            je = [f / c * .98 + 2 * T, f / c * .98 + 2 * (T - P)],
                            Ge = [m / c * .98 + 2 * T, m / c * .98 + 2 * (T - P)];
                        for (let Xe = 0; Xe < 12; Xe++) {
                            const Ke = Math.PI / 2 / 12 * Xe;
                            ke(je[0] - O + O * Math.sin(Ke), Ge[0] - O + O * Math.sin(Ke), B - B * Math.cos(Ke), Ue)
                        }
                        for (let Je = 0; Je < 12; Je++) {
                            const Ye = Math.PI / 2 / 12 * Je;
                            ke(ze[0] - I + I * Math.cos(Ye), He[0] - I + I * Math.cos(Ye), C - I + I * Math.sin(Ye), Ue)
                        }
                        for (let Qe = 0; Qe < 12; Qe++) {
                            const Ze = Math.PI / 2 / 12 * Qe;
                            ke(ze[1] + I - I * Math.sin(Ze), He[1] + I - I * Math.sin(Ze), C - I + I * Math.cos(Ze), Ue)
                        }
                        ke(ze[1], He[1], C - (R + v / c), Ue), ke(je[1], Ge[1], 0, Ue), Fe.setAttribute("position", new ph(Ue, 3));
                        const Ve = [],
                            qe = 38;
                        for (let $e = 0; $e < qe; $e++) N($e, ($e + 1) % qe, Le, Ue, Ve);
                        Fe.setIndex(Ve), Fe.computeVertexNormals();
                        const We = new zh(Fe, S);
                        We.position.set(0, 0 / c, 0), E.add(We), r = 4 * (f + T * c)
                    } else if ("Cushion" == u.name) {
                        let et = .8 / c,
                            tt = (et - .005 / c) * x,
                            nt = f / 2 / c,
                            rt = m / 2 / c;
                        const it = 64,
                            ot = .3;
                        if (a) {
                            e = .10062893081761001 * tt
                        }

                        function at(e, t, n) {
                            return Math.sqrt(Math.pow(t * Math.sin(e), 2) + Math.pow(n * Math.cos(e), 2))
                        }

                        function st(e, t, n) {
                            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e3;
                            const i = (n - t) / r;
                            let o = (e(t) + e(n)) / 2;
                            for (let a = 1; a < r; a++) o += e(t + a * i);
                            return o * i
                        }

                        function lt(e, t, n, r) {
                            let i = 0,
                                o = e;
                            for (; i < t;) o += .05, i = st((e => at(e, n, r)), e, o);
                            for (; i > t;) o -= .001, i = st((e => at(e, n, r)), e, o);
                            for (; i < t;) o += 1e-4, i = st((e => at(e, n, r)), e, o);
                            for (; i > t;) o -= 1e-5, i = st((e => at(e, n, r)), e, o);
                            return o
                        }

                        function ct(e, t, n, r) {
                            let i = [0];
                            const o = Math.PI * (3 * (t + e) - Math.sqrt((3 * t + e) * (t + 3 * e))) / it;
                            for (let c = 0; c < it - 1; c++) {
                                const n = lt(i[i.length - 1], o, t, e);
                                i.push(n)
                            }
                            const a = i.map((t => e * Math.sin(t))),
                                s = i.map((e => -t * Math.cos(e))),
                                l = i.map((n => 0 !== Math.sin(n) ? e * Math.cos(n) / (t * Math.sin(n)) : 1 / 0)),
                                u = l.map((e => Math.atan(e))),
                                d = i.map(((e, t) => ({
                                    theta: e,
                                    x: a[t],
                                    z: s[t],
                                    node_tangent: l[t],
                                    node_rotation: u[t]
                                }))),
                                h = new Yd({
                                    color: 65280
                                });
                            d.forEach((e => {
                                const t = new Xy(.1 / c, 32, 32);
                                new zh(t, h).position.set(e.x, n, e.z)
                            }));
                            const p = [],
                                f = 2 * (2 * e + 2 * t) / it;
                            let m = 0;

                            function g(e, t) {
                                p.push({
                                    x: e,
                                    y: n,
                                    z: t
                                })
                            }
                            let v = f,
                                y = -t;
                            for (; v <= e; v += f) g(v, y), m += f;
                            for (v = e, y = f - (e - m) - t; y <= t; y += f) g(v, y), m += f;
                            for (y = t, v = e - (f - (2 * t + e - m)); v >= -e; v -= f) g(v, y), m += f;
                            for (v = -e, y = t - (f - (2 * t + 3 * e - m)); y >= -t; y -= f) g(v, y), m += f;
                            for (y = -t, v = f - (4 * t + 3 * e - m) - e; p.length < it;) g(v, y), v += f, m += f;
                            const b = new Yd({
                                color: 255
                            });
                            p.forEach((e => {
                                const t = new Xy(.1 / c, 32, 32);
                                new zh(t, b).position.set(e.x, n, e.z)
                            }));
                            const x = new Yd({
                                color: 16711680
                            });
                            for (let _ = 0; _ < it; _++) {
                                const i = new Xy(.1 / c, 32, 32),
                                    o = (new zh(i, x), [e - Math.abs(p[(_ + (it - 1)) % it].x) + (t - Math.abs(p[(_ + (it - 1)) % it].z))] / (e + t) * (1 - ot) + ot),
                                    a = 1 - o,
                                    s = a * d[_].x + o * p[(_ + (it - 1)) % it].x,
                                    l = n,
                                    u = a * d[_].z + o * p[(_ + (it - 1)) % it].z;
                                r.push(s, l, u)
                            }
                        }
                        t = .10062893081761001 * tt;
                        const ut = [.98 * nt + T, .98 * nt],
                            dt = [.98 * rt + T, .98 * rt],
                            ht = [.98 * nt + T, .98 * nt + T - P],
                            pt = [.98 * rt + T, .98 * rt + T - P],
                            ft = new Mh,
                            mt = [];
                        for (let xt = 0; xt < 12; xt++) {
                            const _t = Math.PI / 2 / 12 * xt;
                            ct(ht[0] - O + O * Math.sin(_t), pt[0] - O + O * Math.sin(_t), B - B * Math.cos(_t), mt)
                        }
                        for (let Mt = 0; Mt < 12; Mt++) {
                            const wt = Math.PI / 2 / 12 * Mt;
                            ct(ut[0] - I + I * Math.cos(wt), dt[0] - I + I * Math.cos(wt), C - I + I * Math.sin(wt), mt)
                        }
                        for (let At = 0; At < 12; At++) {
                            const St = Math.PI / 2 / 12 * At;
                            ct(ut[1] + I - I * Math.sin(St), dt[1] + I - I * Math.sin(St), C - I + I * Math.cos(St), mt)
                        }
                        ct(ut[1], dt[1], C - (R + v / c), mt), ct(ht[1], pt[1], 0, mt), ft.setAttribute("position", new ph(mt, 3));
                        const gt = [],
                            vt = 38;
                        for (let Et = 0; Et < vt; Et++) N(Et, (Et + 1) % vt, it, mt, gt);
                        ft.setIndex(gt), ft.computeVertexNormals();
                        const yt = new zh(ft, S);
                        let bt;
                        yt.position.set(0, 0 / c, 0), E.add(yt), A.traverse((e => {
                            e.isMesh && "diamondmesh" === e.name && (bt = e.material)
                        })), r = 2 * (f + T * c) + 2 * (m + T * c)
                    } else if ("Asscher" == u.name || "Emerald" == u.name || "Radiant" == u.name) {
                        let Ct = .8 / c,
                            Tt = (Ct - .005 / c) * x,
                            Pt = (Ct + .1 / c) * x;
                        const Rt = {
                                Asscher: .15018,
                                Emerald: .2026,
                                Radiant: .15308
                            }[u.name],
                            It = 100,
                            Ot = f / c + Tt,
                            Bt = Rt * Ot;
                        Math.sqrt(2);
                        Math.sqrt(2);
                        const Lt = Rt * (f / c);
                        if (a) {
                            e = .10062893081761001 * Tt
                        }
                        let Dt, Nt;

                        function kt(e, t, n, r, i) {
                            for (let o = 0; o < It / 4; o++) {
                                const a = e / 2 - r - (e - 2 * r) * o / (It / 4 - 1),
                                    s = n,
                                    l = t / 2;
                                i.push(a, s, l)
                            }
                            for (let o = 0; o < It / 4; o++) {
                                const a = -e / 2,
                                    s = n,
                                    l = t / 2 - r - (t - 2 * r) * o / (It / 4 - 1);
                                i.push(a, s, l)
                            }
                            for (let o = 0; o < It / 4; o++) {
                                const a = -e / 2 + r + (e - 2 * r) * o / (It / 4 - 1),
                                    s = n,
                                    l = -t / 2;
                                i.push(a, s, l)
                            }
                            for (let o = 0; o < It / 4; o++) {
                                const a = e / 2,
                                    s = n,
                                    l = -t / 2 + r + (t - 2 * r) * o / (It / 4 - 1);
                                i.push(a, s, l)
                            }
                        }
                        t = .10062893081761001 * Tt, A.traverse((e => {
                            e.isMesh && "diamondmesh" === e.name ? Dt = e.material : e.isMesh && "asschermeshcorner" === e.name && (Nt = e.material)
                        }));
                        const Ft = new Mh,
                            Ut = [],
                            zt = [f / c * .98 + 2 * T, f / c * .98],
                            Ht = [m / c * .98 + 2 * T, m / c * .98],
                            jt = [f / c * .98 + 2 * T, f / c * .98 + 2 * (T - P)],
                            Gt = [m / c * .98 + 2 * T, m / c * .98 + 2 * (T - P)];
                        for (let Xt = 0; Xt < 12; Xt++) {
                            const Kt = Math.PI / 2 / 12 * Xt;
                            kt(jt[0] - O + O * Math.sin(Kt), Gt[0] - O + O * Math.sin(Kt), B - B * Math.cos(Kt), Lt + T * (2 - Math.sqrt(2)), Ut)
                        }
                        for (let Jt = 0; Jt < 12; Jt++) {
                            const Yt = Math.PI / 2 / 12 * Jt;
                            kt(zt[0] - I + I * Math.cos(Yt), Ht[0] - I + I * Math.cos(Yt), C - I + I * Math.sin(Yt), Lt + T * (2 - Math.sqrt(2)), Ut)
                        }
                        for (let Qt = 0; Qt < 12; Qt++) {
                            const Zt = Math.PI / 2 / 12 * Qt;
                            kt(zt[1] + I - I * Math.sin(Zt), Ht[1] + I - I * Math.sin(Zt), C - I + I * Math.cos(Zt), Lt, Ut)
                        }
                        kt(zt[1], Ht[1], C - (R + v / c), Lt, Ut), kt(jt[1], Gt[1], 0, Lt, Ut), Ft.setAttribute("position", new ph(Ut, 3));
                        const Vt = [],
                            qt = 38;
                        for (let $t = 0; $t < qt; $t++) N($t, ($t + 1) % qt, It, Ut, Vt);
                        Ft.setIndex(Vt), Ft.computeVertexNormals();
                        const Wt = new zh(Ft, S);
                        Wt.position.set(0, 0 / c, 0), E.add(Wt), r = 2 * (f + T * c) + 2 * (m + T * c)
                    } else if ("Marquise" == u.name) {
                        let en = .8 / c,
                            tn = (en - .005 / c) * x,
                            nn = f / 2 / c,
                            rn = m / 2 / c,
                            on = nn + tn;
                        const an = 64;
                        if (a) {
                            e = .10062893081761001 * tn
                        }

                        function sn(e, t, n) {
                            return Math.sqrt(Math.pow(t * Math.sin(e), 2) + Math.pow(n * Math.cos(e), 2))
                        }

                        function ln(e, t, n) {
                            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e3;
                            const i = (n - t) / r;
                            let o = (e(t) + e(n)) / 2;
                            for (let a = 1; a < r; a++) o += e(t + a * i);
                            return o * i
                        }

                        function cn(e, t, n, r) {
                            let i = 0,
                                o = e;
                            for (; i < t;) o += .05, i = ln((e => sn(e, n, r)), e, o);
                            for (; i > t;) o -= .001, i = ln((e => sn(e, n, r)), e, o);
                            for (; i < t;) o += 1e-4, i = ln((e => sn(e, n, r)), e, o);
                            for (; i > t;) o -= 1e-5, i = ln((e => sn(e, n, r)), e, o);
                            return o
                        }

                        function un(e, t, n, r, i) {
                            let o = [0];
                            const a = Math.PI * (3 * (t + e) - Math.sqrt((3 * t + e) * (t + 3 * e))) / an;
                            for (let c = 0; c < an - 1; c++) {
                                const n = cn(o[o.length - 1], a, t, e);
                                o.push(n)
                            }
                            const s = o.map((t => e * Math.sin(t))),
                                l = o.map((e => -t * Math.cos(e))),
                                u = o.map((n => 0 !== Math.sin(n) ? e * Math.cos(n) / (t * Math.sin(n)) : 1 / 0)),
                                d = u.map((e => Math.atan(e))),
                                h = o.map(((e, t) => ({
                                    theta: e,
                                    x: s[t],
                                    z: l[t],
                                    node_tangent: u[t],
                                    node_rotation: d[t]
                                }))),
                                p = new Yd({
                                    color: 65280
                                });
                            h.forEach((e => {
                                const t = new Xy(.1 / c, 32, 32);
                                new zh(t, p).position.set(e.x, n, e.z)
                            }));
                            const f = [];

                            function m(e, t) {
                                f.push({
                                    x: e,
                                    z: t
                                })
                            }
                            for (let c = 0; c < an / 2; c++) {
                                const n = c * (2 * (t + r) / (an / 2)) - (t + r);
                                m(e - e / (t + r) * Math.abs(n), n)
                            }
                            for (let c = 0; c < an / 2; c++) {
                                const n = t + r - c * (2 * (t + r) / (an / 2));
                                m(-e + e / (t + r) * Math.abs(n), n)
                            }
                            const g = new Yd({
                                color: 255
                            });
                            f.forEach((e => {
                                const t = new Xy(.1 / c, 32, 32);
                                new zh(t, g).position.set(e.x, n, e.z)
                            }));
                            const v = new Yd({
                                color: 16711680
                            });
                            for (let y = 0; y < an; y++) {
                                const t = new Xy(.1 / c, 32, 32),
                                    r = new zh(t, v),
                                    o = (e - Math.abs(f[y].x)) / e,
                                    a = Math.min(.55 * o, 1),
                                    s = 1 - a,
                                    l = s * h[y].x + a * f[y].x,
                                    u = n,
                                    d = s * h[y].z + a * f[y].z;
                                if (e > nn && e < on && y > 0) {
                                    let e = i[i.length - 3],
                                        t = i[i.length - 1];
                                    dn += Math.sqrt(Math.pow(l - e, 2) + Math.pow(d - t, 2)), 1 == y && (dn += Math.sqrt(Math.pow(l - e, 2) + Math.pow(d - t, 2)))
                                }
                                i.push(l, u, d), r.position.set(l, u, d)
                            }
                        }
                        t = .10062893081761001 * tn;
                        let dn = 0;
                        const hn = [.98 * nn + T, .98 * nn],
                            pn = [.98 * rn + T, .98 * rn],
                            fn = [.98 * nn + T, .98 * nn + T - P],
                            mn = [.98 * rn + T, .98 * rn + T - P],
                            gn = new Mh,
                            vn = [];
                        for (let _n = 0; _n < 12; _n++) {
                            const Mn = Math.PI / 2 / 12 * _n;
                            un(fn[0] - O + O * Math.sin(Mn), mn[0] - O + O * Math.sin(Mn), B - B * Math.cos(Mn), T, vn)
                        }
                        for (let wn = 0; wn < 12; wn++) {
                            const An = Math.PI / 2 / 12 * wn;
                            un(hn[0] - I + I * Math.cos(An), pn[0] - I + I * Math.cos(An), C - I + I * Math.sin(An), T, vn)
                        }
                        for (let Sn = 0; Sn < 12; Sn++) {
                            const En = Math.PI / 2 / 12 * Sn;
                            un(hn[1] + I - I * Math.sin(En), pn[1] + I - I * Math.sin(En), C - I + I * Math.cos(En), 0, vn)
                        }
                        un(hn[1], pn[1], C - (R + v / c), 0, vn), un(fn[1], mn[1], 0, 0, vn), gn.setAttribute("position", new ph(vn, 3));
                        const yn = [],
                            bn = 38;
                        for (let Cn = 0; Cn < bn; Cn++) N(Cn, (Cn + 1) % bn, an, vn, yn);
                        gn.setIndex(yn), gn.computeVertexNormals();
                        const xn = new zh(gn, S);
                        xn.position.set(0, 0 / c, 0), E.add(xn), dn = 0, un(.98 * nn + T / 2, .98 * rn + T / 2, 0, T / 2, []), r = dn * c
                    } else if ("Pear" == u.name) {
                        let Tn = .8 / c,
                            Pn = (Tn - .005 / c) * x,
                            Rn = f / 2 / c,
                            In = (m - f / 2) / c,
                            On = Rn + Pn;
                        const Bn = 64;
                        if (a) {
                            e = .10062893081761001 * Pn
                        }

                        function Ln(e, t, n) {
                            return Math.sqrt(Math.pow(t * Math.sin(e), 2) + Math.pow(n * Math.cos(e), 2))
                        }

                        function Dn(e, t, n) {
                            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e3;
                            const i = (n - t) / r;
                            let o = (e(t) + e(n)) / 2;
                            for (let a = 1; a < r; a++) o += e(t + a * i);
                            return o * i
                        }

                        function Nn(e, t, n, r) {
                            let i = 0,
                                o = e;
                            for (; i < t;) o += .05, i = Dn((e => Ln(e, n, r)), e, o);
                            for (; i > t;) o -= .001, i = Dn((e => Ln(e, n, r)), e, o);
                            for (; i < t;) o += 1e-4, i = Dn((e => Ln(e, n, r)), e, o);
                            for (; i > t;) o -= 1e-5, i = Dn((e => Ln(e, n, r)), e, o);
                            return o
                        }

                        function kn(e, t, n, r, i) {
                            let o = [0];
                            const a = Math.PI * (3 * (t + e) - Math.sqrt((3 * t + e) * (t + 3 * e))) / Bn;
                            for (let c = 0; c < Bn - 1; c++) {
                                const n = Nn(o[o.length - 1], a, t, e);
                                o.push(n)
                            }
                            const s = o.map((t => e * Math.sin(t))),
                                l = o.map((n => n > Math.PI / 2 && n < 3 * Math.PI / 2 ? -e * Math.cos(n) : -t * Math.cos(n))),
                                u = o.map((n => 0 !== Math.sin(n) ? e * Math.cos(n) / (t * Math.sin(n)) : 1 / 0)),
                                d = u.map((e => Math.atan(e))),
                                h = o.map(((e, t) => ({
                                    theta: e,
                                    x: s[t],
                                    z: l[t],
                                    node_tangent: u[t],
                                    node_rotation: d[t]
                                }))),
                                p = new Yd({
                                    color: 65280
                                });
                            h.forEach((e => {
                                const t = new Xy(.1 / c, 32, 32);
                                new zh(t, p).position.set(e.x, n, e.z)
                            }));
                            const f = [];

                            function m(e, t) {
                                f.push({
                                    x: e,
                                    z: t
                                })
                            }
                            for (let c = 0; c < Bn / 2; c++) {
                                const n = c * (2 * (t + r) / (Bn / 2)) - (t + r),
                                    i = e - e / (t + r) * Math.abs(n);
                                n <= 0 ? m(i, n) : m(0, 0)
                            }
                            for (let c = 0; c < Bn / 2; c++) {
                                const n = t + r - c * (2 * (t + r) / (Bn / 2)),
                                    i = -e + e / (t + r) * Math.abs(n);
                                n <= 0 ? m(i, n) : m(0, 0)
                            }
                            const g = new Yd({
                                color: 255
                            });
                            f.forEach((e => {
                                const t = new Xy(.1 / c, 32, 32);
                                new zh(t, g).position.set(e.x, n, e.z)
                            }));
                            const v = new Yd({
                                color: 16711680
                            });
                            for (let y = 0; y < Bn; y++) {
                                const t = new Xy(.1 / c, 32, 32),
                                    r = new zh(t, v),
                                    o = (e - Math.abs(f[y].x)) / e,
                                    a = Math.min(.55 * o, 1),
                                    s = 1 - a;
                                let l, u, d;
                                if (0 === f[y].x && 0 === f[y].z ? (l = h[y].x, u = n, d = h[y].z) : (l = s * h[y].x + a * f[y].x, u = n, d = s * h[y].z + a * f[y].z), e > Rn && e < On && y > 0) {
                                    let e = i[i.length - 3],
                                        t = i[i.length - 1];
                                    Fn += Math.sqrt(Math.pow(l - e, 2) + Math.pow(d - t, 2)), 1 == y && (Fn += Math.sqrt(Math.pow(l - e, 2) + Math.pow(d - t, 2)))
                                }
                                i.push(l, u, d), r.position.set(l, u, d)
                            }
                        }
                        t = .10062893081761001 * Pn;
                        let Fn = 0;
                        const Un = [.98 * Rn + T, .98 * Rn],
                            zn = [.98 * In + T, .98 * In],
                            Hn = [.98 * Rn + T, .98 * Rn + T - P],
                            jn = [.98 * In + T, .98 * In + T - P],
                            Gn = new Mh,
                            Vn = [];
                        for (let Kn = 0; Kn < 12; Kn++) {
                            const Jn = Math.PI / 2 / 12 * Kn;
                            kn(Hn[0] - O + O * Math.sin(Jn), jn[0] - O + O * Math.sin(Jn), B - B * Math.cos(Jn), T, Vn)
                        }
                        for (let Yn = 0; Yn < 12; Yn++) {
                            const Qn = Math.PI / 2 / 12 * Yn;
                            kn(Un[0] - I + I * Math.cos(Qn), zn[0] - I + I * Math.cos(Qn), C - I + I * Math.sin(Qn), T, Vn)
                        }
                        for (let Zn = 0; Zn < 12; Zn++) {
                            const $n = Math.PI / 2 / 12 * Zn;
                            kn(Un[1] + I - I * Math.sin($n), zn[1] + I - I * Math.sin($n), C - I + I * Math.cos($n), 0, Vn)
                        }
                        kn(Un[1], zn[1], C - (R + v / c), 0, Vn), kn(Hn[1], jn[1], 0, 0, Vn), Gn.setAttribute("position", new ph(Vn, 3));
                        const qn = [],
                            Wn = 38;
                        for (let er = 0; er < Wn; er++) N(er, (er + 1) % Wn, Bn, Vn, qn);
                        Gn.setIndex(qn), Gn.computeVertexNormals();
                        const Xn = new zh(Gn, S);
                        Xn.position.set(0, 0 / c, 0), E.add(Xn), Fn = 0, kn(.98 * Rn + T / 2, .98 * In + T / 2, 0, T / 2, []), r = Fn * c
                    }
                    n((T * c * C * c + (P - T) * c * (C - R - v / c) * c / 2) * r)
                }), [u, d, x, s, p, t, a, h, b, c, S]), (0, r.useEffect)((() => {
                    i([])
                }), []), E.rotation.order = "YXZ", E.rotation.set(0, 0, 0), E.position.set(0, D, 0), (0, Nn.jsx)("primitive", {
                    object: E,
                    scale: [1, 1, 1]
                })
            },
            $P = e => {
                let {
                    prongCount: t,
                    prongOrientation: n,
                    diamondsVisibility: i,
                    setHaloBasketPave: o,
                    setHaloBasketVolume: a,
                    extraMetal: s,
                    scaleReducerVector: l,
                    scaleReducer: c,
                    type: u,
                    basketHalo: d,
                    caratWeight: h,
                    diamondWidth: p,
                    diamondLength: f,
                    diamondPavHeight: m,
                    diamondGirdleThickness: g,
                    diamondPositionY: v,
                    haloThicknessRatio: y,
                    basketThicknessRatio: b,
                    prongArmCalculations: x,
                    prongMetalColor: _
                } = e;
                const {
                    gl: M,
                    scene: w
                } = KM(), A = (0, r.useMemo)((() => new rb({
                    color: _,
                    metalness: 1,
                    roughness: .05,
                    wireframe: !1
                })), [_]), S = (0, r.useMemo)((() => new Hm), [h, u, d, i, s, c, v, t, n]), E = "Pave" === d.name || "Hidden" === d.name;
                let C = JP(u.name, v, m, x, 0, c),
                    T = (0, r.useRef)(0),
                    P = "";
                s && (P += "_Manufacturing");
                let R = "";
                "Round" == u.name ? R += "Round" : "Oval" == u.name ? R += "Oval" : "Marquise" == u.name || "Pear" == u.name || "Cushion" == u.name ? R += "Curved" : R += "Straight";
                let I = "";
                "Round" == u.name || "Oval" == u.name ? I += "RoundBlockDiag" : "Marquise" == u.name || "Pear" == u.name ? I += "RoundBlock" : I += "StraightBlock";
                let O = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/basket/Block" + P + "/" + R + "Block0.15.glb"),
                    B = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/basket/Block" + P + "/" + R + "Block0.23.glb"),
                    L = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/basket/Plain" + P + "/" + I + "PlainLeft.glb"),
                    D = ZM(yC, "https://dealsondiamonds.com/3d-ring-builder/using/basket/Plain" + P + "/" + I + "PlainRight.glb");
                return r.useEffect((() => {
                    T.current = 0;
                    let e = YP(u.name, p, f, 0, x, E, b, c),
                        t = e.topOuterWidth,
                        n = e.topOuterLength,
                        r = e.topInnerWidth,
                        o = e.topInnerLength,
                        l = e.bottomOuterWidth,
                        d = e.bottomOuterLength,
                        h = e.bottomInnerWidth,
                        m = e.bottomInnerLength,
                        g = (e.diamondEdgeToTopOuterRatio, 0),
                        v = 0,
                        y = 0,
                        _ = 0;
                    const M = .125 / c,
                        C = (.8 / c + M) * b,
                        P = .5716 * b,
                        R = .4559 * b,
                        I = 2 * Math.PI * t,
                        N = x.prongWidth / c,
                        k = N / 2;
                    Math.PI, x.prongOrientation;
                    v = E ? .08419 : .1, _ = (.8419 + v) * b;
                    let F = 0,
                        U = [],
                        z = [];
                    const H = {
                            0: .8897,
                            .15: .9559,
                            .23: 1.108
                        },
                        j = .4871;
                    s && (g = E ? .08419 : .1);
                    const G = {
                        Round: {
                            prongRadius: p / 2 / (p / 2 + k * c),
                            girdleLine: p / 2 / (p / 2 + P),
                            cornerCorrectionMultiplier: .9
                        },
                        Oval: {
                            prongRadius: p / 2 / (p / 2 + k * c),
                            girdleLine: p / 2 / (p / 2 + P),
                            cornerCorrectionMultiplier: 1
                        },
                        Pear: {
                            prongRadius: p / 2 / (p / 2 + k * c),
                            girdleLine: p / 2 / (p / 2 + P),
                            cornerCorrectionMultiplier: .9
                        },
                        Marquise: {
                            prongRadius: p / 2 / (p / 2 + k * c),
                            girdleLine: p / 2 / (p / 2 + P),
                            cornerCorrectionMultiplier: 1
                        },
                        Cushion: {
                            prongRadius: 1,
                            girdleLine: 1,
                            cornerCorrectionMultiplier: 1
                        },
                        Princess: {
                            prongRadius: 1,
                            girdleLine: 1,
                            cornerCorrectionMultiplier: .8
                        },
                        Emerald: {
                            prongRadius: 1,
                            girdleLine: 1,
                            cornerCorrectionMultiplier: 1
                        },
                        Radiant: {
                            prongRadius: 1,
                            girdleLine: 1,
                            cornerCorrectionMultiplier: .9
                        },
                        Asscher: {
                            prongRadius: 1,
                            girdleLine: 1,
                            cornerCorrectionMultiplier: .95
                        }
                    };
                    let V;

                    function q(e, t, n, r) {
                        return Math.sqrt(Math.pow(n - e, 2) + Math.pow(r - t, 2))
                    }

                    function W(e, t) {
                        const n = [];
                        return n.push(e.point), t.indexPrev > e.indexPrev ? n.push(...U.slice(e.indexPrev + 1, t.indexPrev + 1)) : (n.push(...U.slice(e.indexPrev + 1)), n.push(...U.slice(0, t.indexPrev + 1))), n.push(t.point), n
                    }

                    function X(e, t) {
                        let n = 0;
                        const r = W(e, t);
                        for (let i = 1; i < r.length; i++) {
                            const e = r[i - 1],
                                t = r[i];
                            n += q(e.x, e.z, t.x, t.z)
                        }
                        return n
                    }

                    function K(e, t) {
                        let n, r, o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        .15 === o ? (n = O.scene.clone(!0), r = "Diamondmesh434") : .23 === o && (n = B.scene.clone(!0), r = "Diamondmesh434"), n.position.set(e.x, e.y, e.z), n.rotation.set(0, t, 0), n.scale.set(b / c, b / c, b / c), S.add(n),
                            function(e, t) {
                                e.traverse((e => {
                                    e.isMesh && (e.name.startsWith("DiamondMesh") || (e.material = A))
                                }));
                                const n = t;
                                if (i) e.getObjectByName(n).material = V;
                                else {
                                    let t = e.getObjectByName(n);
                                    t.parent.remove(t)
                                }
                            }(n, r)
                    }

                    function J(e, t, n) {
                        let r;
                        "left" === n ? r = L.scene.clone(!0) : "right" === n && (r = D.scene.clone(!0)), r.position.set(e.x, e.y, e.z), r.rotation.set(0, t, 0), r.scale.set(b / c, b / c, b / c), S.add(r), r.traverse((e => {
                            e.isMesh && (e.material = A)
                        }))
                    }

                    function Y(e, t, n, r) {
                        let i = 0;
                        const o = W(e, t);
                        let a = G[u.name].cornerCorrectionMultiplier,
                            s = n - 2 * k * G[u.name].prongRadius * a,
                            l = s / r;
                        if (l > .95 * H[.23] * b / c) {
                            a -= ((r + 1) * C - s) / k / 2, s = n - 2 * k * G[u.name].prongRadius * a, l = s / (r += 1)
                        }
                        const d = l < C ? .15 : .23,
                            h = l,
                            p = l / 2 + k * G[u.name].prongRadius * a - M / 2,
                            f = .95 * (H[d] / 2 + j / 2) * b / c;
                        let m = p - f,
                            g = e.point;
                        for (let c = 1; c < o.length; c++) {
                            const e = o[c];
                            let t = q(g.x, g.z, e.x, e.z);
                            if (m -= t, m <= 0 && t > 0) {
                                const n = 1 + m / t,
                                    a = (1 - n) * g.x + n * e.x,
                                    s = 0,
                                    l = (1 - n) * g.z + n * e.z,
                                    p = o[c - 2 >= 0 ? c - 2 : c - 1].x - o[c].x,
                                    v = o[c - 2 >= 0 ? c - 2 : c - 1].z - o[c].z;
                                let y = Math.PI + Math.PI / 2 - Math.atan2(v, p);
                                const b = o[c - 1].x - o[c + 1 < o.length ? c + 1 : c].x,
                                    x = o[c - 1].z - o[c + 1 < o.length ? c + 1 : c].z;
                                let _ = (1 - n) * y + n * (Math.PI + Math.PI / 2 - Math.atan2(x, b));
                                if (i === r + 1) {
                                    "Round" != u.name && "Oval" != u.name && "Pear" != u.name && "Marquise" != u.name && "Cushion" != u.name || J({
                                        x: a,
                                        y: s,
                                        z: l
                                    }, _, "left");
                                    break
                                }
                                0 === i ? "Round" != u.name && "Oval" != u.name && "Pear" != u.name && "Marquise" != u.name && "Cushion" != u.name || J({
                                    x: a,
                                    y: s,
                                    z: l
                                }, _, "right") : (K({
                                    x: a,
                                    y: s,
                                    z: l
                                }, _, d), T.current += 1), i += 1, g = {
                                    x: a,
                                    y: s,
                                    z: l
                                }, m = h, 1 !== i && i !== r + 1 || (m = f)
                            } else g = e
                        }
                    }

                    function Q() {
                        ! function() {
                            let e = 0;
                            for (let i = 0; i < x.prongOrientation.length; i++)
                                if (-Math.PI / 2 + x.prongOrientation[i] >= F) {
                                    e = i;
                                    break
                                }
                            let t = e,
                                n = 0;
                            const r = 10 * Math.PI / 180;
                            for (let i = 1; i < U.length; i++) {
                                let e = -Math.PI / 2 + x.prongOrientation[t];
                                e < 0 && (e = 2 * Math.PI + e);
                                let o = U[i - 1],
                                    a = Math.atan2(o.z, o.x);
                                a < 0 && (a = 2 * Math.PI + a);
                                const s = U[i];
                                let l = Math.atan2(s.z, s.x);
                                if (l < 0 && (l = 2 * Math.PI + l), l >= e && l < e + r) {
                                    const r = 1 - (e - a) / (l - a),
                                        c = r * o.x + (1 - r) * s.x,
                                        u = 0,
                                        d = r * o.z + (1 - r) * s.z;
                                    if (z.push({
                                            point: {
                                                x: c,
                                                y: u,
                                                z: d
                                            },
                                            indexPrev: i - 1
                                        }), n += 1, t = (t + 1) % x.prongOrientation.length, n === x.prongOrientation.length) break
                                }
                            }
                        }();
                        for (let e = 0; e < z.length; e++) {
                            const t = z[e],
                                n = z[(e + 1) % z.length],
                                r = X(t, n) + M;
                            Y(t, n, r, Math.floor((r / G[u.name].girdleLine - 2 * k * G[u.name].cornerCorrectionMultiplier) / C))
                        }
                    }
                    if (w.traverse((e => {
                            e.isMesh && "diamondmesh" === e.name && (V = e.material)
                        })), "Round" == u.name) {
                        const Z = 100,
                            $ = 10,
                            ee = x.prongWidth / c;
                        const te = (.8419 + g) / c * b;
                        const ne = te / 2,
                            re = -te / 2,
                            ie = new Mh,
                            oe = new Yd({
                                color: 65280
                            }),
                            ae = new Xy(.05 / c, 32, 32);

                        function se(e, t, n) {
                            for (let r = 0; r < Z; r++) {
                                const i = r / Z * 2 * Math.PI,
                                    o = e * Math.cos(i),
                                    a = t,
                                    s = e * Math.sin(i);
                                n.push(o, a, s), 0 == t && U.push({
                                    x: o,
                                    y: a,
                                    z: s
                                });
                                new zh(ae, oe).position.set(o, a, s)
                            }
                        }
                        let le = [],
                            ce = [];
                        se(r + g / c, ne, le), se(t + g / c, ne, le), se(h + g / c, re, le), se(l + g / c, re, le);
                        const ue = [];
                        for (let pe = 0; pe < Z; pe++) {
                            const fe = (pe + 1) % Z,
                                me = pe,
                                ge = pe + Z;
                            ue.push(me, fe, ge), ue.push(fe + Z, ge, fe), ue.push(pe, pe + 2 * Z, fe), ue.push(fe, pe + 2 * Z, fe + 2 * Z), ue.push(pe + 2 * Z, pe + 3 * Z, fe + 2 * Z), ue.push(fe + 2 * Z, pe + 3 * Z, fe + 3 * Z)
                        }
                        const de = .15 * ee;
                        for (let ve = 0; ve < $ + 1; ve++) {
                            const ye = Math.PI / $ * ve;
                            let be = de * Math.sin(ye);
                            const xe = ve / $;
                            E && (be = 0), se(t + g / c - xe * (t + g / c - (l + g / c)) + be, te / 2 - xe * te, ce)
                        }
                        le = le.concat(ce);
                        for (let _e = 0; _e < Z; _e++)
                            for (let Me = 0; Me < $; Me++) {
                                const we = 4 * Z + Me * Z + _e,
                                    Ae = 4 * Z + Me * Z + (_e + 1) % Z,
                                    Se = we + Z,
                                    Ee = Ae + Z,
                                    Ce = le.length / 3;
                                we >= Ce || Ae >= Ce || Se >= Ce || Ee >= Ce ? console.error("Index out of bounds: current=".concat(we, ", next=").concat(Ae, ", below=").concat(Se, ", belowNext=").concat(Ee)) : (ue.push(we, Ae, Se), ue.push(Ae, Ee, Se))
                            }
                        ie.setAttribute("position", new ph(le, 3)), ie.setIndex(ue), ie.computeVertexNormals(), E && (F = 0, Q());
                        const he = new zh(ie, A);
                        he.position.set(0, 0, 0), S.add(he), E && (t += R / c, n += R / c, l += R / c, d += R / c);
                        y = Math.PI * Math.pow((t * c + v + l * c + v) / 2, 2) - Math.PI * Math.pow((r * c + v + h * c + v) / 2, 2)
                    } else if ("Oval" == u.name) {
                        const Te = 100,
                            Pe = 10,
                            Re = x.prongWidth / c;
                        const Ie = (.8419 + g) / c * b;
                        const Oe = Ie / 2,
                            Be = -Ie / 2,
                            Le = new Mh;
                        new Yd({
                            color: 65280
                        }), new Xy(.02 / c, 32, 32);

                        function De(e, t, n, r) {
                            for (let i = 0; i < Te; i++) {
                                const o = i / Te * 2 * Math.PI,
                                    a = e * Math.cos(o),
                                    s = n,
                                    l = t * Math.sin(o);
                                r.push(a, s, l), 0 == n && U.push({
                                    x: a,
                                    y: s,
                                    z: l
                                })
                            }
                        }
                        let Ne = [],
                            ke = [];
                        De(r, o, Oe, Ne), De(t, n, Oe, Ne), De(h, m, Be, Ne), De(l, d, Be, Ne);
                        const Fe = [];
                        for (let je = 0; je < Te; je++) {
                            const Ge = (je + 1) % Te,
                                Ve = je,
                                qe = je + Te;
                            Fe.push(Ve, Ge, qe), Fe.push(Ge + Te, qe, Ge), Fe.push(je, je + 2 * Te, Ge), Fe.push(Ge, je + 2 * Te, Ge + 2 * Te), Fe.push(je + 2 * Te, je + 3 * Te, Ge + 2 * Te), Fe.push(Ge + 2 * Te, je + 3 * Te, Ge + 3 * Te)
                        }
                        const Ue = .15 * Re;
                        for (let We = 0; We < Pe + 1; We++) {
                            const Xe = Math.PI / Pe * We;
                            let Ke = Ue * Math.sin(Xe);
                            const Je = We / Pe;
                            E && (Ke = 0), De(t - Je * (t - l) + Ke, n - Je * (n - d) + Ke, Ie / 2 - Je * Ie, ke)
                        }
                        Ne = Ne.concat(ke);
                        for (let Ye = 0; Ye < Te; Ye++)
                            for (let Qe = 0; Qe < Pe; Qe++) {
                                const Ze = 4 * Te + Qe * Te + Ye,
                                    $e = 4 * Te + Qe * Te + (Ye + 1) % Te,
                                    et = Ze + Te,
                                    tt = $e + Te,
                                    nt = Ne.length / 3;
                                Ze >= nt || $e >= nt || et >= nt || tt >= nt ? console.error("Index out of bounds: current=".concat(Ze, ", next=").concat($e, ", below=").concat(et, ", belowNext=").concat(tt)) : (Fe.push(Ze, $e, et), Fe.push($e, tt, et))
                            }
                        let ze;
                        Le.setAttribute("position", new ph(Ne, 3)), Le.setIndex(Fe), Le.computeVertexNormals(), w.traverse((e => {
                            e.isMesh && "diamondmesh" === e.name && (ze = e.material)
                        })), E && (F = 0, Q());
                        const He = new zh(Le, A);
                        He.position.set(0, 0, 0), S.add(He), E && (t += R / c, n += R / c, l += R / c, d += R / c);
                        y = Math.PI * ((t * c + v + l * c + v) / 2) * ((n * c + v + d * c + v) / 2) - Math.PI * ((r * c + v + h * c + v) / 2) * ((o * c + v + m * c + v) / 2)
                    } else if ("Princess" == u.name) {
                        const rt = 100,
                            it = 10,
                            ot = x.prongWidth / c,
                            at = (.8419 + g) / c * b,
                            st = at / 2,
                            lt = -at / 2,
                            ct = new Mh,
                            ut = new Yd({
                                color: 65280
                            }),
                            dt = new Xy(.05 / c, 32, 32);

                        function ht(e, t, n, r) {
                            const i = 2 * (2 * e + 2 * t) / rt;
                            let o = 0,
                                a = 0,
                                s = i,
                                l = n,
                                c = -t;
                            for (; s <= e; s += i) {
                                r.push(s, l, c), 0 == n && U.push({
                                    x: s,
                                    y: l,
                                    z: c
                                }), a += 1, o += i;
                                new zh(dt, ut).position.set(s, l, c)
                            }
                            for (s = e, c = i - (e - o) - t; c <= t; c += i) {
                                r.push(s, l, c), 0 == n && U.push({
                                    x: s,
                                    y: l,
                                    z: c
                                }), a += 1, o += i;
                                new zh(dt, ut).position.set(s, l, c)
                            }
                            for (c = t, s = e - (i - (2 * t + e - o)); s >= -e; s -= i) {
                                r.push(s, l, c), 0 == n && U.push({
                                    x: s,
                                    y: l,
                                    z: c
                                }), a += 1, o += i;
                                new zh(dt, ut).position.set(s, l, c)
                            }
                            for (s = -e, c = t - (i - (2 * t + 3 * e - o)); c >= -t; c -= i) {
                                r.push(s, l, c), 0 == n && U.push({
                                    x: s,
                                    y: l,
                                    z: c
                                }), a += 1, o += i;
                                new zh(dt, ut).position.set(s, l, c)
                            }
                            for (c = -t, s = i - (4 * t + 3 * e - o) - e; a < rt;) {
                                r.push(s, l, c), 0 == n && U.push({
                                    x: s,
                                    y: l,
                                    z: c
                                }), a += 1, s += i;
                                new zh(dt, ut).position.set(s, l, c), o += i
                            }
                        }
                        let pt = [],
                            ft = [];
                        ht(r, o, st, pt), ht(t, n, st, pt), ht(h, m, lt, pt), ht(l, d, lt, pt);
                        const mt = [];
                        for (let yt = 0; yt < rt; yt++) {
                            const bt = (yt + 1) % rt,
                                xt = yt,
                                _t = yt + rt;
                            mt.push(xt, bt, _t), mt.push(bt + rt, _t, bt), mt.push(yt, yt + 2 * rt, bt), mt.push(bt, yt + 2 * rt, bt + 2 * rt), mt.push(yt + 2 * rt, yt + 3 * rt, bt + 2 * rt), mt.push(bt + 2 * rt, yt + 3 * rt, bt + 3 * rt)
                        }
                        const gt = .1 * ot;
                        for (let Mt = 0; Mt < it + 1; Mt++) {
                            const wt = Math.PI / it * Mt;
                            let At = gt * Math.sin(wt);
                            const St = Mt / it;
                            E && (At = 0), ht(t - St * (t - l) + At, n - St * (n - d) + At, at / 2 - St * at, ft)
                        }
                        pt = pt.concat(ft);
                        for (let Et = 0; Et < rt; Et++)
                            for (let Ct = 0; Ct < it; Ct++) {
                                const Tt = 4 * rt + Ct * rt + Et,
                                    Pt = 4 * rt + Ct * rt + (Et + 1) % rt,
                                    Rt = Tt + rt,
                                    It = Pt + rt,
                                    Ot = pt.length / 3;
                                Tt >= Ot || Pt >= Ot || Rt >= Ot || It >= Ot ? console.error("Index out of bounds: current=".concat(Tt, ", next=").concat(Pt, ", below=").concat(Rt, ", belowNext=").concat(It)) : (mt.push(Tt, Pt, Rt), mt.push(Pt, It, Rt))
                            }
                        ct.setAttribute("position", new ph(pt, 3)), ct.setIndex(mt), ct.computeVertexNormals(), E && (F = -Math.PI / 2, Q());
                        const vt = new zh(ct, A);
                        vt.position.set(0, 0, 0), S.add(vt), E && (t += R / c, n += R / c, l += R / c, d += R / c);
                        y = (t * c + v + l * c + v) / 2 * 2 * 2 * ((n * c + v + d * c + v) / 2) - (r * c + v + h * c + v) / 2 * 2 * 2 * ((o * c + v + m * c + v) / 2)
                    } else if ("Asscher" == u.name || "Emerald" == u.name || "Radiant" == u.name) {
                        const Bt = 25,
                            Lt = 5,
                            Dt = 4 * Bt + 4 * (Lt - 1),
                            Nt = 10,
                            kt = x.prongWidth / c,
                            Ft = (.8419 + g) / c * b,
                            Ut = Ft / 2,
                            zt = -Ft / 2,
                            Ht = new Mh,
                            jt = new Yd({
                                color: 65280
                            }),
                            Gt = new Xy(.03 / c, 32, 32);

                        function Vt(e, t, n, r, i) {
                            function o(e, t, n) {
                                r.push(e, t, n), 0 == t && U.push({
                                    x: e,
                                    y: t,
                                    z: n
                                });
                                new zh(Gt, jt).position.set(e, t, n)
                            }
                            let a = kt / 2;
                            E && (a *= i);
                            const s = 2 * (e - a) / (Bt - 1),
                                l = 2 * (t - a) / (Bt - 1);
                            for (let c = 0; c < Bt; c++) o(-e + a + c * s, n, -t);
                            for (let c = 1; c < Lt; c++) o(e - a + a / Lt * c, n, a / Lt * c - t);
                            for (let c = 0; c < Bt; c++) o(e, n, -t + a + c * l);
                            for (let c = 1; c < Lt; c++) o(e - a / Lt * c, n, t - a + a / Lt * c);
                            for (let c = 0; c < Bt; c++) o(e - a - c * s, n, t);
                            for (let c = 1; c < Lt; c++) o(-e + a - a / Lt * c, n, t - a / Lt * c);
                            for (let c = 0; c < Bt; c++) o(-e, n, t - a - c * l);
                            for (let c = 1; c < Lt; c++) o(a / Lt * c - e, n, -t + a - a / Lt * c)
                        }
                        let qt = [],
                            Wt = [];
                        Vt(r, o, Ut, qt, .33), Vt(t, n, Ut, qt, .33), Vt(h, m, zt, qt, 1), Vt(l, d, zt, qt, 1);
                        const Xt = [];
                        for (let Yt = 0; Yt < Dt; Yt++) {
                            const Qt = (Yt + 1) % Dt,
                                Zt = Yt,
                                $t = Yt + Dt;
                            Xt.push(Zt, Qt, $t), Xt.push(Qt + Dt, $t, Qt), Xt.push(Yt, Yt + 2 * Dt, Qt), Xt.push(Qt, Yt + 2 * Dt, Qt + 2 * Dt), Xt.push(Yt + 2 * Dt, Yt + 3 * Dt, Qt + 2 * Dt), Xt.push(Qt + 2 * Dt, Yt + 3 * Dt, Qt + 3 * Dt)
                        }
                        const Kt = .1 * kt;
                        for (let en = 0; en < Nt + 1; en++) {
                            const tn = Math.PI / Nt * en;
                            let nn = Kt * Math.sin(tn);
                            const rn = en / Nt;
                            E && (nn = 0), Vt(t - rn * (t - l) + nn, n - rn * (n - d) + nn, Ft / 2 - rn * Ft, Wt, .33 + en / (Nt - 1) * (1 - .33))
                        }
                        qt = qt.concat(Wt);
                        for (let on = 0; on < Dt; on++)
                            for (let an = 0; an < Nt; an++) {
                                const sn = 4 * Dt + an * Dt + on,
                                    ln = 4 * Dt + an * Dt + (on + 1) % Dt,
                                    cn = sn + Dt,
                                    un = ln + Dt,
                                    dn = qt.length / 3;
                                sn >= dn || ln >= dn || cn >= dn || un >= dn ? console.error("Index out of bounds: current=".concat(sn, ", next=").concat(ln, ", below=").concat(cn, ", belowNext=").concat(un)) : (Xt.push(sn, ln, cn), Xt.push(ln, un, cn))
                            }
                        Ht.setAttribute("position", new ph(qt, 3)), Ht.setIndex(Xt), Ht.computeVertexNormals(), E && (F = -Math.PI / 2, Q());
                        const Jt = new zh(Ht, A);
                        Jt.position.set(0, 0, 0), S.add(Jt), E && (t += R / c, n += R / c, l += R / c, d += R / c);
                        y = (t * c + v + l * c + v) / 2 * 2 * 2 * ((n * c + v + d * c + v) / 2) - (r * c + v + h * c + v) / 2 * 2 * 2 * ((o * c + v + m * c + v) / 2)
                    } else if ("Cushion" == u.name) {
                        const hn = 64,
                            pn = 10,
                            fn = x.prongWidth / c,
                            mn = (.8419 + g) / c * b,
                            gn = mn / 2,
                            vn = -mn / 2,
                            yn = .3,
                            bn = new Mh;
                        new Yd({
                            color: 65280
                        }), new Xy(.05 / c, 32, 32);

                        function xn(e, t, n) {
                            return Math.sqrt(Math.pow(t * Math.sin(e), 2) + Math.pow(n * Math.cos(e), 2))
                        }

                        function _n(e, t, n) {
                            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e3;
                            const i = (n - t) / r;
                            let o = (e(t) + e(n)) / 2;
                            for (let a = 1; a < r; a++) o += e(t + a * i);
                            return o * i
                        }

                        function Mn(e, t, n, r) {
                            let i = 0,
                                o = e;
                            for (; i < t;) o += .05, i = _n((e => xn(e, n, r)), e, o);
                            for (; i > t;) o -= .001, i = _n((e => xn(e, n, r)), e, o);
                            for (; i < t;) o += 1e-4, i = _n((e => xn(e, n, r)), e, o);
                            for (; i > t;) o -= 1e-5, i = _n((e => xn(e, n, r)), e, o);
                            return o
                        }

                        function wn(e, t, n, r) {
                            let i = [0];
                            const o = Math.PI * (3 * (t + e) - Math.sqrt((3 * t + e) * (t + 3 * e))) / hn;
                            for (let c = 0; c < hn - 1; c++) {
                                const n = Mn(i[i.length - 1], o, t, e);
                                i.push(n)
                            }
                            const a = i.map((t => e * Math.sin(t))),
                                s = i.map((e => -t * Math.cos(e))),
                                l = i.map((n => 0 !== Math.sin(n) ? e * Math.cos(n) / (t * Math.sin(n)) : 1 / 0)),
                                u = l.map((e => Math.atan(e))),
                                d = i.map(((e, t) => ({
                                    theta: e,
                                    x: a[t],
                                    z: s[t],
                                    node_tangent: l[t],
                                    node_rotation: u[t]
                                }))),
                                h = new Yd({
                                    color: 65280
                                });
                            d.forEach((e => {
                                const t = new Xy(.1 / c, 32, 32);
                                new zh(t, h).position.set(e.x, 0, e.z)
                            }));
                            const p = [],
                                f = 2 * (2 * e + 2 * t) / hn;
                            let m = 0;

                            function g(e, t) {
                                p.push({
                                    x: e,
                                    y: n,
                                    z: t
                                })
                            }
                            let v = f,
                                y = -t;
                            for (; v <= e; v += f) g(v, y), m += f;
                            for (v = e, y = f - (e - m) - t; y <= t; y += f) g(v, y), m += f;
                            for (y = t, v = e - (f - (2 * t + e - m)); v >= -e; v -= f) g(v, y), m += f;
                            for (v = -e, y = t - (f - (2 * t + 3 * e - m)); y >= -t; y -= f) g(v, y), m += f;
                            for (y = -t, v = f - (4 * t + 3 * e - m) - e; p.length < hn;) g(v, y), v += f, m += f;
                            const b = new Yd({
                                color: 255
                            });
                            p.forEach((e => {
                                const t = new Xy(.1 / c, 32, 32);
                                new zh(t, b).position.set(e.x, e.y, e.z)
                            }));
                            const x = new Yd({
                                color: 16711680
                            });
                            for (let _ = 0; _ < hn; _++) {
                                const i = new Xy(.03 / c, 32, 32),
                                    o = new zh(i, x),
                                    a = [e - Math.abs(p[(_ + (hn - 1)) % hn].x) + (t - Math.abs(p[(_ + (hn - 1)) % hn].z))] / (e + t) * (1 - yn) + yn,
                                    s = 1 - a,
                                    l = s * d[_].x + a * p[(_ + (hn - 1)) % hn].x,
                                    u = n,
                                    h = s * d[_].z + a * p[(_ + (hn - 1)) % hn].z;
                                r.push(l, u, h), 0 == n && U.push({
                                    x: l,
                                    y: u,
                                    z: h
                                }), o.position.set(l, u, h)
                            }
                        }
                        let An = [],
                            Sn = [];
                        wn(r, o, gn, An), wn(t, n, gn, An), wn(h, m, vn, An), wn(l, d, vn, An);
                        const En = [];
                        for (let Pn = 0; Pn < hn; Pn++) {
                            const Rn = (Pn + 1) % hn,
                                In = Pn,
                                On = Pn + hn;
                            En.push(In, Rn, On), En.push(Rn + hn, On, Rn), En.push(Pn, Pn + 2 * hn, Rn), En.push(Rn, Pn + 2 * hn, Rn + 2 * hn), En.push(Pn + 2 * hn, Pn + 3 * hn, Rn + 2 * hn), En.push(Rn + 2 * hn, Pn + 3 * hn, Rn + 3 * hn)
                        }
                        const Cn = .1 * fn;
                        for (let Bn = 0; Bn < pn + 1; Bn++) {
                            const Ln = Math.PI / pn * Bn;
                            let Dn = Cn * Math.sin(Ln);
                            const Nn = Bn / pn;
                            E && (Dn = 0), wn(t - Nn * (t - l) + Dn, n - Nn * (n - d) + Dn, mn / 2 - Nn * mn, Sn)
                        }
                        An = An.concat(Sn);
                        for (let kn = 0; kn < hn; kn++)
                            for (let Fn = 0; Fn < pn; Fn++) {
                                const Un = 4 * hn + Fn * hn + kn,
                                    zn = 4 * hn + Fn * hn + (kn + 1) % hn,
                                    Hn = Un + hn,
                                    jn = zn + hn,
                                    Gn = An.length / 3;
                                Un >= Gn || zn >= Gn || Hn >= Gn || jn >= Gn ? console.error("Index out of bounds: current=".concat(Un, ", next=").concat(zn, ", below=").concat(Hn, ", belowNext=").concat(jn)) : (En.push(Un, zn, Hn), En.push(zn, jn, Hn))
                            }
                        bn.setAttribute("position", new ph(An, 3)), bn.setIndex(En), bn.computeVertexNormals(), E && (F = -Math.PI / 2, Q());
                        const Tn = new zh(bn, A);
                        Tn.position.set(0, 0, 0), S.add(Tn), E && (t += R / c, n += R / c, l += R / c, d += R / c);
                        y = (t * c + v + l * c + v) / 2 * 2 * 2 * ((n * c + v + d * c + v) / 2) - (r * c + v + h * c + v) / 2 * 2 * 2 * ((o * c + v + m * c + v) / 2)
                    } else if ("Marquise" == u.name) {
                        const Vn = 64,
                            qn = 10,
                            Wn = x.prongWidth / c,
                            Xn = (.8419 + g) / c * b,
                            Kn = Xn / 2,
                            Jn = -Xn / 2,
                            Yn = new Mh;
                        new Yd({
                            color: 65280
                        }), new Xy(.05 / c, 32, 32);

                        function Qn(e, t, n) {
                            return Math.sqrt(Math.pow(t * Math.sin(e), 2) + Math.pow(n * Math.cos(e), 2))
                        }

                        function Zn(e, t, n) {
                            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e3;
                            const i = (n - t) / r;
                            let o = (e(t) + e(n)) / 2;
                            for (let a = 1; a < r; a++) o += e(t + a * i);
                            return o * i
                        }

                        function $n(e, t, n, r) {
                            let i = 0,
                                o = e;
                            for (; i < t;) o += .05, i = Zn((e => Qn(e, n, r)), e, o);
                            for (; i > t;) o -= .001, i = Zn((e => Qn(e, n, r)), e, o);
                            for (; i < t;) o += 1e-4, i = Zn((e => Qn(e, n, r)), e, o);
                            for (; i > t;) o -= 1e-5, i = Zn((e => Qn(e, n, r)), e, o);
                            return o
                        }

                        function er(e, t, n, r, i) {
                            let o = [0];
                            const a = Math.PI * (3 * (t + e) - Math.sqrt((3 * t + e) * (t + 3 * e))) / Vn;
                            for (let c = 0; c < Vn - 1; c++) {
                                const n = $n(o[o.length - 1], a, t, e);
                                o.push(n)
                            }
                            const s = o.map((t => e * Math.sin(t))),
                                l = o.map((e => -t * Math.cos(e))),
                                u = o.map((n => 0 !== Math.sin(n) ? e * Math.cos(n) / (t * Math.sin(n)) : 1 / 0)),
                                d = u.map((e => Math.atan(e))),
                                h = o.map(((e, t) => ({
                                    theta: e,
                                    x: s[t],
                                    z: l[t],
                                    node_tangent: u[t],
                                    node_rotation: d[t]
                                }))),
                                p = new Yd({
                                    color: 65280
                                });
                            h.forEach((e => {
                                const t = new Xy(.1 / c, 32, 32);
                                new zh(t, p).position.set(e.x, 0, e.z)
                            }));
                            const f = [];

                            function m(e, t) {
                                f.push({
                                    x: e,
                                    y: n,
                                    z: t
                                })
                            }
                            for (let c = 0; c < Vn / 2; c++) {
                                const n = c * (2 * (t + r) / (Vn / 2)) - (t + r);
                                m(e - e / (t + r) * Math.abs(n), n)
                            }
                            for (let c = 0; c < Vn / 2; c++) {
                                const n = t + r - c * (2 * (t + r) / (Vn / 2));
                                m(-e + e / (t + r) * Math.abs(n), n)
                            }
                            const g = new Yd({
                                color: 255
                            });
                            f.forEach((e => {
                                const t = new Xy(.1 / c, 32, 32);
                                new zh(t, g).position.set(e.x, 0, e.z)
                            }));
                            const v = new Yd({
                                color: 16711680
                            });
                            for (let y = 0; y < Vn; y++) {
                                const t = new Xy(.1 / c, 32, 32),
                                    r = new zh(t, v),
                                    o = (e - Math.abs(f[y].x)) / e,
                                    a = Math.min(.55 * o, 1),
                                    s = 1 - a,
                                    l = s * h[y].x + a * f[y].x,
                                    u = n,
                                    d = s * h[y].z + a * f[y].z;
                                i.push(l, u, d), 0 == n && U.push({
                                    x: l,
                                    y: u,
                                    z: d
                                }), r.position.set(l, u, d)
                            }
                        }
                        let tr = [],
                            nr = [];
                        er(r, o, Kn, o - n, tr), er(t, n, Kn, 0, tr), er(h, m, Jn, m - d, tr), er(l, d, Jn, 0, tr);
                        const rr = [];
                        for (let ar = 0; ar < Vn; ar++) {
                            const sr = (ar + 1) % Vn,
                                lr = ar,
                                cr = ar + Vn;
                            rr.push(lr, sr, cr), rr.push(sr + Vn, cr, sr), rr.push(ar, ar + 2 * Vn, sr), rr.push(sr, ar + 2 * Vn, sr + 2 * Vn), rr.push(ar + 2 * Vn, ar + 3 * Vn, sr + 2 * Vn), rr.push(sr + 2 * Vn, ar + 3 * Vn, sr + 3 * Vn)
                        }
                        const ir = .1 * Wn;
                        for (let ur = 0; ur < qn + 1; ur++) {
                            const dr = Math.PI / qn * ur;
                            let hr = ir * Math.sin(dr);
                            const pr = ur / qn;
                            E && (hr = 0), er(t - pr * (t - l) + hr, n - pr * (n - d) + hr, Xn / 2 - pr * Xn, 0, nr)
                        }
                        tr = tr.concat(nr);
                        for (let fr = 0; fr < Vn; fr++)
                            for (let mr = 0; mr < qn; mr++) {
                                const gr = 4 * Vn + mr * Vn + fr,
                                    vr = 4 * Vn + mr * Vn + (fr + 1) % Vn,
                                    yr = gr + Vn,
                                    br = vr + Vn,
                                    xr = tr.length / 3;
                                gr >= xr || vr >= xr || yr >= xr || br >= xr ? console.error("Index out of bounds: current=".concat(gr, ", next=").concat(vr, ", below=").concat(yr, ", belowNext=").concat(br)) : (rr.push(gr, vr, yr), rr.push(vr, br, yr))
                            }
                        Yn.setAttribute("position", new ph(tr, 3)), Yn.setIndex(rr), Yn.computeVertexNormals(), E && (F = -Math.PI / 2, Q());
                        const or = new zh(Yn, A);
                        or.position.set(0, 0, 0), S.add(or), E && (t += R / c, n += R / c, l += R / c, d += R / c);
                        y = (t * c + v + l * c + v) / 2 * 2 * ((n * c + v + d * c + v) / 2) - (r * c + v + h * c + v) / 2 * 2 * ((o * c + v + m * c + v) / 2)
                    } else if ("Pear" == u.name) {
                        const _r = 64,
                            Mr = 10,
                            wr = x.prongWidth / c,
                            Ar = (.8419 + g) / c * b,
                            Sr = Ar / 2,
                            Er = -Ar / 2,
                            Cr = new Mh;
                        new Yd({
                            color: 65280
                        }), new Xy(.05 / c, 32, 32);

                        function Tr(e, t, n) {
                            return Math.sqrt(Math.pow(t * Math.sin(e), 2) + Math.pow(n * Math.cos(e), 2))
                        }

                        function Pr(e, t, n) {
                            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e3;
                            const i = (n - t) / r;
                            let o = (e(t) + e(n)) / 2;
                            for (let a = 1; a < r; a++) o += e(t + a * i);
                            return o * i
                        }

                        function Rr(e, t, n, r) {
                            let i = 0,
                                o = e;
                            for (; i < t;) o += .05, i = Pr((e => Tr(e, n, r)), e, o);
                            for (; i > t;) o -= .001, i = Pr((e => Tr(e, n, r)), e, o);
                            for (; i < t;) o += 1e-4, i = Pr((e => Tr(e, n, r)), e, o);
                            for (; i > t;) o -= 1e-5, i = Pr((e => Tr(e, n, r)), e, o);
                            return o
                        }

                        function Ir(e, t, n, r, i) {
                            let o = [0];
                            const a = Math.PI * (3 * (t + e) - Math.sqrt((3 * t + e) * (t + 3 * e))) / _r;
                            for (let c = 0; c < _r - 1; c++) {
                                const n = Rr(o[o.length - 1], a, t, e);
                                o.push(n)
                            }
                            const s = o.map((t => e * Math.sin(t))),
                                l = o.map((n => n > Math.PI / 2 && n < 3 * Math.PI / 2 ? -e * Math.cos(n) : -t * Math.cos(n))),
                                u = o.map((n => 0 !== Math.sin(n) ? e * Math.cos(n) / (t * Math.sin(n)) : 1 / 0)),
                                d = u.map((e => Math.atan(e))),
                                h = o.map(((e, t) => ({
                                    theta: e,
                                    x: s[t],
                                    z: l[t],
                                    node_tangent: u[t],
                                    node_rotation: d[t]
                                }))),
                                p = new Yd({
                                    color: 65280
                                });
                            h.forEach((e => {
                                const t = new Xy(.1 / c, 32, 32);
                                new zh(t, p).position.set(e.x, 0, e.z)
                            }));
                            const f = [];

                            function m(e, t) {
                                f.push({
                                    x: e,
                                    y: n,
                                    z: t
                                })
                            }
                            for (let c = 0; c < _r / 2; c++) {
                                const n = c * (2 * (t + r) / (_r / 2)) - (t + r),
                                    i = e - e / (t + r) * Math.abs(n);
                                n <= 0 ? m(i, n) : m(0, 0)
                            }
                            for (let c = 0; c < _r / 2; c++) {
                                const n = t + r - c * (2 * (t + r) / (_r / 2)),
                                    i = -e + e / (t + r) * Math.abs(n);
                                n <= 0 ? m(i, n) : m(0, 0)
                            }
                            const g = new Yd({
                                color: 255
                            });
                            f.forEach((e => {
                                const t = new Xy(.1 / c, 32, 32);
                                new zh(t, g).position.set(e.x, 0, e.z)
                            }));
                            const v = new Yd({
                                color: 16711680
                            });
                            for (let y = 0; y < _r; y++) {
                                const t = new Xy(.1 / c, 32, 32),
                                    r = new zh(t, v),
                                    o = (e - Math.abs(f[y].x)) / e,
                                    a = Math.min(.55 * o, 1),
                                    s = 1 - a;
                                let l, u, d;
                                0 === f[y].x && 0 === f[y].z ? (l = h[y].x, u = n, d = h[y].z) : (l = s * h[y].x + a * f[y].x, u = n, d = s * h[y].z + a * f[y].z), i.push(l, u, d), 0 == n && U.push({
                                    x: l,
                                    y: u,
                                    z: d
                                }), r.position.set(l, u, d)
                            }
                        }
                        let Or = [],
                            Br = [];
                        Ir(r, o, Sr, o - n, Or), Ir(t, n, Sr, 0, Or), Ir(h, m, Er, m - d, Or), Ir(l, d, Er, 0, Or);
                        const Lr = [];
                        for (let kr = 0; kr < _r; kr++) {
                            const Fr = (kr + 1) % _r,
                                Ur = kr,
                                zr = kr + _r;
                            Lr.push(Ur, Fr, zr), Lr.push(Fr + _r, zr, Fr), Lr.push(kr, kr + 2 * _r, Fr), Lr.push(Fr, kr + 2 * _r, Fr + 2 * _r), Lr.push(kr + 2 * _r, kr + 3 * _r, Fr + 2 * _r), Lr.push(Fr + 2 * _r, kr + 3 * _r, Fr + 3 * _r)
                        }
                        const Dr = .1 * wr;
                        for (let Hr = 0; Hr < Mr + 1; Hr++) {
                            const jr = Math.PI / Mr * Hr;
                            let Gr = Dr * Math.sin(jr);
                            const Vr = Hr / Mr;
                            E && (Gr = 0), Ir(t - Vr * (t - l) + Gr, n - Vr * (n - d) + Gr, Ar / 2 - Vr * Ar, 0, Br)
                        }
                        Or = Or.concat(Br);
                        for (let qr = 0; qr < _r; qr++)
                            for (let Wr = 0; Wr < Mr; Wr++) {
                                const Xr = 4 * _r + Wr * _r + qr,
                                    Kr = 4 * _r + Wr * _r + (qr + 1) % _r,
                                    Jr = Xr + _r,
                                    Yr = Kr + _r,
                                    Qr = Or.length / 3;
                                Xr >= Qr || Kr >= Qr || Jr >= Qr || Yr >= Qr ? console.error("Index out of bounds: current=".concat(Xr, ", next=").concat(Kr, ", below=").concat(Jr, ", belowNext=").concat(Yr)) : (Lr.push(Xr, Kr, Jr), Lr.push(Kr, Yr, Jr))
                            }
                        Cr.setAttribute("position", new ph(Or, 3)), Cr.setIndex(Lr), Cr.computeVertexNormals(), E && (F = -Math.PI / 2, Q());
                        const Nr = new zh(Cr, A);
                        Nr.position.set(0, 0, 0), S.add(Nr), E && (t += R / c, n += R / c, l += R / c, d += R / c);
                        y = (t * c + v + l * c + v) / 2 * ((n * c + v + d * c + v) / 2) + Math.PI * Math.pow((t * c + v + l * c + v) / 2, 2) / 2 - ((r * c + v + h * c + v) / 2 * ((o * c + v + m * c + v) / 2) + Math.PI * Math.pow((r * c + v + h * c + v) / 2, 2) / 2)
                    }
                    a(y * _)
                }), [u, E, h, y, d, b, s, i, c, A, t, n, v]), S.rotation.order = "YXZ", S.rotation.set(0, 0, 0), S.position.set(0, C, 0), (0, r.useEffect)((() => {
                    o([{
                        quantity: T.current,
                        size: .8 * b,
                        shape: "Round",
                        style: "Petite French Pave"
                    }])
                }), [b, T, h, E]), (0, Nn.jsx)("primitive", {
                    object: S,
                    scale: [1, 1, 1]
                })
            },
            eR = e => {
                let {
                    index: t,
                    headCount: n,
                    extraMetal: i,
                    diamondsVisibility: o,
                    headOrientation: a,
                    headRotations: s,
                    scaleReducer: l,
                    scaleReducerVector: c,
                    diamondWidth: u,
                    diamondLength: d,
                    diamondPavHeight: h,
                    diamondGirdleThickness: p,
                    diamondCrownHeight: f,
                    diamondCaratWeight: m,
                    caratWeightMultiplier: g,
                    diamondType: v,
                    prongCount: y,
                    prongOrientation: b,
                    prongArmCalculations: x,
                    prongArmType: _,
                    prongTipType: M,
                    prongWidth: w,
                    hasProngPave: A,
                    basketHalo: S,
                    haloThicknessRatio: E,
                    basketThicknessRatio: C,
                    prongMetalColor: T,
                    cathedral: P,
                    bandInnerRadius: R,
                    bandWidth: I,
                    bandPaveStyle: O,
                    setLeftHeadVolume: B,
                    setCenterHeadVolume: L,
                    setRightHeadVolume: D,
                    setLeftHeadProngPave: N,
                    setLeftHeadHaloBasketPave: k,
                    setCenterHeadProngPave: F,
                    setCenterHeadHaloBasketPave: U,
                    setRightHeadProngPave: z,
                    setRightHeadHaloBasketPave: H,
                    onLoadComplete: j,
                    numberOfElements: G
                } = e;
                const V = x.diamondPositionY,
                    q = S && "Classic" === S.name ? x.diamondPositionY + w / l * .15 : x.diamondPositionY,
                    W = s[t],
                    [X, K] = (0, r.useState)(0),
                    [J, Y] = (0, r.useState)(0),
                    Q = 0 === t ? N : 1 === t ? F : z,
                    Z = 0 === t ? k : 1 === t ? U : H,
                    $ = i && G > 1 ? 5 / l : 0;
                return (0, r.useEffect)((() => {
                    0 === t ? B(X + J) : 1 === t ? L(X + J) : 2 === t && D(X + J)
                }), [J, t, X, L, B, D]), (0, r.useEffect)((() => {
                    S || Y(0), !S || "Metal" !== S.name && "Pave" !== S.name || Z([])
                }), [S]), (0, Nn.jsxs)("group", {
                    rotation: [0, a, W, "XZY"],
                    position: [0, $, 0],
                    children: [(0, Nn.jsx)(NP, {
                        diamondsVisibility: o,
                        caratWeight: m,
                        scaleReducer: l,
                        caratWeightMultiplier: g,
                        type: v,
                        positionY: q,
                        onLoadComplete: j
                    }), (0, Nn.jsx)(VP, {
                        type: v,
                        headCount: n,
                        setProngsVolume: K,
                        setProngsPave: Q,
                        diamondsVisibility: o,
                        extraMetal: i,
                        basketHalo: S,
                        scaleReducerVector: c,
                        scaleReducer: l,
                        hasProngPave: A,
                        prongArmType: _,
                        prongTipType: M,
                        prongCount: y,
                        prongArmCalculations: x,
                        prongWidth: w,
                        prongMetalColor: T,
                        cathedral: P,
                        caratWeight: m,
                        bandInnerRadius: R,
                        bandWidth: I,
                        bandPaveStyle: O,
                        headOrientation: a
                    }), S && "Classic" === S.name && (0, Nn.jsx)(QP, {
                        prongCount: y,
                        setHaloBasketVolume: Y,
                        setHaloBasketPave: Z,
                        prongWidth: w,
                        prongOrientation: b,
                        extraMetal: i,
                        diamondsVisibility: o,
                        scaleReducerVector: c,
                        scaleReducer: l,
                        type: v,
                        prongTipType: M,
                        basketHalo: S,
                        caratWeight: m,
                        diamondWidth: u,
                        diamondLength: d,
                        diamondPavHeight: h,
                        diamondGirdleThickness: p,
                        diamondCrownHeight: f,
                        diamondPositionY: V,
                        haloThicknessRatio: E,
                        prongArmCalculations: x,
                        prongMetalColor: T
                    }), S && "Bezel" === S.name && (0, Nn.jsx)(ZP, {
                        setHaloBasketVolume: Y,
                        setHaloBasketPave: Z,
                        prongWidth: w,
                        prongOrientation: b,
                        extraMetal: i,
                        diamondsVisibility: o,
                        scaleReducerVector: c,
                        scaleReducer: l,
                        type: v,
                        prongTipType: M,
                        basketHalo: S,
                        caratWeight: m,
                        diamondWidth: u,
                        diamondLength: d,
                        diamondPavHeight: h,
                        diamondGirdleThickness: p,
                        diamondCrownHeight: f,
                        diamondPositionY: V,
                        haloThicknessRatio: E,
                        prongArmCalculations: x,
                        prongMetalColor: T
                    }), S && ("Metal" === S.name || "Pave" === S.name || "Hidden" === S.name) && (0, Nn.jsx)($P, {
                        prongCount: y,
                        prongOrientation: b,
                        setHaloBasketVolume: Y,
                        setHaloBasketPave: Z,
                        extraMetal: i,
                        diamondsVisibility: o,
                        scaleReducerVector: c,
                        scaleReducer: l,
                        type: v,
                        basketHalo: S,
                        caratWeight: m,
                        diamondWidth: u,
                        diamondLength: d,
                        diamondPavHeight: h,
                        diamondGirdleThickness: p,
                        diamondPositionY: V,
                        haloThicknessRatio: E,
                        basketThicknessRatio: C,
                        prongArmCalculations: x,
                        prongMetalColor: T
                    })]
                })
            },
            tR = new WeakMap;
        class nR extends Lb {
            constructor(e) {
                super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
                    position: "POSITION",
                    normal: "NORMAL",
                    color: "COLOR",
                    uv: "TEX_COORD"
                }, this.defaultAttributeTypes = {
                    position: "Float32Array",
                    normal: "Float32Array",
                    color: "Float32Array",
                    uv: "Float32Array"
                }
            }
            setDecoderPath(e) {
                return this.decoderPath = e, this
            }
            setDecoderConfig(e) {
                return this.decoderConfig = e, this
            }
            setWorkerLimit(e) {
                return this.workerLimit = e, this
            }
            load(e, t, n, r) {
                const i = new kb(this.manager);
                i.setPath(this.path), i.setResponseType("arraybuffer"), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(e, (e => {
                    this.parse(e, t, r)
                }), n, r)
            }
            parse(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : () => {};
                this.decodeDracoFile(e, t, null, null, Vl).catch(n)
            }
            decodeDracoFile(e, t, n, r) {
                let i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : ql,
                    o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : () => {};
                const a = {
                    attributeIDs: n || this.defaultAttributeIDs,
                    attributeTypes: r || this.defaultAttributeTypes,
                    useUniqueIDs: !!n,
                    vertexColorSpace: i
                };
                return this.decodeGeometry(e, a).then(t).catch(o)
            }
            decodeGeometry(e, t) {
                const n = JSON.stringify(t);
                if (tR.has(e)) {
                    const t = tR.get(e);
                    if (t.key === n) return t.promise;
                    if (0 === e.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                }
                let r;
                const i = this.workerNextTaskID++,
                    o = e.byteLength,
                    a = this._getWorker(i, o).then((n => (r = n, new Promise(((n, o) => {
                        r._callbacks[i] = {
                            resolve: n,
                            reject: o
                        }, r.postMessage({
                            type: "decode",
                            id: i,
                            taskConfig: t,
                            buffer: e
                        }, [e])
                    }))))).then((e => this._createGeometry(e.geometry)));
                return a.catch((() => !0)).then((() => {
                    r && i && this._releaseTask(r, i)
                })), tR.set(e, {
                    key: n,
                    promise: a
                }), a
            }
            _createGeometry(e) {
                const t = new Mh;
                e.index && t.setIndex(new ih(e.index.array, 1));
                for (let n = 0; n < e.attributes.length; n++) {
                    const r = e.attributes[n],
                        i = r.name,
                        o = r.array,
                        a = r.itemSize,
                        s = new ih(o, a);
                    "color" === i && (this._assignVertexColorSpace(s, r.vertexColorSpace), s.normalized = o instanceof Float32Array === !1), t.setAttribute(i, s)
                }
                return t
            }
            _assignVertexColorSpace(e, t) {
                if (t !== Vl) return;
                const n = new Wd;
                for (let r = 0, i = e.count; r < i; r++) n.fromBufferAttribute(e, r).convertSRGBToLinear(), e.setXYZ(r, n.r, n.g, n.b)
            }
            _loadLibrary(e, t) {
                const n = new kb(this.manager);
                return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise(((t, r) => {
                    n.load(e, t, void 0, r)
                }))
            }
            preload() {
                return this._initDecoder(), this
            }
            _initDecoder() {
                if (this.decoderPending) return this.decoderPending;
                const e = "object" !== typeof WebAssembly || "js" === this.decoderConfig.type,
                    t = [];
                return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((t => {
                    const n = t[0];
                    e || (this.decoderConfig.wasmBinary = t[1]);
                    const r = rR.toString(),
                        i = ["/* draco decoder */", n, "", "/* worker */", r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))].join("\n");
                    this.workerSourceURL = URL.createObjectURL(new Blob([i]))
                })), this.decoderPending
            }
            _getWorker(e, t) {
                return this._initDecoder().then((() => {
                    if (this.workerPool.length < this.workerLimit) {
                        const e = new Worker(this.workerSourceURL);
                        e._callbacks = {}, e._taskCosts = {}, e._taskLoad = 0, e.postMessage({
                            type: "init",
                            decoderConfig: this.decoderConfig
                        }), e.onmessage = function(t) {
                            const n = t.data;
                            switch (n.type) {
                                case "decode":
                                    e._callbacks[n.id].resolve(n);
                                    break;
                                case "error":
                                    e._callbacks[n.id].reject(n);
                                    break;
                                default:
                                    console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"')
                            }
                        }, this.workerPool.push(e)
                    } else this.workerPool.sort((function(e, t) {
                        return e._taskLoad > t._taskLoad ? -1 : 1
                    }));
                    const n = this.workerPool[this.workerPool.length - 1];
                    return n._taskCosts[e] = t, n._taskLoad += t, n
                }))
            }
            _releaseTask(e, t) {
                e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t]
            }
            debug() {
                console.log("Task load: ", this.workerPool.map((e => e._taskLoad)))
            }
            dispose() {
                for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
                return this.workerPool.length = 0, "" !== this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), this
            }
        }

        function rR() {
            let e, t;

            function n(e, t, n, r, i, o) {
                const a = o.num_components(),
                    s = n.num_points() * a,
                    l = s * i.BYTES_PER_ELEMENT,
                    c = function(e, t) {
                        switch (t) {
                            case Float32Array:
                                return e.DT_FLOAT32;
                            case Int8Array:
                                return e.DT_INT8;
                            case Int16Array:
                                return e.DT_INT16;
                            case Int32Array:
                                return e.DT_INT32;
                            case Uint8Array:
                                return e.DT_UINT8;
                            case Uint16Array:
                                return e.DT_UINT16;
                            case Uint32Array:
                                return e.DT_UINT32
                        }
                    }(e, i),
                    u = e._malloc(l);
                t.GetAttributeDataArrayForAllPoints(n, o, c, l, u);
                const d = new i(e.HEAPF32.buffer, u, s).slice();
                return e._free(u), {
                    name: r,
                    array: d,
                    itemSize: a
                }
            }
            onmessage = function(r) {
                const i = r.data;
                switch (i.type) {
                    case "init":
                        e = i.decoderConfig, t = new Promise((function(t) {
                            e.onModuleLoaded = function(e) {
                                t({
                                    draco: e
                                })
                            }, DracoDecoderModule(e)
                        }));
                        break;
                    case "decode":
                        const r = i.buffer,
                            o = i.taskConfig;
                        t.then((e => {
                            const t = e.draco,
                                a = new t.Decoder;
                            try {
                                const e = function(e, t, r, i) {
                                        const o = i.attributeIDs,
                                            a = i.attributeTypes;
                                        let s, l;
                                        const c = t.GetEncodedGeometryType(r);
                                        if (c === e.TRIANGULAR_MESH) s = new e.Mesh, l = t.DecodeArrayToMesh(r, r.byteLength, s);
                                        else {
                                            if (c !== e.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                            s = new e.PointCloud, l = t.DecodeArrayToPointCloud(r, r.byteLength, s)
                                        }
                                        if (!l.ok() || 0 === s.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
                                        const u = {
                                            index: null,
                                            attributes: []
                                        };
                                        for (const d in o) {
                                            const r = self[a[d]];
                                            let l, c;
                                            if (i.useUniqueIDs) c = o[d], l = t.GetAttributeByUniqueId(s, c);
                                            else {
                                                if (c = t.GetAttributeId(s, e[o[d]]), -1 === c) continue;
                                                l = t.GetAttribute(s, c)
                                            }
                                            const h = n(e, t, s, d, r, l);
                                            "color" === d && (h.vertexColorSpace = i.vertexColorSpace), u.attributes.push(h)
                                        }
                                        c === e.TRIANGULAR_MESH && (u.index = function(e, t, n) {
                                            const r = n.num_faces(),
                                                i = 3 * r,
                                                o = 4 * i,
                                                a = e._malloc(o);
                                            t.GetTrianglesUInt32Array(n, o, a);
                                            const s = new Uint32Array(e.HEAPF32.buffer, a, i).slice();
                                            return e._free(a), {
                                                array: s,
                                                itemSize: 1
                                            }
                                        }(e, t, s));
                                        return e.destroy(s), u
                                    }(t, a, new Int8Array(r), o),
                                    s = e.attributes.map((e => e.array.buffer));
                                e.index && s.push(e.index.array.buffer), self.postMessage({
                                    type: "decode",
                                    id: i.id,
                                    geometry: e
                                }, s)
                            } catch (s) {
                                console.error(s), self.postMessage({
                                    type: "error",
                                    id: i.id,
                                    error: s.message
                                })
                            } finally {
                                t.destroy(a)
                            }
                        }))
                }
            }
        }
        const iR = e => {
                let {
                    index: t,
                    headCount: n,
                    diamondsVisibility: i,
                    metalColor: o,
                    surpriseStonePosition: a,
                    scaleReducerVector: s,
                    headRotations: l
                } = e;
                const {
                    gl: c,
                    scene: u
                } = KM(), d = (0, r.useMemo)((() => new rb({
                    color: o,
                    metalness: 1,
                    roughness: .05,
                    wireframe: !1
                })), [o]), [h, p] = (0, r.useState)(null), [f, m] = (0, r.useState)(null), g = l[t], v = Bo((e => e.setSurpriseStones)), y = new nR;
                y.setDecoderPath("https://www.gstatic.com/draco/v1/decoders/"), y.setDecoderConfig({
                    type: "wasm"
                });
                const b = ZM(yC, "./test/SurpriseStone.glb", (e => {
                    e.setDRACOLoader(y)
                }));
                let x;
                return u.traverse((e => {
                    e.isMesh && "onecround" === e.name && (x = e.material)
                })), (0, r.useEffect)((() => {
                    v({
                        quantity: 1 === n || 2 === n ? 2 * n : 2,
                        size: 1.5,
                        shape: "Round"
                    });
                    const e = b.scene.clone(!0),
                        t = b.scene.clone(!0);
                    if (p(e), m(t), e.getObjectByName("SurpriseStoneMetal").material = d, t.getObjectByName("SurpriseStoneMetal").material = d, i && x) e.getObjectByName("DiamondMesh").material = x, t.getObjectByName("DiamondMesh").material = x;
                    else {
                        let n = e.getObjectByName("DiamondMesh"),
                            r = t.getObjectByName("DiamondMesh");
                        n.parent.remove(n), r.parent.remove(r)
                    }
                }), [o, u, d, i, x]), (0, Nn.jsxs)("group", {
                    rotation: [0, 0, g],
                    children: [h && (0, Nn.jsx)("primitive", {
                        object: h,
                        position: [a.x, a.y, -a.z],
                        rotation: [0, Math.PI, 0],
                        scale: s
                    }), f && (0, Nn.jsx)("primitive", {
                        object: f,
                        position: [a.x, a.y, a.z],
                        scale: s
                    })]
                })
            },
            oR = (e, t, n, r) => {
                const i = .5749 / .9 * t;
                let o = 1.8;
                "None" !== n && (o = .36000000000000004 + Math.max(.8 * 1.8, i));
                return {
                    x: 0,
                    y: (e + o - o + 1.1) / r,
                    z: (Math.max(.5 * t, .9) - .5) / r
                }
            },
            aR = (e, t, n, r) => {
                let i;
                if ("Round" == e) i = {
                    "4 Classic": [45, 135, 225, 315],
                    "4 Compass": [0, 90, 180, 270],
                    "6 Prong": [0, 60, 120, 180, 240, 300]
                };
                else if ("Cushion" == e) {
                    let e = .211 * r * .5,
                        t = Math.atan((r - 2 * e) / (n - 2 * e)) * (180 / Math.PI);
                    i = {
                        "4 Classic": [t, 180 - t, 180 + t, 360 - t],
                        "4 Compass": [0, 90, 180, 270]
                    }
                } else if ("Oval" == e) {
                    let e = Math.atan(r / n) * (180 / Math.PI);
                    i = {
                        "4 Classic": [e, 180 - e, 180 + e, 360 - e],
                        "4 Compass": [0, 90, 180, 270],
                        "6 Prong": [0, 60, 120, 180, 240, 300]
                    }
                } else if ("Princess" == e) {
                    let e = Math.atan(r / n) * (180 / Math.PI);
                    i = {
                        "4 Classic": [e, 180 - e, 180 + e, 360 - e]
                    }
                } else if ("Emerald" == e) {
                    let e = .202 * r * .5,
                        t = Math.atan((r - 2 * e) / (n - 2 * e)) * (180 / Math.PI);
                    i = {
                        "4 Classic": [t, 180 - t, 180 + t, 360 - t],
                        "4 Compass": [0, 90, 180, 270]
                    }
                } else if ("Pear" == e) {
                    Math.atan(.39856 * r / (.38521 * n)), Math.PI;
                    let e = Math.atan(.44515 * r / (2 * (n - r / 2) * .20304)) * (180 / Math.PI);
                    i = {
                        "3 Prong": [0, 135, 225],
                        "5 Prong": [0, 90 - e, 135, 225, 270 + e]
                    }
                } else if ("Radiant" == e) {
                    let e = .176 * r * .5,
                        t = Math.atan((r - 2 * e) / (n - 2 * e)) * (180 / Math.PI);
                    i = {
                        "4 Classic": [t, 180 - t, 180 + t, 360 - t],
                        "4 Compass": [0, 90, 180, 270]
                    }
                } else if ("Asscher" == e) {
                    let e = .183 * r * .5,
                        t = Math.atan((r - 2 * e) / (n - 2 * e)) * (180 / Math.PI);
                    i = {
                        "4 Classic": [t, 180 - t, 180 + t, 360 - t],
                        "4 Compass": [0, 90, 180, 270]
                    }
                } else if ("Marquise" == e) {
                    let e = Math.atan(.44515 * r / (.18304 * n)) * (180 / Math.PI);
                    i = {
                        "6 Prong": [0, e, 180 - e, 180, 180 + e, 360 - e]
                    }
                } else if ("Heart" == e) {
                    let e = Math.atan(.40312 * r / (.27134 * n)) * (180 / Math.PI),
                        t = Math.atan(.33215 * r / (.35981 * n)) * (180 / Math.PI);
                    i = {
                        "3 Prong": [e, 180, 360 - e],
                        "5 Prong": [90 - e, 90 + t, 180, 270 - t, 270 + e]
                    }
                }
                let o = i[t];
                return o.forEach((function(e, t) {
                    o[t] = e * (Math.PI / 180)
                })), o
            },
            sR = (e, t, n, r, i, o, a) => {
                const s = o.pavHeight - a + t,
                    l = ((e, t, n, r, i, o) => {
                        const a = o + r,
                            s = (n - 2) / (2 * n) * e,
                            l = Math.pow(i / 2, 2) + Math.pow(a, 2),
                            c = i * (s - e / 2),
                            u = Math.pow(s - e / 2, 2) - Math.pow(a, 2),
                            d = (-c + Math.sqrt(Math.pow(c, 2) - 4 * l * u)) / (2 * l),
                            h = (-c - Math.sqrt(Math.pow(c, 2) - 4 * l * u)) / (2 * l);
                        let p = 1;
                        return p = d > 0 ? d : h, Math.acos(p)
                    })(i, 0, r, t, 2 * e, o.pavHeight - a),
                    c = (r - 2) * i / (2 * r * Math.cos(l)),
                    u = i / 2 / Math.sin(l),
                    d = e + c,
                    h = s + u,
                    p = c * Math.sin(l),
                    f = ((e, t, n) => Math.sqrt(Math.pow(e, 2) + Math.pow(t, 2)) - n)(d, h, p);
                return {
                    angleOfApproach: l,
                    cSide: f,
                    b_Side: u
                }
            },
            lR = (e, t, n) => {
                let r, i;
                return r = Math.min(Math.floor(10 * (.8 + t / 10)) / 10, 1.3), i = 1.125 * r * (1 / .9), i
            },
            cR = (e, t, n, r, i, o, a, s, l, c, u, d, h, p, f, m) => {
                const g = lR(0, n),
                    v = (Math.PI, .5749 / .9 * p);
                let y = 1.8;
                "None" !== f && (y = .36000000000000004 + Math.max(.8 * 1.8, v));
                const b = h + y,
                    x = .45 * g,
                    _ = ((e, t, n) => {
                        function r(e) {
                            for (var t, n = 0, r = 0; r < e.length; r++) null != e[r] && e[r] > n && (t = r, n = e[r]);
                            return t
                        }
                        let i = 0;
                        return "Level Set" == t ? i = n == e[r(e)] ? 0 : e[r(e)] - n : "Tiered" == t && (i = 0), i
                    })(l, c, s.pavHeight);
                let M = 0;
                u && "Classic" === u.name && "None" !== m && (M = .4);
                const w = .5 + _ + M;
                let A = 0,
                    S = 0,
                    E = 0;
                const C = .715 * g;
                let T = g / 6.6;
                if (u && "Classic" === u.name) {
                    A = (.8 - .005) * d;
                    S = 1.1834 * d - s.girdleThickness, E = T + (A - C) / 2
                } else if (u && "Bezel" === u.name) {
                    E = T + (g / 2 * .9 - 1.1 * g * .9 + .04), S = 1.3 * g * .9 - .2 - s.girdleThickness - .1
                }
                let P, R = [],
                    I = [],
                    O = [],
                    B = ((e, t, n, r, i) => {
                        let o;
                        if ("Round" == e) o = {
                            "4 Classic": [i / 2, i / 2, i / 2, i / 2],
                            "4 Compass": [i / 2, i / 2, i / 2, i / 2],
                            "6 Prong": [i / 2, i / 2, i / 2, i / 2, i / 2, i / 2]
                        };
                        else if ("Cushion" == e) {
                            let e = .211 * i * .5,
                                t = Math.sqrt(Math.pow(i / 2 - e, 2) + Math.pow(r / 2 - e, 2));
                            o = {
                                "4 Classic": [t, t, t, t],
                                "4 Compass": [r / 2, i / 2, r / 2, i / 2]
                            }
                        } else if ("Oval" == e) {
                            let a = r / 2,
                                s = i / 2,
                                l = aR(e, t, r, i),
                                c = [];
                            for (let e = 0; e < n; e++) {
                                let t = l[e],
                                    n = a * s / Math.sqrt((s * Math.cos(t)) ** 2 + (a * Math.sin(t)) ** 2);
                                c.push(n)
                            }
                            o = {
                                "4 Classic": c,
                                "4 Compass": c,
                                "6 Prong": c
                            }
                        } else if ("Princess" == e) {
                            let e = Math.sqrt(Math.pow(i / 2, 2) + Math.pow(r / 2, 2));
                            o = {
                                "4 Classic": [e, e, e, e]
                            }
                        } else if ("Emerald" == e) {
                            let e = .2026 * i * .5,
                                t = Math.sqrt(Math.pow(i / 2 - e, 2) + Math.pow(r / 2 - e, 2));
                            o = {
                                "4 Classic": [t, t, t, t],
                                "4 Compass": [r / 2, i / 2, r / 2, i / 2]
                            }
                        } else if ("Pear" == e) {
                            Math.sqrt(Math.pow(.39856 * i, 2) + Math.pow(.38521 * r, 2));
                            let e = Math.sqrt(Math.pow(.44515 * i, 2) + Math.pow(2 * (r - i / 2) * .20304, 2));
                            o = {
                                "3 Prong": [r - i / 2, i / 2, i / 2],
                                "5 Prong": [r - i / 2, e, i / 2, i / 2, e]
                            }
                        } else if ("Radiant" == e) {
                            let e = .15308 * i * .5,
                                t = Math.sqrt(Math.pow(i / 2 - e, 2) + Math.pow(r / 2 - e, 2));
                            o = {
                                "4 Classic": [t, t, t, t],
                                "4 Compass": [r / 2, i / 2, r / 2, i / 2]
                            }
                        } else if ("Asscher" == e) {
                            let e = .15018 * i * .5,
                                t = Math.sqrt(Math.pow(i / 2 - e, 2) + Math.pow(r / 2 - e, 2));
                            o = {
                                "4 Classic": [t, t, t, t],
                                "4 Compass": [r / 2, i / 2, r / 2, i / 2]
                            }
                        } else if ("Marquise" == e) {
                            let e = Math.sqrt(Math.pow(.44515 * i, 2) + Math.pow(.18304 * r, 2));
                            o = {
                                "6 Prong": [r / 2, e, e, r / 2, e, e]
                            }
                        } else if ("Heart" == e) {
                            let e = Math.sqrt(Math.pow(.40312 * i, 2) + Math.pow(.27134 * r, 2)),
                                t = Math.sqrt(Math.pow(.33215 * i, 2) + Math.pow(.35981 * r, 2)),
                                n = .6661 * r;
                            o = {
                                "3 Prong": [e, n, e],
                                "5 Prong": [e, t, n, t, e]
                            }
                        }
                        return o[t]
                    })(t, i, o, s.length, s.width);
                for (let L = 0; L < o; L++) P = sR(B[L] + E, w, 0, 6.6, g, s, S), R.push(P.angleOfApproach), I.push(P.cSide), O.push(P.b_Side);
                return {
                    prongArmLength: I,
                    prongOrientation: aR(t, i, s.length, s.width),
                    prongAngleOfApproach: R,
                    prongArmASide: B,
                    prongWidth: g,
                    diamondPositionY: (b - x + w + Math.max(...O)) / e,
                    clearance: w / e
                }
            },
            uR = (e, t, n, r) => {
                let i;
                return 1 == t && ("Classic" == r ? i = 0 : "East-West" == r ? i = 90 : "Kite" == r && (i = 45)), 2 == t && ("Pear" == n || "Oval" == n ? "Classic" == r ? i = 0 : "Tilted" == r && (i = 22) : "Heart" == n ? "Classic" == r ? i = 0 : "Tilted" == r && (i = -30) : i = 0, 0 == e && (i = -i)), 3 == t && ("Classic" == r ? i = 0 : "East-West" == r && (i = 90, "Heart" == n && (i = -i)), 2 == e && (i = -i), 1 == e && (i = 0)), i * (Math.PI / 180)
            },
            dR = (e, t, n, r, i, o) => {
                const a = {
                    Classic: {
                        Round: 0,
                        Oval: 0,
                        Princess: .7,
                        Emerald: .15,
                        Cushion: .1,
                        Radiant: .225,
                        Pear: 0,
                        Marquise: .425,
                        Asscher: .215
                    },
                    Tilted: {
                        Oval: .5,
                        Pear: 0
                    },
                    "East-West": {
                        Oval: 0,
                        Emerald: .15,
                        Cushion: .1,
                        Radiant: .225,
                        Pear: 0,
                        Marquise: .95
                    }
                };
                if (1 == n) return 0;
                if (2 == n) {
                    const n = !1,
                        o = 0,
                        s = .03,
                        l = .8,
                        c = 1.1621;
                    let u = c * r.haloThicknessRatio,
                        d = c * i.haloThicknessRatio,
                        h = 0,
                        p = 0,
                        f = 0,
                        m = 0,
                        g = 0,
                        v = 0;
                    r.basketHalo && "Classic" === r.basketHalo.name ? (f = (l - .005) * r.haloThicknessRatio, h = u - r.diamondGirdleThickness) : r.basketHalo && "Hidden" === r.basketHalo.name ? h = .4 * (.5 + r.diamondPavHeight) : g = r.prongWidth * a[r.orientation][r.diamondName], i.basketHalo && "Classic" === i.basketHalo.name ? (m = (l - .005) * i.haloThicknessRatio, p = d - i.diamondGirdleThickness) : i.basketHalo && "Hidden" === i.basketHalo.name ? p = .4 * (.5 + i.diamondPavHeight) : v = i.prongWidth * a[i.orientation][i.diamondName];
                    let y = r.diamondPositionY - h / t + r.diamondPavHeight / t,
                        b = r.diamondWidth / 2 + f + g + s,
                        x = i.diamondPositionY - p / t + i.diamondPavHeight / t,
                        _ = i.diamondWidth / 2 + m + v + s;
                    if ("Tilted" == r.orientation) {
                        Math.PI;
                        const e = .75,
                            t = 1 - e;
                        b = r.diamondWidth / 2 * e + r.diamondLength / 2 * t + f + g + s
                    }
                    if ("Tilted" == i.orientation) {
                        Math.PI;
                        const e = .75,
                            t = 1 - e;
                        _ = i.diamondWidth / 2 * e + i.diamondLength / 2 * t + m + v + s
                    }
                    n && (b += o, _ += o);
                    let M = (Math.atan(b / t / y) + Math.atan(_ / t / x)) / 2;
                    if (0 == e) return M;
                    if (2 == e) return -M
                }
                if (3 == n) {
                    const n = .1,
                        i = .8,
                        s = 1.1621;
                    let l = s * r.haloThicknessRatio,
                        c = s * o.haloThicknessRatio,
                        u = 0,
                        d = 0,
                        h = 0,
                        p = 0,
                        f = 0,
                        m = 0;
                    r.basketHalo && "Classic" === r.basketHalo.name ? (h = (i - .005) * r.haloThicknessRatio, u = l - r.diamondGirdleThickness) : r.basketHalo && "Hidden" === r.basketHalo.name ? u = .4 * (.5 + r.diamondPavHeight) : f = r.prongWidth * a[r.orientation][r.diamondName], o.basketHalo && "Classic" === o.basketHalo.name ? (p = (i - .005) * o.haloThicknessRatio, d = c - o.diamondGirdleThickness) : o.basketHalo && "Hidden" === o.basketHalo.name ? d = .4 * (.5 + o.diamondPavHeight) : (m = o.prongWidth * a[o.orientation][o.diamondName], "Marquise" == r.diamondName && "East-West" == r.orientation && (m = 0));
                    let g = r.diamondPositionY - u / t + r.diamondPavHeight / t,
                        v = r.diamondWidth / 2 + h + f + n,
                        y = o.diamondPositionY - d / t + o.diamondPavHeight / t,
                        b = o.diamondWidth / 2 + p + m + n;
                    "East-West" == r.orientation && (v = r.diamondLength / 2 + h + f + n, "Pear" == r.diamondName && (v = r.diamondWidth / 2 + h + f + n));
                    let x = Math.atan(v / t / g) + Math.atan(b / t / y);
                    if (0 == e) return x;
                    if (2 == e) return -x;
                    if (1 == e) return 0
                }
            },
            hR = () => {
                const {
                    nodes: e,
                    scene: t
                } = wP("./test/halo/princessHaloCornerV5.glb");
                let n = ZM(Fw, "diamond (1).hdr");
                const i = (0, r.useRef)(),
                    [o, a] = (0, r.useState)(0),
                    s = t.children[0].children[1].geometry;
                (0, r.useEffect)((() => {
                    i.current.name = "diamondmeshcorner"
                }), [s]);
                const l = {
                    bounces: 3,
                    aberrationStrength: .01,
                    ior: 2.75,
                    fresnel: 1,
                    color: "white",
                    fastChroma: !0
                };
                return (0, Nn.jsx)(AP, {
                    resolution: 1024,
                    envMap: n,
                    children: e => (0, Nn.jsx)("mesh", {
                        ref: i,
                        geometry: s,
                        scale: [.01, .01, .01],
                        position: [0, 0, 0],
                        children: (0, Nn.jsx)(LP, {
                            envMap: e,
                            ...l
                        })
                    }, o)
                })
            },
            pR = () => {
                const {
                    nodes: e,
                    scene: t
                } = wP("./test/halo/AsscherCorner.glb");
                let n = ZM(Fw, "diamond (1).hdr");
                const i = (0, r.useRef)(),
                    [o, a] = (0, r.useState)(0),
                    s = t.children[0].children[2].geometry;
                (0, r.useEffect)((() => {
                    i.current.name = "asschermeshcorner"
                }), [s]);
                const l = {
                    bounces: 3,
                    aberrationStrength: .01,
                    ior: 2.75,
                    fresnel: 1,
                    color: "white",
                    fastChroma: !0
                };
                return (0, Nn.jsx)(AP, {
                    resolution: 1024,
                    envMap: n,
                    children: e => (0, Nn.jsx)("mesh", {
                        ref: i,
                        geometry: s,
                        scale: [.01, .01, .01],
                        position: [10, 10, 10],
                        children: (0, Nn.jsx)(LP, {
                            envMap: e,
                            ...l
                        })
                    }, o)
                })
            },
            fR = () => {
                const {
                    nodes: e,
                    scene: t
                } = wP("https://stonealgo-configurator.s3.amazonaws.com/glb/surprisestone.glb");
                let n = ZM(Fw, "diamond (1).hdr");
                const i = (0, r.useRef)(),
                    [o, a] = (0, r.useState)(0),
                    s = t.children[0].children[1].geometry;
                (0, r.useEffect)((() => {
                    i.current.name = "onecround"
                }), [s]);
                const l = {
                    bounces: 3,
                    aberrationStrength: .01,
                    ior: 2.75,
                    fresnel: 1,
                    color: "white",
                    fastChroma: !0
                };
                return (0, Nn.jsx)(AP, {
                    resolution: 1024,
                    envMap: n,
                    children: e => (0, Nn.jsx)("mesh", {
                        ref: i,
                        geometry: s,
                        scale: [.01, .01, .01],
                        position: [5, 5, -5],
                        children: (0, Nn.jsx)(LP, {
                            envMap: e,
                            ...l
                        })
                    }, o)
                })
            },
            mR = () => {
                const {
                    nodes: e,
                    scene: t
                } = wP("https://dealsondiamonds.com/3d-ring-builder/test/band/Band0.22.glb");
                let n = ZM(Fw, "diamond (1).hdr");
                const i = (0, r.useRef)(),
                    [o, a] = (0, r.useState)(0),
                    s = t.children[0].children[1].geometry;
                (0, r.useEffect)((() => {
                    i.current.name = "Band"
                }), [s]);
                const l = {
                    bounces: 3.5,
                    aberrationStrength: .01,
                    ior: 2.75,
                    fresnel: 1,
                    color: "white",
                    fastChroma: !0
                };
                return (0, Nn.jsx)(AP, {
                    resolution: 1024,
                    envMap: n,
                    children: e => (0, Nn.jsx)("mesh", {
                        ref: i,
                        geometry: s,
                        scale: [.01, .01, .01],
                        position: [5, 11, -5],
                        children: (0, Nn.jsx)(LP, {
                            envMap: e,
                            ...l
                        })
                    }, o)
                })
            };

        function gR() {
            return (0, Nn.jsxs)(r.Suspense, {
                fallback: null,
                children: [(0, Nn.jsx)(hR, {}), (0, Nn.jsx)(pR, {}), (0, Nn.jsx)(fR, {}), (0, Nn.jsx)(mR, {})]
            })
        }
        class vR {
            parse(e) {
                let t = "",
                    n = 0,
                    r = 0,
                    i = 0;
                const o = new Pu,
                    a = new Wd,
                    s = new Pu,
                    l = new Yc,
                    c = [];
                return e.traverse((function(e) {
                    !0 === e.isMesh && function(e) {
                        let a = 0,
                            u = 0,
                            d = 0;
                        const h = e.geometry,
                            p = new Qc,
                            f = h.getAttribute("position"),
                            m = h.getAttribute("normal"),
                            g = h.getAttribute("uv"),
                            v = h.getIndex();
                        if (t += "o " + e.name + "\n", e.material && e.material.name && (t += "usemtl " + e.material.name + "\n"), void 0 !== f)
                            for (let n = 0, r = f.count; n < r; n++, a++) o.fromBufferAttribute(f, n), o.applyMatrix4(e.matrixWorld), t += "v " + o.x + " " + o.y + " " + o.z + "\n";
                        if (void 0 !== g)
                            for (let n = 0, r = g.count; n < r; n++, d++) l.fromBufferAttribute(g, n), t += "vt " + l.x + " " + l.y + "\n";
                        if (void 0 !== m) {
                            p.getNormalMatrix(e.matrixWorld);
                            for (let e = 0, n = m.count; e < n; e++, u++) s.fromBufferAttribute(m, e), s.applyMatrix3(p).normalize(), t += "vn " + s.x + " " + s.y + " " + s.z + "\n"
                        }
                        if (null !== v)
                            for (let o = 0, s = v.count; o < s; o += 3) {
                                for (let e = 0; e < 3; e++) {
                                    const t = v.getX(o + e) + 1;
                                    c[e] = n + t + (m || g ? "/" + (g ? r + t : "") + (m ? "/" + (i + t) : "") : "")
                                }
                                t += "f " + c.join(" ") + "\n"
                            } else
                                for (let o = 0, s = f.count; o < s; o += 3) {
                                    for (let e = 0; e < 3; e++) {
                                        const t = o + e + 1;
                                        c[e] = n + t + (m || g ? "/" + (g ? r + t : "") + (m ? "/" + (i + t) : "") : "")
                                    }
                                    t += "f " + c.join(" ") + "\n"
                                }
                        n += a, r += d, i += u
                    }(e), !0 === e.isLine && function(e) {
                        let r = 0;
                        const i = e.geometry,
                            a = e.type,
                            s = i.getAttribute("position");
                        if (t += "o " + e.name + "\n", void 0 !== s)
                            for (let n = 0, l = s.count; n < l; n++, r++) o.fromBufferAttribute(s, n), o.applyMatrix4(e.matrixWorld), t += "v " + o.x + " " + o.y + " " + o.z + "\n";
                        if ("Line" === a) {
                            t += "l ";
                            for (let e = 1, r = s.count; e <= r; e++) t += n + e + " ";
                            t += "\n"
                        }
                        if ("LineSegments" === a)
                            for (let o = 1, l = o + 1, c = s.count; o < c; o += 2, l = o + 1) t += "l " + (n + o) + " " + (n + l) + "\n";
                        n += r
                    }(e), !0 === e.isPoints && function(e) {
                        let r = 0;
                        const i = e.geometry,
                            s = i.getAttribute("position"),
                            l = i.getAttribute("color");
                        if (t += "o " + e.name + "\n", void 0 !== s) {
                            for (let n = 0, i = s.count; n < i; n++, r++) o.fromBufferAttribute(s, n), o.applyMatrix4(e.matrixWorld), t += "v " + o.x + " " + o.y + " " + o.z, void 0 !== l && (a.fromBufferAttribute(l, n).convertLinearToSRGB(), t += " " + a.r + " " + a.g + " " + a.b), t += "\n";
                            t += "p ";
                            for (let e = 1, r = s.count; e <= r; e++) t += n + e + " ";
                            t += "\n"
                        }
                        n += r
                    }(e)
                })), t
            }
        }
        const yR = (e, t) => {
                const n = new Blob([e], {
                        type: "text/plain"
                    }),
                    r = document.createElement("a");
                r.href = URL.createObjectURL(n), r.download = t, r.click()
            },
            bR = e => {
                const t = (new vR).parse(e),
                    n = Math.floor(99999 * Math.random()) + 1;
                yR(t, "Ring_".concat(n, ".obj"))
            };
        const xR = function(e, t, n, r) {
                return new Promise(((i, o) => {
                    e.setClearColor(0, 0), n.position.set(-1.75, 2.5, 4), setTimeout((async () => {
                        try {
                            e.render(t, n);
                            const a = document.createElement("canvas");
                            a.width = e.domElement.width, a.height = e.domElement.height;
                            a.getContext("2d").drawImage(e.domElement, 0, 0);
                            const s = function(e, t) {
                                for (var n = e.split(","), r = n[0].match(/:(.*?);/)[1], i = atob(n[1]), o = i.length, a = new Uint8Array(o); o--;) a[o] = i.charCodeAt(o);
                                return new File([a], t, {
                                    type: r
                                })
                            }(a.toDataURL("image/png"), function(e, t) {
                                return "default_".concat(e, ".").concat(t)
                            }(r, "png"));
                            let l = new FormData;
                            l.append("file", s);
                            const c = await async function(e) {
                                var t;
                                return await fetch("https://api.modularcx.link/stone-algo-backend/s3/upload-to-s3", {
                                    method: "POST",
                                    body: e
                                }).then((e => e.json())).then((e => {
                                    t = e
                                })).catch((e => {
                                    console.error("Error:", e)
                                })), t
                            }(l);
                            c && c.data[0] && c.data[0].Location ? i(c.data[0].Location) : (console.error("Unexpected response structure:", c), o(new Error("Unexpected response structure")))
                        } catch (a) {
                            console.error("Error in takeScreenshot:", a), o(a)
                        }
                    }), 100)
                }))
            },
            _R = e => {
                let {
                    exportManufacturingFile: t,
                    handleManufacturingOnEnd: n
                } = e;
                const i = Mn((e => e)),
                    o = yn((e => e)),
                    a = o.prongMetalColor,
                    s = o.band.bandMetalColor,
                    {
                        stoneElevation: l,
                        heads: c,
                        band: u
                    } = i,
                    d = (0, r.useRef)(),
                    h = (0, r.useRef)(null),
                    [p, f] = (0, r.useState)(10),
                    m = [1 / p, 1 / p, 1 / p],
                    [g, v] = (0, r.useState)(!0),
                    [y, b] = (0, r.useState)(!1),
                    x = (0, r.useRef)(),
                    _ = (0, r.useRef)(),
                    M = (0, r.useRef)(),
                    [w, A] = (0, r.useState)(null),
                    [S, E] = (0, r.useState)(null),
                    C = Bo((e => e.numberOfElements)),
                    T = Bo((e => e.headsVolume)),
                    P = Bo((e => e.prongPave)),
                    R = Bo((e => e.haloBasketPave)),
                    I = Bo((e => e.bandVolume)),
                    O = Bo((e => e.bandPave)),
                    B = Bo((e => e.bridgePave)),
                    L = Bo((e => e.surpriseStones)),
                    D = Bo((e => e.accentGems)),
                    N = Bo((e => e.laserEngraving)),
                    k = Bo((e => e.setNumberOfElements)),
                    F = Bo((e => e.diamondType)),
                    [U, z] = (0, r.useState)(0),
                    [H, j] = (0, r.useState)(0),
                    [G, V] = (0, r.useState)(0),
                    [q, W] = (0, r.useState)([]),
                    [X, K] = (0, r.useState)([]),
                    [J, Y] = (0, r.useState)([]),
                    [Q, Z] = (0, r.useState)([]),
                    [$, ee] = (0, r.useState)([]),
                    [te, ne] = (0, r.useState)([]),
                    re = Bo((e => e.setHeadsVolume)),
                    ie = Bo((e => e.setProngPave)),
                    oe = Bo((e => e.setHaloBasketPave)),
                    ae = Bo((e => e.setSurpriseStones)),
                    se = Bo((e => e.setDiamondType)),
                    [le, ce] = (0, r.useState)(0),
                    ue = () => {
                        ce((e => e + 1))
                    };
                (0, r.useEffect)((() => {}), [le, 1]);
                const de = async e => {
                    if (x.current && _.current && M.current) {
                        const n = x.current.getPixelRatio();
                        x.current.setPixelRatio(2);
                        try {
                            const t = await xR(x.current, _.current, M.current, e.detail.data.hashedKey);
                            mt(t), x.current.setPixelRatio(n);
                            const r = new CustomEvent("screenshotTaken", {
                                detail: {
                                    screenShoturl: t
                                }
                            });
                            window.dispatchEvent(r)
                        } catch (t) {
                            console.error("Error in handleScreenshot:", t)
                        }
                        M.current.position.set(-1.75, 2.5, 4)
                    } else console.error("One or more refs are not available")
                };
                (0, r.useEffect)((() => (window.addEventListener("handleScreenshot", de), () => {
                    window.removeEventListener("handleScreenshot", de)
                })), []);
                const he = Math.round(10 * (.8095 * u.ringSize + 11.6645)) / 10 / 2,
                    pe = [c[0] ? c[0].stone.dimensions.pavHeight : null, c[1] ? c[1].stone.dimensions.pavHeight : null, c[2] ? c[2].stone.dimensions.pavHeight : null],
                    fe = c.filter((function(e) {
                        return null != e
                    })).length;
                let me = 1 === fe || 3 === fe ? c[1].stone.name : null,
                    ge = ((1 === fe || 3 === fe) && c[1].stone.caratWeight, 1 === fe || 3 === fe ? c[1].stone.dimensions.width : null),
                    ve = 1 === fe || 3 === fe ? c[1].stone.dimensions.length : null,
                    ye = 1 === fe || 3 === fe ? c[1].stone.dimensions.depth : null,
                    be = 1 === fe || 3 === fe ? c[1].stone.dimensions.pavHeight : null,
                    xe = 1 === fe || 3 === fe ? c[1].stone.dimensions.girdleThickness : null,
                    _e = ((1 === fe || 3 === fe) && c[1].stone.dimensions.crownHeight, 1 === fe || 3 === fe ? cR(p, c[1].stone.name, c[1].stone.caratWeight, c[1].prongPave, c[1].prongCount.type, c[1].prongCount.value, c[1].prongArm.name, {
                        length: ve,
                        width: ge,
                        pavHeight: be,
                        girdleThickness: xe
                    }, pe, l, c[1].basketHalo, qP(c[1].stone.caratWeight), he, u.bandWidth, u.bandPaveStyle, u.bandCathedral).diamondPositionY : null),
                    Me = 1 === fe || 3 === fe ? cR(p, c[1].stone.name, c[1].stone.caratWeight, c[1].prongPave, c[1].prongCount.type, c[1].prongCount.value, c[1].prongArm.name, {
                        length: ve,
                        width: ge,
                        pavHeight: be,
                        girdleThickness: xe
                    }, pe, l, c[1].basketHalo, qP(c[1].stone.caratWeight), he, u.bandWidth, u.bandPaveStyle, u.bandCathedral) : null,
                    we = 1 === fe || 3 === fe ? c[1].basketHalo : null,
                    Ae = we ? "Pave" === we.name || "Hidden" === we.name : null,
                    Se = 1 === fe || 3 === fe ? qP(c[1].stone.caratWeight) : null,
                    Ee = .795 * Se,
                    Ce = 1 === fe || 3 === fe ? WP(c[1].stone.caratWeight) : null,
                    Te = 1 === fe || 3 === fe ? c[1].orientation : null,
                    Pe = 1 === fe || 3 === fe ? lR(c[1].prongArm.name, c[1].stone.caratWeight, c[1].prongPave) : null,
                    Re = we ? "Bezel" === we.name : null,
                    Ie = Pe / 2 * .9,
                    Oe = 1.1 * Pe * .9,
                    Be = 1.3 * Pe / p * .9,
                    Le = .2 / p,
                    De = 2 === fe || 3 === fe ? c[0].stone.name : null,
                    Ne = ((2 === fe || 3 === fe) && c[0].stone.caratWeight, 2 === fe || 3 === fe ? c[0].stone.dimensions.width : null),
                    ke = 2 === fe || 3 === fe ? c[0].stone.dimensions.length : null,
                    Fe = 2 === fe || 3 === fe ? c[0].stone.dimensions.pavHeight : null,
                    Ue = 2 === fe || 3 === fe ? c[0].stone.dimensions.girdleThickness : null,
                    ze = ((2 === fe || 3 === fe) && c[0].stone.dimensions.crownHeight, 2 === fe || 3 === fe ? cR(p, c[0].stone.name, c[0].stone.caratWeight, c[0].prongPave, c[0].prongCount.type, c[0].prongCount.value, c[0].prongArm.name, {
                        length: ke,
                        width: Ne,
                        pavHeight: Fe,
                        girdleThickness: Ue
                    }, pe, l, c[0].basketHalo, qP(c[0].stone.caratWeight), he, u.bandWidth, u.bandPaveStyle, u.bandCathedral).diamondPositionY : null),
                    He = 2 === fe || 3 === fe ? cR(p, c[0].stone.name, c[0].stone.caratWeight, c[0].prongPave, c[0].prongCount.type, c[0].prongCount.value, c[0].prongArm.name, {
                        length: ke,
                        width: Ne,
                        pavHeight: Fe,
                        girdleThickness: Ue
                    }, pe, l, c[0].basketHalo, qP(c[0].stone.caratWeight), he, u.bandWidth, u.bandPaveStyle, u.bandCathedral) : null,
                    je = 2 === fe || 3 === fe ? c[0].basketHalo : null,
                    Ge = je ? "Pave" === je.name || "Hidden" === je.name : null,
                    Ve = 2 === fe || 3 === fe ? qP(c[0].stone.caratWeight) : null,
                    qe = 2 === fe || 3 === fe ? WP(c[0].stone.caratWeight) : null,
                    We = 2 === fe || 3 === fe ? c[0].orientation : null,
                    Xe = ((2 === fe || 3 === fe) && lR(c[0].prongArm.name, c[0].stone.caratWeight, c[0].prongPave), 2 === fe || 3 === fe ? c[2].stone.name : null),
                    Ke = ((2 === fe || 3 === fe) && c[2].stone.caratWeight, 2 === fe || 3 === fe ? c[2].stone.dimensions.width : null),
                    Je = 2 === fe || 3 === fe ? c[2].stone.dimensions.length : null,
                    Ye = 2 === fe || 3 === fe ? c[2].stone.dimensions.pavHeight : null,
                    Qe = 2 === fe || 3 === fe ? c[2].stone.dimensions.girdleThickness : null,
                    Ze = ((2 === fe || 3 === fe) && c[2].stone.dimensions.crownHeight, 2 === fe || 3 === fe ? cR(p, c[2].stone.name, c[2].stone.caratWeight, c[2].prongPave, c[2].prongCount.type, c[2].prongCount.value, c[2].prongArm.name, {
                        length: Je,
                        width: Ke,
                        pavHeight: Ye,
                        girdleThickness: Qe
                    }, pe, l, c[2].basketHalo, qP(c[2].stone.caratWeight), he, u.bandWidth, u.bandPaveStyle, u.bandCathedral).diamondPositionY : null),
                    $e = 2 === fe || 3 === fe ? cR(p, c[2].stone.name, c[2].stone.caratWeight, c[2].prongPave, c[2].prongCount.type, c[2].prongCount.value, c[2].prongArm.name, {
                        length: Je,
                        width: Ke,
                        pavHeight: Ye,
                        girdleThickness: Qe
                    }, pe, l, c[2].basketHalo, qP(c[2].stone.caratWeight), he, u.bandWidth, u.bandPaveStyle, u.bandCathedral) : null,
                    et = 2 === fe || 3 === fe ? c[2].basketHalo : null,
                    tt = et ? "Pave" === et.name || "Hidden" === et.name : null,
                    nt = 2 === fe || 3 === fe ? qP(c[2].stone.caratWeight) : null,
                    rt = 2 === fe || 3 === fe ? WP(c[2].stone.caratWeight) : null;
                (2 === fe || 3 === fe) && c[2].orientation, (2 === fe || 3 === fe) && lR(c[2].prongArm.name, c[2].stone.caratWeight, c[2].prongPave);
                const it = 1 === fe ? [null, lR(c[1].prongArm.name, c[1].stone.caratWeight, c[1].prongPave), null] : 2 === fe ? [lR(c[0].prongArm.name, c[0].stone.caratWeight, c[0].prongPave), null, lR(c[2].prongArm.name, c[2].stone.caratWeight, c[2].prongPave)] : [lR(c[0].prongArm.name, c[0].stone.caratWeight, c[0].prongPave), lR(c[1].prongArm.name, c[1].stone.caratWeight, c[1].prongPave), lR(c[2].prongArm.name, c[2].stone.caratWeight, c[2].prongPave)],
                    ot = 1 === fe ? [0, 0, 0] : [dR(0, p, fe, {
                        diamondName: c[0].stone.name,
                        diamondWidth: Ne,
                        diamondLength: ke,
                        diamondPavHeight: Fe,
                        diamondGirdleThickness: Ue,
                        diamondPositionY: cR(p, c[0].stone.name, c[0].stone.caratWeight, c[0].prongPave, c[0].prongCount.type, c[0].prongCount.value, c[0].prongArm.name, {
                            length: ke,
                            width: Ne,
                            pavHeight: Fe,
                            girdleThickness: Ue
                        }, pe, l, c[0].basketHalo, qP(c[0].stone.caratWeight), he, u.bandWidth, u.bandPaveStyle, u.bandCathedral).diamondPositionY,
                        basketHalo: c[0].basketHalo,
                        haloThicknessRatio: qP(c[0].stone.caratWeight),
                        orientation: c[0].orientation,
                        prongWidth: it[0]
                    }, {
                        diamondName: c[2].stone.name,
                        diamondWidth: Ke,
                        diamondLength: Je,
                        diamondPavHeight: Ye,
                        diamondGirdleThickness: Qe,
                        diamondPositionY: cR(p, c[2].stone.name, c[2].stone.caratWeight, c[2].prongPave, c[2].prongCount.type, c[2].prongCount.value, c[2].prongArm.name, {
                            length: Je,
                            width: Ke,
                            pavHeight: Ye,
                            girdleThickness: Qe
                        }, pe, l, c[2].basketHalo, qP(c[2].stone.caratWeight), he, u.bandWidth, u.bandPaveStyle, u.bandCathedral).diamondPositionY,
                        basketHalo: c[2].basketHalo,
                        haloThicknessRatio: qP(c[2].stone.caratWeight),
                        orientation: c[2].orientation,
                        prongWidth: it[2]
                    }, {
                        diamondName: me,
                        diamondWidth: ge,
                        diamondLength: ve,
                        diamondPavHeight: be,
                        diamondGirdleThickness: xe,
                        diamondPositionY: _e,
                        basketHalo: we,
                        haloThicknessRatio: Se,
                        orientation: Te,
                        prongWidth: Pe
                    }), 0, dR(2, p, fe, {
                        diamondName: c[2].stone.name,
                        diamondWidth: Ke,
                        diamondLength: Je,
                        diamondPavHeight: Ye,
                        diamondGirdleThickness: Qe,
                        diamondPositionY: cR(p, c[2].stone.name, c[2].stone.caratWeight, c[2].prongPave, c[2].prongCount.type, c[2].prongCount.value, c[2].prongArm.name, {
                            length: Je,
                            width: Ke,
                            pavHeight: Ye,
                            girdleThickness: Qe
                        }, pe, l, c[2].basketHalo, qP(c[2].stone.caratWeight), he, u.bandWidth, u.bandPaveStyle, u.bandCathedral).diamondPositionY,
                        basketHalo: c[2].basketHalo,
                        haloThicknessRatio: qP(c[2].stone.caratWeight),
                        orientation: c[2].orientation,
                        prongWidth: it[2]
                    }, {
                        diamondName: c[0].stone.name,
                        diamondWidth: Ne,
                        diamondLength: ke,
                        diamondPavHeight: Fe,
                        diamondGirdleThickness: Ue,
                        diamondPositionY: cR(p, c[0].stone.name, c[0].stone.caratWeight, c[0].prongPave, c[0].prongCount.type, c[0].prongCount.value, c[0].prongArm.name, {
                            length: ke,
                            width: Ne,
                            pavHeight: Fe,
                            girdleThickness: Ue
                        }, pe, l, c[0].basketHalo, qP(c[0].stone.caratWeight), he, u.bandWidth, u.bandPaveStyle, u.bandCathedral).diamondPositionY,
                        basketHalo: c[0].basketHalo,
                        haloThicknessRatio: qP(c[0].stone.caratWeight),
                        orientation: c[0].orientation,
                        prongWidth: it[0]
                    }, {
                        diamondName: me,
                        diamondWidth: ge,
                        diamondLength: ve,
                        diamondPavHeight: be,
                        diamondGirdleThickness: xe,
                        diamondPositionY: _e,
                        basketHalo: we,
                        haloThicknessRatio: Se,
                        orientation: Te,
                        prongWidth: Pe
                    })],
                    at = 1 === fe ? [null, XP(_e, be, xe, Se, p, Re, Be, Le), null] : 2 === fe ? null : [XP(ze, Fe, Ue, Ve, p, Re, Be, Le), XP(_e, be, xe, Se, p, Re, Be, Le), XP(Ze, Ye, Qe, nt, p, Re, Be, Le)],
                    st = 1 === fe ? [null, JP(me, _e, be, Me, 0, p), null] : 2 === fe ? null : [JP(De, ze, Fe, He, 0, p), JP(me, _e, be, Me, 0, p), JP(Xe, Ze, Ye, $e, 0, p)],
                    lt = 1 === fe ? [null, YP(me, ge, ve, 0, Me, Ae, Ce, p), null] : 2 === fe ? null : [YP(De, Ne, ke, 0, He, Ge, qe, p), YP(me, ge, ve, 0, Me, Ae, Ce, p), YP(Xe, Ke, Je, 0, $e, tt, rt, p)],
                    ct = 1 === fe ? {
                        orientation: Te,
                        basketHalo: we,
                        diamondWidth: ge,
                        diamondLength: ve
                    } : 2 === fe ? null : {
                        orientation: We,
                        basketHalo: je,
                        diamondWidth: Ne,
                        diamondLength: ke
                    },
                    [ut, dt] = (0, r.useState)(window.innerWidth < 600 ? "100vw" : "calc(100vw - 360px)"),
                    [ht, pt] = (0, r.useState)(window.innerWidth < 600 ? "85vw" : "100vh"),
                    [ft, mt] = (0, r.useState)("");
                (0, r.useEffect)((() => {
                    const e = 2.41;
                    let t = [0, 0, 0];
                    2 == fe ? t = [e, 0, e] : 3 == fe ? t = [e, e, e] : 1 === fe && (t = u.bandMetalColor === c[1].prongMetalColor ? [0, 0, 0] : [0, e, 0]), 1 === fe ? (z(0), V(0)) : 2 === fe && j(0), re([U + t[0], H + t[1], G + t[2]])
                }), [fe, H, U, G, u.bandMetalColor, c]), (0, r.useEffect)((() => {
                    (1 !== fe || c[1].surpriseStones) && (2 !== fe || c[0].surpriseStones) && (3 !== fe || c[1].surpriseStones) || ae({
                        quantity: 0,
                        size: .8,
                        shape: "Round"
                    })
                }), [fe, c]), (0, r.useEffect)((() => {
                    c[0] || (W([]), K([])), c[1] || (Y([]), Z([])), c[2] || (ee([]), ne([]))
                }), [c]), (0, r.useEffect)((() => {
                    const e = [],
                        t = [];
                    if (e.push(...q), e.push(...J), e.push(...$), t.push(...X), t.push(...Q), t.push(...te), c[0] && c[0].prongPave || c[1] && c[1].prongPave || c[2] && c[2].prongPave) {
                        const t = new Map;
                        e.forEach((e => {
                            const {
                                quantity: n,
                                size: r,
                                ...i
                            } = e;
                            if (t.has(r)) {
                                const e = t.get(r);
                                t.set(r, { ...e,
                                    quantity: e.quantity + n
                                })
                            } else t.set(r, {
                                quantity: n,
                                size: r,
                                ...i
                            })
                        })), ie(Array.from(t.values()))
                    } else ie([]);
                    if (c[0] && c[0].basketHalo || c[1] && c[1].basketHalo || c[2] && c[2].basketHalo) {
                        const e = new Map;
                        t.forEach((t => {
                            const {
                                quantity: n,
                                size: r,
                                ...i
                            } = t;
                            if (e.has(r)) {
                                const t = e.get(r);
                                e.set(r, { ...t,
                                    quantity: t.quantity + n
                                })
                            } else e.set(r, {
                                quantity: n,
                                size: r,
                                ...i
                            })
                        })), oe(Array.from(e.values()))
                    } else oe([])
                }), [c, Q, J, X, q, te, $]), (0, r.useEffect)((() => {
                    fe > 1 ? k(fe + 1) : 1 === fe && (u.bandMetalColor === c[1].prongMetalColor ? k(1) : k(fe + 1))
                }), [u.bandMetalColor, fe, c]), (0, r.useEffect)((() => {
                    se(i.diamondtype)
                }), [i.diamondtype]), (0, r.useEffect)((() => {
                    t && (f(1), v(!1), b(!0), setTimeout((() => {
                        _.current && bR(_.current)
                    }), 3e3), n(), setTimeout((() => {
                        f(10), v(!0), b(!1)
                    }), 3200));
                    const e = () => {
                        dt(window.innerWidth < 600 ? "100vw" : "calc(100vw - 360px)"), pt(window.innerWidth < 600 ? "85vw" : "100vh")
                    };
                    return window.addEventListener("resize", e), () => window.removeEventListener("resize", e)
                }), [t, n]), (0, r.useEffect)((() => {
                    (() => {
                        try {
                            const e = Cn(),
                                t = new URL(window.location.href).searchParams.get("jewelerid"),
                                n = {
                                    numberOfElements: C,
                                    headsMetal: e.HeadMetalColor,
                                    headsVolume: T.reduce(((e, t) => e + t), 0),
                                    bandMetal: e.BandMetalColor,
                                    bandVolume: I,
                                    prongPave: P,
                                    haloBasketPave: R,
                                    bandPave: O,
                                    bridgePave: B,
                                    surpriseStones: L,
                                    accentGems: D,
                                    laserEngraving: N,
                                    diamondType: F,
                                    jewelerID: t
                                };
                            e.pricing = n, A(e)
                        } catch (e) {
                            console.error("Error fetching ring ID:", e)
                        }
                    })()
                }), [i, O, C, T, I, P, R, B, L, D, N, F, a, s]);
                return (0, r.useEffect)((() => (h.current && clearTimeout(h.current), h.current = setTimeout((() => {
                    w && (async () => {
                        const e = await Pn(w);
                        E(e)
                    })()
                }), 1e3), () => {
                    h.current && clearTimeout(h.current)
                })), [w]), (0, r.useEffect)((() => {
                    w && S && (window.parent.postMessage({
                        type: "design_changed",
                        ringObject: w,
                        ringID: S.hashedKey
                    }, "*"), A(null), E(null))
                }), [S, w]), (0, Nn.jsx)(Nn.Fragment, {
                    children: (0, Nn.jsxs)(Nw, {
                        style: {
                            height: ht,
                            width: ut
                        },
                        camera: {
                            position: [-1.75, 2.5, 4],
                            fov: 50,
                            zoom: window.innerWidth < 600 ? 1.3 : 1
                        },
                        onCreated: e => {
                            let {
                                gl: t,
                                scene: n,
                                camera: r
                            } = e;
                            x.current = t, _.current = n, M.current = r
                        },
                        gl: {
                            powerPreference: "default",
                            antialias: !1
                        },
                        children: [(0, Nn.jsxs)(r.Suspense, {
                            fallback: null,
                            children: [" ", (0, Nn.jsx)(FP, {}), g && (0, Nn.jsx)(gR, {}), (0, Nn.jsx)(gT, {
                                diamondsVisibility: g,
                                bandMetal: u.bandMetalColor,
                                scaleReducerVector: m,
                                scaleReducer: p,
                                bandStyle: u.bandStyle,
                                bandFit: u.bandFit,
                                bandWidth: u.bandWidth,
                                ringSize: u.ringSize,
                                bandInnerRadius: he,
                                bandPaveStyle: u.bandPaveStyle,
                                bandPaveLength: u.bandPaveLength,
                                halosVerticalPlacement: at,
                                centerBezelTopThickness: Ie,
                                centerBezelBottomThickness: Oe,
                                basketsVerticalPlacement: st,
                                basketsDimensions: lt,
                                headProperties: ct,
                                cathedral: u.bandCathedral,
                                headCount: fe,
                                prongWidths: it,
                                headRotations: ot,
                                extraMetal: y,
                                numberOfElements: C,
                                centerHaloThickness: Ee,
                                centerStoneCheckForKiteOrCompass: c[1] && ("Kite" === c[1].orientation || "4 Compass" === c[1].prongCount.type)
                            }), c.map(((e, t) => e && (0, Nn.jsx)(eR, {
                                index: t,
                                headCount: fe,
                                extraMetal: y,
                                diamondsVisibility: g,
                                headRotations: ot,
                                headOrientation: uR(t, fe, e.stone.name, e.orientation),
                                scaleReducer: p,
                                scaleReducerVector: m,
                                diamondWidth: e.stone.dimensions.width,
                                diamondLength: e.stone.dimensions.length,
                                diamondPavHeight: e.stone.dimensions.pavHeight,
                                diamondGirdleThickness: e.stone.dimensions.girdleThickness,
                                diamondCrownHeight: e.stone.dimensions.crownHeight,
                                diamondCaratWeight: e.stone.caratWeight,
                                caratWeightMultiplier: e.stone.caratWeightMultiplier,
                                diamondType: e.stone,
                                prongCount: e.prongCount.value,
                                prongOrientation: e.prongCount.type,
                                prongArmCalculations: cR(p, e.stone.name, e.stone.caratWeight, e.prongPave, e.prongCount.type, e.prongCount.value, e.prongArm.name, {
                                    length: e.stone.dimensions.length,
                                    width: e.stone.dimensions.width,
                                    pavHeight: e.stone.dimensions.pavHeight,
                                    girdleThickness: e.stone.dimensions.girdleThickness
                                }, pe, l, e.basketHalo, qP(e.stone.caratWeight), he, u.bandWidth, u.bandPaveStyle, u.bandCathedral),
                                prongArmType: e.prongArm,
                                prongTipType: e.prongTip,
                                hasProngPave: e.prongPave,
                                prongWidth: lR(e.prongArm.name, e.stone.caratWeight, e.prongPave),
                                basketHalo: e.basketHalo,
                                haloThicknessRatio: qP(e.stone.caratWeight),
                                basketThicknessRatio: WP(e.stone.caratWeight),
                                prongMetalColor: e.prongMetalColor,
                                cathedral: u.bandCathedral,
                                bandInnerRadius: he,
                                bandWidth: u.bandWidth,
                                bandPaveStyle: u.bandPaveStyle,
                                setLeftHeadVolume: z,
                                setCenterHeadVolume: j,
                                setRightHeadVolume: V,
                                setLeftHeadProngPave: W,
                                setLeftHeadHaloBasketPave: K,
                                setCenterHeadProngPave: Y,
                                setCenterHeadHaloBasketPave: Z,
                                setRightHeadProngPave: ee,
                                setRightHeadHaloBasketPave: ne,
                                onLoadComplete: ue,
                                numberOfElements: C
                            }, t))), c.map(((e, t) => e && e.surpriseStones && (fe < 3 || 1 == t) && (0, Nn.jsx)(iR, {
                                index: t,
                                headCount: fe,
                                diamondsVisibility: g,
                                metalColor: u.bandMetalColor,
                                surpriseStonePosition: oR(he, u.bandWidth, u.bandPaveStyle, p),
                                scaleReducerVector: m,
                                headRotations: ot
                            }, t))), (0, Nn.jsx)(CA, {
                                files: "Mod blurred x2 contrast_v6_90.hdr"
                            })]
                        }), (0, Nn.jsx)(DA, {
                            ref: d,
                            enablePan: !1,
                            autoRotate: !0,
                            autoRotateSpeed: 12,
                            minDistance: window.innerWidth < 600 ? 3.5 : 3,
                            maxDistance: 10,
                            rotateSpeed: 1.5,
                            target: [0, c[1] ? (_e + ye / p + 1.0627) / 2 - 1.0627 : 0, 0]
                        })]
                    })
                })
            };

        function MR(e) {
            let {
                setSavedAndReviewed: t
            } = e;
            const [n, i] = (0, r.useState)(!1);
            return (0, Nn.jsxs)("div", {
                className: "wrapper",
                children: [(0, Nn.jsx)(Qo, {
                    handleManufacturingButton: () => {
                        i(!0)
                    },
                    setSavedAndReviewed: t
                }), (0, Nn.jsx)("div", {
                    className: "RingmobileContainer",
                    children: (0, Nn.jsx)(_R, {
                        exportManufacturingFile: n,
                        handleManufacturingOnEnd: () => {
                            i(!1)
                        }
                    })
                })]
            })
        }
        const wR = e => {
            let {
                text: t
            } = e;
            return (0, Nn.jsx)("div", {
                className: zn,
                style: {
                    zIndex: 99,
                    background: "#fff"
                },
                children: (0, Nn.jsxs)("div", {
                    className: Hn,
                    children: [(0, Nn.jsx)("div", {
                        className: jn
                    }), (0, Nn.jsx)("span", {
                        className: Gn,
                        children: t
                    })]
                })
            })
        };
        const AR = function() {
                const [e, t] = (0, r.useState)(!1), [n, i] = (0, r.useState)(!1), a = (() => {
                    const {
                        isLoading: e
                    } = (0, o.useQuery)(["allStones"], Rn, {
                        refetchOnWindowFocus: !1,
                        refetchOnMount: !1,
                        refetchOnReconnect: !1,
                        refetchIntervalInBackground: !1,
                        staleTime: 1 / 0
                    });
                    return e
                })(), s = (0, r.useCallback)((e => {
                    if (!e) return t(!0);
                    const {
                        dataUI: n,
                        data3D: r
                    } = e;
                    var i;
                    n && (i = n, yn.getState().initiateDefaultRing(i)), r && ((e, t) => {
                        const n = ["center", "side", "left", "right"],
                            r = ["Cushion", "Radiant"];
                        Object.keys(t).filter((e => n.includes(e))).map((e => m[e])).forEach((t => {
                            const n = e.heads[t];
                            if (!n) return;
                            const {
                                stone: i
                            } = n;
                            !A(i.dimensions.length, i.dimensions.width) && r.includes(i.name) && (i.diamondShape = _(i.diamondShape))
                        })), Mn.getState().initiateRing(e)
                    })(r, n), t(!0)
                }), []), l = (e => {
                    let {
                        onSuccess: t,
                        onError: n
                    } = e;
                    return (0, o.useQuery)(["getRingById"], Tn, {
                        onSuccess: t,
                        onError: n,
                        refetchOnWindowFocus: !1,
                        refetchOnMount: !1,
                        staleTime: 1 / 0,
                        cacheTime: 1 / 0,
                        retry: !1,
                        retryOnMount: !1,
                        refetchOnReconnect: !1,
                        enabled: !1
                    })
                })({
                    onSuccess: s,
                    onError: (0, r.useCallback)((() => {
                        t(!0)
                    }), [])
                }), c = e && !a;
                return (0, r.useEffect)((() => {
                    l.isFetched || l.refetch()
                }), [l]), (0, Nn.jsxs)("div", {
                    className: "App",
                    children: [c ? (0, Nn.jsx)(MR, {
                        setSavedAndReviewed: i
                    }) : (0, Nn.jsx)(Vn, {
                        text: "designing your dearm..."
                    }), n ? (0, Nn.jsx)(wR, {
                        text: "Reviewing your design..."
                    }) : null]
                })
            },
            SR = new o.QueryClient({
                queryCache: new o.QueryCache({
                    onSuccess: (e, t) => {
                        if ("allStones" !== t.queryKey[0]) return;
                        const n = e.map((e => ({
                            name: e.name,
                            meshes: e.meshes,
                            caratWeightMultiplier: e.caratWeightMultiplier,
                            dimensions: e.dimensions,
                            diamondShape: e.glbUrl
                        })));
                        xn("availableStones")(n)
                    }
                })
            });
        i.createRoot(document.getElementById("root")).render((0, Nn.jsx)(o.QueryClientProvider, {
            client: SR,
            children: (0, Nn.jsx)(AR, {})
        }))
    })()
})();

